From 35ee15eab36eafc660a50284529613ed9dd044da Mon Sep 17 00:00:00 2001
From: Michael Stefaniuc <mstefani@winehq.org>
Date: Sun, 14 Mar 2021 22:54:36 +0100
Subject: [PATCH] wldap32: Remove redundant NULL check before heap_free().

Signed-off-by: Michael Stefaniuc <mstefani@winehq.org>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/wldap32/page.c | 7 ++-----
 1 file changed, 2 insertions(+), 5 deletions(-)

diff --git a/dlls/wldap32/page.c b/dlls/wldap32/page.c
index a16ea52409ef..07f29be0d50a 100644
--- a/dlls/wldap32/page.c
+++ b/dlls/wldap32/page.c
@@ -241,11 +241,8 @@ ULONG CDECL ldap_get_paged_count( WLDAP32_LDAP *ld, PLDAPSearch search,
         return WLDAP32_LDAP_SUCCESS;
     }
 
-    if (search->cookie)
-    {
-        heap_free( search->cookie );
-        search->cookie = NULL;
-    }
+    heap_free( search->cookie );
+    search->cookie = NULL;
 
     ret = ldap_parse_page_controlW( ld, server_ctrls, count, &search->cookie );
     if (ret == WLDAP32_LDAP_SUCCESS)
From 62721a7db3bf03b24bde51a50dc75340a4b05ded Mon Sep 17 00:00:00 2001
From: Hans Leidekker <hans@codeweavers.com>
Date: Tue, 6 Apr 2021 15:46:52 +0200
Subject: [PATCH] include: Remove functions declarations from winldap.h that
 don't exist in the native header.

Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/adsldp/adsldp.c       |  1 +
 dlls/wldap32/tests/parse.c |  1 +
 include/Makefile.in        |  1 +
 include/winldap.h          | 12 ------------
 4 files changed, 3 insertions(+), 12 deletions(-)

diff --git a/dlls/adsldp/adsldp.c b/dlls/adsldp/adsldp.c
index 63f800b50615..89d658c53ffe 100644
--- a/dlls/adsldp/adsldp.c
+++ b/dlls/adsldp/adsldp.c
@@ -38,6 +38,7 @@
 #include "lmcons.h"
 #include "lmapibuf.h"
 #include "winldap.h"
+#include "winber.h"
 
 #include "adsldp_private.h"
 
diff --git a/dlls/wldap32/tests/parse.c b/dlls/wldap32/tests/parse.c
index 9fdd4db03ad5..8deebcbc6bf8 100644
--- a/dlls/wldap32/tests/parse.c
+++ b/dlls/wldap32/tests/parse.c
@@ -24,6 +24,7 @@
 #include <windef.h>
 #include <winbase.h>
 #include <winldap.h>
+#include <winber.h>
 
 #include "wine/test.h"
 
diff --git a/include/Makefile.in b/include/Makefile.in
index 9133e5c63155..3b60e1be303a 100644
--- a/include/Makefile.in
+++ b/include/Makefile.in
@@ -741,6 +741,7 @@ SOURCES = \
 	wimgapi.h \
 	winapifamily.h \
 	winbase.h \
+	winber.h \
 	wincodec.idl \
 	wincodecsdk.idl \
 	wincon.h \
diff --git a/include/winldap.h b/include/winldap.h
index 2d41eaa3fa23..2cc29ef693c5 100644
--- a/include/winldap.h
+++ b/include/winldap.h
@@ -632,19 +632,7 @@ ULONG CDECL ldap_value_freeW(PWCHAR*);
 #define    ldap_value_free WINELIB_NAME_AW(ldap_value_free)
 ULONG CDECL ldap_value_free_len(struct berval**);
 
-BerElement* CDECL ber_alloc_t(INT);
-BERVAL* CDECL ber_bvdup(BERVAL*);
-void CDECL ber_bvecfree(PBERVAL*);
 void CDECL ber_bvfree(BERVAL*);
-ULONG CDECL ber_first_element(BerElement*,ULONG*,CHAR**);
-INT CDECL ber_flatten(BerElement*,PBERVAL*);
-void CDECL ber_free(BerElement*,INT);
-BerElement* CDECL ber_init(BERVAL*);
-ULONG CDECL ber_next_element(BerElement*,ULONG*,CHAR*);
-ULONG CDECL ber_peek_tag(BerElement*,ULONG*);
-INT WINAPIV ber_printf(BerElement*,PCHAR,...);
-ULONG CDECL ber_skip_tag(BerElement*,ULONG*);
-INT WINAPIV ber_scanf(BerElement*,PCHAR,...);
 
 ULONG CDECL LdapGetLastError(void);
 ULONG CDECL LdapMapErrorToWin32(ULONG);
From 842987cd12057cfe757a4a1df03945840b4cf8c9 Mon Sep 17 00:00:00 2001
From: Hans Leidekker <hans@codeweavers.com>
Date: Tue, 6 Apr 2021 15:46:53 +0200
Subject: [PATCH] wldap32/tests: Add ber_printf/scanf tests.

Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/wldap32/tests/Makefile.in |  1 +
 dlls/wldap32/tests/ber.c       | 72 ++++++++++++++++++++++++++++++++++
 2 files changed, 73 insertions(+)
 create mode 100644 dlls/wldap32/tests/ber.c

diff --git a/dlls/wldap32/tests/Makefile.in b/dlls/wldap32/tests/Makefile.in
index 6df015083e82..05fe5b9af6d5 100644
--- a/dlls/wldap32/tests/Makefile.in
+++ b/dlls/wldap32/tests/Makefile.in
@@ -2,4 +2,5 @@ TESTDLL   = wldap32.dll
 IMPORTS   = wldap32
 
 C_SRCS = \
+	ber.c \
 	parse.c
diff --git a/dlls/wldap32/tests/ber.c b/dlls/wldap32/tests/ber.c
new file mode 100644
index 000000000000..56d54fa6f5ac
--- /dev/null
+++ b/dlls/wldap32/tests/ber.c
@@ -0,0 +1,72 @@
+/*
+ * Copyright 2021 Hans Leidekker for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include <stdarg.h>
+#include <windef.h>
+#include <winbase.h>
+#include <winldap.h>
+#include <winber.h>
+
+#include "wine/test.h"
+
+static void test_ber_printf(void)
+{
+    int ret;
+    BerElement *ber;
+    struct berval *bv;
+
+    ber = ber_alloc_t( 0 );
+    todo_wine ok( ber == NULL, "ber_alloc_t succeeded\n" );
+
+    ber = ber_alloc_t( LBER_USE_DER );
+    ok( ber != NULL, "ber_alloc_t failed\n" );
+
+    ret = ber_printf( ber, (char *)"{i}", -1 );
+    todo_wine ok( !ret, "got %d\n", ret );
+
+    ret = ber_flatten( ber, &bv );
+    ok( !ret, "got %d\n", ret );
+    todo_wine ok( bv->bv_len == 12, "got %d\n", bv->bv_len );
+    if (bv->bv_len == 12) ok( !memcmp( bv->bv_val, "0\x84\x00\x00\x00\x06\x02\x04\xff\xff\xff\xff", 12 ), "got %s\n",
+                              wine_dbgstr_an(bv->bv_val, 12) );
+    ber_bvfree( bv );
+    ber_free( ber, 1 );
+}
+
+static void test_ber_scanf(void)
+{
+    int ret;
+    BerElement *ber;
+    struct berval bv = { 12, (char *)"0\x84\x00\x00\x00\x06\x02\x04\xff\xff\xff\xff" };
+    int i;
+
+    ber = ber_init( &bv );
+    ok( ber != NULL, "ber_init failed\n" );
+
+    i = 0;
+    ret = ber_scanf( ber, (char *)"{i}", &i );
+    ok( !ret, "got %d\n", ret );
+    ok( i == -1, "got %d\n", i );
+    ber_free( ber, 1 );
+}
+
+START_TEST(ber)
+{
+    test_ber_printf();
+    test_ber_scanf();
+}
From 1805b3a1fc6ce23f8ac88cfacedf3b248c6a94fe Mon Sep 17 00:00:00 2001
From: Hans Leidekker <hans@codeweavers.com>
Date: Wed, 14 Apr 2021 09:40:25 +0200
Subject: [PATCH] wldap32: Move support for add functions to a new Unix
 library.

Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/wldap32/Makefile.in       |   1 +
 dlls/wldap32/add.c             | 274 ++--------
 dlls/wldap32/init.c            |  10 +-
 dlls/wldap32/libldap.c         |  81 +++
 dlls/wldap32/libldap.h         |  72 +++
 dlls/wldap32/main.c            |  12 +-
 dlls/wldap32/winldap_private.h | 910 ++++++++++++++++++++++++++++++++-
 dlls/wldap32/wldap32.h         |  30 +-
 8 files changed, 1137 insertions(+), 253 deletions(-)
 create mode 100644 dlls/wldap32/libldap.c
 create mode 100644 dlls/wldap32/libldap.h

diff --git a/dlls/wldap32/Makefile.in b/dlls/wldap32/Makefile.in
index 7dc2984c5aa8..18a37151f998 100644
--- a/dlls/wldap32/Makefile.in
+++ b/dlls/wldap32/Makefile.in
@@ -15,6 +15,7 @@ C_SRCS = \
 	error.c \
 	extended.c \
 	init.c \
+	libldap.c \
 	main.c \
 	misc.c \
 	modify.c \
diff --git a/dlls/wldap32/add.c b/dlls/wldap32/add.c
index 0d0c8bfa117c..cce7726a2415 100644
--- a/dlls/wldap32/add.c
+++ b/dlls/wldap32/add.c
@@ -18,62 +18,39 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#include "config.h"
-#include "wine/port.h"
-
 #include <stdarg.h>
-#ifdef HAVE_LDAP_H
-#include <ldap.h>
-#endif
-
 #include "windef.h"
 #include "winbase.h"
 #include "winnls.h"
 
-#include "winldap_private.h"
-#include "wldap32.h"
 #include "wine/debug.h"
+#include "winldap_private.h"
 
-#ifdef HAVE_LDAP
 WINE_DEFAULT_DEBUG_CHANNEL(wldap32);
 
-static LDAPMod *nullattrs[] = { NULL };
-#endif
-
 /***********************************************************************
  *      ldap_addA     (WLDAP32.@)
  *
  * See ldap_addW.
  */
-ULONG CDECL ldap_addA( WLDAP32_LDAP *ld, PCHAR dn, LDAPModA *attrs[] )
+ULONG CDECL ldap_addA( WLDAP32_LDAP *ld, char *dn, LDAPModA **attrs )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
     WCHAR *dnW = NULL;
     LDAPModW **attrsW = NULL;
 
-    ret = WLDAP32_LDAP_NO_MEMORY;
-
     TRACE( "(%p, %s, %p)\n", ld, debugstr_a(dn), attrs );
 
     if (!ld) return ~0u;
 
-    if (dn) {
-        dnW = strAtoW( dn );
-        if (!dnW) goto exit;
-    }
-    if (attrs) {
-        attrsW = modarrayAtoW( attrs );
-        if (!attrsW) goto exit;
-    }
+    if (dn && !(dnW = strAtoW( dn ))) goto exit;
+    if (attrs && !(attrsW = modarrayAtoW( attrs ))) goto exit;
 
     ret = ldap_addW( ld, dnW, attrsW );
 
 exit:
     strfreeW( dnW );
     modarrayfreeW( attrsW );
-
-#endif
     return ret;
 }
 
@@ -97,42 +74,15 @@ ULONG CDECL ldap_addA( WLDAP32_LDAP *ld, PCHAR dn, LDAPModA *attrs[] )
  *  the operation. Cancel the operation by calling ldap_abandon
  *  with the message ID.
  */
-ULONG CDECL ldap_addW( WLDAP32_LDAP *ld, PWCHAR dn, LDAPModW *attrs[] )
+ULONG CDECL ldap_addW( WLDAP32_LDAP *ld, WCHAR *dn, LDAPModW **attrs )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
-    char *dnU = NULL;
-    LDAPMod **attrsU = NULL;
-    int msg;
- 
-    ret = WLDAP32_LDAP_NO_MEMORY;
+    ULONG ret, msg;
 
     TRACE( "(%p, %s, %p)\n", ld, debugstr_w(dn), attrs );
 
-    if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
-
-    if (dn) {
-        dnU = strWtoU( dn );
-        if (!dnU) goto exit;
-    }
-    if (attrs) {
-        attrsU = modarrayWtoU( attrs );
-        if (!attrsU) goto exit;
-    }
-
-    ret = ldap_add_ext( ld->ld, dn ? dnU : "", attrs ? attrsU : nullattrs, NULL, NULL, &msg );
-
-    if (ret == LDAP_SUCCESS)
-        ret = msg;
-    else
-        ret = ~0u;
-
-exit:
-    strfreeU( dnU );
-    modarrayfreeU( attrsU );
-
-#endif
-    return ret;
+    ret = ldap_add_extW( ld, dn, attrs, NULL, NULL, &msg );
+    if (ret == WLDAP32_LDAP_SUCCESS) return msg;
+    return ~0u;
 }
 
 /***********************************************************************
@@ -140,38 +90,22 @@ ULONG CDECL ldap_addW( WLDAP32_LDAP *ld, PWCHAR dn, LDAPModW *attrs[] )
  *
  * See ldap_add_extW.
  */
-ULONG CDECL ldap_add_extA( WLDAP32_LDAP *ld, PCHAR dn, LDAPModA *attrs[],
-    PLDAPControlA *serverctrls, PLDAPControlA *clientctrls, ULONG *message )
+ULONG CDECL ldap_add_extA( WLDAP32_LDAP *ld, char *dn, LDAPModA **attrs, LDAPControlA **serverctrls,
+                           LDAPControlA **clientctrls, ULONG *message )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
     WCHAR *dnW = NULL;
     LDAPModW **attrsW = NULL;
     LDAPControlW **serverctrlsW = NULL, **clientctrlsW = NULL;
 
-    ret = WLDAP32_LDAP_NO_MEMORY;
-
-    TRACE( "(%p, %s, %p, %p, %p, %p)\n", ld, debugstr_a(dn), attrs,
-           serverctrls, clientctrls, message );
+    TRACE( "(%p, %s, %p, %p, %p, %p)\n", ld, debugstr_a(dn), attrs, serverctrls, clientctrls, message );
 
     if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
 
-    if (dn) {
-        dnW = strAtoW( dn );
-        if (!dnW) goto exit;
-    }
-    if (attrs) {
-        attrsW = modarrayAtoW( attrs );
-        if (!attrsW) goto exit;
-    }
-    if (serverctrls) {
-        serverctrlsW = controlarrayAtoW( serverctrls );
-        if (!serverctrlsW) goto exit;
-    }
-    if (clientctrls) {
-        clientctrlsW = controlarrayAtoW( clientctrls );
-        if (!clientctrlsW) goto exit;
-    }
+    if (dn && !(dnW = strAtoW( dn ))) goto exit;
+    if (attrs && !(attrsW = modarrayAtoW( attrs ))) goto exit;
+    if (serverctrls && !(serverctrlsW = controlarrayAtoW( serverctrls ))) goto exit;
+    if (clientctrls && !(clientctrlsW = controlarrayAtoW( clientctrls ))) goto exit;
 
     ret = ldap_add_extW( ld, dnW, attrsW, serverctrlsW, clientctrlsW, message );
 
@@ -180,8 +114,6 @@ ULONG CDECL ldap_add_extA( WLDAP32_LDAP *ld, PCHAR dn, LDAPModA *attrs[],
     modarrayfreeW( attrsW );
     controlarrayfreeW( serverctrlsW );
     controlarrayfreeW( clientctrlsW );
-
-#endif
     return ret;
 }
 
@@ -208,50 +140,30 @@ ULONG CDECL ldap_add_extA( WLDAP32_LDAP *ld, PCHAR dn, LDAPModA *attrs[],
  *  the operation. The serverctrls and clientctrls parameters are
  *  optional and should be set to NULL if not used.
  */
-ULONG CDECL ldap_add_extW( WLDAP32_LDAP *ld, PWCHAR dn, LDAPModW *attrs[],
-    PLDAPControlW *serverctrls, PLDAPControlW *clientctrls, ULONG *message )
+ULONG CDECL ldap_add_extW( WLDAP32_LDAP *ld, WCHAR *dn, LDAPModW **attrs, LDAPControlW **serverctrls,
+                           LDAPControlW **clientctrls, ULONG *message )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
     char *dnU = NULL;
-    LDAPMod **attrsU = NULL;
-    LDAPControl **serverctrlsU = NULL, **clientctrlsU = NULL;
-    int dummy;
+    LDAPModU **attrsU = NULL;
+    LDAPControlU **serverctrlsU = NULL, **clientctrlsU = NULL;
 
-    ret = WLDAP32_LDAP_NO_MEMORY;
-
-    TRACE( "(%p, %s, %p, %p, %p, %p)\n", ld, debugstr_w(dn), attrs,
-           serverctrls, clientctrls, message );
+    TRACE( "(%p, %s, %p, %p, %p, %p)\n", ld, debugstr_w(dn), attrs, serverctrls, clientctrls, message );
 
     if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
 
-    if (dn) {
-        dnU = strWtoU( dn );
-        if (!dnU) goto exit;
-    }
-    if (attrs) {
-        attrsU = modarrayWtoU( attrs );
-        if (!attrsU) goto exit;
-    }
-    if (serverctrls) {
-        serverctrlsU = controlarrayWtoU( serverctrls );
-        if (!serverctrlsU) goto exit;
-    }
-    if (clientctrls) {
-        clientctrlsU = controlarrayWtoU( clientctrls );
-        if (!clientctrlsU) goto exit;
-    }
-
-    ret = map_error( ldap_add_ext( ld->ld, dn ? dnU : "", attrs ? attrsU : nullattrs, serverctrlsU,
-                                   clientctrlsU, message ? (int *)message : &dummy ));
+    if (dn && !(dnU = strWtoU( dn ))) goto exit;
+    if (attrs && !(attrsU = modarrayWtoU( attrs ))) goto exit;
+    if (serverctrls && !(serverctrlsU = controlarrayWtoU( serverctrls ))) goto exit;
+    if (clientctrls && !(clientctrlsU = controlarrayWtoU( clientctrls ))) goto exit;
+
+    ret = map_error( ldap_funcs->ldap_add_ext( ld->ld, dnU, attrsU, serverctrlsU, clientctrlsU, message ) );
 
 exit:
     strfreeU( dnU );
     modarrayfreeU( attrsU );
     controlarrayfreeU( serverctrlsU );
     controlarrayfreeU( clientctrlsU );
-
-#endif
     return ret;
 }
 
@@ -260,38 +172,22 @@ ULONG CDECL ldap_add_extW( WLDAP32_LDAP *ld, PWCHAR dn, LDAPModW *attrs[],
  *
  * See ldap_add_ext_sW.
  */
-ULONG CDECL ldap_add_ext_sA( WLDAP32_LDAP *ld, PCHAR dn, LDAPModA *attrs[],
-    PLDAPControlA *serverctrls, PLDAPControlA *clientctrls )
+ULONG CDECL ldap_add_ext_sA( WLDAP32_LDAP *ld, char *dn, LDAPModA **attrs, LDAPControlA **serverctrls,
+                             LDAPControlA **clientctrls )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
     WCHAR *dnW = NULL;
     LDAPModW **attrsW = NULL;
     LDAPControlW **serverctrlsW = NULL, **clientctrlsW = NULL;
 
-    ret = WLDAP32_LDAP_NO_MEMORY;
-
-    TRACE( "(%p, %s, %p, %p, %p)\n", ld, debugstr_a(dn), attrs,
-           serverctrls, clientctrls );
+    TRACE( "(%p, %s, %p, %p, %p)\n", ld, debugstr_a(dn), attrs, serverctrls, clientctrls );
 
     if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
 
-    if (dn) {
-        dnW = strAtoW( dn );
-        if (!dnW) goto exit;
-    }
-    if (attrs) {
-        attrsW = modarrayAtoW( attrs );
-        if (!attrsW) goto exit;
-    }
-    if (serverctrls) {
-        serverctrlsW = controlarrayAtoW( serverctrls );
-        if (!serverctrlsW) goto exit;
-    }
-    if (clientctrls) {
-        clientctrlsW = controlarrayAtoW( clientctrls );
-        if (!clientctrlsW) goto exit;
-    }
+    if (dn && !(dnW = strAtoW( dn ))) goto exit;
+    if (attrs && !(attrsW = modarrayAtoW( attrs ))) goto exit;
+    if (serverctrls && !(serverctrlsW = controlarrayAtoW( serverctrls ))) goto exit;
+    if (clientctrls && !(clientctrlsW = controlarrayAtoW( clientctrls ))) goto exit;
 
     ret = ldap_add_ext_sW( ld, dnW, attrsW, serverctrlsW, clientctrlsW );
 
@@ -300,8 +196,6 @@ ULONG CDECL ldap_add_ext_sA( WLDAP32_LDAP *ld, PCHAR dn, LDAPModA *attrs[],
     modarrayfreeW( attrsW );
     controlarrayfreeW( serverctrlsW );
     controlarrayfreeW( clientctrlsW );
-
-#endif
     return ret;
 }
 
@@ -326,49 +220,30 @@ ULONG CDECL ldap_add_ext_sA( WLDAP32_LDAP *ld, PCHAR dn, LDAPModA *attrs[],
  *  The serverctrls and clientctrls parameters are optional and
  *  should be set to NULL if not used.
  */
-ULONG CDECL ldap_add_ext_sW( WLDAP32_LDAP *ld, PWCHAR dn, LDAPModW *attrs[],
-    PLDAPControlW *serverctrls, PLDAPControlW *clientctrls )
+ULONG CDECL ldap_add_ext_sW( WLDAP32_LDAP *ld, WCHAR *dn, LDAPModW **attrs, LDAPControlW **serverctrls,
+                             LDAPControlW **clientctrls )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
     char *dnU = NULL;
-    LDAPMod **attrsU = NULL;
-    LDAPControl **serverctrlsU = NULL, **clientctrlsU = NULL;
+    LDAPModU **attrsU = NULL;
+    LDAPControlU **serverctrlsU = NULL, **clientctrlsU = NULL;
 
-    ret = WLDAP32_LDAP_NO_MEMORY;
-
-    TRACE( "(%p, %s, %p, %p, %p)\n", ld, debugstr_w(dn), attrs,
-           serverctrls, clientctrls );
+    TRACE( "(%p, %s, %p, %p, %p)\n", ld, debugstr_w(dn), attrs, serverctrls, clientctrls );
 
     if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
 
-    if (dn) {
-        dnU = strWtoU( dn );
-        if (!dnU) goto exit;
-    }
-    if (attrs) {
-        attrsU = modarrayWtoU( attrs );
-        if (!attrsU) goto exit;
-    }
-    if (serverctrls) {
-        serverctrlsU = controlarrayWtoU( serverctrls );
-        if (!serverctrlsU) goto exit;
-    }
-    if (clientctrls) {
-        clientctrlsU = controlarrayWtoU( clientctrls );
-        if (!clientctrlsU) goto exit;
-    }
-
-    ret = map_error( ldap_add_ext_s( ld->ld, dn ? dnU : "", attrs ? attrsU : nullattrs,
-                                     serverctrlsU, clientctrlsU ));
+    if (dn && !(dnU = strWtoU( dn ))) goto exit;
+    if (attrs && !(attrsU = modarrayWtoU( attrs ))) goto exit;
+    if (serverctrls && !(serverctrlsU = controlarrayWtoU( serverctrls ))) goto exit;
+    if (clientctrls && !(clientctrlsU = controlarrayWtoU( clientctrls ))) goto exit;
+
+    ret = map_error( ldap_funcs->ldap_add_ext_s( ld->ld, dnU, attrsU, serverctrlsU, clientctrlsU ) );
 
 exit:
     strfreeU( dnU );
     modarrayfreeU( attrsU );
     controlarrayfreeU( serverctrlsU );
     controlarrayfreeU( clientctrlsU );
-
-#endif
     return ret;
 }
 
@@ -377,35 +252,24 @@ ULONG CDECL ldap_add_ext_sW( WLDAP32_LDAP *ld, PWCHAR dn, LDAPModW *attrs[],
  *
  * See ldap_add_sW.
  */
-ULONG CDECL ldap_add_sA( WLDAP32_LDAP *ld, PCHAR dn, LDAPModA *attrs[] )
+ULONG CDECL ldap_add_sA( WLDAP32_LDAP *ld, char *dn, LDAPModA **attrs )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
     WCHAR *dnW = NULL;
     LDAPModW **attrsW = NULL;
 
-    ret = WLDAP32_LDAP_NO_MEMORY;
-
     TRACE( "(%p, %s, %p)\n", ld, debugstr_a(dn), attrs );
 
     if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
 
-    if (dn) {
-        dnW = strAtoW( dn );
-        if (!dnW) goto exit;
-    }
-    if (attrs) {
-        attrsW = modarrayAtoW( attrs );
-        if (!attrsW) goto exit;
-    }
+    if (dn && !(dnW = strAtoW( dn ))) goto exit;
+    if (attrs && !(attrsW = modarrayAtoW( attrs ))) goto exit;
 
     ret = ldap_add_sW( ld, dnW, attrsW );
 
 exit:
     strfreeW( dnW );
     modarrayfreeW( attrsW );
-
-#endif
     return ret;
 }
 
@@ -424,34 +288,8 @@ ULONG CDECL ldap_add_sA( WLDAP32_LDAP *ld, PCHAR dn, LDAPModA *attrs[] )
  *  Success: LDAP_SUCCESS
  *  Failure: An LDAP error code.
  */
-ULONG CDECL ldap_add_sW( WLDAP32_LDAP *ld, PWCHAR dn, LDAPModW *attrs[] )
+ULONG CDECL ldap_add_sW( WLDAP32_LDAP *ld, WCHAR *dn, LDAPModW **attrs )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
-    char *dnU = NULL;
-    LDAPMod **attrsU = NULL;
-
-    ret = WLDAP32_LDAP_NO_MEMORY;
-
     TRACE( "(%p, %s, %p)\n", ld, debugstr_w(dn), attrs );
-
-    if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
-
-    if (dn) {
-        dnU = strWtoU( dn );
-        if (!dnU) goto exit;
-    }
-    if (attrs) {
-        attrsU = modarrayWtoU( attrs );
-        if (!attrsU) goto exit;
-    }
-
-    ret = map_error( ldap_add_ext_s( ld->ld, dn ? dnU : "", attrs ? attrsU : nullattrs, NULL, NULL ));
-
-exit:
-    strfreeU( dnU );
-    modarrayfreeU( attrsU );
-
-#endif
-    return ret;
+    return ldap_add_ext_sW( ld, dn, attrs, NULL, NULL );
 }
diff --git a/dlls/wldap32/init.c b/dlls/wldap32/init.c
index 0072ede67723..6586caa0ef50 100644
--- a/dlls/wldap32/init.c
+++ b/dlls/wldap32/init.c
@@ -128,11 +128,11 @@ static BOOL has_ldap_scheme( char *url )
 static char *join_hostnames( const char *scheme, char **hostnames, ULONG portnumber )
 {
     char *res, *p, *q, **v;
-    unsigned int i = 0, size = 0; 
+    unsigned int i = 0, size = 0;
     static const char sep[] = " ", fmt[] = ":%d";
     char port[7];
 
-    sprintf( port, fmt, portnumber ); 
+    sprintf( port, fmt, portnumber );
 
     for (v = hostnames; *v; v++)
     {
@@ -147,7 +147,7 @@ static char *join_hostnames( const char *scheme, char **hostnames, ULONG portnum
 
         size += strlen( *v );
 
-        if (!strchr( q, ':' )) 
+        if (!strchr( q, ':' ))
             size += strlen( port );
 
         i++;
@@ -212,7 +212,7 @@ static WLDAP32_LDAP *create_context( const char *url )
 
     ld = heap_alloc_zero( sizeof( *ld ));
     if (!ld) return NULL;
-    if (ldap_initialize( &ld->ld, url ) != LDAP_SUCCESS)
+    if (ldap_initialize( (LDAP **)&ld->ld, url ) != LDAP_SUCCESS)
     {
         heap_free( ld );
         return NULL;
@@ -307,7 +307,7 @@ WLDAP32_LDAP * CDECL cldap_openW( PWCHAR hostname, ULONG portnumber )
 /***********************************************************************
  *      ldap_connect     (WLDAP32.@)
  *
- * Connect to an LDAP server. 
+ * Connect to an LDAP server.
  *
  * PARAMS
  *  ld      [I] Pointer to an LDAP context.
diff --git a/dlls/wldap32/libldap.c b/dlls/wldap32/libldap.c
new file mode 100644
index 000000000000..0372206062af
--- /dev/null
+++ b/dlls/wldap32/libldap.c
@@ -0,0 +1,81 @@
+/*
+ * Unix interface for libldap
+ *
+ * Copyright 2021 Hans Leidekker for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#ifdef HAVE_LDAP
+#include <stdarg.h>
+#ifdef HAVE_LDAP_H
+# include <ldap.h>
+#endif
+#ifdef HAVE_SASL_SASL_H
+# include <sasl/sasl.h>
+#endif
+
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+#include "windef.h"
+#include "winternl.h"
+#include "winbase.h"
+
+#include "wine/debug.h"
+#include "winldap_private.h"
+
+C_ASSERT( sizeof(BerValueU) == sizeof(BerValue) );
+C_ASSERT( sizeof(LDAPModU) == sizeof(LDAPMod) );
+C_ASSERT( sizeof(LDAPControlU) == sizeof(LDAPControl) );
+C_ASSERT( sizeof(LDAPSortKeyU) == sizeof(LDAPSortKey) );
+C_ASSERT( sizeof(LDAPVLVInfoU) == sizeof(LDAPVLVInfo) );
+
+static LDAPMod *nullattrs[] = { NULL };
+
+int CDECL wrap_ldap_add_ext( void *ld, char *dn, LDAPModU **attrs, LDAPControlU **serverctrls,
+                             LDAPControlU **clientctrls, ULONG *msg )
+{
+    int dummy;
+    return ldap_add_ext( ld, dn ? dn : "", attrs ? (LDAPMod **)attrs : nullattrs, (LDAPControl **)serverctrls,
+                         (LDAPControl **)clientctrls, msg ? (int *)msg : &dummy );
+}
+
+int CDECL wrap_ldap_add_ext_s( void *ld, char *dn, LDAPModU **attrs, LDAPControlU **serverctrls,
+                               LDAPControlU **clientctrls )
+{
+    return ldap_add_ext_s( ld, dn ? dn : "", attrs ? (LDAPMod **)attrs : nullattrs, (LDAPControl **)serverctrls,
+                           (LDAPControl **)clientctrls );
+}
+
+static const struct ldap_funcs funcs =
+{
+    wrap_ldap_add_ext,
+    wrap_ldap_add_ext_s,
+};
+
+NTSTATUS CDECL __wine_init_unix_lib( HMODULE module, DWORD reason, const void *ptr_in, void *ptr_out )
+{
+    if (reason != DLL_PROCESS_ATTACH) return STATUS_SUCCESS;
+    *(const struct ldap_funcs **)ptr_out = &funcs;
+    return STATUS_SUCCESS;
+}
+
+#endif /* HAVE_LDAP */
diff --git a/dlls/wldap32/libldap.h b/dlls/wldap32/libldap.h
new file mode 100644
index 000000000000..d9d833cdcb83
--- /dev/null
+++ b/dlls/wldap32/libldap.h
@@ -0,0 +1,72 @@
+/*
+ * Copyright 2021 Hans Leidekker for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+/* compatible with structures defined in ldap.h */
+typedef struct bervalU
+{
+    unsigned long bv_len;
+    char         *bv_val;
+} BerValueU;
+
+typedef struct
+{
+    int   mod_op;
+    char *mod_type;
+    union
+    {
+        char           **modv_strvals;
+        struct bervalU **modv_bvals;
+    } mod_vals;
+} LDAPModU;
+
+typedef struct
+{
+    char          *ldctl_oid;
+    struct bervalU ldctl_value;
+    char           ldctl_iscritical;
+} LDAPControlU;
+
+typedef struct
+{
+    char *attributeType;
+    char *orderingRule;
+    int   reverseOrder;
+} LDAPSortKeyU;
+
+typedef struct
+{
+    int             ldvlv_version;
+    int             ldvlv_before_count;
+    int             ldvlv_after_count;
+    int             ldvlv_offset;
+    int             ldvlv_count;
+    struct bervalU *ldvlv_attrvalue;
+    struct bervalU *ldvlv_context;
+    void           *ldvlv_extradata;
+} LDAPVLVInfoU;
+
+extern int CDECL wrap_ldap_add_ext(void *, char *, LDAPModU **, LDAPControlU **, LDAPControlU **, ULONG *) DECLSPEC_HIDDEN;
+extern int CDECL wrap_ldap_add_ext_s(void *, char *, LDAPModU **, LDAPControlU **, LDAPControlU **) DECLSPEC_HIDDEN;
+
+struct ldap_funcs
+{
+    int (CDECL *ldap_add_ext)(void *, char *, LDAPModU **, LDAPControlU **, LDAPControlU **, ULONG *);
+    int (CDECL *ldap_add_ext_s)(void *, char *, LDAPModU **, LDAPControlU **, LDAPControlU **);
+};
+
+extern const struct ldap_funcs *ldap_funcs;
diff --git a/dlls/wldap32/main.c b/dlls/wldap32/main.c
index ce9e60367b99..55a08c9bad5e 100644
--- a/dlls/wldap32/main.c
+++ b/dlls/wldap32/main.c
@@ -18,18 +18,20 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#include "config.h"
-
-#include "wine/debug.h"
 #include <stdarg.h>
-
 #include "windef.h"
+#include "winternl.h"
 #include "winbase.h"
 
+#include "wine/debug.h"
+#include "libldap.h"
+
 HINSTANCE hwldap32;
 
 WINE_DEFAULT_DEBUG_CHANNEL(wldap32);
 
+const struct ldap_funcs *ldap_funcs = NULL;
+
 BOOL WINAPI DllMain( HINSTANCE hinst, DWORD reason, LPVOID reserved )
 {
     TRACE( "(%p, %d, %p)\n", hinst, reason, reserved );
@@ -39,6 +41,8 @@ BOOL WINAPI DllMain( HINSTANCE hinst, DWORD reason, LPVOID reserved )
     case DLL_PROCESS_ATTACH:
         hwldap32 = hinst;
         DisableThreadLibraryCalls( hinst );
+        if (__wine_init_unix_lib( hinst, reason, NULL, &ldap_funcs ))
+            ERR( "No libldap support, expect problems\n" );
         break;
     }
     return TRUE;
diff --git a/dlls/wldap32/winldap_private.h b/dlls/wldap32/winldap_private.h
index 8cd546b88b57..d0583c61f500 100644
--- a/dlls/wldap32/winldap_private.h
+++ b/dlls/wldap32/winldap_private.h
@@ -22,6 +22,11 @@
  * native headers.
  */
 
+#include <assert.h>
+#include "winternl.h"
+#include "winnls.h"
+#include "libldap.h"
+
 typedef enum {
     WLDAP32_LDAP_SUCCESS                 =   0x00,
     WLDAP32_LDAP_UNWILLING_TO_PERFORM    =   0x35,
@@ -101,7 +106,9 @@ typedef struct berelement
 #define WLDAP32_LDAP_OPT_SECURITY_CONTEXT       0x99
 #define WLDAP32_LDAP_OPT_ROOTDSE_CACHE          0x9a
 
-#define WLDAP32_LDAP_AUTH_NEGOTIATE             0x486
+#define WLDAP32_LDAP_AUTH_SIMPLE         0x80
+#define WLDAP32_LDAP_AUTH_SASL           0x83
+#define WLDAP32_LDAP_AUTH_NEGOTIATE     0x486
 
 typedef struct WLDAP32_berval
 {
@@ -111,9 +118,6 @@ typedef struct WLDAP32_berval
 
 typedef struct wldap32
 {
-#ifdef HAVE_LDAP
-    LDAP *ld;
-#endif
     struct
     {
         UINT_PTR sb_sd;
@@ -137,7 +141,9 @@ typedef struct wldap32
     ULONG ld_cldaptimeout;
     ULONG ld_refhoplimit;
     ULONG ld_options;
+    /* internal LDAP context */
     struct berval **ld_server_ctrls;
+    void *ld;
 } WLDAP32_LDAP, *WLDAP32_PLDAP;
 
 typedef struct ldapmodA {
@@ -424,10 +430,10 @@ ULONG CDECL ldap_rename_ext_sA(WLDAP32_LDAP*,PCHAR,PCHAR,PCHAR,INT,PLDAPControlA
 ULONG CDECL ldap_rename_ext_sW(WLDAP32_LDAP*,PWCHAR,PWCHAR,PWCHAR,INT,PLDAPControlW*,PLDAPControlW*);
 ULONG CDECL WLDAP32_ldap_result(WLDAP32_LDAP*,ULONG,ULONG,struct l_timeval*,WLDAP32_LDAPMessage**);
 ULONG CDECL WLDAP32_ldap_result2error(WLDAP32_LDAP*,WLDAP32_LDAPMessage*,ULONG);
-ULONG CDECL ldap_sasl_bindA(WLDAP32_LDAP*,const PCHAR,const PCHAR,const BERVAL*,PLDAPControlA*,PLDAPControlA*,int*);
-ULONG CDECL ldap_sasl_bindW(WLDAP32_LDAP*,const PWCHAR,const PWCHAR,const BERVAL*,PLDAPControlW*,PLDAPControlW*,int*);
-ULONG CDECL ldap_sasl_bind_sA(WLDAP32_LDAP*,const PCHAR,const PCHAR,const BERVAL*,PLDAPControlA*,PLDAPControlA*,PBERVAL*);
-ULONG CDECL ldap_sasl_bind_sW(WLDAP32_LDAP*,const PWCHAR,const PWCHAR,const BERVAL*,PLDAPControlW*,PLDAPControlW*,PBERVAL*);
+ULONG CDECL ldap_sasl_bindA(WLDAP32_LDAP*,const PSTR,const PSTR,const BERVAL*,PLDAPControlA*,PLDAPControlA*,int*);
+ULONG CDECL ldap_sasl_bindW(WLDAP32_LDAP*,const PWSTR,const PWSTR,const BERVAL*,PLDAPControlW*,PLDAPControlW*,int*);
+ULONG CDECL ldap_sasl_bind_sA(WLDAP32_LDAP*,const PSTR,const PSTR,const BERVAL*,PLDAPControlA*,PLDAPControlA*,PBERVAL*);
+ULONG CDECL ldap_sasl_bind_sW(WLDAP32_LDAP*,const PWSTR,const PWSTR,const BERVAL*,PLDAPControlW*,PLDAPControlW*,PBERVAL*);
 ULONG CDECL ldap_search_abandon_page(WLDAP32_PLDAP,PLDAPSearch);
 ULONG CDECL ldap_searchA(WLDAP32_LDAP*,PCHAR,ULONG,PCHAR,PCHAR[],ULONG);
 ULONG CDECL ldap_searchW(WLDAP32_LDAP*,PWCHAR,ULONG,PWCHAR,PWCHAR[],ULONG);
@@ -473,3 +479,891 @@ ULONG CDECL LdapGetLastError(void);
 ULONG CDECL LdapMapErrorToWin32(ULONG);
 int CDECL LdapUnicodeToUTF8(LPCWSTR,int,LPSTR,int);
 int CDECL LdapUTF8ToUnicode(LPCSTR,int,LPWSTR,int);
+
+ULONG map_error( int ) DECLSPEC_HIDDEN;
+
+static inline char *strdupU( const char *src )
+{
+    char *dst;
+    if (!src) return NULL;
+    if ((dst = RtlAllocateHeap( GetProcessHeap(), 0, (strlen( src ) + 1) * sizeof(char) ))) strcpy( dst, src );
+    return dst;
+}
+
+#ifndef HAVE_LDAP
+static inline WCHAR *strdupW( const WCHAR *src )
+{
+    WCHAR *dst;
+    if (!src) return NULL;
+    if ((dst = RtlAllocateHeap( GetProcessHeap(), 0, (lstrlenW( src ) + 1) * sizeof(WCHAR) ))) lstrcpyW( dst, src );
+    return dst;
+}
+
+static inline char *strWtoU( const WCHAR *str )
+{
+    char *ret = NULL;
+    if (str)
+    {
+        int len = WideCharToMultiByte( CP_UTF8, 0, str, -1, NULL, 0, NULL, NULL );
+        if ((ret = RtlAllocateHeap( GetProcessHeap(), 0, len )))
+            WideCharToMultiByte( CP_UTF8, 0, str, -1, ret, len, NULL, NULL );
+    }
+    return ret;
+}
+
+static inline char *strnWtoU( const WCHAR *str, DWORD in_len, DWORD *out_len )
+{
+    char *ret = NULL;
+    *out_len = 0;
+    if (str)
+    {
+        DWORD len = WideCharToMultiByte( CP_UTF8, 0, str, in_len, NULL, 0, NULL, NULL );
+        if ((ret = RtlAllocateHeap( GetProcessHeap(), 0, len + 1 )))
+        {
+            WideCharToMultiByte( CP_UTF8, 0, str, in_len, ret, len, NULL, NULL );
+            ret[len] = 0;
+            *out_len = len;
+        }
+    }
+    return ret;
+}
+
+static inline void strfreeU( char *str )
+{
+    RtlFreeHeap( GetProcessHeap(), 0, str );
+}
+
+static inline WCHAR *strAtoW( const char *str )
+{
+    WCHAR *ret = NULL;
+    if (str)
+    {
+        DWORD len = MultiByteToWideChar( CP_ACP, 0, str, -1, NULL, 0 );
+        if ((ret = RtlAllocateHeap( GetProcessHeap(), 0, len * sizeof(WCHAR) )))
+            MultiByteToWideChar( CP_ACP, 0, str, -1, ret, len );
+    }
+    return ret;
+}
+
+static inline void strfreeW( WCHAR *str )
+{
+    RtlFreeHeap( GetProcessHeap(), 0, str );
+}
+
+static inline WCHAR *strnAtoW( const char *str, DWORD in_len, DWORD *out_len )
+{
+    WCHAR *ret = NULL;
+    *out_len = 0;
+    if (str)
+    {
+        DWORD len = MultiByteToWideChar( CP_ACP, 0, str, in_len, NULL, 0 );
+        if ((ret = RtlAllocateHeap( GetProcessHeap(), 0, (len + 1) * sizeof(WCHAR) )))
+        {
+            MultiByteToWideChar( CP_ACP, 0, str, in_len, ret, len );
+            ret[len] = 0;
+            *out_len = len;
+        }
+    }
+    return ret;
+}
+
+static inline DWORD bvarraylenW( struct WLDAP32_berval **bv )
+{
+    struct WLDAP32_berval **p = bv;
+    while (*p) p++;
+    return p - bv;
+}
+
+static inline DWORD strarraylenW( WCHAR **strarray )
+{
+    WCHAR **p = strarray;
+    while (*p) p++;
+    return p - strarray;
+}
+
+static inline char **strarrayWtoU( WCHAR **strarray )
+{
+    char **strarrayU = NULL;
+    DWORD size;
+
+    if (strarray)
+    {
+        size = sizeof(char *) * (strarraylenW( strarray ) + 1);
+        if ((strarrayU = RtlAllocateHeap( GetProcessHeap(), 0, size )))
+        {
+            WCHAR **p = strarray;
+            char **q = strarrayU;
+
+            while (*p) *q++ = strWtoU( *p++ );
+            *q = NULL;
+        }
+    }
+    return strarrayU;
+}
+
+static inline char *strWtoA( const WCHAR *str )
+{
+    char *ret = NULL;
+    if (str)
+    {
+        DWORD len = WideCharToMultiByte( CP_ACP, 0, str, -1, NULL, 0, NULL, NULL );
+        if ((ret = RtlAllocateHeap( GetProcessHeap(), 0, len )))
+            WideCharToMultiByte( CP_ACP, 0, str, -1, ret, len, NULL, NULL );
+    }
+    return ret;
+}
+
+static inline char **strarrayWtoA( WCHAR **strarray )
+{
+    char **strarrayA = NULL;
+    DWORD size;
+
+    if (strarray)
+    {
+        size = sizeof(char *) * (strarraylenW( strarray ) + 1);
+        if ((strarrayA = RtlAllocateHeap( GetProcessHeap(), 0, size )))
+        {
+            WCHAR **p = strarray;
+            char **q = strarrayA;
+
+            while (*p) *q++ = strWtoA( *p++ );
+            *q = NULL;
+        }
+    }
+    return strarrayA;
+}
+
+#define WLDAP32_LDAP_MOD_BVALUES    0x80
+
+static inline DWORD modarraylenW( LDAPModW **modarray )
+{
+    LDAPModW **p = modarray;
+    while (*p) p++;
+    return p - modarray;
+}
+
+static inline struct bervalU *bervalWtoU( const struct WLDAP32_berval *bv )
+{
+    struct bervalU *berval;
+    DWORD size = sizeof(*berval) + bv->bv_len;
+
+    if ((berval = RtlAllocateHeap( GetProcessHeap(), 0, size )))
+    {
+        char *val = (char *)(berval + 1);
+
+        berval->bv_len = bv->bv_len;
+        berval->bv_val = val;
+        memcpy( val, bv->bv_val, bv->bv_len );
+    }
+    return berval;
+}
+
+static inline DWORD bvarraylenU( struct bervalU **bv )
+{
+    struct bervalU **p = bv;
+    while (*p) p++;
+    return p - bv;
+}
+
+static inline struct WLDAP32_berval *bervalUtoW( const struct bervalU *bv )
+{
+    struct WLDAP32_berval *berval;
+    DWORD size = sizeof(*berval) + bv->bv_len;
+
+    assert( bv->bv_len <= ~0u );
+
+    if ((berval = RtlAllocateHeap( GetProcessHeap(), 0, size )))
+    {
+        char *val = (char *)(berval + 1);
+
+        berval->bv_len = bv->bv_len;
+        berval->bv_val = val;
+        memcpy( val, bv->bv_val, bv->bv_len );
+    }
+    return berval;
+}
+
+static inline struct WLDAP32_berval **bvarrayUtoW( struct bervalU **bv )
+{
+    struct WLDAP32_berval **berval = NULL;
+    DWORD size;
+
+    if (bv)
+    {
+        size = sizeof(*berval) * (bvarraylenU( bv ) + 1);
+        if ((berval = RtlAllocateHeap( GetProcessHeap(), 0, size )))
+        {
+            struct bervalU **p = bv;
+            struct WLDAP32_berval **q = berval;
+
+            while (*p) *q++ = bervalUtoW( *p++ );
+            *q = NULL;
+        }
+    }
+    return berval;
+}
+
+static inline void bvfreeU( struct bervalU *berval )
+{
+    RtlFreeHeap( GetProcessHeap(), 0, berval );
+}
+
+static inline struct bervalU **bvarrayWtoU( struct WLDAP32_berval **bv )
+{
+    struct bervalU **berval = NULL;
+    DWORD size;
+
+    if (bv)
+    {
+        size = sizeof(*berval) * (bvarraylenW( bv ) + 1);
+        if ((berval = RtlAllocateHeap( GetProcessHeap(), 0, size )))
+        {
+            struct WLDAP32_berval **p = bv;
+            struct bervalU **q = berval;
+
+            while (*p) *q++ = bervalWtoU( *p++ );
+            *q = NULL;
+        }
+    }
+    return berval;
+}
+
+static inline LDAPModU *modWtoU( const LDAPModW *mod )
+{
+    LDAPModU *modU;
+
+    if ((modU = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(LDAPModU) )))
+    {
+        modU->mod_op = mod->mod_op;
+        modU->mod_type = strWtoU( mod->mod_type );
+
+        if (mod->mod_op & WLDAP32_LDAP_MOD_BVALUES)
+            modU->mod_vals.modv_bvals = bvarrayWtoU( mod->mod_vals.modv_bvals );
+        else
+            modU->mod_vals.modv_strvals = strarrayWtoU( mod->mod_vals.modv_strvals );
+    }
+    return modU;
+}
+
+static inline LDAPModU **modarrayWtoU( LDAPModW **modarray )
+{
+    LDAPModU **modarrayU = NULL;
+    DWORD size;
+
+    if (modarray)
+    {
+        size = sizeof(LDAPModU *) * (modarraylenW( modarray ) + 1);
+        if ((modarrayU = RtlAllocateHeap( GetProcessHeap(), 0, size )))
+        {
+            LDAPModW **p = modarray;
+            LDAPModU **q = modarrayU;
+
+            while (*p) *q++ = modWtoU( *p++ );
+            *q = NULL;
+        }
+    }
+    return modarrayU;
+}
+
+static inline void bvarrayfreeU( struct bervalU **bv )
+{
+    struct bervalU **p = bv;
+    while (*p) RtlFreeHeap( GetProcessHeap(), 0, *p++ );
+    RtlFreeHeap( GetProcessHeap(), 0, bv );
+}
+
+static inline void strarrayfreeU( char **strarray )
+{
+    if (strarray)
+    {
+        char **p = strarray;
+        while (*p) strfreeU( *p++ );
+        RtlFreeHeap( GetProcessHeap(), 0, strarray );
+    }
+}
+
+static inline void modfreeU( LDAPModU *mod )
+{
+    if (mod->mod_op & WLDAP32_LDAP_MOD_BVALUES)
+        bvarrayfreeU( mod->mod_vals.modv_bvals );
+    else
+        strarrayfreeU( mod->mod_vals.modv_strvals );
+    RtlFreeHeap( GetProcessHeap(), 0, mod );
+}
+
+static inline void modarrayfreeU( LDAPModU **modarray )
+{
+    if (modarray)
+    {
+        LDAPModU **p = modarray;
+        while (*p) modfreeU( *p++ );
+        RtlFreeHeap( GetProcessHeap(), 0, modarray );
+    }
+}
+
+static inline DWORD modarraylenA( LDAPModA **modarray )
+{
+    LDAPModA **p = modarray;
+    while (*p) p++;
+    return p - modarray;
+}
+
+static inline struct WLDAP32_berval *bervalWtoW( const struct WLDAP32_berval *bv )
+{
+    struct WLDAP32_berval *berval;
+    DWORD size = sizeof(*berval) + bv->bv_len;
+
+    if ((berval = RtlAllocateHeap( GetProcessHeap(), 0, size )))
+    {
+        char *val = (char *)(berval + 1);
+
+        berval->bv_len = bv->bv_len;
+        berval->bv_val = val;
+        memcpy( val, bv->bv_val, bv->bv_len );
+    }
+    return berval;
+}
+
+static inline struct WLDAP32_berval **bvarrayWtoW( struct WLDAP32_berval **bv )
+{
+    struct WLDAP32_berval **berval = NULL;
+    DWORD size;
+
+    if (bv)
+    {
+        size = sizeof(*berval) * (bvarraylenW( bv ) + 1);
+        if ((berval = RtlAllocateHeap( GetProcessHeap(), 0, size )))
+        {
+            struct WLDAP32_berval **p = bv;
+            struct WLDAP32_berval **q = berval;
+
+            while (*p) *q++ = bervalWtoW( *p++ );
+            *q = NULL;
+        }
+    }
+    return berval;
+}
+
+static inline DWORD strarraylenA( char **strarray )
+{
+    char **p = strarray;
+    while (*p) p++;
+    return p - strarray;
+}
+
+static inline WCHAR **strarrayAtoW( char **strarray )
+{
+    WCHAR **strarrayW = NULL;
+    DWORD size;
+
+    if (strarray)
+    {
+        size  = sizeof(WCHAR *) * (strarraylenA( strarray ) + 1);
+        if ((strarrayW = RtlAllocateHeap( GetProcessHeap(), 0, size )))
+        {
+            char **p = strarray;
+            WCHAR **q = strarrayW;
+
+            while (*p) *q++ = strAtoW( *p++ );
+            *q = NULL;
+        }
+    }
+    return strarrayW;
+}
+
+static inline LDAPModW *modAtoW( const LDAPModA *mod )
+{
+    LDAPModW *modW;
+
+    if ((modW = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(LDAPModW) )))
+    {
+        modW->mod_op = mod->mod_op;
+        modW->mod_type = strAtoW( mod->mod_type );
+
+        if (mod->mod_op & WLDAP32_LDAP_MOD_BVALUES)
+            modW->mod_vals.modv_bvals = bvarrayWtoW( mod->mod_vals.modv_bvals );
+        else
+            modW->mod_vals.modv_strvals = strarrayAtoW( mod->mod_vals.modv_strvals );
+    }
+    return modW;
+}
+
+static inline LDAPModW **modarrayAtoW( LDAPModA **modarray )
+{
+    LDAPModW **modarrayW = NULL;
+    DWORD size;
+
+    if (modarray)
+    {
+        size = sizeof(LDAPModW *) * (modarraylenA( modarray ) + 1);
+        if ((modarrayW = RtlAllocateHeap( GetProcessHeap(), 0, size )))
+        {
+            LDAPModA **p = modarray;
+            LDAPModW **q = modarrayW;
+
+            while (*p) *q++ = modAtoW( *p++ );
+            *q = NULL;
+        }
+    }
+    return modarrayW;
+}
+
+static inline void bvarrayfreeW( struct WLDAP32_berval **bv )
+{
+    struct WLDAP32_berval **p = bv;
+    while (*p) RtlFreeHeap( GetProcessHeap(), 0, *p++ );
+    RtlFreeHeap( GetProcessHeap(), 0, bv );
+}
+
+static inline void strarrayfreeW( WCHAR **strarray )
+{
+    if (strarray)
+    {
+        WCHAR **p = strarray;
+        while (*p) strfreeW( *p++ );
+        RtlFreeHeap( GetProcessHeap(), 0, strarray );
+    }
+}
+
+static inline void modfreeW( LDAPModW *mod )
+{
+    if (mod->mod_op & WLDAP32_LDAP_MOD_BVALUES)
+        bvarrayfreeW( mod->mod_vals.modv_bvals );
+    else
+        strarrayfreeW( mod->mod_vals.modv_strvals );
+    RtlFreeHeap( GetProcessHeap(), 0, mod );
+}
+
+static inline void modarrayfreeW( LDAPModW **modarray )
+{
+    if (modarray)
+    {
+        LDAPModW **p = modarray;
+        while (*p) modfreeW( *p++ );
+        RtlFreeHeap( GetProcessHeap(), 0, modarray );
+    }
+}
+
+static inline DWORD controlarraylenA( LDAPControlA **controlarray )
+{
+    LDAPControlA **p = controlarray;
+    while (*p) p++;
+    return p - controlarray;
+}
+
+static inline LDAPControlW *controlAtoW( const LDAPControlA *control )
+{
+    LDAPControlW *controlW;
+    DWORD len = control->ldctl_value.bv_len;
+    char *val = NULL;
+
+    if (control->ldctl_value.bv_val)
+    {
+        if (!(val = RtlAllocateHeap( GetProcessHeap(), 0, len ))) return NULL;
+        memcpy( val, control->ldctl_value.bv_val, len );
+    }
+
+    if (!(controlW = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(LDAPControlW) )))
+    {
+        RtlFreeHeap( GetProcessHeap(), 0, val );
+        return NULL;
+    }
+
+    controlW->ldctl_oid = strAtoW( control->ldctl_oid );
+    controlW->ldctl_value.bv_len = len;
+    controlW->ldctl_value.bv_val = val;
+    controlW->ldctl_iscritical = control->ldctl_iscritical;
+
+    return controlW;
+}
+
+static inline LDAPControlW **controlarrayAtoW( LDAPControlA **controlarray )
+{
+    LDAPControlW **controlarrayW = NULL;
+    DWORD size;
+
+    if (controlarray)
+    {
+        size = sizeof(LDAPControlW *) * (controlarraylenA( controlarray ) + 1);
+        if ((controlarrayW = RtlAllocateHeap( GetProcessHeap(), 0, size )))
+        {
+            LDAPControlA **p = controlarray;
+            LDAPControlW **q = controlarrayW;
+
+            while (*p) *q++ = controlAtoW( *p++ );
+            *q = NULL;
+        }
+    }
+    return controlarrayW;
+}
+
+static inline void controlfreeW( LDAPControlW *control )
+{
+    if (control)
+    {
+        strfreeW( control->ldctl_oid );
+        RtlFreeHeap( GetProcessHeap(), 0, control->ldctl_value.bv_val );
+        RtlFreeHeap( GetProcessHeap(), 0, control );
+    }
+}
+
+static inline void controlarrayfreeW( LDAPControlW **controlarray )
+{
+    if (controlarray)
+    {
+        LDAPControlW **p = controlarray;
+        while (*p) controlfreeW( *p++ );
+        RtlFreeHeap( GetProcessHeap(), 0, controlarray );
+    }
+}
+
+static inline DWORD controlarraylenW( LDAPControlW **controlarray )
+{
+    LDAPControlW **p = controlarray;
+    while (*p) p++;
+    return p - controlarray;
+}
+
+static inline LDAPControlA *controlWtoA( const LDAPControlW *control )
+{
+    LDAPControlA *controlA;
+    DWORD len = control->ldctl_value.bv_len;
+    char *val = NULL;
+
+    if (control->ldctl_value.bv_val)
+    {
+        if (!(val = RtlAllocateHeap( GetProcessHeap(), 0, len ))) return NULL;
+        memcpy( val, control->ldctl_value.bv_val, len );
+    }
+
+    if (!(controlA = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(LDAPControlA) )))
+    {
+        RtlFreeHeap( GetProcessHeap(), 0, val );
+        return NULL;
+    }
+
+    controlA->ldctl_oid = strWtoA( control->ldctl_oid );
+    controlA->ldctl_value.bv_len = len;
+    controlA->ldctl_value.bv_val = val;
+    controlA->ldctl_iscritical = control->ldctl_iscritical;
+
+    return controlA;
+}
+
+static inline void strfreeA( char *str )
+{
+    RtlFreeHeap( GetProcessHeap(), 0, str );
+}
+
+static inline void controlfreeA( LDAPControlA *control )
+{
+    if (control)
+    {
+        strfreeA( control->ldctl_oid );
+        RtlFreeHeap( GetProcessHeap(), 0, control->ldctl_value.bv_val );
+        RtlFreeHeap( GetProcessHeap(), 0, control );
+    }
+}
+
+static inline void controlarrayfreeA( LDAPControlA **controlarray )
+{
+    if (controlarray)
+    {
+        LDAPControlA **p = controlarray;
+        while (*p) controlfreeA( *p++ );
+        RtlFreeHeap( GetProcessHeap(), 0, controlarray );
+    }
+}
+
+static inline LDAPControlU *controlWtoU( const LDAPControlW *control )
+{
+    LDAPControlU *controlU;
+    DWORD len = control->ldctl_value.bv_len;
+    char *val = NULL;
+
+    if (control->ldctl_value.bv_val)
+    {
+        if (!(val = RtlAllocateHeap( GetProcessHeap(), 0, len ))) return NULL;
+        memcpy( val, control->ldctl_value.bv_val, len );
+    }
+
+    if (!(controlU = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(LDAPControlU) )))
+    {
+        RtlFreeHeap( GetProcessHeap(), 0, val );
+        return NULL;
+    }
+
+    controlU->ldctl_oid = strWtoU( control->ldctl_oid );
+    controlU->ldctl_value.bv_len = len;
+    controlU->ldctl_value.bv_val = val;
+    controlU->ldctl_iscritical = control->ldctl_iscritical;
+
+    return controlU;
+}
+
+static inline LDAPControlU **controlarrayWtoU( LDAPControlW **controlarray )
+{
+    LDAPControlU **controlarrayU = NULL;
+    DWORD size;
+
+    if (controlarray)
+    {
+        size = sizeof(LDAPControlU *) * (controlarraylenW( controlarray ) + 1);
+        if ((controlarrayU = RtlAllocateHeap( GetProcessHeap(), 0, size )))
+        {
+            LDAPControlW **p = controlarray;
+            LDAPControlU **q = controlarrayU;
+
+            while (*p) *q++ = controlWtoU( *p++ );
+            *q = NULL;
+        }
+    }
+    return controlarrayU;
+}
+
+static inline void controlfreeU( LDAPControlU *control )
+{
+    if (control)
+    {
+        strfreeU( control->ldctl_oid );
+        RtlFreeHeap( GetProcessHeap(), 0, control->ldctl_value.bv_val );
+        RtlFreeHeap( GetProcessHeap(), 0, control );
+    }
+}
+
+static inline void controlarrayfreeU( LDAPControlU **controlarray )
+{
+    if (controlarray)
+    {
+        LDAPControlU **p = controlarray;
+        while (*p) controlfreeU( *p++ );
+        RtlFreeHeap( GetProcessHeap(), 0, controlarray );
+    }
+}
+
+static inline DWORD controlarraylenU( LDAPControlU **controlarray )
+{
+    LDAPControlU **p = controlarray;
+    while (*p) p++;
+    return p - controlarray;
+}
+
+static inline WCHAR *strUtoW( const char *str )
+{
+    WCHAR *ret = NULL;
+    if (str)
+    {
+        DWORD len = MultiByteToWideChar( CP_UTF8, 0, str, -1, NULL, 0 );
+        if ((ret = RtlAllocateHeap( GetProcessHeap(), 0, len * sizeof(WCHAR) )))
+            MultiByteToWideChar( CP_UTF8, 0, str, -1, ret, len );
+    }
+    return ret;
+}
+
+static inline DWORD strarraylenU( char **strarray )
+{
+    char **p = strarray;
+    while (*p) p++;
+    return p - strarray;
+}
+
+static inline WCHAR **strarrayUtoW( char **strarray )
+{
+    WCHAR **strarrayW = NULL;
+    DWORD size;
+
+    if (strarray)
+    {
+        size = sizeof(WCHAR *) * (strarraylenU( strarray ) + 1);
+        if ((strarrayW = RtlAllocateHeap( GetProcessHeap(), 0, size )))
+        {
+            char **p = strarray;
+            WCHAR **q = strarrayW;
+
+            while (*p) *q++ = strUtoW( *p++ );
+            *q = NULL;
+        }
+    }
+    return strarrayW;
+}
+
+static inline LDAPControlW *controlUtoW( const LDAPControlU *control )
+{
+    LDAPControlW *controlW;
+    DWORD len = control->ldctl_value.bv_len;
+    char *val = NULL;
+
+    if (control->ldctl_value.bv_val)
+    {
+        if (!(val = RtlAllocateHeap( GetProcessHeap(), 0, len ))) return NULL;
+        memcpy( val, control->ldctl_value.bv_val, len );
+    }
+
+    if (!(controlW = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(LDAPControlW) )))
+    {
+        RtlFreeHeap( GetProcessHeap(), 0, val );
+        return NULL;
+    }
+
+    controlW->ldctl_oid = strUtoW( control->ldctl_oid );
+    controlW->ldctl_value.bv_len = len;
+    controlW->ldctl_value.bv_val = val;
+    controlW->ldctl_iscritical = control->ldctl_iscritical;
+
+    return controlW;
+}
+
+static inline DWORD sortkeyarraylenA( LDAPSortKeyA **sortkeyarray )
+{
+    LDAPSortKeyA **p = sortkeyarray;
+    while (*p) p++;
+    return p - sortkeyarray;
+}
+
+static inline LDAPSortKeyW *sortkeyAtoW( const LDAPSortKeyA *sortkey )
+{
+    LDAPSortKeyW *sortkeyW;
+
+    if ((sortkeyW = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(LDAPSortKeyW) )))
+    {
+        sortkeyW->sk_attrtype = strAtoW( sortkey->sk_attrtype );
+        sortkeyW->sk_matchruleoid = strAtoW( sortkey->sk_matchruleoid );
+        sortkeyW->sk_reverseorder = sortkey->sk_reverseorder;
+    }
+    return sortkeyW;
+}
+
+static inline LDAPSortKeyW **sortkeyarrayAtoW( LDAPSortKeyA **sortkeyarray )
+{
+    LDAPSortKeyW **sortkeyarrayW = NULL;
+    DWORD size;
+
+    if (sortkeyarray)
+    {
+        size = sizeof(LDAPSortKeyW *) * (sortkeyarraylenA( sortkeyarray ) + 1);
+        if ((sortkeyarrayW = RtlAllocateHeap( GetProcessHeap(), 0, size )))
+        {
+            LDAPSortKeyA **p = sortkeyarray;
+            LDAPSortKeyW **q = sortkeyarrayW;
+
+            while (*p) *q++ = sortkeyAtoW( *p++ );
+            *q = NULL;
+        }
+    }
+    return sortkeyarrayW;
+}
+
+static inline void sortkeyfreeW( LDAPSortKeyW *sortkey )
+{
+    if (sortkey)
+    {
+        strfreeW( sortkey->sk_attrtype );
+        strfreeW( sortkey->sk_matchruleoid );
+        RtlFreeHeap( GetProcessHeap(), 0, sortkey );
+    }
+}
+
+static inline void sortkeyarrayfreeW( LDAPSortKeyW **sortkeyarray )
+{
+    if (sortkeyarray)
+    {
+        LDAPSortKeyW **p = sortkeyarray;
+        while (*p) sortkeyfreeW( *p++ );
+        RtlFreeHeap( GetProcessHeap(), 0, sortkeyarray );
+    }
+}
+
+static inline DWORD sortkeyarraylenW( LDAPSortKeyW **sortkeyarray )
+{
+    LDAPSortKeyW **p = sortkeyarray;
+    while (*p) p++;
+    return p - sortkeyarray;
+}
+
+static inline LDAPSortKeyU *sortkeyWtoU( const LDAPSortKeyW *sortkey )
+{
+    LDAPSortKeyU *sortkeyU;
+
+    if ((sortkeyU = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(LDAPSortKeyU) )))
+    {
+        sortkeyU->attributeType = strWtoU( sortkey->sk_attrtype );
+        sortkeyU->orderingRule = strWtoU( sortkey->sk_matchruleoid );
+        sortkeyU->reverseOrder = sortkey->sk_reverseorder;
+    }
+    return sortkeyU;
+}
+
+static inline LDAPSortKeyU **sortkeyarrayWtoU( LDAPSortKeyW **sortkeyarray )
+{
+    LDAPSortKeyU **sortkeyarrayU = NULL;
+    DWORD size;
+
+    if (sortkeyarray)
+    {
+        size = sizeof(LDAPSortKeyU *) * (sortkeyarraylenW( sortkeyarray ) + 1);
+        if ((sortkeyarrayU = RtlAllocateHeap( GetProcessHeap(), 0, size )))
+        {
+            LDAPSortKeyW **p = sortkeyarray;
+            LDAPSortKeyU **q = sortkeyarrayU;
+
+            while (*p) *q++ = sortkeyWtoU( *p++ );
+            *q = NULL;
+        }
+    }
+    return sortkeyarrayU;
+}
+
+static inline void sortkeyfreeU( LDAPSortKeyU *sortkey )
+{
+    if (sortkey)
+    {
+        strfreeU( sortkey->attributeType );
+        strfreeU( sortkey->orderingRule );
+        RtlFreeHeap( GetProcessHeap(), 0, sortkey );
+    }
+}
+
+static inline void sortkeyarrayfreeU( LDAPSortKeyU **sortkeyarray )
+{
+    if (sortkeyarray)
+    {
+        LDAPSortKeyU **p = sortkeyarray;
+        while (*p) sortkeyfreeU( *p++ );
+        RtlFreeHeap( GetProcessHeap(), 0, sortkeyarray );
+    }
+}
+
+static inline LDAPVLVInfoU *vlvinfoWtoU( const WLDAP32_LDAPVLVInfo *info )
+{
+    LDAPVLVInfoU *infoU;
+
+    if ((infoU = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(*infoU) )))
+    {
+        infoU->ldvlv_version       = info->ldvlv_version;
+        infoU->ldvlv_before_count  = info->ldvlv_before_count;
+        infoU->ldvlv_after_count   = info->ldvlv_after_count;
+        infoU->ldvlv_offset        = info->ldvlv_offset;
+        infoU->ldvlv_count         = info->ldvlv_count;
+        if (!(infoU->ldvlv_attrvalue = bervalWtoU( info->ldvlv_attrvalue )))
+        {
+            RtlFreeHeap( GetProcessHeap(), 0, infoU );
+            return NULL;
+        }
+        if (!(infoU->ldvlv_context = bervalWtoU( info->ldvlv_context )))
+        {
+            RtlFreeHeap( GetProcessHeap(), 0, infoU->ldvlv_attrvalue );
+            RtlFreeHeap( GetProcessHeap(), 0, infoU );
+            return NULL;
+        }
+        infoU->ldvlv_extradata     = info->ldvlv_extradata;
+    }
+    return infoU;
+}
+
+static inline void vlvinfofreeU( LDAPVLVInfoU *info )
+{
+    RtlFreeHeap( GetProcessHeap(), 0, info->ldvlv_attrvalue );
+    RtlFreeHeap( GetProcessHeap(), 0, info->ldvlv_context );
+    RtlFreeHeap( GetProcessHeap(), 0, info );
+}
+#endif
diff --git a/dlls/wldap32/wldap32.h b/dlls/wldap32/wldap32.h
index 5b099c9fabc6..17132ff80c1c 100644
--- a/dlls/wldap32/wldap32.h
+++ b/dlls/wldap32/wldap32.h
@@ -30,14 +30,7 @@ ULONG map_error( int ) DECLSPEC_HIDDEN;
  * to and from ansi (A), wide character (W) and utf8 (U) encodings.
  */
 
-static inline char *strdupU( const char *src )
-{
-    char *dst;
-    if (!src) return NULL;
-    if ((dst = heap_alloc( (strlen( src ) + 1) * sizeof(char) ))) strcpy( dst, src );
-    return dst;
-}
-
+#ifdef HAVE_LDAP
 static inline WCHAR *strdupW( const WCHAR *src )
 {
     WCHAR *dst;
@@ -264,16 +257,6 @@ static inline LPWSTR *strarraydupW( LPWSTR *strarray )
     return strarrayW;
 }
 
-static inline void strarrayfreeA( LPSTR *strarray )
-{
-    if (strarray)
-    {
-        LPSTR *p = strarray;
-        while (*p) strfreeA( *p++ );
-        heap_free( strarray );
-    }
-}
-
 static inline void strarrayfreeW( LPWSTR *strarray )
 {
     if (strarray)
@@ -316,6 +299,17 @@ static inline void bvarrayfreeW( struct WLDAP32_berval **bv )
     while (*p) heap_free( *p++ );
     heap_free( bv );
 }
+#endif
+
+static inline void strarrayfreeA( LPSTR *strarray )
+{
+    if (strarray)
+    {
+        LPSTR *p = strarray;
+        while (*p) strfreeA( *p++ );
+        heap_free( strarray );
+    }
+}
 
 #ifdef HAVE_LDAP
 
From 3f25be74fc3a2c8e1cbe6cf980d0e31b617064a7 Mon Sep 17 00:00:00 2001
From: Hans Leidekker <hans@codeweavers.com>
Date: Tue, 6 Apr 2021 15:46:51 +0200
Subject: [PATCH] include: Add winber.h.

Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 include/winber.h | 37 +++++++++++++++++++++++++++++++++++++
 1 file changed, 37 insertions(+)
 create mode 100644 include/winber.h

diff --git a/include/winber.h b/include/winber.h
new file mode 100644
index 000000000000..40ab0f40ed8d
--- /dev/null
+++ b/include/winber.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright 2021 Hans Leidekker for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __WINE_WINBER_H
+#define __WINE_WINBER_H
+
+#define LBER_ERROR   (~0L)
+#define LBER_DEFAULT (~0L)
+
+typedef int ber_int_t;
+typedef unsigned int ber_tag_t;
+typedef unsigned int ber_len_t;
+
+BerElement * CDECL ber_alloc_t( int );
+void CDECL ber_bvfree( BERVAL * );
+int CDECL ber_flatten( BerElement *, BERVAL ** );
+void CDECL ber_free( BerElement *, int );
+BerElement * CDECL ber_init( BERVAL * );
+int WINAPIV ber_printf( BerElement *, char *, ... );
+ULONG WINAPIV ber_scanf( BerElement *, char *, ... );
+
+#endif /* __WINE_WINBER_H */
From 1114f2970d659def7e9b785db06d60d80eb26b58 Mon Sep 17 00:00:00 2001
From: Hans Leidekker <hans@codeweavers.com>
Date: Wed, 14 Apr 2021 09:40:26 +0200
Subject: [PATCH] wldap32: Move support for ber functions to the Unix library.

Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/wldap32/ber.c             | 348 ++++++++++++++-------------------
 dlls/wldap32/libldap.c         | 260 ++++++++++++++++++++++++
 dlls/wldap32/libldap.h         |  28 +++
 dlls/wldap32/misc.c            |  28 ++-
 dlls/wldap32/winldap_private.h |  22 +++
 include/winber.h               |   6 +
 6 files changed, 477 insertions(+), 215 deletions(-)

diff --git a/dlls/wldap32/ber.c b/dlls/wldap32/ber.c
index 7f39b9cfe17d..ae5e9292e04e 100644
--- a/dlls/wldap32/ber.c
+++ b/dlls/wldap32/ber.c
@@ -18,24 +18,16 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#include "config.h"
-
 #include <stdarg.h>
-#ifdef HAVE_LDAP_H
-#include <ldap.h>
-#endif
-
 #include "windef.h"
 #include "winbase.h"
-#include "winldap_private.h"
-#include "wldap32.h"
+#include "winnls.h"
+
 #include "wine/debug.h"
+#include "wine/heap.h"
+#include "winldap_private.h"
 
-#ifdef HAVE_LDAP
 WINE_DEFAULT_DEBUG_CHANNEL(wldap32);
-#endif
-
-#define WLDAP32_LBER_ERROR (~0U)
 
 /***********************************************************************
  *      ber_alloc_t     (WLDAP32.@)
@@ -52,13 +44,17 @@ WINE_DEFAULT_DEBUG_CHANNEL(wldap32);
  * NOTES
  *  Free the berelement structure with ber_free.
  */
-WLDAP32_BerElement * CDECL WLDAP32_ber_alloc_t( INT options )
+WLDAP32_BerElement * CDECL WLDAP32_ber_alloc_t( int options )
 {
-#ifdef HAVE_LDAP
-    return ber_alloc_t( options );
-#else
-    return NULL;
-#endif
+    WLDAP32_BerElement *ret;
+
+    if (!(ret = heap_alloc( sizeof(*ret) ))) return NULL;
+    if (!(ret->opaque = ldap_funcs->ber_alloc_t( options )))
+    {
+        heap_free( ret );
+        return NULL;
+    }
+    return ret;
 }
 
 
@@ -98,7 +94,7 @@ BERVAL * CDECL WLDAP32_ber_bvdup( BERVAL *berval )
  *  Use this function only to free an array of berval structures
  *  returned by a call to ber_scanf with a 'V' in the format string.
  */
-void CDECL WLDAP32_ber_bvecfree( PBERVAL *berval )
+void CDECL WLDAP32_ber_bvecfree( BERVAL **berval )
 {
     bvarrayfreeW( berval );
 }
@@ -142,26 +138,9 @@ void CDECL WLDAP32_ber_bvfree( BERVAL *berval )
  * NOTES
  *  len and cookie should be passed to ber_next_element.
  */
-ULONG CDECL WLDAP32_ber_first_element( WLDAP32_BerElement *berelement, ULONG *ret_len, CHAR **opaque )
+ULONG CDECL WLDAP32_ber_first_element( WLDAP32_BerElement *ber, ULONG *len, char **opaque )
 {
-#ifdef HAVE_LDAP
-    ber_len_t len;
-    ber_tag_t ret;
-
-    if ((ret = ber_first_element( berelement, &len, opaque )) != LBER_ERROR)
-    {
-        if (len > ~0u)
-        {
-            ERR( "len too large\n" );
-            return WLDAP32_LBER_ERROR;
-        }
-        *ret_len = len;
-    }
-    return ret;
-
-#else
-    return WLDAP32_LBER_ERROR;
-#endif
+    return ldap_funcs->ber_first_element( ber->opaque, len, opaque );
 }
 
 
@@ -181,23 +160,18 @@ ULONG CDECL WLDAP32_ber_first_element( WLDAP32_BerElement *berelement, ULONG *re
  * NOTES
  *  Free the berval structure with ber_bvfree.
  */
-INT CDECL WLDAP32_ber_flatten( WLDAP32_BerElement *berelement, PBERVAL *berval )
+int CDECL WLDAP32_ber_flatten( WLDAP32_BerElement *ber, BERVAL **berval )
 {
-#ifdef HAVE_LDAP
-    struct berval *bervalU;
+    struct bervalU *bervalU;
     struct WLDAP32_berval *bervalW;
 
-    if (ber_flatten( berelement, &bervalU )) return WLDAP32_LBER_ERROR;
+    if (ldap_funcs->ber_flatten( ber->opaque, &bervalU )) return WLDAP32_LBER_ERROR;
 
-    bervalW = bervalUtoW( bervalU );
-    ber_bvfree( bervalU );
+    if (!(bervalW = bervalUtoW( bervalU ))) return WLDAP32_LBER_ERROR;
+    ldap_funcs->ber_bvfree( bervalU );
     if (!bervalW) return WLDAP32_LBER_ERROR;
     *berval = bervalW;
     return 0;
-
-#else
-    return WLDAP32_LBER_ERROR;
-#endif
 }
 
 
@@ -217,11 +191,10 @@ INT CDECL WLDAP32_ber_flatten( WLDAP32_BerElement *berelement, PBERVAL *berval )
  *  Set buf to 0 if the berelement was allocated with ldap_first_attribute
  *  or ldap_next_attribute, otherwise set it to 1.
  */
-void CDECL WLDAP32_ber_free( WLDAP32_BerElement *berelement, INT buf )
+void CDECL WLDAP32_ber_free( WLDAP32_BerElement *ber, int freebuf )
 {
-#ifdef HAVE_LDAP
-    ber_free( berelement, buf );
-#endif
+    ldap_funcs->ber_free( ber->opaque, freebuf );
+    heap_free( ber );
 }
 
 
@@ -242,17 +215,22 @@ void CDECL WLDAP32_ber_free( WLDAP32_BerElement *berelement, INT buf )
  */
 WLDAP32_BerElement * CDECL WLDAP32_ber_init( BERVAL *berval )
 {
-#ifdef HAVE_LDAP
-    struct berval *bervalU;
+    struct bervalU *bervalU;
     WLDAP32_BerElement *ret;
 
-    if (!(bervalU = bervalWtoU( berval ))) return NULL;
-    ret = ber_init( bervalU );
+    if (!(ret = heap_alloc( sizeof(*ret) ))) return NULL;
+    if (!(bervalU = bervalWtoU( berval )))
+    {
+        heap_free( ret );
+        return NULL;
+    }
+    if (!(ret->opaque = ldap_funcs->ber_init( bervalU )))
+    {
+        heap_free( ret );
+        ret = NULL;
+    }
     heap_free( bervalU );
     return ret;
-#else
-    return NULL;
-#endif
 }
 
 
@@ -274,26 +252,9 @@ WLDAP32_BerElement * CDECL WLDAP32_ber_init( BERVAL *berval )
  *  len and cookie are initialized by ber_first_element and should
  *  be passed on in subsequent calls to ber_next_element.
  */
-ULONG CDECL WLDAP32_ber_next_element( WLDAP32_BerElement *berelement, ULONG *ret_len, CHAR *opaque )
+ULONG CDECL WLDAP32_ber_next_element( WLDAP32_BerElement *ber, ULONG *len, char *opaque )
 {
-#ifdef HAVE_LDAP
-    ber_len_t len;
-    ber_tag_t ret;
-
-    if ((ret = ber_next_element( berelement, &len, opaque )) != LBER_ERROR)
-    {
-        if (len > ~0u)
-        {
-            ERR( "len too large\n" );
-            return WLDAP32_LBER_ERROR;
-        }
-        *ret_len = len;
-    }
-    return ret;
-
-#else
-    return WLDAP32_LBER_ERROR;
-#endif
+    return ldap_funcs->ber_next_element( ber->opaque, len, opaque );
 }
 
 
@@ -310,26 +271,9 @@ ULONG CDECL WLDAP32_ber_next_element( WLDAP32_BerElement *berelement, ULONG *ret
  *  Success: Tag of the next element.
  *  Failure: LBER_DEFAULT (no more data).
  */
-ULONG CDECL WLDAP32_ber_peek_tag( WLDAP32_BerElement *berelement, ULONG *ret_len )
+ULONG CDECL WLDAP32_ber_peek_tag( WLDAP32_BerElement *ber, ULONG *len )
 {
-#ifdef HAVE_LDAP
-    ber_len_t len;
-    ber_tag_t ret;
-
-    if ((ret = ber_peek_tag( berelement, &len )) != LBER_ERROR)
-    {
-        if (len > ~0u)
-        {
-            ERR( "len too large\n" );
-            return WLDAP32_LBER_ERROR;
-        }
-        *ret_len = len;
-    }
-    return ret;
-
-#else
-    return WLDAP32_LBER_ERROR;
-#endif
+    return ldap_funcs->ber_peek_tag( ber->opaque, len );
 }
 
 
@@ -346,26 +290,9 @@ ULONG CDECL WLDAP32_ber_peek_tag( WLDAP32_BerElement *berelement, ULONG *ret_len
  *  Success: Tag of the next element.
  *  Failure: LBER_DEFAULT (no more data).
  */
-ULONG CDECL WLDAP32_ber_skip_tag( WLDAP32_BerElement *berelement, ULONG *ret_len )
+ULONG CDECL WLDAP32_ber_skip_tag( WLDAP32_BerElement *ber, ULONG *len )
 {
-#ifdef HAVE_LDAP
-    ber_len_t len;
-    ber_tag_t ret;
-
-    if ((ret = ber_skip_tag( berelement, &len )) != LBER_ERROR)
-    {
-        if (len > ~0u)
-        {
-            ERR( "len too large\n" );
-            return WLDAP32_LBER_ERROR;
-        }
-        *ret_len = len;
-    }
-    return ret;
-
-#else
-    return WLDAP32_LBER_ERROR;
-#endif
+    return ldap_funcs->ber_skip_tag( ber->opaque, len );
 }
 
 
@@ -380,16 +307,15 @@ ULONG CDECL WLDAP32_ber_skip_tag( WLDAP32_BerElement *berelement, ULONG *ret_len
  *  ...        [I]   Values to encode.
  *
  * RETURNS
- *  Success: Non-negative number. 
+ *  Success: Non-negative number.
  *  Failure: LBER_ERROR
  *
  * NOTES
  *  berelement must have been allocated with ber_alloc_t. This function
  *  can be called multiple times to append data.
  */
-INT WINAPIV WLDAP32_ber_printf( WLDAP32_BerElement *berelement, PCHAR fmt, ... )
+int WINAPIV WLDAP32_ber_printf( WLDAP32_BerElement *ber, char *fmt, ... )
 {
-#ifdef HAVE_LDAP
     __ms_va_list list;
     int ret = 0;
     char new_fmt[2];
@@ -399,63 +325,64 @@ INT WINAPIV WLDAP32_ber_printf( WLDAP32_BerElement *berelement, PCHAR fmt, ... )
     while (*fmt)
     {
         new_fmt[0] = *fmt++;
-        switch(new_fmt[0])
+        switch (new_fmt[0])
         {
         case 'b':
         case 'e':
         case 'i':
-            {
-                int i = va_arg( list, int );
-                ret = ber_printf( berelement, new_fmt, i );
-                break;
-            }
+        {
+            int i = va_arg( list, int );
+            ret = ldap_funcs->ber_printf( ber->opaque, new_fmt, i );
+            break;
+        }
         case 'o':
         case 's':
-            {
-                char *str = va_arg( list, char * );
-                ret = ber_printf( berelement, new_fmt, str );
-                break;
-            }
+        {
+            char *str = va_arg( list, char * );
+            ret = ldap_funcs->ber_printf( ber->opaque, new_fmt, str );
+            break;
+        }
         case 't':
-            {
-                unsigned int tag = va_arg( list, unsigned int );
-                ret = ber_printf( berelement, new_fmt, tag );
-                break;
-            }
+        {
+            unsigned int tag = va_arg( list, unsigned int );
+            ret = ldap_funcs->ber_printf( ber->opaque, new_fmt, tag );
+            break;
+        }
         case 'v':
-            {
-                char **array = va_arg( list, char ** );
-                ret = ber_printf( berelement, new_fmt, array );
-                break;
-            }
+        {
+            char **array = va_arg( list, char ** );
+            ret = ldap_funcs->ber_printf( ber->opaque, new_fmt, array );
+            break;
+        }
         case 'V':
+        {
+            struct WLDAP32_berval **array = va_arg( list, struct WLDAP32_berval ** );
+            struct bervalU **arrayU;
+            if (!(arrayU = bvarrayWtoU( array )))
             {
-                struct WLDAP32_berval **array = va_arg( list, struct WLDAP32_berval ** );
-                struct berval **arrayU;
-                if (!(arrayU = bvarrayWtoU( array )))
-                {
-                    ret = -1;
-                    break;
-                }
-                ret = ber_printf( berelement, new_fmt, arrayU );
-                bvarrayfreeU( arrayU );
+                ret = -1;
                 break;
             }
+            ret = ldap_funcs->ber_printf( ber->opaque, new_fmt, arrayU );
+            bvarrayfreeU( arrayU );
+            break;
+        }
         case 'X':
-            {
-                char *str = va_arg( list, char * );
-                int len = va_arg( list, int );
-                new_fmt[0] = 'B';  /* 'X' is deprecated */
-                ret = ber_printf( berelement, new_fmt, str, len );
-                break;
-            }
+        {
+            char *str = va_arg( list, char * );
+            int len = va_arg( list, int );
+            new_fmt[0] = 'B';  /* 'X' is deprecated */
+            ret = ldap_funcs->ber_printf( ber->opaque, new_fmt, str, len );
+            break;
+        }
         case 'n':
         case '{':
         case '}':
         case '[':
         case ']':
-            ret = ber_printf( berelement, new_fmt );
+            ret = ldap_funcs->ber_printf( ber->opaque, new_fmt );
             break;
+
         default:
             FIXME( "Unknown format '%c'\n", new_fmt[0] );
             ret = -1;
@@ -465,9 +392,6 @@ INT WINAPIV WLDAP32_ber_printf( WLDAP32_BerElement *berelement, PCHAR fmt, ... )
     }
     __ms_va_end( list );
     return ret;
-#else
-    return WLDAP32_LBER_ERROR;
-#endif
 }
 
 
@@ -482,16 +406,15 @@ INT WINAPIV WLDAP32_ber_printf( WLDAP32_BerElement *berelement, PCHAR fmt, ... )
  *  ...        [I]   Pointers to values to be decoded.
  *
  * RETURNS
- *  Success: Non-negative number. 
+ *  Success: Non-negative number.
  *  Failure: LBER_ERROR
  *
  * NOTES
  *  berelement must have been allocated with ber_init. This function
  *  can be called multiple times to decode data.
  */
-INT WINAPIV WLDAP32_ber_scanf( WLDAP32_BerElement *berelement, PCHAR fmt, ... )
+int WINAPIV WLDAP32_ber_scanf( WLDAP32_BerElement *ber, char *fmt, ... )
 {
-#ifdef HAVE_LDAP
     __ms_va_list list;
     int ret = 0;
     char new_fmt[2];
@@ -501,65 +424,81 @@ INT WINAPIV WLDAP32_ber_scanf( WLDAP32_BerElement *berelement, PCHAR fmt, ... )
     while (*fmt)
     {
         new_fmt[0] = *fmt++;
-        switch(new_fmt[0])
+        switch (new_fmt[0])
         {
         case 'a':
-            {
-                char **ptr = va_arg( list, char ** );
-                ret = ber_scanf( berelement, new_fmt, ptr );
-                break;
-            }
+        {
+            char *str, **ptr = va_arg( list, char ** );
+            if ((ret = ldap_funcs->ber_scanf( ber->opaque, new_fmt, &str )) == -1) break;
+            *ptr = strdupU( str );
+            ldap_funcs->ldap_memfree( str );
+            break;
+        }
         case 'b':
         case 'e':
         case 'i':
-            {
-                int *i = va_arg( list, int * );
-                ret = ber_scanf( berelement, new_fmt, i );
-                break;
-            }
+        {
+            int *i = va_arg( list, int * );
+            ret = ldap_funcs->ber_scanf( ber->opaque, new_fmt, i );
+            break;
+        }
         case 't':
-            {
-                unsigned int *tag = va_arg( list, unsigned int * );
-                ret = ber_scanf( berelement, new_fmt, tag );
-                break;
-            }
+        {
+            unsigned int *tag = va_arg( list, unsigned int * );
+            ret = ldap_funcs->ber_scanf( ber->opaque, new_fmt, tag );
+            break;
+        }
         case 'v':
+        {
+            char *str, **arrayU, **ptr, ***array = va_arg( list, char *** );
+            if ((ret = ldap_funcs->ber_scanf( ber->opaque, new_fmt, &arrayU )) == -1) break;
+            *array = strarrayUtoU( arrayU );
+            ptr = arrayU;
+            while ((str = *ptr))
             {
-                char ***array = va_arg( list, char *** );
-                ret = ber_scanf( berelement, new_fmt, array );
-                break;
+                ldap_funcs->ldap_memfree( str );
+                ptr++;
             }
+            ldap_funcs->ldap_memfree( arrayU );
+            break;
+        }
         case 'B':
-            {
-                char **str = va_arg( list, char ** );
-                int *len = va_arg( list, int * );
-                ret = ber_scanf( berelement, new_fmt, str, len );
-                break;
-            }
+        {
+            char *strU, **str = va_arg( list, char ** );
+            int *len = va_arg( list, int * );
+            if ((ret = ldap_funcs->ber_scanf( ber->opaque, new_fmt, &strU, len )) == -1) break;
+            *str = heap_alloc( *len );
+            memcpy( *str, strU, *len );
+            ldap_funcs->ldap_memfree( strU );
+            break;
+        }
         case 'O':
-            {
-                struct berval **ptr = va_arg( list, struct berval ** );
-                ret = ber_scanf( berelement, new_fmt, ptr );
-                break;
-            }
+        {
+            struct WLDAP32_berval **berval = va_arg( list, struct WLDAP32_berval ** );
+            struct bervalU *bervalU;
+            if ((ret = ldap_funcs->ber_scanf( ber->opaque, new_fmt, &bervalU )) == -1) break;
+            *berval = bervalUtoW( bervalU );
+            ldap_funcs->ber_bvfree( bervalU );
+            break;
+        }
         case 'V':
-            {
-                struct WLDAP32_berval **arrayW, ***array = va_arg( list, struct WLDAP32_berval *** );
-                struct berval **arrayU;
-                if ((ret = ber_scanf( berelement, new_fmt, &arrayU )) == -1) break;
-                if ((arrayW = bvarrayUtoW( arrayU ))) *array = arrayW;
-                else ret = -1;
-                bvarrayfreeU( arrayU );
-                break;
-            }
+        {
+            struct WLDAP32_berval ***array = va_arg( list, struct WLDAP32_berval *** );
+            struct bervalU **arrayU;
+            if ((ret = ldap_funcs->ber_scanf( ber->opaque, new_fmt, &arrayU )) == -1) break;
+            *array = bvarrayUtoW( arrayU );
+            ldap_funcs->ber_bvecfree( arrayU );
+            break;
+        }
         case 'n':
         case 'x':
         case '{':
         case '}':
         case '[':
         case ']':
-            ret = ber_scanf( berelement, new_fmt );
+            ret = ldap_funcs->ber_scanf( ber->opaque, new_fmt );
             break;
+
         default:
             FIXME( "Unknown format '%c'\n", new_fmt[0] );
             ret = -1;
@@ -569,7 +508,4 @@ INT WINAPIV WLDAP32_ber_scanf( WLDAP32_BerElement *berelement, PCHAR fmt, ... )
     }
     __ms_va_end( list );
     return ret;
-#else
-    return WLDAP32_LBER_ERROR;
-#endif
 }
diff --git a/dlls/wldap32/libldap.c b/dlls/wldap32/libldap.c
index 0372206062af..3436cffc4a1c 100644
--- a/dlls/wldap32/libldap.c
+++ b/dlls/wldap32/libldap.c
@@ -42,6 +42,8 @@
 #include "wine/debug.h"
 #include "winldap_private.h"
 
+WINE_DEFAULT_DEBUG_CHANNEL(wldap32);
+
 C_ASSERT( sizeof(BerValueU) == sizeof(BerValue) );
 C_ASSERT( sizeof(LDAPModU) == sizeof(LDAPMod) );
 C_ASSERT( sizeof(LDAPControlU) == sizeof(LDAPControl) );
@@ -50,6 +52,246 @@ C_ASSERT( sizeof(LDAPVLVInfoU) == sizeof(LDAPVLVInfo) );
 
 static LDAPMod *nullattrs[] = { NULL };
 
+void * CDECL wrap_ber_alloc_t( int options )
+{
+    return ber_alloc_t( options );
+}
+
+void CDECL wrap_ber_bvecfree( struct bervalU **berval )
+{
+    ber_bvecfree( (struct berval **)berval );
+}
+
+void CDECL wrap_ber_bvfree( struct bervalU *berval )
+{
+    ber_bvfree( (struct berval *)berval );
+}
+
+unsigned int CDECL wrap_ber_first_element( void *ber, ULONG *ret_len, char **last )
+{
+    ber_len_t len;
+    ber_tag_t ret;
+
+    if ((ret = ber_first_element( ber, &len, last )) == LBER_ERROR) return WLDAP32_LBER_ERROR;
+    if (ret > ~0u)
+    {
+        ERR( "ret too large\n" );
+        return WLDAP32_LBER_ERROR;
+    }
+    if (len > ~0u)
+    {
+        ERR( "len too large\n" );
+        return WLDAP32_LBER_ERROR;
+    }
+
+    *ret_len = len;
+    return ret;
+}
+
+int CDECL wrap_ber_flatten( void *ber, struct bervalU **berval )
+{
+    return ber_flatten( ber, (struct berval **)berval );
+}
+
+void CDECL wrap_ber_free( void *ber, int freebuf )
+{
+    ber_free( ber, freebuf );
+}
+
+void * CDECL wrap_ber_init( struct bervalU *berval )
+{
+    return ber_init( (struct berval *)berval );
+}
+
+unsigned int CDECL wrap_ber_next_element( void *ber, unsigned int *ret_len, char *last )
+{
+    ber_len_t len;
+    ber_tag_t ret;
+
+    if ((ret = ber_next_element( ber, &len, last )) == LBER_ERROR) return WLDAP32_LBER_ERROR;
+    if (ret > ~0u)
+    {
+        ERR( "ret too large\n" );
+        return WLDAP32_LBER_ERROR;
+    }
+    if (len > ~0u)
+    {
+        ERR( "len too large\n" );
+        return WLDAP32_LBER_ERROR;
+    }
+
+    *ret_len = len;
+    return ret;
+}
+
+unsigned int CDECL wrap_ber_peek_tag( void *ber, unsigned int *ret_len )
+{
+    ber_len_t len;
+    ber_tag_t ret;
+
+    if ((ret = ber_peek_tag( ber, &len )) == LBER_ERROR) return WLDAP32_LBER_ERROR;
+    if (len > ~0u)
+    {
+        ERR( "len too large\n" );
+        return WLDAP32_LBER_ERROR;
+    }
+
+    *ret_len = len;
+    return ret;
+}
+
+unsigned int CDECL wrap_ber_skip_tag( void *ber, unsigned int *ret_len )
+{
+    ber_len_t len;
+    ber_tag_t ret;
+
+    if ((ret = ber_skip_tag( ber, &len )) == LBER_ERROR) return WLDAP32_LBER_ERROR;
+    if (len > ~0u)
+    {
+        ERR( "len too large\n" );
+        return WLDAP32_LBER_ERROR;
+    }
+
+    *ret_len = len;
+    return ret;
+}
+
+int WINAPIV wrap_ber_printf( void *ber, char *fmt, ... )
+{
+    int ret;
+    __ms_va_list args;
+
+    assert( strlen(fmt) == 1 );
+
+    __ms_va_start( args, fmt );
+    switch (fmt[0])
+    {
+    case 'b':
+    case 'e':
+    case 'i':
+    {
+        int i = va_arg( args, int );
+        ret = ber_printf( ber, fmt, i );
+        break;
+    }
+    case 'o':
+    case 's':
+    {
+        char *str = va_arg( args, char * );
+        ret = ber_printf( ber, fmt, str );
+        break;
+    }
+    case 't':
+    {
+        unsigned int tag = va_arg( args, unsigned int );
+        ret = ber_printf( ber, fmt, tag );
+        break;
+    }
+    case 'v':
+    {
+        char **array = va_arg( args, char ** );
+        ret = ber_printf( ber, fmt, array );
+        break;
+    }
+    case 'V':
+    {
+        struct berval **array = va_arg( args, struct berval ** );
+        ret = ber_printf( ber, fmt, array );
+        break;
+    }
+    case 'B':
+    {
+        char *str = va_arg( args, char * );
+        int len = va_arg( args, int );
+        ret = ber_printf( ber, fmt, str, len );
+        break;
+    }
+    case 'n':
+    case '{':
+    case '}':
+    case '[':
+    case ']':
+        ret = ber_printf( ber, fmt );
+        break;
+
+    default:
+        assert( 0 );
+    }
+    __ms_va_end( args );
+    return ret;
+}
+
+int WINAPIV wrap_ber_scanf( void *ber, char *fmt, ... )
+{
+    int ret;
+    __ms_va_list args;
+
+    assert( strlen(fmt) == 1 );
+
+    __ms_va_start( args, fmt );
+    switch (fmt[0])
+    {
+    case 'a':
+    {
+        char **str = va_arg( args, char ** );
+        ret = ber_scanf( ber, fmt, str );
+        break;
+    }
+    case 'b':
+    case 'e':
+    case 'i':
+    {
+        int *i = va_arg( args, int * );
+        ret = ber_scanf( ber, fmt, i );
+        break;
+    }
+    case 't':
+    {
+        unsigned int *tag = va_arg( args, unsigned int * );
+        ret = ber_scanf( ber, fmt, tag );
+        break;
+    }
+    case 'v':
+    {
+        char ***array = va_arg( args, char *** );
+        ret = ber_scanf( ber, fmt, array );
+        break;
+    }
+    case 'B':
+    {
+        char **str = va_arg( args, char ** );
+        int *len = va_arg( args, int * );
+        ret = ber_scanf( ber, fmt, str, len );
+        break;
+    }
+    case 'O':
+    {
+        struct berval **berval = va_arg( args, struct berval ** );
+        ret = ber_scanf( ber, fmt, berval );
+        break;
+    }
+    case 'V':
+    {
+        struct berval ***array = va_arg( args, struct berval *** );
+        ret = ber_scanf( ber, fmt, array );
+        break;
+    }
+    case 'n':
+    case 'x':
+    case '{':
+    case '}':
+    case '[':
+    case ']':
+        ret = ber_scanf( ber, fmt );
+        break;
+
+    default:
+        assert( 0 );
+    }
+    __ms_va_end( args );
+    return ret;
+}
+
 int CDECL wrap_ldap_add_ext( void *ld, char *dn, LDAPModU **attrs, LDAPControlU **serverctrls,
                              LDAPControlU **clientctrls, ULONG *msg )
 {
@@ -65,10 +307,28 @@ int CDECL wrap_ldap_add_ext_s( void *ld, char *dn, LDAPModU **attrs, LDAPControl
                            (LDAPControl **)clientctrls );
 }
 
+void CDECL wrap_ldap_memfree( void *ptr )
+{
+    return ldap_memfree( ptr );
+}
+
 static const struct ldap_funcs funcs =
 {
+    wrap_ber_alloc_t,
+    wrap_ber_bvecfree,
+    wrap_ber_bvfree,
+    wrap_ber_first_element,
+    wrap_ber_flatten,
+    wrap_ber_free,
+    wrap_ber_init,
+    wrap_ber_next_element,
+    wrap_ber_peek_tag,
+    wrap_ber_skip_tag,
+    wrap_ber_printf,
+    wrap_ber_scanf,
     wrap_ldap_add_ext,
     wrap_ldap_add_ext_s,
+    wrap_ldap_memfree,
 };
 
 NTSTATUS CDECL __wine_init_unix_lib( HMODULE module, DWORD reason, const void *ptr_in, void *ptr_out )
diff --git a/dlls/wldap32/libldap.h b/dlls/wldap32/libldap.h
index d9d833cdcb83..4ca90d298a05 100644
--- a/dlls/wldap32/libldap.h
+++ b/dlls/wldap32/libldap.h
@@ -60,13 +60,41 @@ typedef struct
     void           *ldvlv_extradata;
 } LDAPVLVInfoU;
 
+extern void * CDECL wrap_ber_alloc_t(int) DECLSPEC_HIDDEN;
+extern void CDECL wrap_ber_bvecfree(struct bervalU **) DECLSPEC_HIDDEN;
+extern void CDECL wrap_ber_bvfree(struct bervalU *) DECLSPEC_HIDDEN;
+extern unsigned int CDECL wrap_ber_first_element(void *, unsigned int *, char **) DECLSPEC_HIDDEN;
+extern int CDECL wrap_ber_flatten(void *, struct bervalU **) DECLSPEC_HIDDEN;
+extern void CDECL wrap_ber_free(void *, int) DECLSPEC_HIDDEN;
+extern void * CDECL wrap_ber_init(struct bervalU *) DECLSPEC_HIDDEN;
+extern unsigned int CDECL wrap_ber_next_element(void *, unsigned int *, char *) DECLSPEC_HIDDEN;
+extern unsigned int CDECL wrap_ber_peek_tag(void *, unsigned int *) DECLSPEC_HIDDEN;
+extern unsigned int CDECL wrap_ber_skip_tag(void *, unsigned int *) DECLSPEC_HIDDEN;
+extern int WINAPIV wrap_ber_printf(void *, char *, ...) DECLSPEC_HIDDEN;
+extern int WINAPIV wrap_ber_scanf(void *, char *, ...) DECLSPEC_HIDDEN;
+
 extern int CDECL wrap_ldap_add_ext(void *, char *, LDAPModU **, LDAPControlU **, LDAPControlU **, ULONG *) DECLSPEC_HIDDEN;
 extern int CDECL wrap_ldap_add_ext_s(void *, char *, LDAPModU **, LDAPControlU **, LDAPControlU **) DECLSPEC_HIDDEN;
+extern void CDECL wrap_ldap_memfree(void *) DECLSPEC_HIDDEN;
 
 struct ldap_funcs
 {
+    void * (CDECL *ber_alloc_t)(int);
+    void (CDECL *ber_bvecfree)(struct bervalU **);
+    void (CDECL *ber_bvfree)(struct bervalU *);
+    unsigned int (CDECL *ber_first_element)(void *, unsigned int *, char **);
+    int (CDECL *ber_flatten)(void *, struct bervalU **);
+    void (CDECL *ber_free)(void *, int);
+    void * (CDECL *ber_init)(struct bervalU *);
+    unsigned int (CDECL *ber_next_element)(void *, unsigned int *, char *);
+    unsigned int (CDECL *ber_peek_tag)(void *, unsigned int *);
+    unsigned int (CDECL *ber_skip_tag)(void *, unsigned int *);
+    int (WINAPIV *ber_printf)(void *, char *, ...);
+    int (WINAPIV *ber_scanf)(void *, char *, ...);
+
     int (CDECL *ldap_add_ext)(void *, char *, LDAPModU **, LDAPControlU **, LDAPControlU **, ULONG *);
     int (CDECL *ldap_add_ext_s)(void *, char *, LDAPModU **, LDAPControlU **, LDAPControlU **);
+    void (CDECL *ldap_memfree)(void *);
 };
 
 extern const struct ldap_funcs *ldap_funcs;
diff --git a/dlls/wldap32/misc.c b/dlls/wldap32/misc.c
index 396429609553..dd1a1ef3f12c 100644
--- a/dlls/wldap32/misc.c
+++ b/dlls/wldap32/misc.c
@@ -328,15 +328,22 @@ PWCHAR CDECL ldap_first_attributeW( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *entry
 {
     PWCHAR ret = NULL;
 #ifdef HAVE_LDAP
+    BerElement *berU;
     char *retU;
 
     TRACE( "(%p, %p, %p)\n", ld, entry, ptr );
 
     if (!ld || !entry) return NULL;
-    retU = ldap_first_attribute( ld->ld, entry, ptr );
 
-    ret = strUtoW( retU );
-    ldap_memfree( retU );
+    retU = ldap_first_attribute( ld->ld, entry, &berU );
+    if (retU)
+    {
+        WLDAP32_BerElement *ber = heap_alloc( sizeof(*ber) );
+        ber->opaque = (char *)berU;
+        *ptr = ber;
+        ret = strUtoW( retU );
+        ldap_memfree( retU );
+    }
 
 #endif
     return ret;
@@ -487,19 +494,22 @@ PCHAR CDECL ldap_next_attributeA( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *entry,
  *  When done iterating and when ptr != NULL, call ber_free( ptr, 0 ).
  */
 PWCHAR CDECL ldap_next_attributeW( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *entry,
-    WLDAP32_BerElement *ptr )
+    WLDAP32_BerElement *ber )
 {
     PWCHAR ret = NULL;
 #ifdef HAVE_LDAP
     char *retU;
 
-    TRACE( "(%p, %p, %p)\n", ld, entry, ptr );
+    TRACE( "(%p, %p, %p)\n", ld, entry, ber );
 
-    if (!ld || !entry || !ptr) return NULL;
-    retU = ldap_next_attribute( ld->ld, entry, ptr );
+    if (!ld || !entry) return NULL;
 
-    ret = strUtoW( retU );
-    ldap_memfree( retU );
+    retU = ldap_next_attribute( ld->ld, entry, (BerElement *)ber->opaque );
+    if (retU)
+    {
+        ret = strUtoW( retU );
+        ldap_memfree( retU );
+    }
 
 #endif
     return ret;
diff --git a/dlls/wldap32/winldap_private.h b/dlls/wldap32/winldap_private.h
index d0583c61f500..22e981cb26dc 100644
--- a/dlls/wldap32/winldap_private.h
+++ b/dlls/wldap32/winldap_private.h
@@ -27,6 +27,8 @@
 #include "winnls.h"
 #include "libldap.h"
 
+#define WLDAP32_LBER_ERROR (~0L)
+
 typedef enum {
     WLDAP32_LDAP_SUCCESS                 =   0x00,
     WLDAP32_LDAP_UNWILLING_TO_PERFORM    =   0x35,
@@ -1187,6 +1189,26 @@ static inline WCHAR **strarrayUtoW( char **strarray )
     return strarrayW;
 }
 
+static inline char **strarrayUtoU( char **strarray )
+{
+    char **strarrayU = NULL;
+    DWORD size;
+
+    if (strarray)
+    {
+        size = sizeof(char *) * (strarraylenU( strarray ) + 1);
+        if ((strarrayU = RtlAllocateHeap( GetProcessHeap(), 0, size )))
+        {
+            char **p = strarray;
+            char **q = strarrayU;
+
+            while (*p) *q++ = strdupU( *p++ );
+            *q = NULL;
+        }
+    }
+    return strarrayU;
+}
+
 static inline LDAPControlW *controlUtoW( const LDAPControlU *control )
 {
     LDAPControlW *controlW;
diff --git a/include/winber.h b/include/winber.h
index 40ab0f40ed8d..372cc3212699 100644
--- a/include/winber.h
+++ b/include/winber.h
@@ -27,11 +27,17 @@ typedef unsigned int ber_tag_t;
 typedef unsigned int ber_len_t;
 
 BerElement * CDECL ber_alloc_t( int );
+BERVAL * CDECL ber_bvdup( BERVAL * );
+void CDECL ber_bvecfree( BERVAL ** );
 void CDECL ber_bvfree( BERVAL * );
+ULONG CDECL ber_first_element( BerElement *, ULONG *, char ** );
 int CDECL ber_flatten( BerElement *, BERVAL ** );
 void CDECL ber_free( BerElement *, int );
 BerElement * CDECL ber_init( BERVAL * );
+ULONG CDECL ber_next_element( BerElement *, ULONG *, char ** );
+ULONG CDECL ber_peek_tag( BerElement *, ULONG * );
 int WINAPIV ber_printf( BerElement *, char *, ... );
 ULONG WINAPIV ber_scanf( BerElement *, char *, ... );
+ULONG CDECL ber_skip_tag( BerElement *, ULONG * );
 
 #endif /* __WINE_WINBER_H */
From db26894eeea5943892a872ea818471732ee66404 Mon Sep 17 00:00:00 2001
From: Hans Leidekker <hans@codeweavers.com>
Date: Wed, 14 Apr 2021 09:40:27 +0200
Subject: [PATCH] wldap32: Move support for bind functions to the Unix library.

Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/wldap32/bind.c            | 419 ++++++++++-----------------------
 dlls/wldap32/libldap.c         |  58 ++++-
 dlls/wldap32/libldap.h         |  52 +++-
 dlls/wldap32/main.c            |   6 +-
 dlls/wldap32/option.c          |   6 +-
 dlls/wldap32/winldap_private.h |   2 +-
 6 files changed, 234 insertions(+), 309 deletions(-)

diff --git a/dlls/wldap32/bind.c b/dlls/wldap32/bind.c
index 1498dc49fe6e..0078b532e669 100644
--- a/dlls/wldap32/bind.c
+++ b/dlls/wldap32/bind.c
@@ -18,63 +18,40 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#include "config.h"
-#include "wine/port.h"
-
 #include <stdarg.h>
-#ifdef HAVE_LDAP_H
-#include <ldap.h>
-#endif
-#ifdef HAVE_SASL_SASL_H
-#include <sasl/sasl.h>
-#endif
-
 #include "windef.h"
 #include "winbase.h"
 #include "winnls.h"
 #include "rpc.h"
 
-#include "winldap_private.h"
-#include "wldap32.h"
 #include "wine/debug.h"
+#include "wine/heap.h"
+#include "winldap_private.h"
 
-#ifdef HAVE_LDAP
 WINE_DEFAULT_DEBUG_CHANNEL(wldap32);
-#endif
 
 /***********************************************************************
  *      ldap_bindA     (WLDAP32.@)
  *
  * See ldap_bindW.
  */
-ULONG CDECL ldap_bindA( WLDAP32_LDAP *ld, PCHAR dn, PCHAR cred, ULONG method )
+ULONG CDECL ldap_bindA( WLDAP32_LDAP *ld, char *dn, char *cred, ULONG method )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
     WCHAR *dnW = NULL, *credW = NULL;
 
-    ret = WLDAP32_LDAP_NO_MEMORY;
-
     TRACE( "(%p, %s, %p, 0x%08x)\n", ld, debugstr_a(dn), cred, method );
 
     if (!ld) return ~0u;
 
-    if (dn) {
-        dnW = strAtoW( dn );
-        if (!dnW) goto exit;
-    }
-    if (cred) {
-        credW = strAtoW( cred );
-        if (!credW) goto exit;
-    }
+    if (dn && !(dnW = strAtoW( dn ))) goto exit;
+    if (cred && !(credW = strAtoW( cred ))) goto exit;
 
     ret = ldap_bindW( ld, dnW, credW, method );
 
 exit:
     strfreeW( dnW );
     strfreeW( credW );
-
-#endif
     return ret;
 }
 
@@ -96,36 +73,28 @@ ULONG CDECL ldap_bindA( WLDAP32_LDAP *ld, PCHAR dn, PCHAR cred, ULONG method )
  * NOTES
  *  Only LDAP_AUTH_SIMPLE is supported (just like native).
  */
-ULONG CDECL ldap_bindW( WLDAP32_LDAP *ld, PWCHAR dn, PWCHAR cred, ULONG method )
+ULONG CDECL ldap_bindW( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *cred, ULONG method )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
     char *dnU = NULL, *credU = NULL;
-    struct berval pwd = { 0, NULL };
+    struct bervalU pwd = { 0, NULL };
     int msg;
 
-    ret = WLDAP32_LDAP_NO_MEMORY;
-
     TRACE( "(%p, %s, %p, 0x%08x)\n", ld, debugstr_w(dn), cred, method );
 
     if (!ld) return ~0u;
-    if (method != LDAP_AUTH_SIMPLE) return WLDAP32_LDAP_PARAM_ERROR;
-
-    if (dn) {
-        dnU = strWtoU( dn );
-        if (!dnU) goto exit;
-    }
-    if (cred) {
-        credU = strWtoU( cred );
-        if (!credU) goto exit;
+    if (method != WLDAP32_LDAP_AUTH_SIMPLE) return WLDAP32_LDAP_PARAM_ERROR;
 
+    if (dn && !(dnU = strWtoU( dn ))) goto exit;
+    if (cred)
+    {
+        if (!(credU = strWtoU( cred ))) goto exit;
         pwd.bv_len = strlen( credU );
         pwd.bv_val = credU;
     }
 
-    ret = ldap_sasl_bind( ld->ld, dnU, LDAP_SASL_SIMPLE, &pwd, NULL, NULL, &msg );
-
-    if (ret == LDAP_SUCCESS)
+    ret = map_error( ldap_funcs->ldap_sasl_bind( ld->ld, dnU, 0, &pwd, NULL, NULL, &msg ) );
+    if (ret == WLDAP32_LDAP_SUCCESS)
         ret = msg;
     else
         ret = ~0u;
@@ -133,8 +102,6 @@ ULONG CDECL ldap_bindW( WLDAP32_LDAP *ld, PWCHAR dn, PWCHAR cred, ULONG method )
 exit:
     strfreeU( dnU );
     strfreeU( credU );
-
-#endif
     return ret;
 }
 
@@ -143,30 +110,23 @@ ULONG CDECL ldap_bindW( WLDAP32_LDAP *ld, PWCHAR dn, PWCHAR cred, ULONG method )
  *
  * See ldap_bind_sW.
  */
-ULONG CDECL ldap_bind_sA( WLDAP32_LDAP *ld, PCHAR dn, PCHAR cred, ULONG method )
+ULONG CDECL ldap_bind_sA( WLDAP32_LDAP *ld, char *dn, char *cred, ULONG method )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
     WCHAR *dnW = NULL, *credW = NULL;
 
-    ret = WLDAP32_LDAP_NO_MEMORY;
-
     TRACE( "(%p, %s, %p, 0x%08x)\n", ld, debugstr_a(dn), cred, method );
 
     if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
 
-    if (dn) {
-        dnW = strAtoW( dn );
-        if (!dnW) goto exit;
-    }
-    if (cred) {
-        if (method == LDAP_AUTH_SIMPLE)
+    if (dn && !(dnW = strAtoW( dn ))) goto exit;
+    if (cred)
+    {
+        if (method == WLDAP32_LDAP_AUTH_SIMPLE)
         {
-            credW = strAtoW( cred );
-            if (!credW) goto exit;
+            if (!(credW = strAtoW( cred ))) goto exit;
         }
-        else
-            credW = (WCHAR *)cred /* SEC_WINNT_AUTH_IDENTITY_A */;
+        else credW = (WCHAR *)cred /* SEC_WINNT_AUTH_IDENTITY_A */;
     }
 
     ret = ldap_bind_sW( ld, dnW, credW, method );
@@ -174,24 +134,19 @@ ULONG CDECL ldap_bind_sA( WLDAP32_LDAP *ld, PCHAR dn, PCHAR cred, ULONG method )
 exit:
     strfreeW( dnW );
     if (credW != (WCHAR *)cred) strfreeW( credW );
-
-#endif
     return ret;
 }
 
-#ifdef HAVE_LDAP
-
-static int sasl_interact( LDAP *ld, unsigned flags, void *defaults, void *interact )
+int CDECL sasl_interact_cb( void *ld, unsigned flags, void *defaults, void *interact )
 {
-#ifdef HAVE_SASL_SASL_H
     SEC_WINNT_AUTH_IDENTITY_A *id = defaults;
-    sasl_interact_t *sasl = interact;
+    struct sasl_interactU *sasl = interact;
 
-    TRACE( "%p,%08x,%p,%p\n", ld, flags, defaults, interact );
+    TRACE( "(%p, 0x%08x, %p, %p)\n", ld, flags, defaults, interact );
 
     while (sasl->id != SASL_CB_LIST_END)
     {
-        TRACE("sasl->id = %04lx\n", sasl->id);
+        TRACE( "sasl->id = %04lx\n", sasl->id );
 
         if (sasl->id == SASL_CB_GETREALM)
         {
@@ -208,19 +163,12 @@ static int sasl_interact( LDAP *ld, unsigned flags, void *defaults, void *intera
             sasl->result = id->Password;
             sasl->len = id->PasswordLength;
         }
-
         sasl++;
     }
 
-    return LDAP_SUCCESS;
-#else
-    FIXME( "%p,%08x,%p,%p: stub\n", ld, flags, defaults, interact );
-    return LDAP_SUCCESS;
-#endif /* HAVE_SASL_SASL_H */
+    return WLDAP32_LDAP_SUCCESS;
 }
 
-#endif /* HAVE_LDAP */
-
 /***********************************************************************
  *      ldap_bind_sW     (WLDAP32.@)
  *
@@ -236,36 +184,27 @@ static int sasl_interact( LDAP *ld, unsigned flags, void *defaults, void *intera
  *  Success: LDAP_SUCCESS
  *  Failure: An LDAP error code.
  */
-ULONG CDECL ldap_bind_sW( WLDAP32_LDAP *ld, PWCHAR dn, PWCHAR cred, ULONG method )
+ULONG CDECL ldap_bind_sW( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *cred, ULONG method )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
     char *dnU = NULL, *credU = NULL;
-    struct berval pwd = { 0, NULL };
-
-    ret = WLDAP32_LDAP_NO_MEMORY;
+    struct bervalU pwd = { 0, NULL };
 
     TRACE( "(%p, %s, %p, 0x%08x)\n", ld, debugstr_w(dn), cred, method );
 
     if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
 
-    if (method == LDAP_AUTH_SIMPLE)
+    if (method == WLDAP32_LDAP_AUTH_SIMPLE)
     {
-        if (dn)
-        {
-            dnU = strWtoU( dn );
-            if (!dnU) goto exit;
-        }
+        if (dn && !(dnU = strWtoU( dn ))) goto exit;
         if (cred)
         {
-            credU = strWtoU( cred );
-            if (!credU) goto exit;
-
+            if (!(credU = strWtoU( cred ))) goto exit;
             pwd.bv_len = strlen( credU );
             pwd.bv_val = credU;
         }
 
-        ret = map_error( ldap_sasl_bind_s( ld->ld, dnU, LDAP_SASL_SIMPLE, &pwd, NULL, NULL, NULL ));
+        ret = map_error( ldap_funcs->ldap_sasl_bind_s( ld->ld, dnU, 0, &pwd, NULL, NULL, NULL ) );
     }
     else if (method == WLDAP32_LDAP_AUTH_NEGOTIATE)
     {
@@ -274,7 +213,6 @@ ULONG CDECL ldap_bind_sW( WLDAP32_LDAP *ld, PWCHAR dn, PWCHAR cred, ULONG method
         SEC_WINNT_AUTH_IDENTITY_W *id = (SEC_WINNT_AUTH_IDENTITY_W *)cred;
 
         memset( &idU, 0, sizeof(idU) );
-
         if (id)
         {
             if (id->Flags & SEC_WINNT_AUTH_IDENTITY_ANSI)
@@ -283,19 +221,17 @@ ULONG CDECL ldap_bind_sW( WLDAP32_LDAP *ld, PWCHAR dn, PWCHAR cred, ULONG method
                 idW.Domain = (unsigned short *)strnAtoW( (char *)id->Domain, id->DomainLength, &idW.DomainLength );
                 idW.User = (unsigned short *)strnAtoW( (char *)id->User, id->UserLength, &idW.UserLength );
                 idW.Password = (unsigned short *)strnAtoW( (char *)id->Password, id->PasswordLength, &idW.PasswordLength );
-
                 id = &idW;
             }
-
             idU.Domain = (unsigned char *)strnWtoU( id->Domain, id->DomainLength, &idU.DomainLength );
             idU.User = (unsigned char *)strnWtoU( id->User, id->UserLength, &idU.UserLength );
             idU.Password = (unsigned char *)strnWtoU( id->Password, id->PasswordLength, &idU.PasswordLength );
         }
 
-        ret = map_error( ldap_sasl_interactive_bind_s( ld->ld,
-                             NULL /* server will ignore DN anyway */,
-                             NULL /* query supportedSASLMechanisms */,
-                             NULL, NULL, LDAP_SASL_QUIET, sasl_interact, &idU ));
+        ret = map_error( ldap_funcs->ldap_sasl_interactive_bind_s( ld->ld,
+                                                                   NULL /* server will ignore DN anyway */,
+                                                                   NULL /* query supportedSASLMechanisms */,
+                                                                   NULL, NULL, 2 /* LDAP_SASL_QUIET */, &idU ) );
 
         if (id && (id->Flags & SEC_WINNT_AUTH_IDENTITY_ANSI))
         {
@@ -317,8 +253,6 @@ ULONG CDECL ldap_bind_sW( WLDAP32_LDAP *ld, PWCHAR dn, PWCHAR cred, ULONG method
 exit:
     strfreeU( dnU );
     strfreeU( credU );
-
-#endif
     return ret;
 }
 
@@ -327,37 +261,23 @@ ULONG CDECL ldap_bind_sW( WLDAP32_LDAP *ld, PWCHAR dn, PWCHAR cred, ULONG method
  *
  * See ldap_sasl_bindW.
  */
-ULONG CDECL ldap_sasl_bindA( WLDAP32_LDAP *ld, const PCHAR dn,
-    const PCHAR mechanism, const BERVAL *cred, PLDAPControlA *serverctrls,
-    PLDAPControlA *clientctrls, int *message )
+ULONG CDECL ldap_sasl_bindA( WLDAP32_LDAP *ld, const PCHAR dn, const PCHAR mechanism, const BERVAL *cred,
+    LDAPControlA **serverctrls, LDAPControlA **clientctrls, int *message )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
     WCHAR *dnW, *mechanismW = NULL;
     LDAPControlW **serverctrlsW = NULL, **clientctrlsW = NULL;
 
-    ret = WLDAP32_LDAP_NO_MEMORY;
-
     TRACE( "(%p, %s, %s, %p, %p, %p, %p)\n", ld, debugstr_a(dn),
            debugstr_a(mechanism), cred, serverctrls, clientctrls, message );
 
     if (!ld || !dn || !mechanism || !cred || !message)
         return WLDAP32_LDAP_PARAM_ERROR;
 
-    dnW = strAtoW( dn );
-    if (!dnW) goto exit;
-
-    mechanismW = strAtoW( mechanism );
-    if (!mechanismW) goto exit;
-
-    if (serverctrls) {
-        serverctrlsW = controlarrayAtoW( serverctrls );
-        if (!serverctrlsW) goto exit;
-    }
-    if (clientctrls) {
-        clientctrlsW = controlarrayAtoW( clientctrls );
-        if (!clientctrlsW) goto exit;
-    }
+    if (!(dnW = strAtoW( dn ))) goto exit;
+    if (!(mechanismW = strAtoW( mechanism ))) goto exit;
+    if (serverctrls && !(serverctrlsW = controlarrayAtoW( serverctrls ))) goto exit;
+    if (clientctrls && !(clientctrlsW = controlarrayAtoW( clientctrls ))) goto exit;
 
     ret = ldap_sasl_bindW( ld, dnW, mechanismW, cred, serverctrlsW, clientctrlsW, message );
 
@@ -366,8 +286,6 @@ ULONG CDECL ldap_sasl_bindA( WLDAP32_LDAP *ld, const PCHAR dn,
     strfreeW( mechanismW );
     controlarrayfreeW( serverctrlsW );
     controlarrayfreeW( clientctrlsW );
-
-#endif
     return ret;
 }
 
@@ -383,7 +301,7 @@ ULONG CDECL ldap_sasl_bindA( WLDAP32_LDAP *ld, const PCHAR dn,
  *  cred        [I] Credentials.
  *  serverctrls [I] Array of LDAP server controls.
  *  clientctrls [I] Array of LDAP client controls.
- *  message     [O] Message ID of the bind operation. 
+ *  message     [O] Message ID of the bind operation.
  *
  * RETURNS
  *  Success: LDAP_SUCCESS
@@ -393,17 +311,13 @@ ULONG CDECL ldap_sasl_bindA( WLDAP32_LDAP *ld, const PCHAR dn,
  *  The serverctrls and clientctrls parameters are optional and should
  *  be set to NULL if not used.
  */
-ULONG CDECL ldap_sasl_bindW( WLDAP32_LDAP *ld, const PWCHAR dn,
-    const PWCHAR mechanism, const BERVAL *cred, PLDAPControlW *serverctrls,
-    PLDAPControlW *clientctrls, int *message )
+ULONG CDECL ldap_sasl_bindW( WLDAP32_LDAP *ld, const PWCHAR dn, const PWCHAR mechanism, const BERVAL *cred,
+    LDAPControlW **serverctrls, LDAPControlW **clientctrls, int *message )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
     char *dnU, *mechanismU = NULL;
-    LDAPControl **serverctrlsU = NULL, **clientctrlsU = NULL;
-    struct berval credU;
-
-    ret = WLDAP32_LDAP_NO_MEMORY;
+    LDAPControlU **serverctrlsU = NULL, **clientctrlsU = NULL;
+    struct bervalU credU;
 
     TRACE( "(%p, %s, %s, %p, %p, %p, %p)\n", ld, debugstr_w(dn),
            debugstr_w(mechanism), cred, serverctrls, clientctrls, message );
@@ -411,34 +325,21 @@ ULONG CDECL ldap_sasl_bindW( WLDAP32_LDAP *ld, const PWCHAR dn,
     if (!ld || !dn || !mechanism || !cred || !message)
         return WLDAP32_LDAP_PARAM_ERROR;
 
-    dnU = strWtoU( dn );
-    if (!dnU) goto exit;
-
-    mechanismU = strWtoU( mechanism );
-    if (!mechanismU) goto exit;
-
-    if (serverctrls) {
-        serverctrlsU = controlarrayWtoU( serverctrls );
-        if (!serverctrlsU) goto exit;
-    }
-    if (clientctrls) {
-        clientctrlsU = controlarrayWtoU( clientctrls );
-        if (!clientctrlsU) goto exit;
-    }
+    if (!(dnU = strWtoU( dn ))) goto exit;
+    if (!(mechanismU = strWtoU( mechanism ))) goto exit;
+    if (serverctrls && !(serverctrlsU = controlarrayWtoU( serverctrls ))) goto exit;
+    if (clientctrls && !(clientctrlsU = controlarrayWtoU( clientctrls ))) goto exit;
 
     credU.bv_len = cred->bv_len;
     credU.bv_val = cred->bv_val;
 
-    ret = map_error( ldap_sasl_bind( ld->ld, dnU, mechanismU, &credU,
-                                     serverctrlsU, clientctrlsU, message ));
+    ret = map_error( ldap_funcs->ldap_sasl_bind( ld->ld, dnU, mechanismU, &credU, serverctrlsU, clientctrlsU, message ) );
 
 exit:
     strfreeU( dnU );
     strfreeU( mechanismU );
     controlarrayfreeU( serverctrlsU );
     controlarrayfreeU( clientctrlsU );
-
-#endif
     return ret;
 }
 
@@ -447,37 +348,23 @@ ULONG CDECL ldap_sasl_bindW( WLDAP32_LDAP *ld, const PWCHAR dn,
  *
  * See ldap_sasl_bind_sW.
  */
-ULONG CDECL ldap_sasl_bind_sA( WLDAP32_LDAP *ld, const PCHAR dn,
-    const PCHAR mechanism, const BERVAL *cred, PLDAPControlA *serverctrls,
-    PLDAPControlA *clientctrls, PBERVAL *serverdata )
+ULONG CDECL ldap_sasl_bind_sA( WLDAP32_LDAP *ld, const PCHAR dn, const PCHAR mechanism, const BERVAL *cred,
+    LDAPControlA **serverctrls, LDAPControlA **clientctrls, BERVAL **serverdata )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
     WCHAR *dnW, *mechanismW = NULL;
     LDAPControlW **serverctrlsW = NULL, **clientctrlsW = NULL;
 
-    ret = WLDAP32_LDAP_NO_MEMORY;
-
     TRACE( "(%p, %s, %s, %p, %p, %p, %p)\n", ld, debugstr_a(dn),
            debugstr_a(mechanism), cred, serverctrls, clientctrls, serverdata );
 
     if (!ld || !dn || !mechanism || !cred || !serverdata)
         return WLDAP32_LDAP_PARAM_ERROR;
 
-    dnW = strAtoW( dn );
-    if (!dnW) goto exit;
-
-    mechanismW = strAtoW( mechanism );
-    if (!mechanismW) goto exit;
-
-    if (serverctrls) {
-        serverctrlsW = controlarrayAtoW( serverctrls );
-        if (!serverctrlsW) goto exit;
-    }
-    if (clientctrls) {
-        clientctrlsW = controlarrayAtoW( clientctrls );
-        if (!clientctrlsW) goto exit;
-    }
+    if (!(dnW = strAtoW( dn ))) goto exit;
+    if (!(mechanismW = strAtoW( mechanism ))) goto exit;
+    if (serverctrls && !(serverctrlsW = controlarrayAtoW( serverctrls ))) goto exit;
+    if (clientctrls && !(clientctrlsW = controlarrayAtoW( clientctrls ))) goto exit;
 
     ret = ldap_sasl_bind_sW( ld, dnW, mechanismW, cred, serverctrlsW, clientctrlsW, serverdata );
 
@@ -486,8 +373,6 @@ ULONG CDECL ldap_sasl_bind_sA( WLDAP32_LDAP *ld, const PCHAR dn,
     strfreeW( mechanismW );
     controlarrayfreeW( serverctrlsW );
     controlarrayfreeW( clientctrlsW );
-
-#endif
     return ret;
 }
 
@@ -514,16 +399,13 @@ ULONG CDECL ldap_sasl_bind_sA( WLDAP32_LDAP *ld, const PCHAR dn,
  *  be set to NULL if not used.
  */
 ULONG CDECL ldap_sasl_bind_sW( WLDAP32_LDAP *ld, const PWCHAR dn,
-    const PWCHAR mechanism, const BERVAL *cred, PLDAPControlW *serverctrls,
-    PLDAPControlW *clientctrls, PBERVAL *serverdata )
+    const PWCHAR mechanism, const BERVAL *cred, LDAPControlW **serverctrls,
+    LDAPControlW **clientctrls, BERVAL **serverdata )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
     char *dnU, *mechanismU = NULL;
-    LDAPControl **serverctrlsU = NULL, **clientctrlsU = NULL;
-    struct berval credU;
-
-    ret = WLDAP32_LDAP_NO_MEMORY;
+    LDAPControlU **serverctrlsU = NULL, **clientctrlsU = NULL;
+    struct bervalU *dataU, credU;
 
     TRACE( "(%p, %s, %s, %p, %p, %p, %p)\n", ld, debugstr_w(dn),
            debugstr_w(mechanism), cred, serverctrls, clientctrls, serverdata );
@@ -531,34 +413,28 @@ ULONG CDECL ldap_sasl_bind_sW( WLDAP32_LDAP *ld, const PWCHAR dn,
     if (!ld || !dn || !mechanism || !cred || !serverdata)
         return WLDAP32_LDAP_PARAM_ERROR;
 
-    dnU = strWtoU( dn );
-    if (!dnU) goto exit;
-
-    mechanismU = strWtoU( mechanism );
-    if (!mechanismU) goto exit;
-
-    if (serverctrls) {
-        serverctrlsU = controlarrayWtoU( serverctrls );
-        if (!serverctrlsU) goto exit;
-    }
-    if (clientctrls) {
-        clientctrlsU = controlarrayWtoU( clientctrls );
-        if (!clientctrlsU) goto exit;
-    }
+    if (!(dnU = strWtoU( dn ))) goto exit;
+    if (!(mechanismU = strWtoU( mechanism ))) goto exit;
+    if (serverctrls && !(serverctrlsU = controlarrayWtoU( serverctrls ))) goto exit;
+    if (clientctrls && !(clientctrlsU = controlarrayWtoU( clientctrls ))) goto exit;
 
     credU.bv_len = cred->bv_len;
     credU.bv_val = cred->bv_val;
 
-    ret = map_error( ldap_sasl_bind_s( ld->ld, dnU, mechanismU, &credU,
-                                       serverctrlsU, clientctrlsU, (struct berval **)serverdata ));
+    ret = map_error( ldap_funcs->ldap_sasl_bind_s( ld->ld, dnU, mechanismU, &credU, serverctrlsU, clientctrlsU, &dataU ) );
+    if (ret == WLDAP32_LDAP_SUCCESS)
+    {
+        BERVAL *ptr;
+        if (!(ptr = bervalUtoW( dataU ))) ret = WLDAP32_LDAP_NO_MEMORY;
+        else *serverdata = ptr;
+        ldap_funcs->ber_bvfree( dataU );
+    }
 
 exit:
     strfreeU( dnU );
     strfreeU( mechanismU );
     controlarrayfreeU( serverctrlsU );
     controlarrayfreeU( clientctrlsU );
-
-#endif
     return ret;
 }
 
@@ -567,34 +443,23 @@ ULONG CDECL ldap_sasl_bind_sW( WLDAP32_LDAP *ld, const PWCHAR dn,
  *
  * See ldap_simple_bindW.
  */
-ULONG CDECL ldap_simple_bindA( WLDAP32_LDAP *ld, PCHAR dn, PCHAR passwd )
+ULONG CDECL ldap_simple_bindA( WLDAP32_LDAP *ld, char *dn, char *passwd )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
     WCHAR *dnW = NULL, *passwdW = NULL;
 
-    ret = WLDAP32_LDAP_NO_MEMORY;
-
     TRACE( "(%p, %s, %p)\n", ld, debugstr_a(dn), passwd );
 
     if (!ld) return ~0u;
 
-    if (dn) {
-        dnW = strAtoW( dn );
-        if (!dnW) goto exit;
-    }
-    if (passwd) {
-        passwdW = strAtoW( passwd );
-        if (!passwdW) goto exit;
-    }
+    if (dn && !(dnW = strAtoW( dn ))) goto exit;
+    if (passwd && !(passwdW = strAtoW( passwd ))) goto exit;
 
     ret = ldap_simple_bindW( ld, dnW, passwdW );
 
 exit:
     strfreeW( dnW );
     strfreeW( passwdW );
-
-#endif
     return ret;
 }
 
@@ -613,37 +478,29 @@ ULONG CDECL ldap_simple_bindA( WLDAP32_LDAP *ld, PCHAR dn, PCHAR passwd )
  *  Failure: An LDAP error code.
  *
  * NOTES
- *  Set dn and passwd to NULL to bind as an anonymous user. 
+ *  Set dn and passwd to NULL to bind as an anonymous user.
  */
-ULONG CDECL ldap_simple_bindW( WLDAP32_LDAP *ld, PWCHAR dn, PWCHAR passwd )
+ULONG CDECL ldap_simple_bindW( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *passwd )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
     char *dnU = NULL, *passwdU = NULL;
-    struct berval pwd = { 0, NULL };
+    struct bervalU pwd = { 0, NULL };
     int msg;
 
-    ret = WLDAP32_LDAP_NO_MEMORY;
-
     TRACE( "(%p, %s, %p)\n", ld, debugstr_w(dn), passwd );
 
     if (!ld) return ~0u;
 
-    if (dn) {
-        dnU = strWtoU( dn );
-        if (!dnU) goto exit;
-    }
-    if (passwd) {
-        passwdU = strWtoU( passwd );
-        if (!passwdU) goto exit;
-
+    if (dn && !(dnU = strWtoU( dn ))) goto exit;
+    if (passwd)
+    {
+        if (!(passwdU = strWtoU( passwd ))) goto exit;
         pwd.bv_len = strlen( passwdU );
         pwd.bv_val = passwdU;
     }
 
-    ret = ldap_sasl_bind( ld->ld, dnU, LDAP_SASL_SIMPLE, &pwd, NULL, NULL, &msg );
-
-    if (ret == LDAP_SUCCESS)
+    ret = map_error( ldap_funcs->ldap_sasl_bind( ld->ld, dnU, 0, &pwd, NULL, NULL, &msg ) );
+    if (ret == WLDAP32_LDAP_SUCCESS)
         ret = msg;
     else
         ret = ~0u;
@@ -651,8 +508,6 @@ ULONG CDECL ldap_simple_bindW( WLDAP32_LDAP *ld, PWCHAR dn, PWCHAR passwd )
 exit:
     strfreeU( dnU );
     strfreeU( passwdU );
-
-#endif
     return ret;
 }
 
@@ -661,34 +516,23 @@ ULONG CDECL ldap_simple_bindW( WLDAP32_LDAP *ld, PWCHAR dn, PWCHAR passwd )
  *
  * See ldap_simple_bind_sW.
  */
-ULONG CDECL ldap_simple_bind_sA( WLDAP32_LDAP *ld, PCHAR dn, PCHAR passwd )
+ULONG CDECL ldap_simple_bind_sA( WLDAP32_LDAP *ld, char *dn, char *passwd )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
     WCHAR *dnW = NULL, *passwdW = NULL;
 
-    ret = WLDAP32_LDAP_NO_MEMORY;
-
     TRACE( "(%p, %s, %p)\n", ld, debugstr_a(dn), passwd );
 
     if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
 
-    if (dn) {
-        dnW = strAtoW( dn );
-        if (!dnW) goto exit;
-    }
-    if (passwd) {
-        passwdW = strAtoW( passwd );
-        if (!passwdW) goto exit;
-    }
+    if (dn && !(dnW = strAtoW( dn ))) goto exit;
+    if (passwd && !(passwdW = strAtoW( passwd ))) goto exit;
 
     ret = ldap_simple_bind_sW( ld, dnW, passwdW );
 
 exit:
     strfreeW( dnW );
     strfreeW( passwdW );
-
-#endif
     return ret;
 }
 
@@ -707,40 +551,31 @@ ULONG CDECL ldap_simple_bind_sA( WLDAP32_LDAP *ld, PCHAR dn, PCHAR passwd )
  *  Failure: An LDAP error code.
  *
  * NOTES
- *  Set dn and passwd to NULL to bind as an anonymous user. 
+ *  Set dn and passwd to NULL to bind as an anonymous user.
  */
-ULONG CDECL ldap_simple_bind_sW( WLDAP32_LDAP *ld, PWCHAR dn, PWCHAR passwd )
+ULONG CDECL ldap_simple_bind_sW( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *passwd )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
     char *dnU = NULL, *passwdU = NULL;
-    struct berval pwd = { 0, NULL };
-
-    ret = WLDAP32_LDAP_NO_MEMORY;
+    struct bervalU pwd = { 0, NULL };
 
     TRACE( "(%p, %s, %p)\n", ld, debugstr_w(dn), passwd );
 
     if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
 
-    if (dn) {
-        dnU = strWtoU( dn );
-        if (!dnU) goto exit;
-    }
-    if (passwd) {
-        passwdU = strWtoU( passwd );
-        if (!passwdU) goto exit;
-
+    if (dn && !(dnU = strWtoU( dn ))) goto exit;
+    if (passwd)
+    {
+        if (!(passwdU = strWtoU( passwd ))) goto exit;
         pwd.bv_len = strlen( passwdU );
         pwd.bv_val = passwdU;
     }
 
-    ret = map_error( ldap_sasl_bind_s( ld->ld, dnU, LDAP_SASL_SIMPLE, &pwd, NULL, NULL, NULL ));
+    ret = map_error( ldap_funcs->ldap_sasl_bind_s( ld->ld, dnU, 0, &pwd, NULL, NULL, NULL ) );
 
 exit:
     strfreeU( dnU );
     strfreeU( passwdU );
-
-#endif
     return ret;
 }
 
@@ -758,22 +593,16 @@ ULONG CDECL ldap_simple_bind_sW( WLDAP32_LDAP *ld, PWCHAR dn, PWCHAR passwd )
  */
 ULONG CDECL WLDAP32_ldap_unbind( WLDAP32_LDAP *ld )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret;
 
     TRACE( "(%p)\n", ld );
 
-    if (ld)
-    {
-        ret = map_error( ldap_unbind_ext( ld->ld, NULL, NULL ));
-        if ( ld->ld_server_ctrls )
-            ldap_value_free_len( ld->ld_server_ctrls );
-        heap_free( ld );
-    }
-    else
-        ret = WLDAP32_LDAP_PARAM_ERROR;
+    if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
+
+    ret = map_error( ldap_funcs->ldap_unbind_ext( ld->ld, NULL, NULL ));
+    if (ld->ld_server_ctrls) ldap_funcs->ldap_value_free_len( ld->ld_server_ctrls );
 
-#endif
+    heap_free( ld );
     return ret;
 }
 
@@ -791,21 +620,15 @@ ULONG CDECL WLDAP32_ldap_unbind( WLDAP32_LDAP *ld )
  */
 ULONG CDECL WLDAP32_ldap_unbind_s( WLDAP32_LDAP *ld )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret;
 
     TRACE( "(%p)\n", ld );
 
-    if (ld)
-    {
-        ret = map_error( ldap_unbind_ext_s( ld->ld, NULL, NULL ));
-        if ( ld->ld_server_ctrls )
-            ldap_value_free_len( ld->ld_server_ctrls );
-        heap_free( ld );
-    }
-    else
-        ret = WLDAP32_LDAP_PARAM_ERROR;
+    if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
+
+    ret = map_error( ldap_funcs->ldap_unbind_ext_s( ld->ld, NULL, NULL ) );
+    if (ld->ld_server_ctrls) ldap_funcs->ldap_value_free_len( ld->ld_server_ctrls );
 
-#endif
+    heap_free( ld );
     return ret;
 }
diff --git a/dlls/wldap32/libldap.c b/dlls/wldap32/libldap.c
index 3436cffc4a1c..380c589257b2 100644
--- a/dlls/wldap32/libldap.c
+++ b/dlls/wldap32/libldap.c
@@ -52,6 +52,8 @@ C_ASSERT( sizeof(LDAPVLVInfoU) == sizeof(LDAPVLVInfo) );
 
 static LDAPMod *nullattrs[] = { NULL };
 
+static const struct ldap_callbacks *callbacks;
+
 void * CDECL wrap_ber_alloc_t( int options )
 {
     return ber_alloc_t( options );
@@ -292,7 +294,7 @@ int WINAPIV wrap_ber_scanf( void *ber, char *fmt, ... )
     return ret;
 }
 
-int CDECL wrap_ldap_add_ext( void *ld, char *dn, LDAPModU **attrs, LDAPControlU **serverctrls,
+int CDECL wrap_ldap_add_ext( void *ld, const char *dn, LDAPModU **attrs, LDAPControlU **serverctrls,
                              LDAPControlU **clientctrls, ULONG *msg )
 {
     int dummy;
@@ -300,7 +302,7 @@ int CDECL wrap_ldap_add_ext( void *ld, char *dn, LDAPModU **attrs, LDAPControlU
                          (LDAPControl **)clientctrls, msg ? (int *)msg : &dummy );
 }
 
-int CDECL wrap_ldap_add_ext_s( void *ld, char *dn, LDAPModU **attrs, LDAPControlU **serverctrls,
+int CDECL wrap_ldap_add_ext_s( void *ld, const char *dn, LDAPModU **attrs, LDAPControlU **serverctrls,
                                LDAPControlU **clientctrls )
 {
     return ldap_add_ext_s( ld, dn ? dn : "", attrs ? (LDAPMod **)attrs : nullattrs, (LDAPControl **)serverctrls,
@@ -312,6 +314,51 @@ void CDECL wrap_ldap_memfree( void *ptr )
     return ldap_memfree( ptr );
 }
 
+int CDECL wrap_ldap_sasl_bind( void *ld, const char *dn, const char *mech, struct bervalU *cred,
+                               LDAPControlU **serverctrls, LDAPControlU **clientctrls, int *msgid )
+{
+    return ldap_sasl_bind( ld, dn, mech, (struct berval *)cred, (LDAPControl **)serverctrls,
+                           (LDAPControl **)clientctrls, msgid );
+}
+
+int CDECL wrap_ldap_sasl_bind_s( void *ld, const char *dn, const char *mech, struct bervalU *cred,
+                                 LDAPControlU **serverctrls, LDAPControlU **clientctrls, struct bervalU **servercred )
+{
+    return ldap_sasl_bind_s( ld, dn, mech, (struct berval *)cred, (LDAPControl **)serverctrls,
+                             (LDAPControl **)clientctrls, (struct berval **)servercred );
+}
+
+static int wrap_sasl_interact( LDAP *ld, unsigned int flags, void *defaults, void *interact )
+{
+#ifdef HAVE_SASL_SASL_H
+    C_ASSERT( sizeof(struct sasl_interactU) == sizeof(struct sasl_interact) );
+    return callbacks->sasl_interact( ld, flags, defaults, interact );
+#endif
+    return -1;
+}
+
+int CDECL wrap_ldap_sasl_interactive_bind_s( void *ld, const char *dn, const char *mech, LDAPControlU **serverctrls,
+                                             LDAPControlU **clientctrls, unsigned int flags, void *defaults )
+{
+    return ldap_sasl_interactive_bind_s( ld, dn, mech, (LDAPControl **)serverctrls, (LDAPControl **)clientctrls, flags,
+                                         wrap_sasl_interact, defaults );
+}
+
+int CDECL wrap_ldap_unbind_ext( void *ld, LDAPControlU **serverctrls, LDAPControlU **clientctrls )
+{
+    return ldap_unbind_ext( ld, (LDAPControl **)serverctrls, (LDAPControl **)clientctrls );
+}
+
+int CDECL wrap_ldap_unbind_ext_s( void *ld, LDAPControlU **serverctrls, LDAPControlU **clientctrls )
+{
+    return ldap_unbind_ext_s( ld, (LDAPControl **)serverctrls, (LDAPControl **)clientctrls );
+}
+
+void CDECL wrap_ldap_value_free_len( struct bervalU **values )
+{
+    ldap_value_free_len( (struct berval **)values );
+}
+
 static const struct ldap_funcs funcs =
 {
     wrap_ber_alloc_t,
@@ -329,11 +376,18 @@ static const struct ldap_funcs funcs =
     wrap_ldap_add_ext,
     wrap_ldap_add_ext_s,
     wrap_ldap_memfree,
+    wrap_ldap_sasl_bind,
+    wrap_ldap_sasl_bind_s,
+    wrap_ldap_sasl_interactive_bind_s,
+    wrap_ldap_unbind_ext,
+    wrap_ldap_unbind_ext_s,
+    wrap_ldap_value_free_len,
 };
 
 NTSTATUS CDECL __wine_init_unix_lib( HMODULE module, DWORD reason, const void *ptr_in, void *ptr_out )
 {
     if (reason != DLL_PROCESS_ATTACH) return STATUS_SUCCESS;
+    callbacks = ptr_in;
     *(const struct ldap_funcs **)ptr_out = &funcs;
     return STATUS_SUCCESS;
 }
diff --git a/dlls/wldap32/libldap.h b/dlls/wldap32/libldap.h
index 4ca90d298a05..9b4f941d6771 100644
--- a/dlls/wldap32/libldap.h
+++ b/dlls/wldap32/libldap.h
@@ -60,6 +60,23 @@ typedef struct
     void           *ldvlv_extradata;
 } LDAPVLVInfoU;
 
+#ifndef SASL_CB_LIST_END
+#define SASL_CB_LIST_END    0
+#define SASL_CB_USER        0x4001
+#define SASL_CB_PASS        0x4004
+#define SASL_CB_GETREALM    0x4008
+#endif
+
+typedef struct sasl_interactU
+{
+    unsigned long id;
+    const char   *challenge;
+    const char   *prompt;
+    const char   *defresult;
+    const void   *result;
+    unsigned int  len;
+} sasl_interact_tU;
+
 extern void * CDECL wrap_ber_alloc_t(int) DECLSPEC_HIDDEN;
 extern void CDECL wrap_ber_bvecfree(struct bervalU **) DECLSPEC_HIDDEN;
 extern void CDECL wrap_ber_bvfree(struct bervalU *) DECLSPEC_HIDDEN;
@@ -73,9 +90,20 @@ extern unsigned int CDECL wrap_ber_skip_tag(void *, unsigned int *) DECLSPEC_HID
 extern int WINAPIV wrap_ber_printf(void *, char *, ...) DECLSPEC_HIDDEN;
 extern int WINAPIV wrap_ber_scanf(void *, char *, ...) DECLSPEC_HIDDEN;
 
-extern int CDECL wrap_ldap_add_ext(void *, char *, LDAPModU **, LDAPControlU **, LDAPControlU **, ULONG *) DECLSPEC_HIDDEN;
-extern int CDECL wrap_ldap_add_ext_s(void *, char *, LDAPModU **, LDAPControlU **, LDAPControlU **) DECLSPEC_HIDDEN;
+extern int CDECL wrap_ldap_add_ext(void *, const char *, LDAPModU **, LDAPControlU **, LDAPControlU **,
+                                   ULONG *) DECLSPEC_HIDDEN;
+extern int CDECL wrap_ldap_add_ext_s(void *, const char *, LDAPModU **, LDAPControlU **,
+                                     LDAPControlU **) DECLSPEC_HIDDEN;
 extern void CDECL wrap_ldap_memfree(void *) DECLSPEC_HIDDEN;
+extern int CDECL wrap_ldap_sasl_bind(void *, const char *, const char *, struct bervalU *, LDAPControlU **,
+                                     LDAPControlU **, int *) DECLSPEC_HIDDEN;
+extern int CDECL wrap_ldap_sasl_bind_s(void *, const char *, const char *, struct bervalU *, LDAPControlU **,
+                                       LDAPControlU **, struct bervalU **) DECLSPEC_HIDDEN;
+extern int CDECL wrap_ldap_sasl_interactive_bind_s(void *, const char *, const char *, LDAPControlU **,
+                                                   LDAPControlU **, unsigned int, void *) DECLSPEC_HIDDEN;
+extern int CDECL wrap_ldap_unbind_ext(void *, LDAPControlU **, LDAPControlU **) DECLSPEC_HIDDEN;
+extern int CDECL wrap_ldap_unbind_ext_s(void *, LDAPControlU **, LDAPControlU **) DECLSPEC_HIDDEN;
+extern void CDECL wrap_ldap_value_free_len(struct bervalU **) DECLSPEC_HIDDEN;
 
 struct ldap_funcs
 {
@@ -92,9 +120,25 @@ struct ldap_funcs
     int (WINAPIV *ber_printf)(void *, char *, ...);
     int (WINAPIV *ber_scanf)(void *, char *, ...);
 
-    int (CDECL *ldap_add_ext)(void *, char *, LDAPModU **, LDAPControlU **, LDAPControlU **, ULONG *);
-    int (CDECL *ldap_add_ext_s)(void *, char *, LDAPModU **, LDAPControlU **, LDAPControlU **);
+    int (CDECL *ldap_add_ext)(void *, const char *, LDAPModU **, LDAPControlU **, LDAPControlU **, ULONG *);
+    int (CDECL *ldap_add_ext_s)(void *, const char *, LDAPModU **, LDAPControlU **, LDAPControlU **);
     void (CDECL *ldap_memfree)(void *);
+    int (CDECL *ldap_sasl_bind)(void *, const char *, const char *, struct bervalU *, LDAPControlU **, LDAPControlU **,
+                                int *);
+    int (CDECL *ldap_sasl_bind_s)(void *, const char *, const char *, struct bervalU *, LDAPControlU **,
+                                  LDAPControlU **, struct bervalU **);
+    int (CDECL *ldap_sasl_interactive_bind_s)(void *, const char *, const char *, LDAPControlU **, LDAPControlU **,
+                                              unsigned int, void *);
+    int (CDECL *ldap_unbind_ext)(void *, LDAPControlU **, LDAPControlU **);
+    int (CDECL *ldap_unbind_ext_s)(void *, LDAPControlU **, LDAPControlU **);
+    void (CDECL *ldap_value_free_len)(struct bervalU **);
+};
+
+extern int CDECL sasl_interact_cb(void *, unsigned int, void *, void *) DECLSPEC_HIDDEN;
+
+struct ldap_callbacks
+{
+    int (CDECL *sasl_interact)(void *, unsigned int, void *, void *);
 };
 
 extern const struct ldap_funcs *ldap_funcs;
diff --git a/dlls/wldap32/main.c b/dlls/wldap32/main.c
index 55a08c9bad5e..c2fdf30f8205 100644
--- a/dlls/wldap32/main.c
+++ b/dlls/wldap32/main.c
@@ -31,6 +31,10 @@ HINSTANCE hwldap32;
 WINE_DEFAULT_DEBUG_CHANNEL(wldap32);
 
 const struct ldap_funcs *ldap_funcs = NULL;
+const struct ldap_callbacks ldap_callbacks =
+{
+    sasl_interact_cb
+};
 
 BOOL WINAPI DllMain( HINSTANCE hinst, DWORD reason, LPVOID reserved )
 {
@@ -41,7 +45,7 @@ BOOL WINAPI DllMain( HINSTANCE hinst, DWORD reason, LPVOID reserved )
     case DLL_PROCESS_ATTACH:
         hwldap32 = hinst;
         DisableThreadLibraryCalls( hinst );
-        if (__wine_init_unix_lib( hinst, reason, NULL, &ldap_funcs ))
+        if (__wine_init_unix_lib( hinst, reason, &ldap_callbacks, &ldap_funcs ))
             ERR( "No libldap support, expect problems\n" );
         break;
     }
diff --git a/dlls/wldap32/option.c b/dlls/wldap32/option.c
index 388432a442c3..8398dff67e46 100644
--- a/dlls/wldap32/option.c
+++ b/dlls/wldap32/option.c
@@ -416,8 +416,8 @@ static BOOL query_supported_server_ctrls( WLDAP32_LDAP *ld )
     {
         ULONG count, i;
 
-        ld->ld_server_ctrls = ldap_get_values_len( ld->ld, entry, attrs[0] );
-        count = ldap_count_values_len( ld->ld_server_ctrls );
+        ld->ld_server_ctrls = (struct bervalU **)ldap_get_values_len( ld->ld, entry, attrs[0] );
+        count = ldap_count_values_len( (struct berval **)ld->ld_server_ctrls );
         for (i = 0; i < count; i++)
             TRACE("%u: %s\n", i, debugstr_an( ld->ld_server_ctrls[i]->bv_val, ld->ld_server_ctrls[i]->bv_len ));
     }
@@ -435,7 +435,7 @@ static BOOL is_supported_server_ctrls( WLDAP32_LDAP *ld, LDAPControl **ctrls )
         return TRUE; /* can't verify, let the server handle it on next query */
 
     user_count = controlarraylenU( ctrls );
-    server_count = ldap_count_values_len( ld->ld_server_ctrls );
+    server_count = ldap_count_values_len( (struct berval **)ld->ld_server_ctrls );
 
     for (n = 0; n < user_count; n++)
     {
diff --git a/dlls/wldap32/winldap_private.h b/dlls/wldap32/winldap_private.h
index 22e981cb26dc..20fc676c7e2a 100644
--- a/dlls/wldap32/winldap_private.h
+++ b/dlls/wldap32/winldap_private.h
@@ -144,7 +144,7 @@ typedef struct wldap32
     ULONG ld_refhoplimit;
     ULONG ld_options;
     /* internal LDAP context */
-    struct berval **ld_server_ctrls;
+    struct bervalU **ld_server_ctrls;
     void *ld;
 } WLDAP32_LDAP, *WLDAP32_PLDAP;
 
From e32a6026a34bc418058bf5df6d918bc6bef6bff1 Mon Sep 17 00:00:00 2001
From: Hans Leidekker <hans@codeweavers.com>
Date: Wed, 14 Apr 2021 09:40:28 +0200
Subject: [PATCH] wldap32: Move support for compare functions to the Unix
 library.

Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/wldap32/compare.c | 355 ++++++++++-------------------------------
 dlls/wldap32/libldap.c |  17 ++
 dlls/wldap32/libldap.h |   8 +
 3 files changed, 108 insertions(+), 272 deletions(-)

diff --git a/dlls/wldap32/compare.c b/dlls/wldap32/compare.c
index c725aa3a7158..7a366572dc9c 100644
--- a/dlls/wldap32/compare.c
+++ b/dlls/wldap32/compare.c
@@ -18,56 +18,33 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#include "config.h"
-#include "wine/port.h"
-
 #include <stdarg.h>
-#ifdef HAVE_LDAP_H
-#include <ldap.h>
-#endif
-
 #include "windef.h"
 #include "winbase.h"
 #include "winnls.h"
 
-#include "winldap_private.h"
-#include "wldap32.h"
 #include "wine/debug.h"
+#include "winldap_private.h"
 
-#ifdef HAVE_LDAP
 WINE_DEFAULT_DEBUG_CHANNEL(wldap32);
-#endif
 
 /***********************************************************************
  *      ldap_compareA     (WLDAP32.@)
  *
  * See ldap_compareW.
  */
-ULONG CDECL ldap_compareA( WLDAP32_LDAP *ld, PCHAR dn, PCHAR attr, PCHAR value )
+ULONG CDECL ldap_compareA( WLDAP32_LDAP *ld, char *dn, char *attr, char *value )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret = ~0u;
     WCHAR *dnW = NULL, *attrW = NULL, *valueW = NULL;
 
-    ret = ~0u;
-
-    TRACE( "(%p, %s, %s, %s)\n", ld, debugstr_a(dn), debugstr_a(attr),
-           debugstr_a(value) );
+    TRACE( "(%p, %s, %s, %s)\n", ld, debugstr_a(dn), debugstr_a(attr), debugstr_a(value) );
 
     if (!ld || !attr) return ~0u;
 
-    if (dn) {
-        dnW = strAtoW( dn );
-        if (!dnW) goto exit;
-    }
-
-    attrW = strAtoW( attr );
-    if (!attrW) goto exit;
-
-    if (value) {
-        valueW = strAtoW( value );
-        if (!valueW) goto exit;
-    }
+    if (dn && !(dnW = strAtoW( dn ))) goto exit;
+    if (!(attrW = strAtoW( attr ))) goto exit;
+    if (value && !(valueW = strAtoW( value ))) goto exit;
 
     ret = ldap_compareW( ld, dnW, attrW, valueW );
 
@@ -75,8 +52,6 @@ ULONG CDECL ldap_compareA( WLDAP32_LDAP *ld, PCHAR dn, PCHAR attr, PCHAR value )
     strfreeW( dnW );
     strfreeW( attrW );
     strfreeW( valueW );
-
-#endif
     return ret;
 }
 
@@ -95,51 +70,15 @@ ULONG CDECL ldap_compareA( WLDAP32_LDAP *ld, PCHAR dn, PCHAR attr, PCHAR value )
  *  Success: Message ID of the compare operation.
  *  Failure: An LDAP error code.
  */
-ULONG CDECL ldap_compareW( WLDAP32_LDAP *ld, PWCHAR dn, PWCHAR attr, PWCHAR value )
+ULONG CDECL ldap_compareW( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *attr, WCHAR *value )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
-    char *dnU = NULL, *attrU = NULL, *valueU = NULL;
-    struct berval val = { 0, NULL };
-    int msg;
-
-    ret = ~0u;
-
-    TRACE( "(%p, %s, %s, %s)\n", ld, debugstr_w(dn), debugstr_w(attr),
-           debugstr_w(value) );
-
-    if (!ld || !attr) return ~0u;
-
-    if (dn) {
-        dnU = strWtoU( dn );
-        if (!dnU) goto exit;
-    }
-
-    attrU = strWtoU( attr );
-    if (!attrU) goto exit;
-
-    if (value) {
-        valueU = strWtoU( value );
-        if (!valueU) goto exit;
-
-        val.bv_len = strlen( valueU );
-        val.bv_val = valueU;
-    }
+    ULONG msg, ret;
 
-    ret = ldap_compare_ext( ld->ld, dn ? dnU : "", attrU, &val, NULL, NULL, &msg );
+    TRACE( "(%p, %s, %s, %s)\n", ld, debugstr_w(dn), debugstr_w(attr), debugstr_w(value) );
 
-    if (ret == LDAP_SUCCESS)
-        ret = msg;
-    else
-        ret = ~0u;
-
-exit:
-    strfreeU( dnU );
-    strfreeU( attrU );
-    strfreeU( valueU );
-
-#endif
-    return ret;
+    ret = ldap_compare_extW( ld, dn, attr, value, NULL, NULL, NULL, &msg );
+    if (ret == WLDAP32_LDAP_SUCCESS) return msg;
+    return ~0u;
 }
 
 /***********************************************************************
@@ -147,46 +86,26 @@ ULONG CDECL ldap_compareW( WLDAP32_LDAP *ld, PWCHAR dn, PWCHAR attr, PWCHAR valu
  *
  * See ldap_compare_extW.
  */
-ULONG CDECL ldap_compare_extA( WLDAP32_LDAP *ld, PCHAR dn, PCHAR attr, PCHAR value,
-    struct WLDAP32_berval *data, PLDAPControlA *serverctrls, PLDAPControlA *clientctrls,
+ULONG CDECL ldap_compare_extA( WLDAP32_LDAP *ld, char *dn, char *attr, char *value,
+    struct WLDAP32_berval *data, LDAPControlA **serverctrls, LDAPControlA **clientctrls,
     ULONG *message )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
     WCHAR *dnW = NULL, *attrW = NULL, *valueW = NULL;
     LDAPControlW **serverctrlsW = NULL, **clientctrlsW = NULL;
 
-    ret = WLDAP32_LDAP_NO_MEMORY;
-
-    TRACE( "(%p, %s, %s, %s, %p, %p, %p, %p)\n", ld, debugstr_a(dn),
-           debugstr_a(attr), debugstr_a(value), data, serverctrls,
-           clientctrls, message );
+    TRACE( "(%p, %s, %s, %s, %p, %p, %p, %p)\n", ld, debugstr_a(dn), debugstr_a(attr), debugstr_a(value),
+           data, serverctrls, clientctrls, message );
 
     if (!ld || !message) return WLDAP32_LDAP_PARAM_ERROR;
 
-    if (dn) {
-        dnW = strAtoW( dn );
-        if (!dnW) goto exit;
-    }
-    if (attr) {
-        attrW = strAtoW( attr );
-        if (!attrW) goto exit;
-    }
-    if (value) {
-        valueW = strAtoW( value );
-        if (!valueW) goto exit;
-    }
-    if (serverctrls) {
-        serverctrlsW = controlarrayAtoW( serverctrls );
-        if (!serverctrlsW) goto exit;
-    }
-    if (clientctrls) {
-        clientctrlsW = controlarrayAtoW( clientctrls );
-        if (!clientctrlsW) goto exit;
-    }
+    if (dn && !(dnW = strAtoW( dn ))) goto exit;
+    if (attr && !(attrW = strAtoW( attr ))) goto exit;
+    if (value && !(valueW = strAtoW( value ))) goto exit;
+    if (serverctrls && !(serverctrlsW = controlarrayAtoW( serverctrls ))) goto exit;
+    if (clientctrls && !(clientctrlsW = controlarrayAtoW( clientctrls ))) goto exit;
 
-    ret = ldap_compare_extW( ld, dnW, attrW, valueW, data,
-                             serverctrlsW, clientctrlsW, message );
+    ret = ldap_compare_extW( ld, dnW, attrW, valueW, data, serverctrlsW, clientctrlsW, message );
 
 exit:
     strfreeW( dnW );
@@ -194,8 +113,6 @@ ULONG CDECL ldap_compare_extA( WLDAP32_LDAP *ld, PCHAR dn, PCHAR attr, PCHAR val
     strfreeW( valueW );
     controlarrayfreeW( serverctrlsW );
     controlarrayfreeW( clientctrlsW );
-
-#endif
     return ret;
 }
 
@@ -223,62 +140,45 @@ ULONG CDECL ldap_compare_extA( WLDAP32_LDAP *ld, PCHAR dn, PCHAR attr, PCHAR val
  *  both are non-NULL, data will be used. The serverctrls and clientctrls
  *  parameters are optional and should be set to NULL if not used.
  */
-ULONG CDECL ldap_compare_extW( WLDAP32_LDAP *ld, PWCHAR dn, PWCHAR attr, PWCHAR value,
-    struct WLDAP32_berval *data, PLDAPControlW *serverctrls, PLDAPControlW *clientctrls,
-    ULONG *message )
+ULONG CDECL ldap_compare_extW( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *attr, WCHAR *value,
+    struct WLDAP32_berval *data, LDAPControlW **serverctrls, LDAPControlW **clientctrls, ULONG *message )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
     char *dnU = NULL, *attrU = NULL, *valueU = NULL;
-    LDAPControl **serverctrlsU = NULL, **clientctrlsU = NULL;
-    struct berval val = { 0, NULL };
+    LDAPControlU **serverctrlsU = NULL, **clientctrlsU = NULL;
+    struct bervalU *dataU = NULL, val = { 0, NULL };
 
-    ret = WLDAP32_LDAP_NO_MEMORY;
-
-    TRACE( "(%p, %s, %s, %s, %p, %p, %p, %p)\n", ld, debugstr_w(dn),
-           debugstr_w(attr), debugstr_w(value), data, serverctrls,
-           clientctrls, message );
+    TRACE( "(%p, %s, %s, %s, %p, %p, %p, %p)\n", ld, debugstr_w(dn), debugstr_w(attr), debugstr_w(value),
+           data, serverctrls, clientctrls, message );
 
     if (!ld || !message) return WLDAP32_LDAP_PARAM_ERROR;
     if (!attr) return WLDAP32_LDAP_NO_MEMORY;
 
-    if (dn) {
-        dnU = strWtoU( dn );
-        if (!dnU) goto exit;
-    }
-
-    attrU = strWtoU( attr );
-    if (!attrU) goto exit;
-
-    if (!data) {
-        if (value) {
-            valueU = strWtoU( value );
-            if (!valueU) goto exit;
-
+    if (dn && !(dnU = strWtoU( dn ))) goto exit;
+    if (!(attrU = strWtoU( attr ))) goto exit;
+    if (!data)
+    {
+        if (value)
+        {
+            if (!(valueU = strWtoU( value ))) goto exit;
             val.bv_len = strlen( valueU );
             val.bv_val = valueU;
         }
     }
-    if (serverctrls) {
-        serverctrlsU = controlarrayWtoU( serverctrls );
-        if (!serverctrlsU) goto exit;
-    }
-    if (clientctrls) {
-        clientctrlsU = controlarrayWtoU( clientctrls );
-        if (!clientctrlsU) goto exit;
-    }
+    else if (!(dataU = bervalWtoU( data ))) goto exit;
 
-    ret = map_error( ldap_compare_ext( ld->ld, dn ? dnU : "", attrU, data ? (struct berval *)data : &val,
-                                       serverctrlsU, clientctrlsU, (int *)message ));
+    if (serverctrls && !(serverctrlsU = controlarrayWtoU( serverctrls ))) goto exit;
+    if (clientctrls && !(clientctrlsU = controlarrayWtoU( clientctrls ))) goto exit;
 
+    ret = map_error( ldap_funcs->ldap_compare_ext( ld->ld, dnU, attrU, dataU ? dataU : &val, serverctrlsU,
+                                                   clientctrlsU, message ) );
 exit:
     strfreeU( dnU );
     strfreeU( attrU );
     strfreeU( valueU );
+    bvfreeU( dataU );
     controlarrayfreeU( serverctrlsU );
     controlarrayfreeU( clientctrlsU );
-
-#endif
     return ret;
 }
 
@@ -287,45 +187,25 @@ ULONG CDECL ldap_compare_extW( WLDAP32_LDAP *ld, PWCHAR dn, PWCHAR attr, PWCHAR
  *
  * See ldap_compare_ext_sW.
  */
-ULONG CDECL ldap_compare_ext_sA( WLDAP32_LDAP *ld, PCHAR dn, PCHAR attr, PCHAR value,
-    struct WLDAP32_berval *data, PLDAPControlA *serverctrls, PLDAPControlA *clientctrls )
+ULONG CDECL ldap_compare_ext_sA( WLDAP32_LDAP *ld, char *dn, char *attr, char *value,
+    struct WLDAP32_berval *data, LDAPControlA **serverctrls, LDAPControlA **clientctrls )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
     WCHAR *dnW = NULL, *attrW = NULL, *valueW = NULL;
     LDAPControlW **serverctrlsW = NULL, **clientctrlsW = NULL;
 
-    ret = WLDAP32_LDAP_NO_MEMORY;
-
-    TRACE( "(%p, %s, %s, %s, %p, %p, %p)\n", ld, debugstr_a(dn),
-           debugstr_a(attr), debugstr_a(value), data, serverctrls,
-           clientctrls );
+    TRACE( "(%p, %s, %s, %s, %p, %p, %p)\n", ld, debugstr_a(dn), debugstr_a(attr), debugstr_a(value),
+           data, serverctrls, clientctrls );
 
     if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
 
-    if (dn) {
-        dnW = strAtoW( dn );
-        if (!dnW) goto exit;
-    }
-    if (attr) {
-        attrW = strAtoW( attr );
-        if (!attrW) goto exit;
-    }
-    if (value) {
-        valueW = strAtoW( value );
-        if (!valueW) goto exit;
-    }
-    if (serverctrls) {
-        serverctrlsW = controlarrayAtoW( serverctrls );
-        if (!serverctrlsW) goto exit;
-    }
-    if (clientctrls) {
-        clientctrlsW = controlarrayAtoW( clientctrls );
-        if (!clientctrlsW) goto exit;
-    }
+    if (dn && !(dnW = strAtoW( dn ))) goto exit;
+    if (attr && !(attrW = strAtoW( attr ))) goto exit;
+    if (value && !(valueW = strAtoW( value ))) goto exit;
+    if (serverctrls && !(serverctrlsW = controlarrayAtoW( serverctrls ))) goto exit;
+    if (clientctrls && !(clientctrlsW = controlarrayAtoW( clientctrls ))) goto exit;
 
-    ret = ldap_compare_ext_sW( ld, dnW, attrW, valueW, data, serverctrlsW,
-                               clientctrlsW );
+    ret = ldap_compare_ext_sW( ld, dnW, attrW, valueW, data, serverctrlsW, clientctrlsW );
 
 exit:
     strfreeW( dnW );
@@ -333,8 +213,6 @@ ULONG CDECL ldap_compare_ext_sA( WLDAP32_LDAP *ld, PCHAR dn, PCHAR attr, PCHAR v
     strfreeW( valueW );
     controlarrayfreeW( serverctrlsW );
     controlarrayfreeW( clientctrlsW );
-
-#endif
     return ret;
 }
 
@@ -361,61 +239,44 @@ ULONG CDECL ldap_compare_ext_sA( WLDAP32_LDAP *ld, PCHAR dn, PCHAR attr, PCHAR v
  *  both are non-NULL, data will be used. The serverctrls and clientctrls
  *  parameters are optional and should be set to NULL if not used.
  */
-ULONG CDECL ldap_compare_ext_sW( WLDAP32_LDAP *ld, PWCHAR dn, PWCHAR attr, PWCHAR value,
-    struct WLDAP32_berval *data, PLDAPControlW *serverctrls, PLDAPControlW *clientctrls )
+ULONG CDECL ldap_compare_ext_sW( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *attr, WCHAR *value,
+    struct WLDAP32_berval *data, LDAPControlW **serverctrls, LDAPControlW **clientctrls )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
     char *dnU = NULL, *attrU = NULL, *valueU = NULL;
-    LDAPControl **serverctrlsU = NULL, **clientctrlsU = NULL;
-    struct berval val = { 0, NULL };
+    LDAPControlU **serverctrlsU = NULL, **clientctrlsU = NULL;
+    struct bervalU *dataU = NULL, val = { 0, NULL };
 
-    ret = WLDAP32_LDAP_NO_MEMORY;
-
-    TRACE( "(%p, %s, %s, %s, %p, %p, %p)\n", ld, debugstr_w(dn),
-           debugstr_w(attr), debugstr_w(value), data, serverctrls,
-           clientctrls );
+    TRACE( "(%p, %s, %s, %s, %p, %p, %p)\n", ld, debugstr_w(dn), debugstr_w(attr), debugstr_w(value), data,
+           serverctrls, clientctrls );
 
     if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
 
-    if (dn) {
-        dnU = strWtoU( dn );
-        if (!dnU) goto exit;
-    }
-    if (attr) {
-        attrU = strWtoU( attr );
-        if (!attrU) goto exit;
-    }
-    if (!data) {
-        if (value) {
-            valueU = strWtoU( value );
-            if (!valueU) goto exit;
-
+    if (dn && !(dnU = strWtoU( dn ))) goto exit;
+    if (attr && !(attrU = strWtoU( attr ))) goto exit;
+    if (!data)
+    {
+        if (value)
+        {
+            if (!(valueU = strWtoU( value ))) goto exit;
             val.bv_len = strlen( valueU );
             val.bv_val = valueU;
         }
     }
-    if (serverctrls) {
-        serverctrlsU = controlarrayWtoU( serverctrls );
-        if (!serverctrlsU) goto exit;
-    }
-    if (clientctrls) {
-        clientctrlsU = controlarrayWtoU( clientctrls );
-        if (!clientctrlsU) goto exit;
-    }
+    else if (!(dataU = bervalWtoU( data ))) goto exit;
 
-    ret = map_error( ldap_compare_ext_s( ld->ld, dn ? dnU : "", attr ? attrU : "",
-                                         data ? (struct berval *)data : &val,
-                                         serverctrlsU, clientctrlsU ));
+    if (serverctrls && !(serverctrlsU = controlarrayWtoU( serverctrls ))) goto exit;
+    if (clientctrls && !(clientctrlsU = controlarrayWtoU( clientctrls ))) goto exit;
 
+    ret = map_error( ldap_funcs->ldap_compare_ext_s( ld->ld, dnU, attrU, dataU ? dataU : &val, serverctrlsU,
+                                                     clientctrlsU ) );
 exit:
     strfreeU( dnU );
     strfreeU( attrU );
     strfreeU( valueU );
+    bvfreeU( dataU );
     controlarrayfreeU( serverctrlsU );
     controlarrayfreeU( clientctrlsU );
-
-#endif
     return ret;
 }
 
@@ -426,29 +287,16 @@ ULONG CDECL ldap_compare_ext_sW( WLDAP32_LDAP *ld, PWCHAR dn, PWCHAR attr, PWCHA
  */
 ULONG CDECL ldap_compare_sA( WLDAP32_LDAP *ld, PCHAR dn, PCHAR attr, PCHAR value )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
     WCHAR *dnW = NULL, *attrW = NULL, *valueW = NULL;
 
-    ret = WLDAP32_LDAP_NO_MEMORY;
-
-    TRACE( "(%p, %s, %s, %s)\n", ld, debugstr_a(dn), debugstr_a(attr),
-           debugstr_a(value) );
+    TRACE( "(%p, %s, %s, %s)\n", ld, debugstr_a(dn), debugstr_a(attr), debugstr_a(value) );
 
     if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
 
-    if (dn) {
-        dnW = strAtoW( dn );
-        if (!dnW) goto exit;
-    }
-    if (attr) {
-        attrW = strAtoW( attr );
-        if (!attrW) goto exit;
-    }
-    if (value) {
-        valueW = strAtoW( value );
-        if (!valueW) goto exit;
-    }
+    if (dn && !(dnW = strAtoW( dn ))) goto exit;
+    if (attr && !(attrW = strAtoW( attr ))) goto exit;
+    if (value && !(valueW = strAtoW( value ))) goto exit;
 
     ret = ldap_compare_sW( ld, dnW, attrW, valueW );
 
@@ -456,8 +304,6 @@ ULONG CDECL ldap_compare_sA( WLDAP32_LDAP *ld, PCHAR dn, PCHAR attr, PCHAR value
     strfreeW( dnW );
     strfreeW( attrW );
     strfreeW( valueW );
-
-#endif
     return ret;
 }
 
@@ -476,43 +322,8 @@ ULONG CDECL ldap_compare_sA( WLDAP32_LDAP *ld, PCHAR dn, PCHAR attr, PCHAR value
  *  Success: LDAP_SUCCESS
  *  Failure: An LDAP error code.
  */
-ULONG CDECL ldap_compare_sW( WLDAP32_LDAP *ld, PWCHAR dn, PWCHAR attr, PWCHAR value )
+ULONG CDECL ldap_compare_sW( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *attr, WCHAR *value )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
-    char *dnU = NULL, *attrU = NULL, *valueU = NULL;
-    struct berval val = { 0, NULL };
-
-    ret = WLDAP32_LDAP_NO_MEMORY;
-
-    TRACE( "(%p, %s, %s, %s)\n", ld, debugstr_w(dn), debugstr_w(attr),
-           debugstr_w(value) );
-
-    if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
-
-    if (dn) {
-        dnU = strWtoU( dn );
-        if (!dnU) goto exit;
-    }
-    if (attr) {
-        attrU = strWtoU( attr );
-        if (!attrU) goto exit;
-    }
-    if (value) {
-        valueU = strWtoU( value );
-        if (!valueU) goto exit;
-
-        val.bv_len = strlen( valueU );
-        val.bv_val = valueU;
-    }
-
-    ret = map_error( ldap_compare_ext_s( ld->ld, dn ? dnU : "", attr ? attrU : "", &val, NULL, NULL ));
-
-exit:
-    strfreeU( dnU );
-    strfreeU( attrU );
-    strfreeU( valueU );
-
-#endif
-    return ret;
+    TRACE( "(%p, %s, %s, %s)\n", ld, debugstr_w(dn), debugstr_w(attr), debugstr_w(value) );
+    return ldap_compare_ext_sW( ld, dn, attr, value, NULL, NULL, NULL );
 }
diff --git a/dlls/wldap32/libldap.c b/dlls/wldap32/libldap.c
index 380c589257b2..0ddd40355146 100644
--- a/dlls/wldap32/libldap.c
+++ b/dlls/wldap32/libldap.c
@@ -309,6 +309,21 @@ int CDECL wrap_ldap_add_ext_s( void *ld, const char *dn, LDAPModU **attrs, LDAPC
                            (LDAPControl **)clientctrls );
 }
 
+int CDECL wrap_ldap_compare_ext( void *ld, const char *dn, const char *attrs, struct bervalU *value,
+                                 LDAPControlU **serverctrls, LDAPControlU **clientctrls, ULONG *msg )
+{
+    int dummy;
+    return ldap_compare_ext( ld, dn ? dn : "", attrs ? attrs : "", (struct berval *)value,
+                             (LDAPControl **)serverctrls, (LDAPControl **)clientctrls, msg ? (int *)msg : &dummy );
+}
+
+int CDECL wrap_ldap_compare_ext_s( void *ld, const char *dn, const char *attrs, struct bervalU *value,
+                                   LDAPControlU **serverctrls, LDAPControlU **clientctrls )
+{
+    return ldap_compare_ext_s( ld, dn ? dn : "", attrs ? attrs : "", (struct berval *)value,
+                               (LDAPControl **)serverctrls, (LDAPControl **)clientctrls );
+}
+
 void CDECL wrap_ldap_memfree( void *ptr )
 {
     return ldap_memfree( ptr );
@@ -375,6 +390,8 @@ static const struct ldap_funcs funcs =
     wrap_ber_scanf,
     wrap_ldap_add_ext,
     wrap_ldap_add_ext_s,
+    wrap_ldap_compare_ext,
+    wrap_ldap_compare_ext_s,
     wrap_ldap_memfree,
     wrap_ldap_sasl_bind,
     wrap_ldap_sasl_bind_s,
diff --git a/dlls/wldap32/libldap.h b/dlls/wldap32/libldap.h
index 9b4f941d6771..0fa1c7e56712 100644
--- a/dlls/wldap32/libldap.h
+++ b/dlls/wldap32/libldap.h
@@ -94,6 +94,10 @@ extern int CDECL wrap_ldap_add_ext(void *, const char *, LDAPModU **, LDAPContro
                                    ULONG *) DECLSPEC_HIDDEN;
 extern int CDECL wrap_ldap_add_ext_s(void *, const char *, LDAPModU **, LDAPControlU **,
                                      LDAPControlU **) DECLSPEC_HIDDEN;
+extern int CDECL wrap_ldap_compare_ext(void *, const char *, const char *, struct bervalU *, LDAPControlU **,
+                                       LDAPControlU **, ULONG *) DECLSPEC_HIDDEN;
+extern int CDECL wrap_ldap_compare_ext_s(void *, const char *, const char *, struct bervalU *, LDAPControlU **,
+                                         LDAPControlU **) DECLSPEC_HIDDEN;
 extern void CDECL wrap_ldap_memfree(void *) DECLSPEC_HIDDEN;
 extern int CDECL wrap_ldap_sasl_bind(void *, const char *, const char *, struct bervalU *, LDAPControlU **,
                                      LDAPControlU **, int *) DECLSPEC_HIDDEN;
@@ -122,6 +126,10 @@ struct ldap_funcs
 
     int (CDECL *ldap_add_ext)(void *, const char *, LDAPModU **, LDAPControlU **, LDAPControlU **, ULONG *);
     int (CDECL *ldap_add_ext_s)(void *, const char *, LDAPModU **, LDAPControlU **, LDAPControlU **);
+    int (CDECL *ldap_compare_ext)(void *, const char *, const char *, struct bervalU *, LDAPControlU **,
+                                  LDAPControlU **, ULONG *);
+    int (CDECL *ldap_compare_ext_s)(void *, const char *, const char *, struct bervalU *, LDAPControlU **,
+                                    LDAPControlU **);
     void (CDECL *ldap_memfree)(void *);
     int (CDECL *ldap_sasl_bind)(void *, const char *, const char *, struct bervalU *, LDAPControlU **, LDAPControlU **,
                                 int *);
From 5bf1900dd0927bf0e4b85586241b1b297969bb15 Mon Sep 17 00:00:00 2001
From: Hans Leidekker <hans@codeweavers.com>
Date: Wed, 14 Apr 2021 09:40:29 +0200
Subject: [PATCH] wldap32: Move support for control functions to the Unix
 library.

Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/wldap32/control.c | 150 ++++++++++++++++-------------------------
 dlls/wldap32/libldap.c |  18 +++++
 dlls/wldap32/libldap.h |   6 ++
 3 files changed, 81 insertions(+), 93 deletions(-)

diff --git a/dlls/wldap32/control.c b/dlls/wldap32/control.c
index f0e0b05c0d1a..42098fc814a1 100644
--- a/dlls/wldap32/control.c
+++ b/dlls/wldap32/control.c
@@ -18,25 +18,15 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#include "config.h"
-#include "wine/port.h"
-
 #include <stdarg.h>
-#ifdef HAVE_LDAP_H
-#include <ldap.h>
-#endif
-
 #include "windef.h"
 #include "winbase.h"
 #include "winnls.h"
 
-#include "winldap_private.h"
-#include "wldap32.h"
 #include "wine/debug.h"
+#include "winldap_private.h"
 
-#ifdef HAVE_LDAP
 WINE_DEFAULT_DEBUG_CHANNEL(wldap32);
-#endif
 
 /***********************************************************************
  *      ldap_control_freeA     (WLDAP32.@)
@@ -45,14 +35,9 @@ WINE_DEFAULT_DEBUG_CHANNEL(wldap32);
  */
 ULONG CDECL ldap_control_freeA( LDAPControlA *control )
 {
-    ULONG ret = WLDAP32_LDAP_SUCCESS;
-#ifdef HAVE_LDAP
-
     TRACE( "(%p)\n", control );
     controlfreeA( control );
-
-#endif
-    return ret;
+    return WLDAP32_LDAP_SUCCESS;
 }
 
 /***********************************************************************
@@ -68,14 +53,9 @@ ULONG CDECL ldap_control_freeA( LDAPControlA *control )
  */
 ULONG CDECL ldap_control_freeW( LDAPControlW *control )
 {
-    ULONG ret = WLDAP32_LDAP_SUCCESS;
-#ifdef HAVE_LDAP
-
     TRACE( "(%p)\n", control );
     controlfreeW( control );
-
-#endif
-    return ret;
+    return WLDAP32_LDAP_SUCCESS;
 }
 
 /***********************************************************************
@@ -85,14 +65,9 @@ ULONG CDECL ldap_control_freeW( LDAPControlW *control )
  */
 ULONG CDECL ldap_controls_freeA( LDAPControlA **controls )
 {
-    ULONG ret = WLDAP32_LDAP_SUCCESS;
-#ifdef HAVE_LDAP
-
     TRACE( "(%p)\n", controls );
     controlarrayfreeA( controls );
-
-#endif
-    return ret;
+    return WLDAP32_LDAP_SUCCESS;
 }
 
 /***********************************************************************
@@ -108,14 +83,9 @@ ULONG CDECL ldap_controls_freeA( LDAPControlA **controls )
  */
 ULONG CDECL ldap_controls_freeW( LDAPControlW **controls )
 {
-    ULONG ret = WLDAP32_LDAP_SUCCESS;
-#ifdef HAVE_LDAP
-
     TRACE( "(%p)\n", controls );
     controlarrayfreeW( controls );
-
-#endif
-    return ret;
+    return WLDAP32_LDAP_SUCCESS;
 }
 
 /***********************************************************************
@@ -123,31 +93,29 @@ ULONG CDECL ldap_controls_freeW( LDAPControlW **controls )
  *
  * See ldap_create_sort_controlW.
  */
-ULONG CDECL ldap_create_sort_controlA( WLDAP32_LDAP *ld, PLDAPSortKeyA *sortkey,
-    UCHAR critical, PLDAPControlA *control )
+ULONG CDECL ldap_create_sort_controlA( WLDAP32_LDAP *ld, LDAPSortKeyA **sortkey, UCHAR critical,
+    LDAPControlA **control )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
-    LDAPSortKeyW **sortkeyW = NULL;
-    LDAPControlW *controlW = NULL;
+    ULONG ret;
+    LDAPSortKeyW **sortkeyW;
+    LDAPControlW *controlW;
 
     TRACE( "(%p, %p, 0x%02x, %p)\n", ld, sortkey, critical, control );
 
-    if (!ld || !sortkey || !control)
-        return WLDAP32_LDAP_PARAM_ERROR;
+    if (!ld || !sortkey || !control) return WLDAP32_LDAP_PARAM_ERROR;
 
-    sortkeyW = sortkeyarrayAtoW( sortkey );
-    if (!sortkeyW) return WLDAP32_LDAP_NO_MEMORY;
+    if (!(sortkeyW = sortkeyarrayAtoW( sortkey ))) return WLDAP32_LDAP_NO_MEMORY;
 
     ret = ldap_create_sort_controlW( ld, sortkeyW, critical, &controlW );
+    if (ret == WLDAP32_LDAP_SUCCESS)
+    {
+        LDAPControlA *controlA = controlWtoA( controlW );
+        if (controlA) *control = controlA;
+        else ret = WLDAP32_LDAP_NO_MEMORY;
+        ldap_control_freeW( controlW );
+    }
 
-    *control = controlWtoA( controlW );
-    if (!*control) ret = WLDAP32_LDAP_NO_MEMORY;
-
-    ldap_control_freeW( controlW );
     sortkeyarrayfreeW( sortkeyW );
-
-#endif
     return ret;
 }
 
@@ -173,31 +141,29 @@ ULONG CDECL ldap_create_sort_controlA( WLDAP32_LDAP *ld, PLDAPSortKeyA *sortkey,
  *  Pass the created control as a server control in subsequent calls
  *  to ldap_search_ext(_s) to obtain sorted search results.
  */
-ULONG CDECL ldap_create_sort_controlW( WLDAP32_LDAP *ld, PLDAPSortKeyW *sortkey,
-    UCHAR critical, PLDAPControlW *control )
+ULONG CDECL ldap_create_sort_controlW( WLDAP32_LDAP *ld, LDAPSortKeyW **sortkey, UCHAR critical,
+    LDAPControlW **control )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
-    LDAPSortKey **sortkeyU = NULL;
-    LDAPControl *controlU = NULL;
+    ULONG ret;
+    LDAPSortKeyU **sortkeyU;
+    LDAPControlU *controlU;
 
     TRACE( "(%p, %p, 0x%02x, %p)\n", ld, sortkey, critical, control );
 
-    if (!ld || !sortkey || !control)
-        return WLDAP32_LDAP_PARAM_ERROR;
+    if (!ld || !sortkey || !control) return WLDAP32_LDAP_PARAM_ERROR;
 
-    sortkeyU = sortkeyarrayWtoU( sortkey );
-    if (!sortkeyU) return WLDAP32_LDAP_NO_MEMORY;
+    if (sortkey && !(sortkeyU = sortkeyarrayWtoU( sortkey ))) return WLDAP32_LDAP_NO_MEMORY;
 
-    ret = map_error( ldap_create_sort_control( ld->ld, sortkeyU, critical, &controlU ));
-
-    *control = controlUtoW( controlU );
-    if (!*control) ret = WLDAP32_LDAP_NO_MEMORY;
+    ret = map_error( ldap_funcs->ldap_create_sort_control( ld->ld, sortkeyU, critical, &controlU ) );
+    if (ret == WLDAP32_LDAP_SUCCESS)
+    {
+        LDAPControlW *controlW = controlUtoW( controlU );
+        if (controlW) *control = controlW;
+        else ret = WLDAP32_LDAP_NO_MEMORY;
+        ldap_funcs->ldap_control_free( controlU );
+    }
 
-    ldap_control_free( controlU );
     sortkeyarrayfreeU( sortkeyU );
-
-#endif
     return ret;
 }
 
@@ -206,27 +172,25 @@ ULONG CDECL ldap_create_sort_controlW( WLDAP32_LDAP *ld, PLDAPSortKeyW *sortkey,
  *
  * See ldap_create_vlv_controlW.
  */
-INT CDECL ldap_create_vlv_controlA( WLDAP32_LDAP *ld, WLDAP32_LDAPVLVInfo *info,
-    UCHAR critical, LDAPControlA **control )
+INT CDECL ldap_create_vlv_controlA( WLDAP32_LDAP *ld, WLDAP32_LDAPVLVInfo *info, UCHAR critical,
+    LDAPControlA **control )
 {
-    INT ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
-    LDAPControlW *controlW = NULL;
+    INT ret;
+    LDAPControlW *controlW;
 
     TRACE( "(%p, %p, 0x%02x, %p)\n", ld, info, critical, control );
 
     if (!ld || !control) return ~0u;
 
     ret = ldap_create_vlv_controlW( ld, info, critical, &controlW );
-
     if (ret == WLDAP32_LDAP_SUCCESS)
     {
-        *control = controlWtoA( controlW );
-        if (!*control) ret = WLDAP32_LDAP_NO_MEMORY;
+        LDAPControlA *controlA = controlWtoA( controlW );
+        if (controlA) *control = controlA;
+        else ret = WLDAP32_LDAP_NO_MEMORY;
         ldap_control_freeW( controlW );
     }
 
-#endif
     return ret;
 }
 
@@ -252,33 +216,35 @@ INT CDECL ldap_create_vlv_controlA( WLDAP32_LDAP *ld, WLDAP32_LDAPVLVInfo *info,
  *  server will then return a sorted, contiguous subset of results
  *  that meets the criteria specified in the LDAPVLVInfo structure.
  */
-INT CDECL ldap_create_vlv_controlW( WLDAP32_LDAP *ld, WLDAP32_LDAPVLVInfo *info,
-    UCHAR critical, LDAPControlW **control )
+INT CDECL ldap_create_vlv_controlW( WLDAP32_LDAP *ld, WLDAP32_LDAPVLVInfo *info, UCHAR critical,
+    LDAPControlW **control )
 {
-    INT ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
-    LDAPControl *controlU = NULL;
+    ULONG ret;
+    LDAPVLVInfoU *infoU = NULL;
+    LDAPControlU *controlU;
 
     TRACE( "(%p, %p, 0x%02x, %p)\n", ld, info, critical, control );
 
     if (!ld || !control) return ~0u;
 
-    ret = map_error( ldap_create_vlv_control( ld->ld, (LDAPVLVInfo *)info, &controlU ));
+    if (info && !(infoU = vlvinfoWtoU( info ))) return WLDAP32_LDAP_NO_MEMORY;
 
+    ret = map_error( ldap_funcs->ldap_create_vlv_control( ld->ld, infoU, &controlU ) );
     if (ret == WLDAP32_LDAP_SUCCESS)
     {
-        *control = controlUtoW( controlU );
-        if (!*control) ret = WLDAP32_LDAP_NO_MEMORY;
-        ldap_control_free( controlU );
+        LDAPControlW *controlW = controlUtoW( controlU );
+        if (controlW) *control = controlW;
+        else ret = WLDAP32_LDAP_NO_MEMORY;
+        ldap_funcs->ldap_control_free( controlU );
     }
 
-#endif
+    vlvinfofreeU( infoU );
     return ret;
 }
 
 static inline void bv_val_dup( const struct WLDAP32_berval *src, struct WLDAP32_berval *dst )
 {
-    if ((dst->bv_val = heap_alloc( src->bv_len )))
+    if ((dst->bv_val = RtlAllocateHeap( GetProcessHeap(), 0 , src->bv_len )))
     {
         memcpy( dst->bv_val, src->bv_val, src->bv_len );
         dst->bv_len = src->bv_len;
@@ -292,8 +258,7 @@ static inline void bv_val_dup( const struct WLDAP32_berval *src, struct WLDAP32_
  *
  * See ldap_encode_sort_controlW.
  */
-ULONG CDECL ldap_encode_sort_controlA( WLDAP32_LDAP *ld, PLDAPSortKeyA *sortkeys,
-    PLDAPControlA ret, BOOLEAN critical )
+ULONG CDECL ldap_encode_sort_controlA( WLDAP32_LDAP *ld, LDAPSortKeyA **sortkeys, LDAPControlA *ret, BOOLEAN critical )
 {
     LDAPControlA *control;
     ULONG result;
@@ -330,8 +295,7 @@ ULONG CDECL ldap_encode_sort_controlA( WLDAP32_LDAP *ld, PLDAPSortKeyA *sortkeys
  *  This function is obsolete. Use its equivalent
  *  ldap_create_sort_control instead.
  */
-ULONG CDECL ldap_encode_sort_controlW( WLDAP32_LDAP *ld, PLDAPSortKeyW *sortkeys,
-    PLDAPControlW ret, BOOLEAN critical )
+ULONG CDECL ldap_encode_sort_controlW( WLDAP32_LDAP *ld, LDAPSortKeyW **sortkeys, LDAPControlW *ret, BOOLEAN critical )
 {
     LDAPControlW *control;
     ULONG result;
@@ -366,7 +330,7 @@ ULONG CDECL ldap_free_controlsA( LDAPControlA **controls )
  *
  * RETURNS
  *  LDAP_SUCCESS
- *  
+ *
  * NOTES
  *  Obsolete, use ldap_controls_freeW.
  */
diff --git a/dlls/wldap32/libldap.c b/dlls/wldap32/libldap.c
index 0ddd40355146..34cd3e987462 100644
--- a/dlls/wldap32/libldap.c
+++ b/dlls/wldap32/libldap.c
@@ -309,6 +309,11 @@ int CDECL wrap_ldap_add_ext_s( void *ld, const char *dn, LDAPModU **attrs, LDAPC
                            (LDAPControl **)clientctrls );
 }
 
+void CDECL wrap_ldap_control_free( LDAPControlU *control )
+{
+    ldap_control_free( (LDAPControl *)control );
+}
+
 int CDECL wrap_ldap_compare_ext( void *ld, const char *dn, const char *attrs, struct bervalU *value,
                                  LDAPControlU **serverctrls, LDAPControlU **clientctrls, ULONG *msg )
 {
@@ -324,6 +329,16 @@ int CDECL wrap_ldap_compare_ext_s( void *ld, const char *dn, const char *attrs,
                                (LDAPControl **)serverctrls, (LDAPControl **)clientctrls );
 }
 
+int CDECL wrap_ldap_create_sort_control( void *ld, LDAPSortKeyU **keylist, int critical, LDAPControlU **control )
+{
+    return ldap_create_sort_control( ld, (LDAPSortKey **)keylist, critical, (LDAPControl **)control );
+}
+
+int CDECL wrap_ldap_create_vlv_control( void *ld, LDAPVLVInfoU *info, LDAPControlU **control )
+{
+    return ldap_create_vlv_control( ld, (LDAPVLVInfo *)info, (LDAPControl **)control );
+}
+
 void CDECL wrap_ldap_memfree( void *ptr )
 {
     return ldap_memfree( ptr );
@@ -392,6 +407,9 @@ static const struct ldap_funcs funcs =
     wrap_ldap_add_ext_s,
     wrap_ldap_compare_ext,
     wrap_ldap_compare_ext_s,
+    wrap_ldap_control_free,
+    wrap_ldap_create_sort_control,
+    wrap_ldap_create_vlv_control,
     wrap_ldap_memfree,
     wrap_ldap_sasl_bind,
     wrap_ldap_sasl_bind_s,
diff --git a/dlls/wldap32/libldap.h b/dlls/wldap32/libldap.h
index 0fa1c7e56712..c582e9f923db 100644
--- a/dlls/wldap32/libldap.h
+++ b/dlls/wldap32/libldap.h
@@ -98,6 +98,9 @@ extern int CDECL wrap_ldap_compare_ext(void *, const char *, const char *, struc
                                        LDAPControlU **, ULONG *) DECLSPEC_HIDDEN;
 extern int CDECL wrap_ldap_compare_ext_s(void *, const char *, const char *, struct bervalU *, LDAPControlU **,
                                          LDAPControlU **) DECLSPEC_HIDDEN;
+extern void CDECL wrap_ldap_control_free(LDAPControlU *) DECLSPEC_HIDDEN;
+extern int CDECL wrap_ldap_create_sort_control(void *, LDAPSortKeyU **, int, LDAPControlU **) DECLSPEC_HIDDEN;
+extern int CDECL wrap_ldap_create_vlv_control(void *, LDAPVLVInfoU *, LDAPControlU **) DECLSPEC_HIDDEN;
 extern void CDECL wrap_ldap_memfree(void *) DECLSPEC_HIDDEN;
 extern int CDECL wrap_ldap_sasl_bind(void *, const char *, const char *, struct bervalU *, LDAPControlU **,
                                      LDAPControlU **, int *) DECLSPEC_HIDDEN;
@@ -130,6 +133,9 @@ struct ldap_funcs
                                   LDAPControlU **, ULONG *);
     int (CDECL *ldap_compare_ext_s)(void *, const char *, const char *, struct bervalU *, LDAPControlU **,
                                     LDAPControlU **);
+    void (CDECL *ldap_control_free)(LDAPControlU *);
+    int (CDECL *ldap_create_sort_control)(void *, LDAPSortKeyU **, int, LDAPControlU **);
+    int (CDECL *ldap_create_vlv_control)(void *, LDAPVLVInfoU *, LDAPControlU **);
     void (CDECL *ldap_memfree)(void *);
     int (CDECL *ldap_sasl_bind)(void *, const char *, const char *, struct bervalU *, LDAPControlU **, LDAPControlU **,
                                 int *);
From d8a2463abca104814f306bc7bc953d1a1f4a4471 Mon Sep 17 00:00:00 2001
From: Hans Leidekker <hans@codeweavers.com>
Date: Thu, 15 Apr 2021 12:20:03 +0200
Subject: [PATCH] wldap32: Move support for delete functions to the Unix
 library.

Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/wldap32/delete.c  | 214 ++++++++++-------------------------------
 dlls/wldap32/libldap.c |  15 +++
 dlls/wldap32/libldap.h |   4 +
 3 files changed, 68 insertions(+), 165 deletions(-)

diff --git a/dlls/wldap32/delete.c b/dlls/wldap32/delete.c
index 95d636e48742..9f2b107f62cf 100644
--- a/dlls/wldap32/delete.c
+++ b/dlls/wldap32/delete.c
@@ -18,50 +18,33 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#include "config.h"
-#include "wine/port.h"
-
 #include <stdarg.h>
-#ifdef HAVE_LDAP_H
-#include <ldap.h>
-#endif
-
 #include "windef.h"
 #include "winbase.h"
 #include "winnls.h"
 
-#include "winldap_private.h"
-#include "wldap32.h"
 #include "wine/debug.h"
+#include "winldap_private.h"
 
-#ifdef HAVE_LDAP
 WINE_DEFAULT_DEBUG_CHANNEL(wldap32);
-#endif
 
 /***********************************************************************
  *      ldap_deleteA     (WLDAP32.@)
  *
  * See ldap_deleteW.
  */
-ULONG CDECL ldap_deleteA( WLDAP32_LDAP *ld, PCHAR dn )
+ULONG CDECL ldap_deleteA( WLDAP32_LDAP *ld, char *dn )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret;
     WCHAR *dnW = NULL;
 
     TRACE( "(%p, %s)\n", ld, debugstr_a(dn) );
 
     if (!ld) return ~0u;
-
-    if (dn) {
-        dnW = strAtoW( dn );
-        if (!dnW) return WLDAP32_LDAP_NO_MEMORY;
-    }
+    if (dn && !(dnW = strAtoW( dn ))) return WLDAP32_LDAP_NO_MEMORY;
 
     ret = ldap_deleteW( ld, dnW );
     strfreeW( dnW );
-
-#endif
     return ret;
 }
 
@@ -83,33 +66,15 @@ ULONG CDECL ldap_deleteA( WLDAP32_LDAP *ld, PCHAR dn )
  *  the operation. Cancel the operation by calling ldap_abandon
  *  with the message ID.
  */
-ULONG CDECL ldap_deleteW( WLDAP32_LDAP *ld, PWCHAR dn )
+ULONG CDECL ldap_deleteW( WLDAP32_LDAP *ld, WCHAR *dn )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
-    char *dnU = NULL;
-    int msg;
+    ULONG ret, msg;
 
     TRACE( "(%p, %s)\n", ld, debugstr_w(dn) );
 
-    if (!ld) return ~0u;
-
-    if (dn) {
-        dnU = strWtoU( dn );
-        if (!dnU) return WLDAP32_LDAP_NO_MEMORY;
-    }
-
-    ret = ldap_delete_ext( ld->ld, dn ? dnU : "", NULL, NULL, &msg );
-
-    if (ret == LDAP_SUCCESS)
-        ret = msg;
-    else
-        ret = ~0u;
-
-    strfreeU( dnU );
-
-#endif
-    return ret;
+    ret = ldap_delete_extW( ld, dn, NULL, NULL, &msg );
+    if (ret == WLDAP32_LDAP_SUCCESS) return msg;
+    return ~0u;
 }
 
 /***********************************************************************
@@ -117,33 +82,20 @@ ULONG CDECL ldap_deleteW( WLDAP32_LDAP *ld, PWCHAR dn )
  *
  * See ldap_delete_extW.
  */
-ULONG CDECL ldap_delete_extA( WLDAP32_LDAP *ld, PCHAR dn, PLDAPControlA *serverctrls,
-    PLDAPControlA *clientctrls, ULONG *message )
+ULONG CDECL ldap_delete_extA( WLDAP32_LDAP *ld, char *dn, LDAPControlA **serverctrls,
+    LDAPControlA **clientctrls, ULONG *message )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
     WCHAR *dnW = NULL;
     LDAPControlW **serverctrlsW = NULL, **clientctrlsW = NULL;
 
-    TRACE( "(%p, %s, %p, %p, %p)\n", ld, debugstr_a(dn), serverctrls,
-           clientctrls, message );
-
-    ret = WLDAP32_LDAP_NO_MEMORY;
+    TRACE( "(%p, %s, %p, %p, %p)\n", ld, debugstr_a(dn), serverctrls, clientctrls, message );
 
     if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
 
-    if (dn) {
-        dnW = strAtoW( dn );
-        if (!dnW) goto exit;
-    }
-    if (serverctrls) {
-        serverctrlsW = controlarrayAtoW( serverctrls );
-        if (!serverctrlsW) goto exit;
-    }
-    if (clientctrls) {
-        clientctrlsW = controlarrayAtoW( clientctrls );
-        if (!clientctrlsW) goto exit;
-    }
+    if (dn && !(dnW = strAtoW( dn ))) goto exit;
+    if (serverctrls && !(serverctrlsW = controlarrayAtoW( serverctrls ))) goto exit;
+    if (clientctrls && !(clientctrlsW = controlarrayAtoW( clientctrls ))) goto exit;
 
     ret = ldap_delete_extW( ld, dnW, serverctrlsW, clientctrlsW, message );
 
@@ -151,8 +103,6 @@ ULONG CDECL ldap_delete_extA( WLDAP32_LDAP *ld, PCHAR dn, PLDAPControlA *serverc
     strfreeW( dnW );
     controlarrayfreeW( serverctrlsW );
     controlarrayfreeW( clientctrlsW );
-
-#endif
     return ret;
 }
 
@@ -177,44 +127,27 @@ ULONG CDECL ldap_delete_extA( WLDAP32_LDAP *ld, PCHAR dn, PLDAPControlA *serverc
  *  the operation. The serverctrls and clientctrls parameters are
  *  optional and should be set to NULL if not used.
  */
-ULONG CDECL ldap_delete_extW( WLDAP32_LDAP *ld, PWCHAR dn, PLDAPControlW *serverctrls,
-    PLDAPControlW *clientctrls, ULONG *message )
+ULONG CDECL ldap_delete_extW( WLDAP32_LDAP *ld, WCHAR *dn, LDAPControlW **serverctrls,
+    LDAPControlW **clientctrls, ULONG *message )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
     char *dnU = NULL;
-    LDAPControl **serverctrlsU = NULL, **clientctrlsU = NULL;
-    int dummy;
-
-    TRACE( "(%p, %s, %p, %p, %p)\n", ld, debugstr_w(dn), serverctrls,
-           clientctrls, message );
+    LDAPControlU **serverctrlsU = NULL, **clientctrlsU = NULL;
 
-    ret = WLDAP32_LDAP_NO_MEMORY;
+    TRACE( "(%p, %s, %p, %p, %p)\n", ld, debugstr_w(dn), serverctrls, clientctrls, message );
 
     if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
 
-    if (dn) {
-        dnU = strWtoU( dn );
-        if (!dnU) goto exit;
-    }
-    if (serverctrls) {
-        serverctrlsU = controlarrayWtoU( serverctrls );
-        if (!serverctrlsU) goto exit;
-    }
-    if (clientctrls) {
-        clientctrlsU = controlarrayWtoU( clientctrls );
-        if (!clientctrlsU) goto exit;
-    }
-
-    ret = map_error( ldap_delete_ext( ld->ld, dn ? dnU : "", serverctrlsU, clientctrlsU,
-                                      message ? (int *)message : &dummy ));
+    if (dn && !(dnU = strWtoU( dn ))) goto exit;
+    if (serverctrls && !(serverctrlsU = controlarrayWtoU( serverctrls ))) goto exit;
+    if (clientctrls && !(clientctrlsU = controlarrayWtoU( clientctrls ))) goto exit;
+
+    ret = map_error( ldap_funcs->ldap_delete_ext( ld->ld, dnU, serverctrlsU, clientctrlsU, message ) );
 
 exit:
     strfreeU( dnU );
     controlarrayfreeU( serverctrlsU );
     controlarrayfreeU( clientctrlsU );
-
-#endif
     return ret;
 }
 
@@ -223,31 +156,20 @@ ULONG CDECL ldap_delete_extW( WLDAP32_LDAP *ld, PWCHAR dn, PLDAPControlW *server
  *
  * See ldap_delete_ext_sW.
  */
-ULONG CDECL ldap_delete_ext_sA( WLDAP32_LDAP *ld, PCHAR dn, PLDAPControlA *serverctrls,
-    PLDAPControlA *clientctrls )
+ULONG CDECL ldap_delete_ext_sA( WLDAP32_LDAP *ld, char *dn, LDAPControlA **serverctrls,
+    LDAPControlA **clientctrls )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
     WCHAR *dnW = NULL;
     LDAPControlW **serverctrlsW = NULL, **clientctrlsW = NULL;
 
-    TRACE( "(%p, %s, %p, %p)\n", ld, debugstr_a(dn), serverctrls,
-           clientctrls );
+    TRACE( "(%p, %s, %p, %p)\n", ld, debugstr_a(dn), serverctrls, clientctrls );
 
     if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
 
-    if (dn) {
-        dnW = strAtoW( dn );
-        if (!dnW) goto exit;
-    }
-    if (serverctrls) {
-        serverctrlsW = controlarrayAtoW( serverctrls );
-        if (!serverctrlsW) goto exit;
-    }
-    if (clientctrls) {
-        clientctrlsW = controlarrayAtoW( clientctrls );
-        if (!clientctrlsW) goto exit;
-    }
+    if (dn && !(dnW = strAtoW( dn ))) goto exit;
+    if (serverctrls && !(serverctrlsW = controlarrayAtoW( serverctrls ))) goto exit;
+    if (clientctrls && !(clientctrlsW = controlarrayAtoW( clientctrls ))) goto exit;
 
     ret = ldap_delete_ext_sW( ld, dnW, serverctrlsW, clientctrlsW );
 
@@ -255,8 +177,6 @@ ULONG CDECL ldap_delete_ext_sA( WLDAP32_LDAP *ld, PCHAR dn, PLDAPControlA *serve
     strfreeW( dnW );
     controlarrayfreeW( serverctrlsW );
     controlarrayfreeW( clientctrlsW );
-
-#endif
     return ret;
 }
 
@@ -279,67 +199,47 @@ ULONG CDECL ldap_delete_ext_sA( WLDAP32_LDAP *ld, PCHAR dn, PLDAPControlA *serve
  *  The serverctrls and clientctrls parameters are optional and
  *  should be set to NULL if not used.
  */
-ULONG CDECL ldap_delete_ext_sW( WLDAP32_LDAP *ld, PWCHAR dn, PLDAPControlW *serverctrls,
-    PLDAPControlW *clientctrls )
+ULONG CDECL ldap_delete_ext_sW( WLDAP32_LDAP *ld, WCHAR *dn, LDAPControlW **serverctrls,
+    LDAPControlW **clientctrls )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
     char *dnU = NULL;
-    LDAPControl **serverctrlsU = NULL, **clientctrlsU = NULL;
+    LDAPControlU **serverctrlsU = NULL, **clientctrlsU = NULL;
 
-    TRACE( "(%p, %s, %p, %p)\n", ld, debugstr_w(dn), serverctrls,
-           clientctrls );
+    TRACE( "(%p, %s, %p, %p)\n", ld, debugstr_w(dn), serverctrls, clientctrls );
 
     if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
 
-    if (dn) {
-        dnU = strWtoU( dn );
-        if (!dnU) goto exit;
-    }
-    if (serverctrls) {
-        serverctrlsU = controlarrayWtoU( serverctrls );
-        if (!serverctrlsU) goto exit;
-    }
-    if (clientctrls) {
-        clientctrlsU = controlarrayWtoU( clientctrls );
-        if (!clientctrlsU) goto exit;
-    }
-
-    ret = map_error( ldap_delete_ext_s( ld->ld, dn ? dnU : "", serverctrlsU, clientctrlsU ));
+    if (dn && !(dnU = strWtoU( dn ))) goto exit;
+    if (serverctrls && !(serverctrlsU = controlarrayWtoU( serverctrls ))) goto exit;
+    if (clientctrls && !(clientctrlsU = controlarrayWtoU( clientctrls ))) goto exit;
+
+    ret = map_error( ldap_funcs->ldap_delete_ext_s( ld->ld, dnU, serverctrlsU, clientctrlsU ) );
 
 exit:
     strfreeU( dnU );
     controlarrayfreeU( serverctrlsU );
     controlarrayfreeU( clientctrlsU );
-
-#endif
     return ret;
 }
- 
+
 /***********************************************************************
  *      ldap_delete_sA     (WLDAP32.@)
  *
  * See ldap_delete_sW.
  */
-ULONG CDECL ldap_delete_sA( WLDAP32_LDAP *ld, PCHAR dn )
+ULONG CDECL ldap_delete_sA( WLDAP32_LDAP *ld, char *dn )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret;
     WCHAR *dnW = NULL;
 
     TRACE( "(%p, %s)\n", ld, debugstr_a(dn) );
 
     if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
-
-    if (dn) {
-        dnW = strAtoW( dn );
-        if (!dnW) return WLDAP32_LDAP_NO_MEMORY;
-    }
+    if (dn && !(dnW = strAtoW( dn ))) return WLDAP32_LDAP_NO_MEMORY;
 
     ret = ldap_delete_sW( ld, dnW );
     strfreeW( dnW );
-
-#endif
     return ret;
 }
 
@@ -356,24 +256,8 @@ ULONG CDECL ldap_delete_sA( WLDAP32_LDAP *ld, PCHAR dn )
  *  Success: LDAP_SUCCESS
  *  Failure: An LDAP error code.
  */
-ULONG CDECL ldap_delete_sW( WLDAP32_LDAP *ld, PWCHAR dn )
+ULONG CDECL ldap_delete_sW( WLDAP32_LDAP *ld, WCHAR *dn )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
-    char *dnU = NULL;
-
     TRACE( "(%p, %s)\n", ld, debugstr_w(dn) );
-
-    if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
-
-    if (dn) {
-        dnU = strWtoU( dn );
-        if (!dnU) return WLDAP32_LDAP_NO_MEMORY;
-    }
-
-    ret = map_error( ldap_delete_ext_s( ld->ld, dn ? dnU : "", NULL, NULL ));
-    strfreeU( dnU );
-
-#endif
-    return ret;
+    return ldap_delete_ext_sW( ld, dn, NULL, NULL );
 }
diff --git a/dlls/wldap32/libldap.c b/dlls/wldap32/libldap.c
index 34cd3e987462..be2e540721b9 100644
--- a/dlls/wldap32/libldap.c
+++ b/dlls/wldap32/libldap.c
@@ -339,6 +339,19 @@ int CDECL wrap_ldap_create_vlv_control( void *ld, LDAPVLVInfoU *info, LDAPContro
     return ldap_create_vlv_control( ld, (LDAPVLVInfo *)info, (LDAPControl **)control );
 }
 
+int CDECL wrap_ldap_delete_ext( void *ld, const char *dn, LDAPControlU **serverctrls, LDAPControlU **clientctrls,
+                                ULONG *msg )
+{
+    int dummy;
+    return ldap_delete_ext( ld, dn ? dn : "", (LDAPControl **)serverctrls, (LDAPControl **)clientctrls,
+                            msg ? (int *)msg : &dummy );
+}
+
+int CDECL wrap_ldap_delete_ext_s( void *ld, const char *dn, LDAPControlU **serverctrls, LDAPControlU **clientctrls )
+{
+    return ldap_delete_ext_s( ld, dn ? dn : "", (LDAPControl **)serverctrls, (LDAPControl **)clientctrls );
+}
+
 void CDECL wrap_ldap_memfree( void *ptr )
 {
     return ldap_memfree( ptr );
@@ -410,6 +423,8 @@ static const struct ldap_funcs funcs =
     wrap_ldap_control_free,
     wrap_ldap_create_sort_control,
     wrap_ldap_create_vlv_control,
+    wrap_ldap_delete_ext,
+    wrap_ldap_delete_ext_s,
     wrap_ldap_memfree,
     wrap_ldap_sasl_bind,
     wrap_ldap_sasl_bind_s,
diff --git a/dlls/wldap32/libldap.h b/dlls/wldap32/libldap.h
index c582e9f923db..dde7d3eba178 100644
--- a/dlls/wldap32/libldap.h
+++ b/dlls/wldap32/libldap.h
@@ -101,6 +101,8 @@ extern int CDECL wrap_ldap_compare_ext_s(void *, const char *, const char *, str
 extern void CDECL wrap_ldap_control_free(LDAPControlU *) DECLSPEC_HIDDEN;
 extern int CDECL wrap_ldap_create_sort_control(void *, LDAPSortKeyU **, int, LDAPControlU **) DECLSPEC_HIDDEN;
 extern int CDECL wrap_ldap_create_vlv_control(void *, LDAPVLVInfoU *, LDAPControlU **) DECLSPEC_HIDDEN;
+extern int CDECL wrap_ldap_delete_ext(void *, const char *, LDAPControlU **, LDAPControlU **, ULONG *) DECLSPEC_HIDDEN;
+extern int CDECL wrap_ldap_delete_ext_s(void *, const char *, LDAPControlU **, LDAPControlU **) DECLSPEC_HIDDEN;
 extern void CDECL wrap_ldap_memfree(void *) DECLSPEC_HIDDEN;
 extern int CDECL wrap_ldap_sasl_bind(void *, const char *, const char *, struct bervalU *, LDAPControlU **,
                                      LDAPControlU **, int *) DECLSPEC_HIDDEN;
@@ -136,6 +138,8 @@ struct ldap_funcs
     void (CDECL *ldap_control_free)(LDAPControlU *);
     int (CDECL *ldap_create_sort_control)(void *, LDAPSortKeyU **, int, LDAPControlU **);
     int (CDECL *ldap_create_vlv_control)(void *, LDAPVLVInfoU *, LDAPControlU **);
+    int (CDECL *ldap_delete_ext)(void *, const char *, LDAPControlU **, LDAPControlU **, ULONG *);
+    int (CDECL *ldap_delete_ext_s)(void *, const char *, LDAPControlU **, LDAPControlU **);
     void (CDECL *ldap_memfree)(void *);
     int (CDECL *ldap_sasl_bind)(void *, const char *, const char *, struct bervalU *, LDAPControlU **, LDAPControlU **,
                                 int *);
From 0f3f49e12c4203ccbb42e5d3a035207972451ad3 Mon Sep 17 00:00:00 2001
From: Hans Leidekker <hans@codeweavers.com>
Date: Thu, 15 Apr 2021 12:20:04 +0200
Subject: [PATCH] wldap32: Move support for error functions to the Unix
 library.

Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/wldap32/error.c   | 64 ++++++++++++++++++------------------------
 dlls/wldap32/libldap.c |  7 +++++
 dlls/wldap32/libldap.h |  3 ++
 3 files changed, 37 insertions(+), 37 deletions(-)

diff --git a/dlls/wldap32/error.c b/dlls/wldap32/error.c
index 11ecaf8763b7..c1b678788f07 100644
--- a/dlls/wldap32/error.c
+++ b/dlls/wldap32/error.c
@@ -18,47 +18,41 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#include "config.h"
-#include "wine/port.h"
-
 #include <stdarg.h>
-#ifdef HAVE_LDAP_H
-#include <ldap.h>
-#endif
-
 #include "windef.h"
 #include "winbase.h"
 #include "winuser.h"
 #include "winnls.h"
 
-#include "winldap_private.h"
-#include "wldap32.h"
 #include "wine/debug.h"
+#include "winldap_private.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(wldap32);
 
+extern HINSTANCE hwldap32 DECLSPEC_HIDDEN;
+
 ULONG map_error( int error )
 {
     switch (error)
     {
-#ifdef HAVE_LDAP_H
-    case LDAP_SERVER_DOWN:              return WLDAP32_LDAP_SERVER_DOWN;
-    case LDAP_LOCAL_ERROR:              return WLDAP32_LDAP_LOCAL_ERROR;
-    case LDAP_DECODING_ERROR:           return WLDAP32_LDAP_DECODING_ERROR;
-    case LDAP_TIMEOUT:                  return WLDAP32_LDAP_TIMEOUT;
-    case LDAP_AUTH_UNKNOWN:             return WLDAP32_LDAP_AUTH_UNKNOWN;
-    case LDAP_FILTER_ERROR:             return WLDAP32_LDAP_FILTER_ERROR;
-    case LDAP_USER_CANCELLED:           return WLDAP32_LDAP_USER_CANCELLED;
-    case LDAP_PARAM_ERROR:              return WLDAP32_LDAP_PARAM_ERROR;
-    case LDAP_NO_MEMORY:                return WLDAP32_LDAP_NO_MEMORY;
-    case LDAP_CONNECT_ERROR:            return WLDAP32_LDAP_CONNECT_ERROR;
-    case LDAP_NOT_SUPPORTED:            return WLDAP32_LDAP_NOT_SUPPORTED;
-    case LDAP_CONTROL_NOT_FOUND:        return WLDAP32_LDAP_CONTROL_NOT_FOUND;
-    case LDAP_NO_RESULTS_RETURNED:      return WLDAP32_LDAP_NO_RESULTS_RETURNED;
-    case LDAP_MORE_RESULTS_TO_RETURN:   return WLDAP32_LDAP_MORE_RESULTS_TO_RETURN;
-    case LDAP_CLIENT_LOOP:              return WLDAP32_LDAP_CLIENT_LOOP;
-    case LDAP_REFERRAL_LIMIT_EXCEEDED:  return WLDAP32_LDAP_REFERRAL_LIMIT_EXCEEDED;
-#endif
+    case  0:    return WLDAP32_LDAP_SUCCESS;
+    case -1:    return WLDAP32_LDAP_SERVER_DOWN;
+    case -2:    return WLDAP32_LDAP_LOCAL_ERROR;
+    case -3:    return WLDAP32_LDAP_ENCODING_ERROR;
+    case -4:    return WLDAP32_LDAP_DECODING_ERROR;
+    case -5:    return WLDAP32_LDAP_TIMEOUT;
+    case -6:    return WLDAP32_LDAP_AUTH_UNKNOWN;
+    case -7:    return WLDAP32_LDAP_FILTER_ERROR;
+    case -8:    return WLDAP32_LDAP_USER_CANCELLED;
+    case -9:    return WLDAP32_LDAP_PARAM_ERROR;
+    case -10:   return WLDAP32_LDAP_NO_MEMORY;
+    case -11:   return WLDAP32_LDAP_CONNECT_ERROR;
+    case -12:   return WLDAP32_LDAP_NOT_SUPPORTED;
+    case -13:   return WLDAP32_LDAP_CONTROL_NOT_FOUND;
+    case -14:   return WLDAP32_LDAP_NO_RESULTS_RETURNED;
+    case -15:   return WLDAP32_LDAP_MORE_RESULTS_TO_RETURN;
+    case -16:   return WLDAP32_LDAP_CLIENT_LOOP;
+    case -17:   return WLDAP32_LDAP_REFERRAL_LIMIT_EXCEEDED;
     default: return error;
     }
 }
@@ -68,7 +62,7 @@ ULONG map_error( int error )
  *
  * See ldap_err2stringW.
  */
-PCHAR CDECL ldap_err2stringA( ULONG err )
+char * CDECL ldap_err2stringA( ULONG err )
 {
     static char buf[256] = "";
 
@@ -98,7 +92,7 @@ PCHAR CDECL ldap_err2stringA( ULONG err )
  *  The returned string is statically allocated, you must not
  *  free this string.
  */
-PWCHAR CDECL ldap_err2stringW( ULONG err )
+WCHAR * CDECL ldap_err2stringW( ULONG err )
 {
     static WCHAR buf[256] = { 0 };
 
@@ -151,22 +145,19 @@ void CDECL WLDAP32_ldap_perror( WLDAP32_LDAP *ld, const PCHAR msg )
  */
 ULONG CDECL WLDAP32_ldap_result2error( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *res, ULONG free )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret;
     int error;
 
     TRACE( "(%p, %p, 0x%08x)\n", ld, res, free );
 
     if (!ld || !res) return ~0u;
 
-    ret = ldap_parse_result( ld->ld, res, &error, NULL, NULL, NULL, NULL, free );
-
-    if (ret == LDAP_SUCCESS)
+    ret = map_error( ldap_funcs->ldap_parse_result( ld->ld, res, &error, NULL, NULL, NULL, NULL, free ) );
+    if (ret == WLDAP32_LDAP_SUCCESS)
         ret = error;
     else
         ret = ~0u;
 
-#endif
     return ret;
 }
 
@@ -303,7 +294,6 @@ ULONG CDECL LdapMapErrorToWin32( ULONG err )
 {
     TRACE( "(0x%08x)\n", err );
 
-    if (err >= ARRAY_SIZE( WLDAP32_errormap ))
-        return ERROR_DS_GENERIC_ERROR;
+    if (err >= ARRAY_SIZE( WLDAP32_errormap )) return ERROR_DS_GENERIC_ERROR;
     return WLDAP32_errormap[err];
 }
diff --git a/dlls/wldap32/libldap.c b/dlls/wldap32/libldap.c
index be2e540721b9..11a3707f200d 100644
--- a/dlls/wldap32/libldap.c
+++ b/dlls/wldap32/libldap.c
@@ -357,6 +357,12 @@ void CDECL wrap_ldap_memfree( void *ptr )
     return ldap_memfree( ptr );
 }
 
+int CDECL wrap_ldap_parse_result( void *ld, void *res, int *errcode, char **matcheddn, char **errmsg,
+                                  char ***referrals, LDAPControlU ***serverctrls, int free )
+{
+    return ldap_parse_result( ld, res, errcode, matcheddn, errmsg, referrals, (LDAPControl ***)serverctrls, free );
+}
+
 int CDECL wrap_ldap_sasl_bind( void *ld, const char *dn, const char *mech, struct bervalU *cred,
                                LDAPControlU **serverctrls, LDAPControlU **clientctrls, int *msgid )
 {
@@ -426,6 +432,7 @@ static const struct ldap_funcs funcs =
     wrap_ldap_delete_ext,
     wrap_ldap_delete_ext_s,
     wrap_ldap_memfree,
+    wrap_ldap_parse_result,
     wrap_ldap_sasl_bind,
     wrap_ldap_sasl_bind_s,
     wrap_ldap_sasl_interactive_bind_s,
diff --git a/dlls/wldap32/libldap.h b/dlls/wldap32/libldap.h
index dde7d3eba178..5ebc5bacd547 100644
--- a/dlls/wldap32/libldap.h
+++ b/dlls/wldap32/libldap.h
@@ -104,6 +104,8 @@ extern int CDECL wrap_ldap_create_vlv_control(void *, LDAPVLVInfoU *, LDAPContro
 extern int CDECL wrap_ldap_delete_ext(void *, const char *, LDAPControlU **, LDAPControlU **, ULONG *) DECLSPEC_HIDDEN;
 extern int CDECL wrap_ldap_delete_ext_s(void *, const char *, LDAPControlU **, LDAPControlU **) DECLSPEC_HIDDEN;
 extern void CDECL wrap_ldap_memfree(void *) DECLSPEC_HIDDEN;
+extern int CDECL wrap_ldap_parse_result(void *, void *, int *, char **, char **, char ***, LDAPControlU ***,
+                                        int) DECLSPEC_HIDDEN;
 extern int CDECL wrap_ldap_sasl_bind(void *, const char *, const char *, struct bervalU *, LDAPControlU **,
                                      LDAPControlU **, int *) DECLSPEC_HIDDEN;
 extern int CDECL wrap_ldap_sasl_bind_s(void *, const char *, const char *, struct bervalU *, LDAPControlU **,
@@ -141,6 +143,7 @@ struct ldap_funcs
     int (CDECL *ldap_delete_ext)(void *, const char *, LDAPControlU **, LDAPControlU **, ULONG *);
     int (CDECL *ldap_delete_ext_s)(void *, const char *, LDAPControlU **, LDAPControlU **);
     void (CDECL *ldap_memfree)(void *);
+    int (CDECL *ldap_parse_result)(void *, void *, int *, char **, char **, char ***, LDAPControlU ***, int);
     int (CDECL *ldap_sasl_bind)(void *, const char *, const char *, struct bervalU *, LDAPControlU **, LDAPControlU **,
                                 int *);
     int (CDECL *ldap_sasl_bind_s)(void *, const char *, const char *, struct bervalU *, LDAPControlU **,
From 22b26a20dc97865f3edc203eae224228131862f4 Mon Sep 17 00:00:00 2001
From: Hans Leidekker <hans@codeweavers.com>
Date: Thu, 15 Apr 2021 12:20:05 +0200
Subject: [PATCH] wldap32: Move support for search functions to the Unix
 library.

Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/wldap32/dn.c      |   2 +-
 dlls/wldap32/error.c   |   2 +-
 dlls/wldap32/libldap.c |  98 ++++++++-
 dlls/wldap32/libldap.h |  36 ++++
 dlls/wldap32/misc.c    | 250 +++++++++++-----------
 dlls/wldap32/parse.c   |  10 +-
 dlls/wldap32/search.c  | 458 +++++++++++------------------------------
 dlls/wldap32/value.c   |   4 +-
 8 files changed, 379 insertions(+), 481 deletions(-)

diff --git a/dlls/wldap32/dn.c b/dlls/wldap32/dn.c
index 6d1a9711016a..b35a5dfe1ac2 100644
--- a/dlls/wldap32/dn.c
+++ b/dlls/wldap32/dn.c
@@ -214,7 +214,7 @@ PWCHAR CDECL ldap_get_dnW( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *entry )
 
     if (!ld || !entry) return NULL;
 
-    retU = ldap_get_dn( ld->ld, entry );
+    retU = ldap_get_dn( ld->ld, entry->Request );
 
     ret = strUtoW( retU );
     ldap_memfree( retU );
diff --git a/dlls/wldap32/error.c b/dlls/wldap32/error.c
index c1b678788f07..a56adc11c02a 100644
--- a/dlls/wldap32/error.c
+++ b/dlls/wldap32/error.c
@@ -152,7 +152,7 @@ ULONG CDECL WLDAP32_ldap_result2error( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *re
 
     if (!ld || !res) return ~0u;
 
-    ret = map_error( ldap_funcs->ldap_parse_result( ld->ld, res, &error, NULL, NULL, NULL, NULL, free ) );
+    ret = map_error( ldap_funcs->ldap_parse_result( ld->ld, res->Request, &error, NULL, NULL, NULL, NULL, free ) );
     if (ret == WLDAP32_LDAP_SUCCESS)
         ret = error;
     else
diff --git a/dlls/wldap32/libldap.c b/dlls/wldap32/libldap.c
index 11a3707f200d..bc1a161127af 100644
--- a/dlls/wldap32/libldap.c
+++ b/dlls/wldap32/libldap.c
@@ -26,6 +26,7 @@
 
 #ifdef HAVE_LDAP
 #include <stdarg.h>
+#include <sys/time.h>
 #ifdef HAVE_LDAP_H
 # include <ldap.h>
 #endif
@@ -49,6 +50,7 @@ C_ASSERT( sizeof(LDAPModU) == sizeof(LDAPMod) );
 C_ASSERT( sizeof(LDAPControlU) == sizeof(LDAPControl) );
 C_ASSERT( sizeof(LDAPSortKeyU) == sizeof(LDAPSortKey) );
 C_ASSERT( sizeof(LDAPVLVInfoU) == sizeof(LDAPVLVInfo) );
+C_ASSERT( sizeof(struct timevalU) == sizeof(struct timeval) );
 
 static LDAPMod *nullattrs[] = { NULL };
 
@@ -294,6 +296,11 @@ int WINAPIV wrap_ber_scanf( void *ber, char *fmt, ... )
     return ret;
 }
 
+int CDECL wrap_ldap_abandon_ext( void *ld, int msgid, LDAPControlU **serverctrls, LDAPControlU **clientctrls )
+{
+    return ldap_abandon_ext( ld, msgid, (LDAPControl **)serverctrls, (LDAPControl **)clientctrls );
+}
+
 int CDECL wrap_ldap_add_ext( void *ld, const char *dn, LDAPModU **attrs, LDAPControlU **serverctrls,
                              LDAPControlU **clientctrls, ULONG *msg )
 {
@@ -309,11 +316,6 @@ int CDECL wrap_ldap_add_ext_s( void *ld, const char *dn, LDAPModU **attrs, LDAPC
                            (LDAPControl **)clientctrls );
 }
 
-void CDECL wrap_ldap_control_free( LDAPControlU *control )
-{
-    ldap_control_free( (LDAPControl *)control );
-}
-
 int CDECL wrap_ldap_compare_ext( void *ld, const char *dn, const char *attrs, struct bervalU *value,
                                  LDAPControlU **serverctrls, LDAPControlU **clientctrls, ULONG *msg )
 {
@@ -329,6 +331,21 @@ int CDECL wrap_ldap_compare_ext_s( void *ld, const char *dn, const char *attrs,
                                (LDAPControl **)serverctrls, (LDAPControl **)clientctrls );
 }
 
+void CDECL wrap_ldap_control_free( LDAPControlU *control )
+{
+    ldap_control_free( (LDAPControl *)control );
+}
+
+int CDECL wrap_ldap_count_entries( void *ld, void *chain )
+{
+    return ldap_count_entries( ld, chain );
+}
+
+int CDECL wrap_ldap_count_references( void *ld, void *chain )
+{
+    return ldap_count_references( ld, chain );
+}
+
 int CDECL wrap_ldap_create_sort_control( void *ld, LDAPSortKeyU **keylist, int critical, LDAPControlU **control )
 {
     return ldap_create_sort_control( ld, (LDAPSortKey **)keylist, critical, (LDAPControl **)control );
@@ -352,17 +369,57 @@ int CDECL wrap_ldap_delete_ext_s( void *ld, const char *dn, LDAPControlU **serve
     return ldap_delete_ext_s( ld, dn ? dn : "", (LDAPControl **)serverctrls, (LDAPControl **)clientctrls );
 }
 
+char * CDECL wrap_ldap_first_attribute( void *ld, void *entry, void **ber )
+{
+    return ldap_first_attribute( ld, entry, (BerElement **)ber );
+}
+
+void * CDECL wrap_ldap_first_entry( void *ld, void *chain )
+{
+    return ldap_first_entry( ld, chain );
+}
+
+void * CDECL wrap_ldap_first_reference( void *ld, void *chain )
+{
+    return ldap_first_reference( ld, chain );
+}
+
 void CDECL wrap_ldap_memfree( void *ptr )
 {
     return ldap_memfree( ptr );
 }
 
+int CDECL wrap_ldap_msgfree( void *msg )
+{
+    return ldap_msgfree( msg );
+}
+
+char * CDECL wrap_ldap_next_attribute( void *ld, void *entry, void *ber )
+{
+    return ldap_next_attribute( ld, entry, ber );
+}
+
+void * CDECL wrap_ldap_next_entry( void *ld, void *entry )
+{
+    return ldap_next_entry( ld, entry );
+}
+
+void * CDECL wrap_ldap_next_reference( void *ld, void *entry )
+{
+    return ldap_next_reference( ld, entry );
+}
+
 int CDECL wrap_ldap_parse_result( void *ld, void *res, int *errcode, char **matcheddn, char **errmsg,
                                   char ***referrals, LDAPControlU ***serverctrls, int free )
 {
     return ldap_parse_result( ld, res, errcode, matcheddn, errmsg, referrals, (LDAPControl ***)serverctrls, free );
 }
 
+int CDECL wrap_ldap_result( void *ld, int msgid, int all, struct timevalU *timeout, void **result )
+{
+    return ldap_result( ld, msgid, all, (struct timeval *)timeout, (LDAPMessage **)result );
+}
+
 int CDECL wrap_ldap_sasl_bind( void *ld, const char *dn, const char *mech, struct bervalU *cred,
                                LDAPControlU **serverctrls, LDAPControlU **clientctrls, int *msgid )
 {
@@ -393,6 +450,23 @@ int CDECL wrap_ldap_sasl_interactive_bind_s( void *ld, const char *dn, const cha
                                          wrap_sasl_interact, defaults );
 }
 
+int CDECL wrap_ldap_search_ext( void *ld, const char *base, int scope, const char *filter, char **attrs, int attrsonly,
+                                LDAPControlU **serverctrls, LDAPControlU **clientctrls, struct timevalU *timeout,
+                                int sizelimit, ULONG *msg )
+{
+    return ldap_search_ext( ld, base, scope, filter, attrs, attrsonly, (LDAPControl **)serverctrls,
+                            (LDAPControl **)clientctrls, (struct timeval *)timeout, sizelimit, (int *)msg );
+}
+
+int CDECL wrap_ldap_search_ext_s( void *ld, const char *base, int scope, const char *filter, char **attrs,
+                                  int attrsonly, LDAPControlU **serverctrls, LDAPControlU **clientctrls,
+                                  struct timevalU *timeout, int sizelimit, void **result )
+{
+    return ldap_search_ext_s( ld, base, scope, filter, attrs, attrsonly, (LDAPControl **)serverctrls,
+                              (LDAPControl **)clientctrls, (struct timeval *)timeout, sizelimit,
+                              (LDAPMessage **)result );
+}
+
 int CDECL wrap_ldap_unbind_ext( void *ld, LDAPControlU **serverctrls, LDAPControlU **clientctrls )
 {
     return ldap_unbind_ext( ld, (LDAPControl **)serverctrls, (LDAPControl **)clientctrls );
@@ -422,20 +496,33 @@ static const struct ldap_funcs funcs =
     wrap_ber_skip_tag,
     wrap_ber_printf,
     wrap_ber_scanf,
+    wrap_ldap_abandon_ext,
     wrap_ldap_add_ext,
     wrap_ldap_add_ext_s,
     wrap_ldap_compare_ext,
     wrap_ldap_compare_ext_s,
     wrap_ldap_control_free,
+    wrap_ldap_count_entries,
+    wrap_ldap_count_references,
     wrap_ldap_create_sort_control,
     wrap_ldap_create_vlv_control,
     wrap_ldap_delete_ext,
     wrap_ldap_delete_ext_s,
+    wrap_ldap_first_attribute,
+    wrap_ldap_first_entry,
+    wrap_ldap_first_reference,
     wrap_ldap_memfree,
+    wrap_ldap_msgfree,
+    wrap_ldap_next_attribute,
+    wrap_ldap_next_entry,
+    wrap_ldap_next_reference,
     wrap_ldap_parse_result,
+    wrap_ldap_result,
     wrap_ldap_sasl_bind,
     wrap_ldap_sasl_bind_s,
     wrap_ldap_sasl_interactive_bind_s,
+    wrap_ldap_search_ext,
+    wrap_ldap_search_ext_s,
     wrap_ldap_unbind_ext,
     wrap_ldap_unbind_ext_s,
     wrap_ldap_value_free_len,
@@ -448,5 +535,4 @@ NTSTATUS CDECL __wine_init_unix_lib( HMODULE module, DWORD reason, const void *p
     *(const struct ldap_funcs **)ptr_out = &funcs;
     return STATUS_SUCCESS;
 }
-
 #endif /* HAVE_LDAP */
diff --git a/dlls/wldap32/libldap.h b/dlls/wldap32/libldap.h
index 5ebc5bacd547..f307eaf4327f 100644
--- a/dlls/wldap32/libldap.h
+++ b/dlls/wldap32/libldap.h
@@ -60,6 +60,12 @@ typedef struct
     void           *ldvlv_extradata;
 } LDAPVLVInfoU;
 
+typedef struct timevalU
+{
+    unsigned long tv_sec;
+    unsigned long tv_usec;
+} LDAP_TIMEVALU;
+
 #ifndef SASL_CB_LIST_END
 #define SASL_CB_LIST_END    0
 #define SASL_CB_USER        0x4001
@@ -90,6 +96,7 @@ extern unsigned int CDECL wrap_ber_skip_tag(void *, unsigned int *) DECLSPEC_HID
 extern int WINAPIV wrap_ber_printf(void *, char *, ...) DECLSPEC_HIDDEN;
 extern int WINAPIV wrap_ber_scanf(void *, char *, ...) DECLSPEC_HIDDEN;
 
+extern int CDECL wrap_ldap_abandon_ext(void *, int, LDAPControlU **, LDAPControlU **) DECLSPEC_HIDDEN;
 extern int CDECL wrap_ldap_add_ext(void *, const char *, LDAPModU **, LDAPControlU **, LDAPControlU **,
                                    ULONG *) DECLSPEC_HIDDEN;
 extern int CDECL wrap_ldap_add_ext_s(void *, const char *, LDAPModU **, LDAPControlU **,
@@ -99,19 +106,33 @@ extern int CDECL wrap_ldap_compare_ext(void *, const char *, const char *, struc
 extern int CDECL wrap_ldap_compare_ext_s(void *, const char *, const char *, struct bervalU *, LDAPControlU **,
                                          LDAPControlU **) DECLSPEC_HIDDEN;
 extern void CDECL wrap_ldap_control_free(LDAPControlU *) DECLSPEC_HIDDEN;
+extern int CDECL wrap_ldap_count_entries(void *, void *) DECLSPEC_HIDDEN;
+extern int CDECL wrap_ldap_count_references(void *, void *) DECLSPEC_HIDDEN;
 extern int CDECL wrap_ldap_create_sort_control(void *, LDAPSortKeyU **, int, LDAPControlU **) DECLSPEC_HIDDEN;
 extern int CDECL wrap_ldap_create_vlv_control(void *, LDAPVLVInfoU *, LDAPControlU **) DECLSPEC_HIDDEN;
 extern int CDECL wrap_ldap_delete_ext(void *, const char *, LDAPControlU **, LDAPControlU **, ULONG *) DECLSPEC_HIDDEN;
 extern int CDECL wrap_ldap_delete_ext_s(void *, const char *, LDAPControlU **, LDAPControlU **) DECLSPEC_HIDDEN;
+extern char * CDECL wrap_ldap_first_attribute(void *, void *, void **) DECLSPEC_HIDDEN;
+extern void * CDECL wrap_ldap_first_entry(void *, void *) DECLSPEC_HIDDEN;
+extern void * CDECL wrap_ldap_first_reference(void *, void *) DECLSPEC_HIDDEN;
 extern void CDECL wrap_ldap_memfree(void *) DECLSPEC_HIDDEN;
+extern int CDECL wrap_ldap_msgfree(void *) DECLSPEC_HIDDEN;
+extern char * CDECL wrap_ldap_next_attribute(void *, void *, void *) DECLSPEC_HIDDEN;
+extern void * CDECL wrap_ldap_next_entry(void *, void *) DECLSPEC_HIDDEN;
+extern void * CDECL wrap_ldap_next_reference(void *, void *) DECLSPEC_HIDDEN;
 extern int CDECL wrap_ldap_parse_result(void *, void *, int *, char **, char **, char ***, LDAPControlU ***,
                                         int) DECLSPEC_HIDDEN;
+extern int CDECL wrap_ldap_result(void *, int, int, struct timevalU *, void **) DECLSPEC_HIDDEN;
 extern int CDECL wrap_ldap_sasl_bind(void *, const char *, const char *, struct bervalU *, LDAPControlU **,
                                      LDAPControlU **, int *) DECLSPEC_HIDDEN;
 extern int CDECL wrap_ldap_sasl_bind_s(void *, const char *, const char *, struct bervalU *, LDAPControlU **,
                                        LDAPControlU **, struct bervalU **) DECLSPEC_HIDDEN;
 extern int CDECL wrap_ldap_sasl_interactive_bind_s(void *, const char *, const char *, LDAPControlU **,
                                                    LDAPControlU **, unsigned int, void *) DECLSPEC_HIDDEN;
+extern int CDECL wrap_ldap_search_ext(void *, const char *, int, const char *, char **, int, LDAPControlU **,
+                                      LDAPControlU **, struct timevalU *, int, ULONG *) DECLSPEC_HIDDEN;
+extern int CDECL wrap_ldap_search_ext_s(void *, const char *, int, const char *, char **, int, LDAPControlU **,
+                                        LDAPControlU **, struct timevalU *, int, void **) DECLSPEC_HIDDEN;
 extern int CDECL wrap_ldap_unbind_ext(void *, LDAPControlU **, LDAPControlU **) DECLSPEC_HIDDEN;
 extern int CDECL wrap_ldap_unbind_ext_s(void *, LDAPControlU **, LDAPControlU **) DECLSPEC_HIDDEN;
 extern void CDECL wrap_ldap_value_free_len(struct bervalU **) DECLSPEC_HIDDEN;
@@ -131,6 +152,7 @@ struct ldap_funcs
     int (WINAPIV *ber_printf)(void *, char *, ...);
     int (WINAPIV *ber_scanf)(void *, char *, ...);
 
+    int (CDECL *ldap_abandon_ext)(void *, int, LDAPControlU **, LDAPControlU **);
     int (CDECL *ldap_add_ext)(void *, const char *, LDAPModU **, LDAPControlU **, LDAPControlU **, ULONG *);
     int (CDECL *ldap_add_ext_s)(void *, const char *, LDAPModU **, LDAPControlU **, LDAPControlU **);
     int (CDECL *ldap_compare_ext)(void *, const char *, const char *, struct bervalU *, LDAPControlU **,
@@ -138,18 +160,32 @@ struct ldap_funcs
     int (CDECL *ldap_compare_ext_s)(void *, const char *, const char *, struct bervalU *, LDAPControlU **,
                                     LDAPControlU **);
     void (CDECL *ldap_control_free)(LDAPControlU *);
+    int (CDECL *ldap_count_entries)(void *, void *);
+    int (CDECL *ldap_count_references)(void *, void *);
     int (CDECL *ldap_create_sort_control)(void *, LDAPSortKeyU **, int, LDAPControlU **);
     int (CDECL *ldap_create_vlv_control)(void *, LDAPVLVInfoU *, LDAPControlU **);
     int (CDECL *ldap_delete_ext)(void *, const char *, LDAPControlU **, LDAPControlU **, ULONG *);
     int (CDECL *ldap_delete_ext_s)(void *, const char *, LDAPControlU **, LDAPControlU **);
+    char * (CDECL *ldap_first_attribute)(void *, void *, void **);
+    void * (CDECL *ldap_first_entry)(void *, void *);
+    void * (CDECL *ldap_first_reference)(void *, void *);
     void (CDECL *ldap_memfree)(void *);
+    int (CDECL *ldap_msgfree)(void *);
+    char * (CDECL *ldap_next_attribute)(void *, void *, void *);
+    void * (CDECL *ldap_next_entry)(void *, void *);
+    void * (CDECL *ldap_next_reference)(void *, void *);
     int (CDECL *ldap_parse_result)(void *, void *, int *, char **, char **, char ***, LDAPControlU ***, int);
+    int (CDECL *ldap_result)(void *, int, int, struct timevalU *, void **);
     int (CDECL *ldap_sasl_bind)(void *, const char *, const char *, struct bervalU *, LDAPControlU **, LDAPControlU **,
                                 int *);
     int (CDECL *ldap_sasl_bind_s)(void *, const char *, const char *, struct bervalU *, LDAPControlU **,
                                   LDAPControlU **, struct bervalU **);
     int (CDECL *ldap_sasl_interactive_bind_s)(void *, const char *, const char *, LDAPControlU **, LDAPControlU **,
                                               unsigned int, void *);
+    int (CDECL *ldap_search_ext)(void *, const char *, int, const char *, char **, int, LDAPControlU **,
+                                 LDAPControlU **, struct timevalU *, int, ULONG *);
+    int (CDECL *ldap_search_ext_s)(void *, const char *, int, const char *, char **, int, LDAPControlU **,
+                                   LDAPControlU **, struct timevalU *, int, void **);
     int (CDECL *ldap_unbind_ext)(void *, LDAPControlU **, LDAPControlU **);
     int (CDECL *ldap_unbind_ext_s)(void *, LDAPControlU **, LDAPControlU **);
     void (CDECL *ldap_value_free_len)(struct bervalU **);
diff --git a/dlls/wldap32/misc.c b/dlls/wldap32/misc.c
index dd1a1ef3f12c..234b84d42f9e 100644
--- a/dlls/wldap32/misc.c
+++ b/dlls/wldap32/misc.c
@@ -18,22 +18,14 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#include "config.h"
-#include "wine/port.h"
-
 #include <stdarg.h>
-#include <stdio.h>
-#ifdef HAVE_LDAP_H
-#include <ldap.h>
-#endif
-
 #include "windef.h"
 #include "winbase.h"
 #include "winnls.h"
 
-#include "winldap_private.h"
-#include "wldap32.h"
 #include "wine/debug.h"
+#include "wine/heap.h"
+#include "winldap_private.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(wldap32);
 
@@ -52,16 +44,10 @@ WINE_DEFAULT_DEBUG_CHANNEL(wldap32);
  */
 ULONG CDECL WLDAP32_ldap_abandon( WLDAP32_LDAP *ld, ULONG msgid )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
-
     TRACE( "(%p, 0x%08x)\n", ld, msgid );
 
     if (!ld) return ~0u;
-    ret = map_error( ldap_abandon_ext( ld->ld, msgid, NULL, NULL ));
-
-#endif
-    return ret;
+    return map_error( ldap_funcs->ldap_abandon_ext( ld->ld, msgid, NULL, NULL ) );
 }
 
 /***********************************************************************
@@ -69,7 +55,7 @@ ULONG CDECL WLDAP32_ldap_abandon( WLDAP32_LDAP *ld, ULONG msgid )
  *
  * See ldap_check_filterW.
  */
-ULONG CDECL ldap_check_filterA( WLDAP32_LDAP *ld, PCHAR filter )
+ULONG CDECL ldap_check_filterA( WLDAP32_LDAP *ld, char *filter )
 {
     ULONG ret;
     WCHAR *filterW = NULL;
@@ -77,11 +63,7 @@ ULONG CDECL ldap_check_filterA( WLDAP32_LDAP *ld, PCHAR filter )
     TRACE( "(%p, %s)\n", ld, debugstr_a(filter) );
 
     if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
-
-    if (filter) {
-        filterW = strAtoW( filter );
-        if (!filterW) return WLDAP32_LDAP_NO_MEMORY;
-    }
+    if (filter && !(filterW = strAtoW( filter ))) return WLDAP32_LDAP_NO_MEMORY;
 
     ret = ldap_check_filterW( ld, filterW );
 
@@ -102,7 +84,7 @@ ULONG CDECL ldap_check_filterA( WLDAP32_LDAP *ld, PCHAR filter )
  *  Success: LDAP_SUCCESS
  *  Failure: An LDAP error code.
  */
-ULONG CDECL ldap_check_filterW( WLDAP32_LDAP *ld, PWCHAR filter )
+ULONG CDECL ldap_check_filterW( WLDAP32_LDAP *ld, WCHAR *filter )
 {
     TRACE( "(%p, %s)\n", ld, debugstr_w(filter) );
 
@@ -155,16 +137,10 @@ WLDAP32_LDAP * CDECL ldap_conn_from_msg( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *
  */
 ULONG CDECL WLDAP32_ldap_count_entries( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *res )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
-
     TRACE( "(%p, %p)\n", ld, res );
 
     if (!ld) return ~0u;
-    ret = ldap_count_entries( ld->ld, res );
-
-#endif
-    return ret;
+    return ldap_funcs->ldap_count_entries( ld->ld, res->Request );
 }
 
 /***********************************************************************
@@ -182,16 +158,10 @@ ULONG CDECL WLDAP32_ldap_count_entries( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *r
  */
 ULONG CDECL WLDAP32_ldap_count_references( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *res )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP_COUNT_REFERENCES
-
     TRACE( "(%p, %p)\n", ld, res );
 
     if (!ld) return 0;
-    ret = ldap_count_references( ld->ld, res );
-
-#endif
-    return ret;
+    return ldap_funcs->ldap_count_references( ld->ld, res->Request );
 }
 
 static ULONG get_escape_size( PCHAR src, ULONG srclen )
@@ -213,7 +183,7 @@ static ULONG get_escape_size( PCHAR src, ULONG srclen )
     return size + 1;
 }
 
-static void escape_filter_element( PCHAR src, ULONG srclen, PCHAR dst )
+static void escape_filter_element( char *src, ULONG srclen, char *dst )
 {
     ULONG i;
     static const char fmt[] = "\\%02X";
@@ -236,22 +206,17 @@ static void escape_filter_element( PCHAR src, ULONG srclen, PCHAR dst )
  *
  * See ldap_escape_filter_elementW.
  */
-ULONG CDECL ldap_escape_filter_elementA( PCHAR src, ULONG srclen, PCHAR dst, ULONG dstlen )
+ULONG CDECL ldap_escape_filter_elementA( char *src, ULONG srclen, char *dst, ULONG dstlen )
 {
-    ULONG len;
+    ULONG len = get_escape_size( src, srclen );
 
     TRACE( "(%p, 0x%08x, %p, 0x%08x)\n", src, srclen, dst, dstlen );
 
-    len = get_escape_size( src, srclen );
     if (!dst) return len;
+    if (!src || dstlen < len) return WLDAP32_LDAP_PARAM_ERROR;
 
-    if (!src || dstlen < len)
-        return WLDAP32_LDAP_PARAM_ERROR;
-    else
-    {
-        escape_filter_element( src, srclen, dst );
-        return WLDAP32_LDAP_SUCCESS;
-    }
+    escape_filter_element( src, srclen, dst );
+    return WLDAP32_LDAP_SUCCESS;
 }
 
 /***********************************************************************
@@ -269,13 +234,12 @@ ULONG CDECL ldap_escape_filter_elementA( PCHAR src, ULONG srclen, PCHAR dst, ULO
  *  Success: LDAP_SUCCESS
  *  Failure: An LDAP error code.
  */
-ULONG CDECL ldap_escape_filter_elementW( PCHAR src, ULONG srclen, PWCHAR dst, ULONG dstlen )
+ULONG CDECL ldap_escape_filter_elementW( char *src, ULONG srclen, WCHAR *dst, ULONG dstlen )
 {
-    ULONG len;
+    ULONG len = get_escape_size( src, srclen );
 
     TRACE( "(%p, 0x%08x, %p, 0x%08x)\n", src, srclen, dst, dstlen );
 
-    len = get_escape_size( src, srclen );
     if (!dst) return len;
 
     /* no matter what you throw at it, this is what native returns */
@@ -287,29 +251,29 @@ ULONG CDECL ldap_escape_filter_elementW( PCHAR src, ULONG srclen, PWCHAR dst, UL
  *
  * See ldap_first_attributeW.
  */
-PCHAR CDECL ldap_first_attributeA( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *entry,
-    WLDAP32_BerElement** ptr )
+char * CDECL ldap_first_attributeA( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *entry, WLDAP32_BerElement **ber )
 {
-    PCHAR ret = NULL;
-#ifdef HAVE_LDAP
+    char *ret = NULL;
     WCHAR *retW;
 
-    TRACE( "(%p, %p, %p)\n", ld, entry, ptr );
+    TRACE( "(%p, %p, %p)\n", ld, entry, ber );
 
     if (!ld || !entry) return NULL;
-    retW = ldap_first_attributeW( ld, entry, ptr );
 
-    ret = strWtoA( retW );
-    ldap_memfreeW( retW );
+    retW = ldap_first_attributeW( ld, entry->Request, ber );
+    if (retW)
+    {
+        ret = strWtoA( retW );
+        ldap_memfreeW( retW );
+    }
 
-#endif
     return ret;
 }
 
 /***********************************************************************
  *      ldap_first_attributeW     (WLDAP32.@)
  *
- * Get the first attribute for a given entry. 
+ * Get the first attribute for a given entry.
  *
  * PARAMS
  *  ld    [I] Pointer to an LDAP context.
@@ -323,29 +287,26 @@ PCHAR CDECL ldap_first_attributeA( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *entry,
  * NOTES
  *  Use ldap_memfree to free the returned string.
  */
-PWCHAR CDECL ldap_first_attributeW( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *entry,
-    WLDAP32_BerElement** ptr )
+WCHAR * CDECL ldap_first_attributeW( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *entry, WLDAP32_BerElement **ptr )
 {
-    PWCHAR ret = NULL;
-#ifdef HAVE_LDAP
-    BerElement *berU;
+    WCHAR *ret = NULL;
+    WLDAP32_BerElement *ber;
     char *retU;
+    void *berU;
 
     TRACE( "(%p, %p, %p)\n", ld, entry, ptr );
 
     if (!ld || !entry) return NULL;
 
-    retU = ldap_first_attribute( ld->ld, entry, &berU );
-    if (retU)
+    retU = ldap_funcs->ldap_first_attribute( ld->ld, entry->Request, &berU );
+    if (retU && (ber = heap_alloc( sizeof(*ber) )))
     {
-        WLDAP32_BerElement *ber = heap_alloc( sizeof(*ber) );
         ber->opaque = (char *)berU;
         *ptr = ber;
         ret = strUtoW( retU );
-        ldap_memfree( retU );
     }
 
-#endif
+    ldap_funcs->ldap_memfree( retU );
     return ret;
 }
 
@@ -363,20 +324,24 @@ PWCHAR CDECL ldap_first_attributeW( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *entry
  *  Failure: NULL
  *
  * NOTES
- *  The returned entry will be freed when the message is freed. 
+ *  The returned entry will be freed when the message is freed.
  */
 WLDAP32_LDAPMessage * CDECL WLDAP32_ldap_first_entry( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *res )
 {
-#ifdef HAVE_LDAP
+    void *msgU;
 
     TRACE( "(%p, %p)\n", ld, res );
 
     if (!ld || !res) return NULL;
-    return ldap_first_entry( ld->ld, res );
 
-#else
+    msgU = ldap_funcs->ldap_first_entry( ld->ld, res->Request );
+    if (msgU)
+    {
+        assert( msgU == res->Request );
+        return res;
+    }
+
     return NULL;
-#endif
 }
 
 /***********************************************************************
@@ -394,16 +359,20 @@ WLDAP32_LDAPMessage * CDECL WLDAP32_ldap_first_entry( WLDAP32_LDAP *ld, WLDAP32_
  */
 WLDAP32_LDAPMessage * CDECL WLDAP32_ldap_first_reference( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *res )
 {
-#ifdef HAVE_LDAP_FIRST_REFERENCE
+    void *msgU;
 
     TRACE( "(%p, %p)\n", ld, res );
 
     if (!ld) return NULL;
-    return ldap_first_reference( ld->ld, res );
 
-#else
+    msgU = ldap_funcs->ldap_first_reference( ld->ld, res->Request );
+    if (msgU)
+    {
+        assert( msgU == res->Request );
+        return res;
+    }
+
     return NULL;
-#endif
 }
 
 /***********************************************************************
@@ -411,7 +380,7 @@ WLDAP32_LDAPMessage * CDECL WLDAP32_ldap_first_reference( WLDAP32_LDAP *ld, WLDA
  *
  * See ldap_memfreeW.
  */
-void CDECL ldap_memfreeA( PCHAR block )
+void CDECL ldap_memfreeA( char *block )
 {
     TRACE( "(%p)\n", block );
     strfreeA( block );
@@ -425,7 +394,7 @@ void CDECL ldap_memfreeA( PCHAR block )
  * PARAMS
  *  block [I] Pointer to memory block to be freed.
  */
-void CDECL ldap_memfreeW( PWCHAR block )
+void CDECL ldap_memfreeW( WCHAR *block )
 {
     TRACE( "(%p)\n", block );
     strfreeW( block );
@@ -441,14 +410,21 @@ void CDECL ldap_memfreeW( PWCHAR block )
  */
 ULONG CDECL WLDAP32_ldap_msgfree( WLDAP32_LDAPMessage *res )
 {
-    ULONG ret = WLDAP32_LDAP_SUCCESS;
-#ifdef HAVE_LDAP
+    WLDAP32_LDAPMessage *entry, *list = res;
 
     TRACE( "(%p)\n", res );
-    ldap_msgfree( res );
 
-#endif
-    return ret;
+    if (!res) return WLDAP32_LDAP_SUCCESS;
+
+    ldap_funcs->ldap_msgfree( res->Request );
+    while (list)
+    {
+        entry = list;
+        list = entry->lm_next;
+        heap_free( entry );
+    }
+
+    return WLDAP32_LDAP_SUCCESS;
 }
 
 /***********************************************************************
@@ -456,22 +432,22 @@ ULONG CDECL WLDAP32_ldap_msgfree( WLDAP32_LDAPMessage *res )
  *
  * See ldap_next_attributeW.
  */
-PCHAR CDECL ldap_next_attributeA( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *entry,
-    WLDAP32_BerElement *ptr )
+char * CDECL ldap_next_attributeA( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *entry, WLDAP32_BerElement *ptr )
 {
-    PCHAR ret = NULL;
-#ifdef HAVE_LDAP
+    char *ret = NULL;
     WCHAR *retW;
 
     TRACE( "(%p, %p, %p)\n", ld, entry, ptr );
 
     if (!ld || !entry || !ptr) return NULL;
-    retW = ldap_next_attributeW( ld, entry, ptr );
 
-    ret = strWtoA( retW );
-    ldap_memfreeW( retW );
+    retW = ldap_next_attributeW( ld, entry->Request, ptr );
+    if (retW)
+    {
+        ret = strWtoA( retW );
+        ldap_memfreeW( retW );
+    }
 
-#endif
     return ret;
 }
 
@@ -493,25 +469,22 @@ PCHAR CDECL ldap_next_attributeA( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *entry,
  *  Free the returned string after each iteration with ldap_memfree.
  *  When done iterating and when ptr != NULL, call ber_free( ptr, 0 ).
  */
-PWCHAR CDECL ldap_next_attributeW( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *entry,
-    WLDAP32_BerElement *ber )
+WCHAR * CDECL ldap_next_attributeW( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *entry, WLDAP32_BerElement *ptr )
 {
-    PWCHAR ret = NULL;
-#ifdef HAVE_LDAP
+    WCHAR *ret = NULL;
     char *retU;
 
-    TRACE( "(%p, %p, %p)\n", ld, entry, ber );
+    TRACE( "(%p, %p, %p)\n", ld, entry, ptr );
 
-    if (!ld || !entry) return NULL;
+    if (!ld || !entry || !ptr) return NULL;
 
-    retU = ldap_next_attribute( ld->ld, entry, (BerElement *)ber->opaque );
+    retU = ldap_funcs->ldap_next_attribute( ld->ld, entry->Request, ptr->opaque );
     if (retU)
     {
         ret = strUtoW( retU );
-        ldap_memfree( retU );
+        ldap_funcs->ldap_memfree( retU );
     }
 
-#endif
     return ret;
 }
 
@@ -533,16 +506,23 @@ PWCHAR CDECL ldap_next_attributeW( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *entry,
  */
 WLDAP32_LDAPMessage * CDECL WLDAP32_ldap_next_entry( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *entry )
 {
-#ifdef HAVE_LDAP
+    WLDAP32_LDAPMessage *msg = NULL;
+    void *msgU;
 
     TRACE( "(%p, %p)\n", ld, entry );
 
     if (!ld || !entry) return NULL;
-    return ldap_next_entry( ld->ld, entry );
 
-#else
-    return NULL;
-#endif
+    if (entry->lm_next) return entry->lm_next;
+
+    msgU = ldap_funcs->ldap_next_entry( ld->ld, entry->Request );
+    if (msgU && (msg = heap_alloc_zero( sizeof(*msg) )))
+    {
+        msg->Request = msgU;
+        entry->lm_next = msg;
+    }
+
+    return msg;
 }
 
 /***********************************************************************
@@ -563,16 +543,23 @@ WLDAP32_LDAPMessage * CDECL WLDAP32_ldap_next_entry( WLDAP32_LDAP *ld, WLDAP32_L
  */
 WLDAP32_LDAPMessage * CDECL WLDAP32_ldap_next_reference( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *entry )
 {
-#ifdef HAVE_LDAP_NEXT_REFERENCE
+    WLDAP32_LDAPMessage *msg = NULL;
+    void *msgU;
 
     TRACE( "(%p, %p)\n", ld, entry );
 
     if (!ld || !entry) return NULL;
-    return ldap_next_reference( ld->ld, entry );
 
-#else
-    return NULL;
-#endif
+    if (entry->lm_next) return entry->lm_next;
+
+    msgU = ldap_funcs->ldap_next_reference( ld->ld, entry->Request );
+    if (msgU && (msg = heap_alloc_zero( sizeof(*msg) )))
+    {
+        msg->Request = msgU;
+        entry->lm_next = msg;
+    }
+
+    return msg;
 }
 
 /***********************************************************************
@@ -611,18 +598,31 @@ WLDAP32_LDAPMessage * CDECL WLDAP32_ldap_next_reference( WLDAP32_LDAP *ld, WLDAP
  *  to immediately return any available results. Free returned results
  *  with ldap_msgfree.
  */
-ULONG CDECL WLDAP32_ldap_result( WLDAP32_LDAP *ld, ULONG msgid, ULONG all,
-    struct l_timeval *timeout, WLDAP32_LDAPMessage **res )
+ULONG CDECL WLDAP32_ldap_result( WLDAP32_LDAP *ld, ULONG msgid, ULONG all, struct l_timeval *timeout,
+    WLDAP32_LDAPMessage **res )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    WLDAP32_LDAPMessage *msg;
+    struct timevalU timeval;
+    void *msgU = NULL;
+    ULONG ret;
 
     TRACE( "(%p, 0x%08x, 0x%08x, %p, %p)\n", ld, msgid, all, timeout, res );
 
     if (!ld || !res || msgid == ~0u) return ~0u;
-    ret = ldap_result( ld->ld, msgid, all, (struct timeval *)timeout, res );
 
-#endif
+    if (timeout)
+    {
+        timeval.tv_sec = timeout->tv_sec;
+        timeval.tv_usec = timeout->tv_usec;
+    }
+
+    ret = ldap_funcs->ldap_result( ld->ld, msgid, all, timeout ? &timeval : NULL, &msgU );
+    if (msgU && (msg = heap_alloc_zero( sizeof(*msg) )))
+    {
+        msg->Request = msgU;
+        *res = msg;
+    }
+
     return ret;
 }
 
@@ -635,7 +635,7 @@ ULONG CDECL WLDAP32_ldap_result( WLDAP32_LDAP *ld, ULONG msgid, ULONG all,
  *  src    [I] Wide character string to convert.
  *  srclen [I] Size of string to convert, in characters.
  *  dst    [O] Pointer to a buffer that receives the converted string.
- *  dstlen [I] Size of the destination buffer in characters. 
+ *  dstlen [I] Size of the destination buffer in characters.
  *
  * RETURNS
  *  The number of characters written into the destination buffer.
@@ -643,7 +643,7 @@ ULONG CDECL WLDAP32_ldap_result( WLDAP32_LDAP *ld, ULONG msgid, ULONG all,
  * NOTES
  *  Set dstlen to zero to ask for the required buffer size.
  */
-int CDECL LdapUnicodeToUTF8( LPCWSTR src, int srclen, LPSTR dst, int dstlen )
+int CDECL LdapUnicodeToUTF8( const WCHAR *src, int srclen, char *dst, int dstlen )
 {
     return WideCharToMultiByte( CP_UTF8, 0, src, srclen, dst, dstlen, NULL, NULL );
 }
@@ -657,7 +657,7 @@ int CDECL LdapUnicodeToUTF8( LPCWSTR src, int srclen, LPSTR dst, int dstlen )
  *  src    [I] UTF8 string to convert.
  *  srclen [I] Size of string to convert, in characters.
  *  dst    [O] Pointer to a buffer that receives the converted string.
- *  dstlen [I] Size of the destination buffer in characters. 
+ *  dstlen [I] Size of the destination buffer in characters.
  *
  * RETURNS
  *  The number of characters written into the destination buffer.
@@ -665,7 +665,7 @@ int CDECL LdapUnicodeToUTF8( LPCWSTR src, int srclen, LPSTR dst, int dstlen )
  * NOTES
  *  Set dstlen to zero to ask for the required buffer size.
  */
-int CDECL LdapUTF8ToUnicode( LPCSTR src, int srclen, LPWSTR dst, int dstlen )
+int CDECL LdapUTF8ToUnicode( const char *src, int srclen, WCHAR *dst, int dstlen )
 {
     return MultiByteToWideChar( CP_UTF8, 0, src, srclen, dst, dstlen );
 }
diff --git a/dlls/wldap32/parse.c b/dlls/wldap32/parse.c
index 6bde8542bec0..bbaa7b1f842d 100644
--- a/dlls/wldap32/parse.c
+++ b/dlls/wldap32/parse.c
@@ -99,7 +99,7 @@ ULONG CDECL ldap_parse_extended_resultW( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *
     if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
     if (!result) return WLDAP32_LDAP_NO_RESULTS_RETURNED;
 
-    ret = map_error( ldap_parse_extended_result( ld->ld, result, &oidU, (struct berval **)data, free ) );
+    ret = map_error( ldap_parse_extended_result( ld->ld, result->Request, &oidU, (struct berval **)data, free ) );
 
     if (oid) {
         *oid = strUtoW( oidU );
@@ -153,18 +153,18 @@ ULONG CDECL ldap_parse_referenceA( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *messag
  * NOTES
  *  Free the referrals with ldap_value_free.
  */
-ULONG CDECL ldap_parse_referenceW( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *message,
+ULONG CDECL ldap_parse_referenceW( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *result,
     PWCHAR **referrals )
 {
     ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
 #ifdef HAVE_LDAP_PARSE_REFERENCE
     char **referralsU = NULL;
 
-    TRACE( "(%p, %p, %p)\n", ld, message, referrals );
+    TRACE( "(%p, %p, %p)\n", ld, result, referrals );
 
     if (!ld) return ~0u;
 
-    ret = map_error( ldap_parse_reference( ld->ld, message, &referralsU, NULL, 0 ));
+    ret = map_error( ldap_parse_reference( ld->ld, result->Request, &referralsU, NULL, 0 ));
 
     *referrals = strarrayUtoW( referralsU );
     ldap_memfree( referralsU );
@@ -249,7 +249,7 @@ ULONG CDECL ldap_parse_resultW( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *result,
 
     if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
 
-    ret = map_error( ldap_parse_result( ld->ld, result, (int *)retcode, &matchedU, &errorU,
+    ret = map_error( ldap_parse_result( ld->ld, result->Request, (int *)retcode, &matchedU, &errorU,
                                         &referralsU, &serverctrlsU, free ));
 
     if (matched) *matched = strUtoW( matchedU );
diff --git a/dlls/wldap32/search.c b/dlls/wldap32/search.c
index 88ecb541c923..b4bf204f8176 100644
--- a/dlls/wldap32/search.c
+++ b/dlls/wldap32/search.c
@@ -18,57 +18,34 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#include "config.h"
-#include "wine/port.h"
-
 #include <stdarg.h>
-#ifdef HAVE_LDAP_H
-#include <ldap.h>
-#endif
-
 #include "windef.h"
 #include "winbase.h"
 #include "winnls.h"
 
-#include "winldap_private.h"
-#include "wldap32.h"
 #include "wine/debug.h"
+#include "wine/heap.h"
+#include "winldap_private.h"
 
-#ifdef HAVE_LDAP
 WINE_DEFAULT_DEBUG_CHANNEL(wldap32);
-#endif
 
 /***********************************************************************
  *      ldap_searchA     (WLDAP32.@)
  *
  * See ldap_searchW.
  */
-ULONG CDECL ldap_searchA( WLDAP32_LDAP *ld, PCHAR base, ULONG scope, PCHAR filter,
-    PCHAR attrs[], ULONG attrsonly )
+ULONG CDECL ldap_searchA( WLDAP32_LDAP *ld, char *base, ULONG scope, char *filter, char **attrs, ULONG attrsonly )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
     WCHAR *baseW = NULL, *filterW = NULL, **attrsW = NULL;
 
-    ret = WLDAP32_LDAP_NO_MEMORY;
-
-    TRACE( "(%p, %s, 0x%08x, %s, %p, 0x%08x)\n", ld, debugstr_a(base),
-           scope, debugstr_a(filter), attrs, attrsonly );
+    TRACE( "(%p, %s, 0x%08x, %s, %p, 0x%08x)\n", ld, debugstr_a(base), scope, debugstr_a(filter), attrs, attrsonly );
 
     if (!ld) return ~0u;
 
-    if (base) {
-        baseW = strAtoW( base );
-        if (!baseW) goto exit;
-    }
-    if (filter) {
-        filterW = strAtoW( filter );
-        if (!filterW) goto exit;
-    }
-    if (attrs) {
-        attrsW = strarrayAtoW( attrs );
-        if (!attrsW) goto exit;
-    }
+    if (base && !(baseW = strAtoW( base ))) goto exit;
+    if (filter && !(filterW = strAtoW( filter ))) goto exit;
+    if (attrs && !(attrsW = strarrayAtoW( attrs ))) goto exit;
 
     ret = ldap_searchW( ld, baseW, scope, filterW, attrsW, attrsonly );
 
@@ -76,8 +53,6 @@ ULONG CDECL ldap_searchA( WLDAP32_LDAP *ld, PCHAR base, ULONG scope, PCHAR filte
     strfreeW( baseW );
     strfreeW( filterW );
     strarrayfreeW( attrsW );
-
-#endif
     return ret;
 }
 
@@ -104,49 +79,14 @@ ULONG CDECL ldap_searchA( WLDAP32_LDAP *ld, PCHAR base, ULONG scope, PCHAR filte
  *  the operation. Cancel the operation by calling ldap_abandon
  *  with the message ID.
  */
-ULONG CDECL ldap_searchW( WLDAP32_LDAP *ld, PWCHAR base, ULONG scope, PWCHAR filter,
-    PWCHAR attrs[], ULONG attrsonly )
+ULONG CDECL ldap_searchW( WLDAP32_LDAP *ld, WCHAR *base, ULONG scope, WCHAR *filter, WCHAR **attrs, ULONG attrsonly )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
-    char *baseU = NULL, *filterU = NULL, **attrsU = NULL;
-    int msg;
-
-    ret = WLDAP32_LDAP_NO_MEMORY;
-
-    TRACE( "(%p, %s, 0x%08x, %s, %p, 0x%08x)\n", ld, debugstr_w(base),
-           scope, debugstr_w(filter), attrs, attrsonly );
-
-    if (!ld) return ~0u;
+    ULONG ret, msg;
+    TRACE( "(%p, %s, 0x%08x, %s, %p, 0x%08x)\n", ld, debugstr_w(base), scope, debugstr_w(filter), attrs, attrsonly );
 
-    if (base) {
-        baseU = strWtoU( base );
-        if (!baseU) goto exit;
-    }
-    if (filter) {
-        filterU = strWtoU( filter );
-        if (!filterU) goto exit;
-    }
-    if (attrs) {
-        attrsU = strarrayWtoU( attrs );
-        if (!attrsU) goto exit;
-    }
-
-    ret = ldap_search_ext( ld->ld, baseU, scope, filterU, attrsU, attrsonly,
-                           NULL, NULL, NULL, 0, &msg );
-
-    if (ret == LDAP_SUCCESS)
-        ret = msg;
-    else
-        ret = ~0u;
-
-exit:
-    strfreeU( baseU );
-    strfreeU( filterU );
-    strarrayfreeU( attrsU );
-
-#endif
-    return ret;
+    ret = ldap_search_extW( ld, base, scope, filter, attrs, attrsonly, NULL, NULL, 0, 0, &msg );
+    if (ret == WLDAP32_LDAP_SUCCESS) return msg;
+    return ~0u;
 }
 
 /***********************************************************************
@@ -154,47 +94,26 @@ ULONG CDECL ldap_searchW( WLDAP32_LDAP *ld, PWCHAR base, ULONG scope, PWCHAR fil
  *
  * See ldap_search_extW.
  */
-ULONG CDECL ldap_search_extA( WLDAP32_LDAP *ld, PCHAR base, ULONG scope,
-    PCHAR filter, PCHAR attrs[], ULONG attrsonly, PLDAPControlA *serverctrls,
-    PLDAPControlA *clientctrls, ULONG timelimit, ULONG sizelimit, ULONG *message )
+ULONG CDECL ldap_search_extA( WLDAP32_LDAP *ld, char *base, ULONG scope, char *filter, char **attrs, ULONG attrsonly,
+    LDAPControlA **serverctrls, LDAPControlA **clientctrls, ULONG timelimit, ULONG sizelimit, ULONG *message )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
     WCHAR *baseW = NULL, *filterW = NULL, **attrsW = NULL;
     LDAPControlW **serverctrlsW = NULL, **clientctrlsW = NULL;
 
-    ret = WLDAP32_LDAP_NO_MEMORY;
-
-    TRACE( "(%p, %s, 0x%08x, %s, %p, 0x%08x, %p, %p, 0x%08x, 0x%08x, %p)\n",
-           ld, debugstr_a(base), scope, debugstr_a(filter), attrs, attrsonly,
-           serverctrls, clientctrls, timelimit, sizelimit, message );
+    TRACE( "(%p, %s, 0x%08x, %s, %p, 0x%08x, %p, %p, 0x%08x, 0x%08x, %p)\n", ld, debugstr_a(base), scope,
+           debugstr_a(filter), attrs, attrsonly, serverctrls, clientctrls, timelimit, sizelimit, message );
 
     if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
 
-    if (base) {
-        baseW = strAtoW( base );
-        if (!baseW) goto exit;
-    }
-    if (filter)
-    {
-        filterW = strAtoW( filter );
-        if (!filterW) goto exit;
-    }
-    if (attrs) {
-        attrsW = strarrayAtoW( attrs );
-        if (!attrsW) goto exit;
-    }
-    if (serverctrls) {
-        serverctrlsW = controlarrayAtoW( serverctrls );
-        if (!serverctrlsW) goto exit;
-    }
-    if (clientctrls) {
-        clientctrlsW = controlarrayAtoW( clientctrls );
-        if (!clientctrlsW) goto exit;
-    }
+    if (base && !(baseW = strAtoW( base ))) goto exit;
+    if (filter && !(filterW = strAtoW( filter ))) goto exit;
+    if (attrs && !(attrsW = strarrayAtoW( attrs ))) goto exit;
+    if (serverctrls && !(serverctrlsW = controlarrayAtoW( serverctrls ))) goto exit;
+    if (clientctrls && !(clientctrlsW = controlarrayAtoW( clientctrls ))) goto exit;
 
-    ret = ldap_search_extW( ld, baseW, scope, filterW, attrsW, attrsonly,
-                            serverctrlsW, clientctrlsW, timelimit, sizelimit, message );
+    ret = ldap_search_extW( ld, baseW, scope, filterW, attrsW, attrsonly, serverctrlsW, clientctrlsW, timelimit,
+                            sizelimit, message );
 
 exit:
     strfreeW( baseW );
@@ -202,8 +121,6 @@ ULONG CDECL ldap_search_extA( WLDAP32_LDAP *ld, PCHAR base, ULONG scope,
     strarrayfreeW( attrsW );
     controlarrayfreeW( serverctrlsW );
     controlarrayfreeW( clientctrlsW );
-
-#endif
     return ret;
 }
 
@@ -235,63 +152,38 @@ ULONG CDECL ldap_search_extA( WLDAP32_LDAP *ld, PCHAR base, ULONG scope,
  *  the operation. Cancel the operation by calling ldap_abandon
  *  with the message ID.
  */
-ULONG CDECL ldap_search_extW( WLDAP32_LDAP *ld, PWCHAR base, ULONG scope,
-    PWCHAR filter, PWCHAR attrs[], ULONG attrsonly, PLDAPControlW *serverctrls,
-    PLDAPControlW *clientctrls, ULONG timelimit, ULONG sizelimit, ULONG *message )
+ULONG CDECL ldap_search_extW( WLDAP32_LDAP *ld, WCHAR *base, ULONG scope, WCHAR *filter, WCHAR **attrs,
+    ULONG attrsonly, LDAPControlW **serverctrls, LDAPControlW **clientctrls, ULONG timelimit, ULONG sizelimit,
+    ULONG *message )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
     char *baseU = NULL, *filterU = NULL, **attrsU = NULL;
-    LDAPControl **serverctrlsU = NULL, **clientctrlsU = NULL;
-    struct timeval tv, *tvp = NULL;
+    LDAPControlU **serverctrlsU = NULL, **clientctrlsU = NULL;
+    struct timevalU timevalU;
 
-    ret = WLDAP32_LDAP_NO_MEMORY;
-
-    TRACE( "(%p, %s, 0x%08x, %s, %p, 0x%08x, %p, %p, 0x%08x, 0x%08x, %p)\n",
-           ld, debugstr_w(base), scope, debugstr_w(filter), attrs, attrsonly,
-           serverctrls, clientctrls, timelimit, sizelimit, message );
+    TRACE( "(%p, %s, 0x%08x, %s, %p, 0x%08x, %p, %p, 0x%08x, 0x%08x, %p)\n", ld, debugstr_w(base), scope,
+           debugstr_w(filter), attrs, attrsonly, serverctrls, clientctrls, timelimit, sizelimit, message );
 
     if (!ld) return ~0u;
 
-    if (base) {
-        baseU = strWtoU( base );
-        if (!baseU) goto exit;
-    }
-    if (filter) {
-        filterU = strWtoU( filter );
-        if (!filterU) goto exit;
-    }
-    if (attrs) {
-        attrsU = strarrayWtoU( attrs );
-        if (!attrsU) goto exit;
-    }
-    if (serverctrls) {
-        serverctrlsU = controlarrayWtoU( serverctrls );
-        if (!serverctrlsU) goto exit;
-    }
-    if (clientctrls) {
-        clientctrlsU = controlarrayWtoU( clientctrls );
-        if (!clientctrlsU) goto exit;
-    }
-
-    if (timelimit)
-    {
-        tv.tv_sec = timelimit;
-        tv.tv_usec = 0;
-        tvp = &tv;
-    }
+    if (base && !(baseU = strWtoU( base ))) goto exit;
+    if (filter && !(filterU = strWtoU( filter ))) goto exit;
+    if (attrs && !(attrsU = strarrayWtoU( attrs ))) goto exit;
+    if (serverctrls && !(serverctrlsU = controlarrayWtoU( serverctrls ))) goto exit;
+    if (clientctrls && !(clientctrlsU = controlarrayWtoU( clientctrls ))) goto exit;
 
-    ret = map_error( ldap_search_ext( ld->ld, baseU, scope, filterU, attrsU, attrsonly,
-                                      serverctrlsU, clientctrlsU, tvp, sizelimit, (int *)message ));
+    timevalU.tv_sec = timelimit;
+    timevalU.tv_usec = 0;
 
+    ret = map_error( ldap_funcs->ldap_search_ext( ld->ld, baseU, scope, filterU, attrsU, attrsonly,
+                                                  serverctrlsU, clientctrlsU, timelimit ? &timevalU : NULL, sizelimit,
+                                                  message ) );
 exit:
     strfreeU( baseU );
     strfreeU( filterU );
     strarrayfreeU( attrsU );
     controlarrayfreeU( serverctrlsU );
     controlarrayfreeU( clientctrlsU );
-
-#endif
     return ret;
 }
 
@@ -300,46 +192,27 @@ ULONG CDECL ldap_search_extW( WLDAP32_LDAP *ld, PWCHAR base, ULONG scope,
  *
  * See ldap_search_ext_sW.
  */
-ULONG CDECL ldap_search_ext_sA( WLDAP32_LDAP *ld, PCHAR base, ULONG scope,
-    PCHAR filter, PCHAR attrs[], ULONG attrsonly, PLDAPControlA *serverctrls,
-    PLDAPControlA *clientctrls, struct l_timeval* timeout, ULONG sizelimit, WLDAP32_LDAPMessage **res )
+ULONG CDECL ldap_search_ext_sA( WLDAP32_LDAP *ld, char *base, ULONG scope, char *filter, char **attrs,
+    ULONG attrsonly, LDAPControlA **serverctrls, LDAPControlA **clientctrls, struct l_timeval *timeout,
+    ULONG sizelimit, WLDAP32_LDAPMessage **res )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
     WCHAR *baseW = NULL, *filterW = NULL, **attrsW = NULL;
     LDAPControlW **serverctrlsW = NULL, **clientctrlsW = NULL;
 
-    ret = WLDAP32_LDAP_NO_MEMORY;
-
-    TRACE( "(%p, %s, 0x%08x, %s, %p, 0x%08x, %p, %p, %p, 0x%08x, %p)\n",
-           ld, debugstr_a(base), scope, debugstr_a(filter), attrs, attrsonly,
-           serverctrls, clientctrls, timeout, sizelimit, res );
+    TRACE( "(%p, %s, 0x%08x, %s, %p, 0x%08x, %p, %p, %p, 0x%08x, %p)\n", ld, debugstr_a(base), scope,
+           debugstr_a(filter), attrs, attrsonly, serverctrls, clientctrls, timeout, sizelimit, res );
 
     if (!ld || !res) return WLDAP32_LDAP_PARAM_ERROR;
 
-    if (base) {
-        baseW = strAtoW( base );
-        if (!baseW) goto exit;
-    }
-    if (filter) {
-        filterW = strAtoW( filter );
-        if (!filterW) goto exit;
-    }
-    if (attrs) {
-        attrsW = strarrayAtoW( attrs );
-        if (!attrsW) goto exit;
-    }
-    if (serverctrls) {
-        serverctrlsW = controlarrayAtoW( serverctrls );
-        if (!serverctrlsW) goto exit;
-    }
-    if (clientctrls) {
-        clientctrlsW = controlarrayAtoW( clientctrls );
-        if (!clientctrlsW) goto exit;
-    }
+    if (base && !(baseW = strAtoW( base ))) goto exit;
+    if (filter && !(filterW = strAtoW( filter ))) goto exit;
+    if (attrs && !(attrsW = strarrayAtoW( attrs ))) goto exit;
+    if (serverctrls && !(serverctrlsW = controlarrayAtoW( serverctrls ))) goto exit;
+    if (clientctrls && !(clientctrlsW = controlarrayAtoW( clientctrls ))) goto exit;
 
-    ret = ldap_search_ext_sW( ld, baseW, scope, filterW, attrsW, attrsonly,
-                              serverctrlsW, clientctrlsW, timeout, sizelimit, res );
+    ret = ldap_search_ext_sW( ld, baseW, scope, filterW, attrsW, attrsonly, serverctrlsW, clientctrlsW, timeout,
+                              sizelimit, res );
 
 exit:
     strfreeW( baseW );
@@ -347,8 +220,6 @@ ULONG CDECL ldap_search_ext_sA( WLDAP32_LDAP *ld, PCHAR base, ULONG scope,
     strarrayfreeW( attrsW );
     controlarrayfreeW( serverctrlsW );
     controlarrayfreeW( clientctrlsW );
-
-#endif
     return ret;
 }
 
@@ -378,47 +249,49 @@ ULONG CDECL ldap_search_ext_sA( WLDAP32_LDAP *ld, PCHAR base, ULONG scope,
  * NOTES
  *  Call ldap_msgfree to free the results.
  */
-ULONG CDECL ldap_search_ext_sW( WLDAP32_LDAP *ld, PWCHAR base, ULONG scope,
-    PWCHAR filter, PWCHAR attrs[], ULONG attrsonly, PLDAPControlW *serverctrls,
-    PLDAPControlW *clientctrls, struct l_timeval* timeout, ULONG sizelimit, WLDAP32_LDAPMessage **res )
+ULONG CDECL ldap_search_ext_sW( WLDAP32_LDAP *ld, WCHAR *base, ULONG scope, WCHAR *filter, WCHAR **attrs,
+    ULONG attrsonly, LDAPControlW **serverctrls, LDAPControlW **clientctrls, struct l_timeval *timeout,
+    ULONG sizelimit, WLDAP32_LDAPMessage **res )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
     char *baseU = NULL, *filterU = NULL, **attrsU = NULL;
-    LDAPControl **serverctrlsU = NULL, **clientctrlsU = NULL;
-
-    ret = WLDAP32_LDAP_NO_MEMORY;
+    LDAPControlU **serverctrlsU = NULL, **clientctrlsU = NULL;
+    struct timevalU timevalU;
+    void *msgU = NULL;
 
-    TRACE( "(%p, %s, 0x%08x, %s, %p, 0x%08x, %p, %p, %p, 0x%08x, %p)\n",
-           ld, debugstr_w(base), scope, debugstr_w(filter), attrs, attrsonly,
-           serverctrls, clientctrls, timeout, sizelimit, res );
+    TRACE( "(%p, %s, 0x%08x, %s, %p, 0x%08x, %p, %p, %p, 0x%08x, %p)\n", ld, debugstr_w(base), scope,
+           debugstr_w(filter), attrs, attrsonly, serverctrls, clientctrls, timeout, sizelimit, res );
 
     if (!ld || !res) return WLDAP32_LDAP_PARAM_ERROR;
 
-    if (base) {
-        baseU = strWtoU( base );
-        if (!baseU) goto exit;
-    }
-    if (filter) {
-        filterU = strWtoU( filter );
-        if (!filterU) goto exit;
-    }
-    if (attrs) {
-        attrsU = strarrayWtoU( attrs );
-        if (!attrsU) goto exit;
-    }
-    if (serverctrls) {
-        serverctrlsU = controlarrayWtoU( serverctrls );
-        if (!serverctrlsU) goto exit;
-    }
-    if (clientctrls) {
-        clientctrlsU = controlarrayWtoU( clientctrls );
-        if (!clientctrlsU) goto exit;
+    if (base && !(baseU = strWtoU( base ))) goto exit;
+    if (filter && !(filterU = strWtoU( filter ))) goto exit;
+    if (attrs && !(attrsU = strarrayWtoU( attrs ))) goto exit;
+    if (serverctrls && !(serverctrlsU = controlarrayWtoU( serverctrls ))) goto exit;
+    if (clientctrls && !(clientctrlsU = controlarrayWtoU( clientctrls ))) goto exit;
+
+    if (timeout)
+    {
+        timevalU.tv_sec = timeout->tv_sec;
+        timevalU.tv_usec = timeout->tv_usec;
     }
 
-    ret = map_error( ldap_search_ext_s( ld->ld, baseU, scope, filterU, attrsU, attrsonly,
-                                        serverctrlsU, clientctrlsU, (struct timeval *)timeout,
-                                        sizelimit, res ));
+    ret = map_error( ldap_funcs->ldap_search_ext_s( ld->ld, baseU, scope, filterU, attrsU, attrsonly, serverctrlsU,
+                                                    clientctrlsU, timeout ? &timevalU : NULL, sizelimit, &msgU ) );
+    if (msgU)
+    {
+        WLDAP32_LDAPMessage *msg = heap_alloc_zero( sizeof(*msg) );
+        if (msg)
+        {
+            msg->Request = msgU;
+            *res = msg;
+        }
+        else
+        {
+            ldap_funcs->ldap_msgfree( msgU );
+            ret = WLDAP32_LDAP_NO_MEMORY;
+        }
+    }
 
 exit:
     strfreeU( baseU );
@@ -426,8 +299,6 @@ ULONG CDECL ldap_search_ext_sW( WLDAP32_LDAP *ld, PWCHAR base, ULONG scope,
     strarrayfreeU( attrsU );
     controlarrayfreeU( serverctrlsU );
     controlarrayfreeU( clientctrlsU );
-
-#endif
     return ret;
 }
 
@@ -436,32 +307,20 @@ ULONG CDECL ldap_search_ext_sW( WLDAP32_LDAP *ld, PWCHAR base, ULONG scope,
  *
  * See ldap_search_sW.
  */
-ULONG CDECL ldap_search_sA( WLDAP32_LDAP *ld, PCHAR base, ULONG scope, PCHAR filter,
-    PCHAR attrs[], ULONG attrsonly, WLDAP32_LDAPMessage **res )
+ULONG CDECL ldap_search_sA( WLDAP32_LDAP *ld, char *base, ULONG scope, char *filter, char **attrs, ULONG attrsonly,
+    WLDAP32_LDAPMessage **res )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
     WCHAR *baseW = NULL, *filterW = NULL, **attrsW = NULL;
 
-    ret = WLDAP32_LDAP_NO_MEMORY;
-
-    TRACE( "(%p, %s, 0x%08x, %s, %p, 0x%08x, %p)\n", ld, debugstr_a(base),
-           scope, debugstr_a(filter), attrs, attrsonly, res );
+    TRACE( "(%p, %s, 0x%08x, %s, %p, 0x%08x, %p)\n", ld, debugstr_a(base), scope, debugstr_a(filter), attrs,
+           attrsonly, res );
 
     if (!ld || !res) return WLDAP32_LDAP_PARAM_ERROR;
 
-    if (base) {
-        baseW = strAtoW( base );
-        if (!baseW) goto exit;
-    }
-    if (filter) {
-        filterW = strAtoW( filter );
-        if (!filterW) goto exit;
-    }
-    if (attrs) {
-        attrsW = strarrayAtoW( attrs );
-        if (!attrsW) goto exit;
-    }
+    if (base && !(baseW = strAtoW( base ))) goto exit;
+    if (filter && !(filterW = strAtoW( filter ))) goto exit;
+    if (attrs && !(attrsW = strarrayAtoW( attrs ))) goto exit;
 
     ret = ldap_search_sW( ld, baseW, scope, filterW, attrsW, attrsonly, res );
 
@@ -469,8 +328,6 @@ ULONG CDECL ldap_search_sA( WLDAP32_LDAP *ld, PCHAR base, ULONG scope, PCHAR fil
     strfreeW( baseW );
     strfreeW( filterW );
     strarrayfreeW( attrsW );
-
-#endif
     return ret;
 }
 
@@ -496,43 +353,12 @@ ULONG CDECL ldap_search_sA( WLDAP32_LDAP *ld, PCHAR base, ULONG scope, PCHAR fil
  * NOTES
  *  Call ldap_msgfree to free the results.
  */
-ULONG CDECL ldap_search_sW( WLDAP32_LDAP *ld, PWCHAR base, ULONG scope, PWCHAR filter,
-    PWCHAR attrs[], ULONG attrsonly, WLDAP32_LDAPMessage **res )
+ULONG CDECL ldap_search_sW( WLDAP32_LDAP *ld, WCHAR *base, ULONG scope, WCHAR *filter, WCHAR **attrs, ULONG attrsonly,
+    WLDAP32_LDAPMessage **res )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
-    char *baseU = NULL, *filterU = NULL, **attrsU = NULL;
-
-    ret = WLDAP32_LDAP_NO_MEMORY;
-
-    TRACE( "(%p, %s, 0x%08x, %s, %p, 0x%08x, %p)\n", ld, debugstr_w(base),
-           scope, debugstr_w(filter), attrs, attrsonly, res );
-
-    if (!ld || !res) return WLDAP32_LDAP_PARAM_ERROR;
-
-    if (base) {
-        baseU = strWtoU( base );
-        if (!baseU) goto exit;
-    }
-    if (filter) {
-        filterU = strWtoU( filter );
-        if (!filterU) goto exit;
-    }
-    if (attrs) {
-        attrsU = strarrayWtoU( attrs );
-        if (!attrsU) goto exit;
-    }
-
-    ret = map_error( ldap_search_ext_s( ld->ld, baseU, scope, filterU, attrsU, attrsonly,
-                                        NULL, NULL, NULL, 0, res ));
-
-exit:
-    strfreeU( baseU );
-    strfreeU( filterU );
-    strarrayfreeU( attrsU );
-
-#endif
-    return ret;
+    TRACE( "(%p, %s, 0x%08x, %s, %p, 0x%08x, %p)\n", ld, debugstr_w(base), scope, debugstr_w(filter), attrs,
+           attrsonly, res );
+    return ldap_search_ext_sW( ld, base, scope, filter, attrs, attrsonly, NULL, NULL, NULL, 0, res );
 }
 
 /***********************************************************************
@@ -540,44 +366,27 @@ ULONG CDECL ldap_search_sW( WLDAP32_LDAP *ld, PWCHAR base, ULONG scope, PWCHAR f
  *
  * See ldap_search_stW.
  */
-ULONG CDECL ldap_search_stA( WLDAP32_LDAP *ld, const PCHAR base, ULONG scope,
-    const PCHAR filter, PCHAR attrs[], ULONG attrsonly,
-    struct l_timeval *timeout, WLDAP32_LDAPMessage **res )
+ULONG CDECL ldap_search_stA( WLDAP32_LDAP *ld, const PCHAR base, ULONG scope, const PCHAR filter, char **attrs,
+    ULONG attrsonly, struct l_timeval *timeout, WLDAP32_LDAPMessage **res )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
     WCHAR *baseW = NULL, *filterW = NULL, **attrsW = NULL;
 
-    ret = WLDAP32_LDAP_NO_MEMORY;
-
-    TRACE( "(%p, %s, 0x%08x, %s, %p, 0x%08x, %p, %p)\n", ld,
-           debugstr_a(base), scope, debugstr_a(filter), attrs,
+    TRACE( "(%p, %s, 0x%08x, %s, %p, 0x%08x, %p, %p)\n", ld, debugstr_a(base), scope, debugstr_a(filter), attrs,
            attrsonly, timeout, res );
 
     if (!ld || !res) return WLDAP32_LDAP_PARAM_ERROR;
 
-    if (base) {
-        baseW = strAtoW( base );
-        if (!baseW) goto exit;
-    }
-    if (filter) {
-        filterW = strAtoW( filter );
-        if (!filterW) goto exit;
-    }
-    if (attrs) {
-        attrsW = strarrayAtoW( attrs );
-        if (!attrsW) goto exit;
-    }
+    if (base && !(baseW = strAtoW( base ))) goto exit;
+    if (filter && !(filterW = strAtoW( filter ))) goto exit;
+    if (attrs && !(attrsW = strarrayAtoW( attrs ))) goto exit;
 
-    ret = ldap_search_stW( ld, baseW, scope, filterW, attrsW, attrsonly,
-                           timeout, res );
+    ret = ldap_search_stW( ld, baseW, scope, filterW, attrsW, attrsonly, timeout, res );
 
 exit:
     strfreeW( baseW );
     strfreeW( filterW );
     strarrayfreeW( attrsW );
-
-#endif
     return ret;
 }
 
@@ -604,43 +413,10 @@ ULONG CDECL ldap_search_stA( WLDAP32_LDAP *ld, const PCHAR base, ULONG scope,
  * NOTES
  *  Call ldap_msgfree to free the results.
  */
-ULONG CDECL ldap_search_stW( WLDAP32_LDAP *ld, const PWCHAR base, ULONG scope,
-    const PWCHAR filter, PWCHAR attrs[], ULONG attrsonly,
-    struct l_timeval *timeout, WLDAP32_LDAPMessage **res )
+ULONG CDECL ldap_search_stW( WLDAP32_LDAP *ld, const PWCHAR base, ULONG scope, const PWCHAR filter, WCHAR **attrs,
+    ULONG attrsonly, struct l_timeval *timeout, WLDAP32_LDAPMessage **res )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
-    char *baseU = NULL, *filterU = NULL, **attrsU = NULL;
-
-    ret = WLDAP32_LDAP_NO_MEMORY;
-
-    TRACE( "(%p, %s, 0x%08x, %s, %p, 0x%08x, %p, %p)\n", ld,
-           debugstr_w(base), scope, debugstr_w(filter), attrs,
+    TRACE( "(%p, %s, 0x%08x, %s, %p, 0x%08x, %p, %p)\n", ld, debugstr_w(base), scope, debugstr_w(filter), attrs,
            attrsonly, timeout, res );
-
-    if (!ld || !res) return WLDAP32_LDAP_PARAM_ERROR;
-
-    if (base) {
-        baseU = strWtoU( base );
-        if (!baseU) goto exit;
-    }
-    if (filter) {
-        filterU = strWtoU( filter );
-        if (!filterU) goto exit;
-    }
-    if (attrs) {
-        attrsU = strarrayWtoU( attrs );
-        if (!attrsU) goto exit;
-    }
-
-    ret = map_error( ldap_search_ext_s( ld->ld, baseU, scope, filterU, attrsU, attrsonly,
-                                        NULL, NULL, (struct timeval *)timeout, 0, res ));
-
-exit:
-    strfreeU( baseU );
-    strfreeU( filterU );
-    strarrayfreeU( attrsU );
-
-#endif
-    return ret;
+    return ldap_search_ext_sW( ld, base, scope, filter, attrs, attrsonly, NULL, NULL, timeout, 0, res );
 }
diff --git a/dlls/wldap32/value.c b/dlls/wldap32/value.c
index ff13289b3092..a7d7d44244f4 100644
--- a/dlls/wldap32/value.c
+++ b/dlls/wldap32/value.c
@@ -228,7 +228,7 @@ PWCHAR * CDECL ldap_get_valuesW( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *entry, P
     attrU = strWtoU( attr );
     if (!attrU) return NULL;
 
-    bv = ldap_get_values_len( ld->ld, entry, attrU );
+    bv = ldap_get_values_len( ld->ld, entry->Request, attrU );
     if (bv)
     {
         retU = bv2str_array( bv );
@@ -305,7 +305,7 @@ struct WLDAP32_berval ** CDECL ldap_get_values_lenW( WLDAP32_LDAP *ld,
     attrU = strWtoU( attr );
     if (!attrU) return NULL;
 
-    ret = ldap_get_values_len( ld->ld, message, attrU );
+    ret = ldap_get_values_len( ld->ld, message->Request, attrU );
 
     strfreeU( attrU );
     return (struct WLDAP32_berval **)ret;
From e21c9596d36678dc28f6872382a3f1ca5189eac7 Mon Sep 17 00:00:00 2001
From: Hans Leidekker <hans@codeweavers.com>
Date: Thu, 15 Apr 2021 12:20:06 +0200
Subject: [PATCH] wldap32: Move support for dn functions to the Unix library.

Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/wldap32/dn.c      | 127 ++++++++++++++---------------------------
 dlls/wldap32/libldap.c |  24 ++++++++
 dlls/wldap32/libldap.h |   8 +++
 3 files changed, 75 insertions(+), 84 deletions(-)

diff --git a/dlls/wldap32/dn.c b/dlls/wldap32/dn.c
index b35a5dfe1ac2..61d421ee2333 100644
--- a/dlls/wldap32/dn.c
+++ b/dlls/wldap32/dn.c
@@ -18,49 +18,35 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#include "config.h"
-#include "wine/port.h"
-
 #include <stdarg.h>
-#ifdef HAVE_LDAP_H
-#include <ldap.h>
-#endif
-
 #include "windef.h"
 #include "winbase.h"
 #include "winnls.h"
 
-#include "winldap_private.h"
-#include "wldap32.h"
 #include "wine/debug.h"
+#include "winldap_private.h"
 
-#ifdef HAVE_LDAP
 WINE_DEFAULT_DEBUG_CHANNEL(wldap32);
-#endif
 
 /***********************************************************************
  *      ldap_dn2ufnA     (WLDAP32.@)
  *
  * See ldap_dn2ufnW.
  */
-PCHAR CDECL ldap_dn2ufnA( PCHAR dn )
+char * CDECL ldap_dn2ufnA( char *dn )
 {
-    PCHAR ret = NULL;
-#ifdef HAVE_LDAP
+    char *ret;
     WCHAR *dnW, *retW;
 
     TRACE( "(%s)\n", debugstr_a(dn) );
 
-    dnW = strAtoW( dn );
-    if (!dnW) return NULL;
+    if (!(dnW = strAtoW( dn ))) return NULL;
 
     retW = ldap_dn2ufnW( dnW );
     ret = strWtoA( retW );
 
     strfreeW( dnW );
     ldap_memfreeW( retW );
-
-#endif
     return ret;
 }
 
@@ -73,30 +59,26 @@ PCHAR CDECL ldap_dn2ufnA( PCHAR dn )
  *  dn  [I] DN to convert.
  *
  * RETURNS
- *  Success: Pointer to a string containing the user-friendly name. 
+ *  Success: Pointer to a string containing the user-friendly name.
  *  Failure: NULL
  *
  * NOTES
  *  Free the string with ldap_memfree.
  */
-PWCHAR CDECL ldap_dn2ufnW( PWCHAR dn )
+WCHAR * CDECL ldap_dn2ufnW( WCHAR *dn )
 {
-    PWCHAR ret = NULL;
-#ifdef HAVE_LDAP
+    WCHAR *ret;
     char *dnU, *retU;
 
     TRACE( "(%s)\n", debugstr_w(dn) );
 
-    dnU = strWtoU( dn );
-    if (!dnU) return NULL;
+    if (!(dnU = strWtoU( dn ))) return NULL;
 
-    retU = ldap_dn2ufn( dnU );
+    retU = ldap_funcs->ldap_dn2ufn( dnU );
     ret = strUtoW( retU );
 
     strfreeU( dnU );
-    ldap_memfree( retU );
-
-#endif
+    ldap_funcs->ldap_memfree( retU );
     return ret;
 }
 
@@ -105,24 +87,20 @@ PWCHAR CDECL ldap_dn2ufnW( PWCHAR dn )
  *
  * See ldap_explode_dnW.
  */
-PCHAR * CDECL ldap_explode_dnA( PCHAR dn, ULONG notypes )
+char ** CDECL ldap_explode_dnA( char *dn, ULONG notypes )
 {
-    PCHAR *ret = NULL;
-#ifdef HAVE_LDAP
+    char **ret;
     WCHAR *dnW, **retW;
 
     TRACE( "(%s, 0x%08x)\n", debugstr_a(dn), notypes );
 
-    dnW = strAtoW( dn );
-    if (!dnW) return NULL;
+    if (!(dnW = strAtoW( dn ))) return NULL;
 
     retW = ldap_explode_dnW( dnW, notypes );
     ret = strarrayWtoA( retW );
 
     strfreeW( dnW );
     ldap_value_freeW( retW );
-
-#endif
     return ret;
 }
 
@@ -137,30 +115,26 @@ PCHAR * CDECL ldap_explode_dnA( PCHAR dn, ULONG notypes )
  *
  * RETURNS
  *  Success: Pointer to a NULL-terminated array that contains the DN
- *           components. 
+ *           components.
  *  Failure: NULL
  *
  * NOTES
  *  Free the string array with ldap_value_free.
  */
-PWCHAR * CDECL ldap_explode_dnW( PWCHAR dn, ULONG notypes )
+WCHAR ** CDECL ldap_explode_dnW( WCHAR *dn, ULONG notypes )
 {
-    PWCHAR *ret = NULL;
-#ifdef HAVE_LDAP
+    WCHAR **ret;
     char *dnU, **retU;
 
     TRACE( "(%s, 0x%08x)\n", debugstr_w(dn), notypes );
 
-    dnU = strWtoU( dn );
-    if (!dnU) return NULL;
+    if (!(dnU = strWtoU( dn ))) return NULL;
 
-    retU = ldap_explode_dn( dnU, notypes );
+    retU = ldap_funcs->ldap_explode_dn( dnU, notypes );
     ret = strarrayUtoW( retU );
 
     strfreeU( dnU );
-    ldap_memvfree( (void **)retU );
-
-#endif
+    ldap_funcs->ldap_memvfree( (void **)retU );
     return ret;
 }
 
@@ -169,11 +143,10 @@ PWCHAR * CDECL ldap_explode_dnW( PWCHAR dn, ULONG notypes )
  *
  * See ldap_get_dnW.
  */
-PCHAR CDECL ldap_get_dnA( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *entry )
+char * CDECL ldap_get_dnA( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *entry )
 {
-    PCHAR ret = NULL;
-#ifdef HAVE_LDAP
-    PWCHAR retW;
+    char *ret;
+    WCHAR *retW;
 
     TRACE( "(%p, %p)\n", ld, entry );
 
@@ -183,8 +156,6 @@ PCHAR CDECL ldap_get_dnA( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *entry )
 
     ret = strWtoA( retW );
     ldap_memfreeW( retW );
-
-#endif
     return ret;
 }
 
@@ -204,22 +175,19 @@ PCHAR CDECL ldap_get_dnA( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *entry )
  * NOTES
  *  Free the string with ldap_memfree.
  */
-PWCHAR CDECL ldap_get_dnW( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *entry )
+WCHAR * CDECL ldap_get_dnW( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *entry )
 {
-    PWCHAR ret = NULL;
-#ifdef HAVE_LDAP
+    WCHAR *ret;
     char *retU;
 
     TRACE( "(%p, %p)\n", ld, entry );
 
     if (!ld || !entry) return NULL;
 
-    retU = ldap_get_dn( ld->ld, entry->Request );
+    retU = ldap_funcs->ldap_get_dn( ld->ld, entry->Request );
 
     ret = strUtoW( retU );
-    ldap_memfree( retU );
-
-#endif
+    ldap_funcs->ldap_memfree( retU );
     return ret;
 }
 
@@ -228,34 +196,28 @@ PWCHAR CDECL ldap_get_dnW( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *entry )
  *
  * See ldap_ufn2dnW.
  */
-ULONG CDECL ldap_ufn2dnA( PCHAR ufn, PCHAR *dn )
+ULONG CDECL ldap_ufn2dnA( char *ufn, char **dn )
 {
-    ULONG ret = WLDAP32_LDAP_SUCCESS;
-#ifdef HAVE_LDAP
-    PWCHAR ufnW = NULL, dnW = NULL;
+    ULONG ret;
+    WCHAR *ufnW = NULL, *dnW = NULL;
 
     TRACE( "(%s, %p)\n", debugstr_a(ufn), dn );
 
     if (!dn) return WLDAP32_LDAP_PARAM_ERROR;
 
     *dn = NULL;
-
-    if (ufn) {
-        ufnW = strAtoW( ufn );
-        if (!ufnW) return WLDAP32_LDAP_NO_MEMORY;
-    }
+    if (ufn && !(ufnW = strAtoW( ufn ))) return WLDAP32_LDAP_NO_MEMORY;
 
     ret = ldap_ufn2dnW( ufnW, &dnW );
-
-    if (dnW) {
-        *dn = strWtoA( dnW );
-        if (!*dn) ret = WLDAP32_LDAP_NO_MEMORY;
+    if (dnW)
+    {
+        char *str;
+        if (!(str = strWtoA( dnW ))) ret = WLDAP32_LDAP_NO_MEMORY;
+        else *dn = str;
     }
 
     strfreeW( ufnW );
     ldap_memfreeW( dnW );
-
-#endif
     return ret;
 }
 
@@ -266,7 +228,7 @@ ULONG CDECL ldap_ufn2dnA( PCHAR ufn, PCHAR *dn )
  *
  * PARAMS
  *  ufn  [I] User-friendly name to convert.
- *  dn   [O] Receives a pointer to a string containing the DN. 
+ *  dn   [O] Receives a pointer to a string containing the DN.
  *
  * RETURNS
  *  Success: LDAP_SUCCESS
@@ -275,10 +237,9 @@ ULONG CDECL ldap_ufn2dnA( PCHAR ufn, PCHAR *dn )
  * NOTES
  *  Free the string with ldap_memfree.
  */
-ULONG CDECL ldap_ufn2dnW( PWCHAR ufn, PWCHAR *dn )
+ULONG CDECL ldap_ufn2dnW( WCHAR *ufn, WCHAR **dn )
 {
     ULONG ret = WLDAP32_LDAP_SUCCESS;
-#ifdef HAVE_LDAP
     char *ufnU = NULL;
 
     TRACE( "(%s, %p)\n", debugstr_w(ufn), dn );
@@ -286,18 +247,16 @@ ULONG CDECL ldap_ufn2dnW( PWCHAR ufn, PWCHAR *dn )
     if (!dn) return WLDAP32_LDAP_PARAM_ERROR;
 
     *dn = NULL;
-
-    if (ufn) {
-        ufnU = strWtoU( ufn );
-        if (!ufnU) return WLDAP32_LDAP_NO_MEMORY;
+    if (ufn)
+    {
+        WCHAR *str;
+        if (!(ufnU = strWtoU( ufn ))) return WLDAP32_LDAP_NO_MEMORY;
 
         /* FIXME: do more than just a copy */
-        *dn = strUtoW( ufnU );
-        if (!*dn) ret = WLDAP32_LDAP_NO_MEMORY;
+        if (!(str = strUtoW( ufnU ))) ret = WLDAP32_LDAP_NO_MEMORY;
+        else *dn = str;
     }
 
     strfreeU( ufnU );
-
-#endif
     return ret;
 }
diff --git a/dlls/wldap32/libldap.c b/dlls/wldap32/libldap.c
index bc1a161127af..c07a898e47cb 100644
--- a/dlls/wldap32/libldap.c
+++ b/dlls/wldap32/libldap.c
@@ -369,6 +369,21 @@ int CDECL wrap_ldap_delete_ext_s( void *ld, const char *dn, LDAPControlU **serve
     return ldap_delete_ext_s( ld, dn ? dn : "", (LDAPControl **)serverctrls, (LDAPControl **)clientctrls );
 }
 
+char * CDECL wrap_ldap_dn2ufn( const char *dn )
+{
+    return ldap_dn2ufn( dn );
+}
+
+char ** CDECL wrap_ldap_explode_dn( const char *dn, int notypes )
+{
+    return ldap_explode_dn( dn, notypes );
+}
+
+char * CDECL wrap_ldap_get_dn( void *ld, void *entry )
+{
+    return ldap_get_dn( ld, entry );
+}
+
 char * CDECL wrap_ldap_first_attribute( void *ld, void *entry, void **ber )
 {
     return ldap_first_attribute( ld, entry, (BerElement **)ber );
@@ -389,6 +404,11 @@ void CDECL wrap_ldap_memfree( void *ptr )
     return ldap_memfree( ptr );
 }
 
+void CDECL wrap_ldap_memvfree( void **ptr )
+{
+    ldap_memvfree( ptr );
+}
+
 int CDECL wrap_ldap_msgfree( void *msg )
 {
     return ldap_msgfree( msg );
@@ -508,10 +528,14 @@ static const struct ldap_funcs funcs =
     wrap_ldap_create_vlv_control,
     wrap_ldap_delete_ext,
     wrap_ldap_delete_ext_s,
+    wrap_ldap_dn2ufn,
+    wrap_ldap_explode_dn,
+    wrap_ldap_get_dn,
     wrap_ldap_first_attribute,
     wrap_ldap_first_entry,
     wrap_ldap_first_reference,
     wrap_ldap_memfree,
+    wrap_ldap_memvfree,
     wrap_ldap_msgfree,
     wrap_ldap_next_attribute,
     wrap_ldap_next_entry,
diff --git a/dlls/wldap32/libldap.h b/dlls/wldap32/libldap.h
index f307eaf4327f..b339ad752bcd 100644
--- a/dlls/wldap32/libldap.h
+++ b/dlls/wldap32/libldap.h
@@ -112,10 +112,14 @@ extern int CDECL wrap_ldap_create_sort_control(void *, LDAPSortKeyU **, int, LDA
 extern int CDECL wrap_ldap_create_vlv_control(void *, LDAPVLVInfoU *, LDAPControlU **) DECLSPEC_HIDDEN;
 extern int CDECL wrap_ldap_delete_ext(void *, const char *, LDAPControlU **, LDAPControlU **, ULONG *) DECLSPEC_HIDDEN;
 extern int CDECL wrap_ldap_delete_ext_s(void *, const char *, LDAPControlU **, LDAPControlU **) DECLSPEC_HIDDEN;
+extern char * CDECL wrap_ldap_dn2ufn(const char *) DECLSPEC_HIDDEN;
+extern char ** CDECL wrap_ldap_explode_dn(const char *, int) DECLSPEC_HIDDEN;
+extern char * CDECL wrap_ldap_get_dn(void *, void *) DECLSPEC_HIDDEN;
 extern char * CDECL wrap_ldap_first_attribute(void *, void *, void **) DECLSPEC_HIDDEN;
 extern void * CDECL wrap_ldap_first_entry(void *, void *) DECLSPEC_HIDDEN;
 extern void * CDECL wrap_ldap_first_reference(void *, void *) DECLSPEC_HIDDEN;
 extern void CDECL wrap_ldap_memfree(void *) DECLSPEC_HIDDEN;
+extern void CDECL wrap_ldap_memvfree(void **) DECLSPEC_HIDDEN;
 extern int CDECL wrap_ldap_msgfree(void *) DECLSPEC_HIDDEN;
 extern char * CDECL wrap_ldap_next_attribute(void *, void *, void *) DECLSPEC_HIDDEN;
 extern void * CDECL wrap_ldap_next_entry(void *, void *) DECLSPEC_HIDDEN;
@@ -166,10 +170,14 @@ struct ldap_funcs
     int (CDECL *ldap_create_vlv_control)(void *, LDAPVLVInfoU *, LDAPControlU **);
     int (CDECL *ldap_delete_ext)(void *, const char *, LDAPControlU **, LDAPControlU **, ULONG *);
     int (CDECL *ldap_delete_ext_s)(void *, const char *, LDAPControlU **, LDAPControlU **);
+    char * (CDECL *ldap_dn2ufn)(const char *);
+    char ** (CDECL *ldap_explode_dn)(const char *, int);
+    char * (CDECL *ldap_get_dn)(void *, void *);
     char * (CDECL *ldap_first_attribute)(void *, void *, void **);
     void * (CDECL *ldap_first_entry)(void *, void *);
     void * (CDECL *ldap_first_reference)(void *, void *);
     void (CDECL *ldap_memfree)(void *);
+    void (CDECL *ldap_memvfree)(void **);
     int (CDECL *ldap_msgfree)(void *);
     char * (CDECL *ldap_next_attribute)(void *, void *, void *);
     void * (CDECL *ldap_next_entry)(void *, void *);
From b0f347b4fccb8437e3aa7f1a4b6ffc3abe9b9cfe Mon Sep 17 00:00:00 2001
From: Hans Leidekker <hans@codeweavers.com>
Date: Thu, 15 Apr 2021 12:20:07 +0200
Subject: [PATCH] wldap32: Move support for extended functions to the Unix
 library.

Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/wldap32/extended.c | 175 ++++++++++++++--------------------------
 dlls/wldap32/libldap.c  |  17 ++++
 dlls/wldap32/libldap.h  |   8 ++
 3 files changed, 84 insertions(+), 116 deletions(-)

diff --git a/dlls/wldap32/extended.c b/dlls/wldap32/extended.c
index 4600109182f4..e09d90fdc60e 100644
--- a/dlls/wldap32/extended.c
+++ b/dlls/wldap32/extended.c
@@ -18,21 +18,13 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#include "config.h"
-#include "wine/port.h"
-
 #include <stdarg.h>
-#ifdef HAVE_LDAP_H
-#include <ldap.h>
-#endif
-
 #include "windef.h"
 #include "winbase.h"
 #include "winnls.h"
 
-#include "winldap_private.h"
-#include "wldap32.h"
 #include "wine/debug.h"
+#include "winldap_private.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(wldap32);
 
@@ -66,33 +58,20 @@ ULONG CDECL ldap_close_extended_op( WLDAP32_LDAP *ld, ULONG msgid )
  *
  * See ldap_extended_operationW.
  */
-ULONG CDECL ldap_extended_operationA( WLDAP32_LDAP *ld, PCHAR oid, struct WLDAP32_berval *data,
-    PLDAPControlA *serverctrls, PLDAPControlA *clientctrls, ULONG *message )
+ULONG CDECL ldap_extended_operationA( WLDAP32_LDAP *ld, char *oid, struct WLDAP32_berval *data,
+    LDAPControlA **serverctrls, LDAPControlA **clientctrls, ULONG *message )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
     WCHAR *oidW = NULL;
     LDAPControlW **serverctrlsW = NULL, **clientctrlsW = NULL;
 
-    ret = WLDAP32_LDAP_NO_MEMORY;
-
-    TRACE( "(%p, %s, %p, %p, %p, %p)\n", ld, debugstr_a(oid), data, serverctrls,
-           clientctrls, message );
+    TRACE( "(%p, %s, %p, %p, %p, %p)\n", ld, debugstr_a(oid), data, serverctrls, clientctrls, message );
 
     if (!ld || !message) return WLDAP32_LDAP_PARAM_ERROR;
 
-    if (oid) {
-        oidW = strAtoW( oid );
-        if (!oidW) goto exit;
-    }
-    if (serverctrls) {
-        serverctrlsW = controlarrayAtoW( serverctrls );
-        if (!serverctrlsW) goto exit;
-    }
-    if (clientctrls) {
-        clientctrlsW = controlarrayAtoW( clientctrls );
-        if (!clientctrlsW) goto exit;
-    }
+    if (oid && !(oidW = strAtoW( oid ))) goto exit;
+    if (serverctrls && !(serverctrlsW = controlarrayAtoW( serverctrls ))) goto exit;
+    if (clientctrls && !(clientctrlsW = controlarrayAtoW( clientctrls ))) goto exit;
 
     ret = ldap_extended_operationW( ld, oidW, data, serverctrlsW, clientctrlsW, message );
 
@@ -100,8 +79,6 @@ ULONG CDECL ldap_extended_operationA( WLDAP32_LDAP *ld, PCHAR oid, struct WLDAP3
     strfreeW( oidW );
     controlarrayfreeW( serverctrlsW );
     controlarrayfreeW( clientctrlsW );
-
-#endif
     return ret;
 }
 
@@ -130,43 +107,30 @@ ULONG CDECL ldap_extended_operationA( WLDAP32_LDAP *ld, PCHAR oid, struct WLDAP3
  *  are optional and should be set to NULL if not used. Call
  *  ldap_close_extended_op to close the operation.
  */
-ULONG CDECL ldap_extended_operationW( WLDAP32_LDAP *ld, PWCHAR oid, struct WLDAP32_berval *data,
-    PLDAPControlW *serverctrls, PLDAPControlW *clientctrls, ULONG *message )
+ULONG CDECL ldap_extended_operationW( WLDAP32_LDAP *ld, WCHAR *oid, struct WLDAP32_berval *data,
+    LDAPControlW **serverctrls, LDAPControlW **clientctrls, ULONG *message )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
     char *oidU = NULL;
-    LDAPControl **serverctrlsU = NULL, **clientctrlsU = NULL;
-
-    ret = WLDAP32_LDAP_NO_MEMORY;
+    LDAPControlU **serverctrlsU = NULL, **clientctrlsU = NULL;
+    struct bervalU *dataU = NULL;
 
-    TRACE( "(%p, %s, %p, %p, %p, %p)\n", ld, debugstr_w(oid), data, serverctrls,
-           clientctrls, message );
+    TRACE( "(%p, %s, %p, %p, %p, %p)\n", ld, debugstr_w(oid), data, serverctrls, clientctrls, message );
 
     if (!ld || !message) return WLDAP32_LDAP_PARAM_ERROR;
 
-    if (oid) {
-        oidU = strWtoU( oid );
-        if (!oidU) goto exit;
-    }
-    if (serverctrls) {
-        serverctrlsU = controlarrayWtoU( serverctrls );
-        if (!serverctrlsU) goto exit;
-    }
-    if (clientctrls) {
-        clientctrlsU = controlarrayWtoU( clientctrls );
-        if (!clientctrlsU) goto exit;
-    }
+    if (oid && !(oidU = strWtoU( oid ))) goto exit;
+    if (data && !(dataU = bervalWtoU( data ))) goto exit;
+    if (serverctrls && !(serverctrlsU = controlarrayWtoU( serverctrls ))) goto exit;
+    if (clientctrls && !(clientctrlsU = controlarrayWtoU( clientctrls ))) goto exit;
 
-    ret = map_error( ldap_extended_operation( ld->ld, oid ? oidU : "", (struct berval *)data,
-                                              serverctrlsU, clientctrlsU, (int *)message ));
+    ret = map_error( ldap_funcs->ldap_extended_operation( ld->ld, oidU, dataU, serverctrlsU, clientctrlsU, message ) );
 
 exit:
     strfreeU( oidU );
+    bvfreeU( dataU );
     controlarrayfreeU( serverctrlsU );
     controlarrayfreeU( clientctrlsU );
-
-#endif
     return ret;
 }
 
@@ -175,41 +139,27 @@ ULONG CDECL ldap_extended_operationW( WLDAP32_LDAP *ld, PWCHAR oid, struct WLDAP
  *
  * See ldap_extended_operation_sW.
  */
-ULONG CDECL ldap_extended_operation_sA( WLDAP32_LDAP *ld, PCHAR oid, struct WLDAP32_berval *data,
-    PLDAPControlA *serverctrls, PLDAPControlA *clientctrls, PCHAR *retoid,
-    struct WLDAP32_berval **retdata )
+ULONG CDECL ldap_extended_operation_sA( WLDAP32_LDAP *ld, char *oid, struct WLDAP32_berval *data,
+    LDAPControlA **serverctrls, LDAPControlA **clientctrls, char **retoid, struct WLDAP32_berval **retdata )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
     WCHAR *oidW = NULL, *retoidW = NULL;
     LDAPControlW **serverctrlsW = NULL, **clientctrlsW = NULL;
 
-    ret = WLDAP32_LDAP_NO_MEMORY;
-
-    TRACE( "(%p, %s, %p, %p, %p, %p, %p)\n", ld, debugstr_a(oid), data, serverctrls,
-           clientctrls, retoid, retdata );
+    TRACE( "(%p, %s, %p, %p, %p, %p, %p)\n", ld, debugstr_a(oid), data, serverctrls, clientctrls, retoid, retdata );
 
     if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
 
-    if (oid) {
-        oidW = strAtoW( oid );
-        if (!oidW) goto exit;
-    }
-    if (serverctrls) {
-        serverctrlsW = controlarrayAtoW( serverctrls );
-        if (!serverctrlsW) goto exit;
-    }
-    if (clientctrls) {
-        clientctrlsW = controlarrayAtoW( clientctrls );
-        if (!clientctrlsW) goto exit;
-    }
-
-    ret = ldap_extended_operation_sW( ld, oidW, data, serverctrlsW, clientctrlsW,
-                                      &retoidW, retdata );
+    if (oid && !(oidW = strAtoW( oid ))) goto exit;
+    if (serverctrls && !(serverctrlsW = controlarrayAtoW( serverctrls ))) goto exit;
+    if (clientctrls && !(clientctrlsW = controlarrayAtoW( clientctrls ))) goto exit;
 
-    if (retoid && retoidW) {
-        *retoid = strWtoA( retoidW );
-        if (!*retoid) ret = WLDAP32_LDAP_NO_MEMORY;
+    ret = ldap_extended_operation_sW( ld, oidW, data, serverctrlsW, clientctrlsW, &retoidW, retdata );
+    if (retoid && retoidW)
+    {
+        char *str = strWtoA( retoidW );
+        if (str) *retoid = str;
+        else ret = WLDAP32_LDAP_NO_MEMORY;
         ldap_memfreeW( retoidW );
     }
 
@@ -217,8 +167,6 @@ ULONG CDECL ldap_extended_operation_sA( WLDAP32_LDAP *ld, PCHAR oid, struct WLDA
     strfreeW( oidW );
     controlarrayfreeW( serverctrlsW );
     controlarrayfreeW( clientctrlsW );
-
-#endif
     return ret;
 }
 
@@ -246,49 +194,44 @@ ULONG CDECL ldap_extended_operation_sA( WLDAP32_LDAP *ld, PCHAR oid, struct WLDA
  *  and retdata parameters are also optional. Set to NULL if not
  *  used. Free retoid and retdata after use with ldap_memfree.
  */
-ULONG CDECL ldap_extended_operation_sW( WLDAP32_LDAP *ld, PWCHAR oid, struct WLDAP32_berval *data,
-    PLDAPControlW *serverctrls, PLDAPControlW *clientctrls, PWCHAR *retoid,
-    struct WLDAP32_berval **retdata )
+ULONG CDECL ldap_extended_operation_sW( WLDAP32_LDAP *ld, WCHAR *oid, struct WLDAP32_berval *data,
+    LDAPControlW **serverctrls, LDAPControlW **clientctrls, WCHAR **retoid, struct WLDAP32_berval **retdata )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
     char *oidU = NULL, *retoidU = NULL;
-    LDAPControl **serverctrlsU = NULL, **clientctrlsU = NULL;
+    LDAPControlU **serverctrlsU = NULL, **clientctrlsU = NULL;
+    struct bervalU *retdataU, *dataU = NULL;
 
-    ret = WLDAP32_LDAP_NO_MEMORY;
-
-    TRACE( "(%p, %s, %p, %p, %p, %p, %p)\n", ld, debugstr_w(oid), data, serverctrls,
-           clientctrls, retoid, retdata );
+    TRACE( "(%p, %s, %p, %p, %p, %p, %p)\n", ld, debugstr_w(oid), data, serverctrls, clientctrls, retoid, retdata );
 
     if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
 
-    if (oid) {
-        oidU = strWtoU( oid );
-        if (!oidU) goto exit;
-    }
-    if (serverctrls) {
-        serverctrlsU = controlarrayWtoU( serverctrls );
-        if (!serverctrlsU) goto exit;
-    }
-    if (clientctrls) {
-        clientctrlsU = controlarrayWtoU( clientctrls );
-        if (!clientctrlsU) goto exit;
+    if (oid && !(oidU = strWtoU( oid ))) goto exit;
+    if (data && !(dataU = bervalWtoU( data ))) goto exit;
+    if (serverctrls && !(serverctrlsU = controlarrayWtoU( serverctrls ))) goto exit;
+    if (clientctrls && !(clientctrlsU = controlarrayWtoU( clientctrls ))) goto exit;
+
+    ret = map_error( ldap_funcs->ldap_extended_operation_s( ld->ld, oidU, dataU, serverctrlsU, clientctrlsU,
+                                                            &retoidU, &retdataU ) );
+    if (retoid && retoidU)
+    {
+        WCHAR *str = strUtoW( retoidU );
+        if (str) *retoid = str;
+        else ret = WLDAP32_LDAP_NO_MEMORY;
+        ldap_funcs->ldap_memfree( retoidU );
     }
-
-    ret = map_error( ldap_extended_operation_s( ld->ld, oid ? oidU : "", (struct berval *)data, serverctrlsU,
-                                                clientctrlsU, &retoidU, (struct berval **)retdata ));
-
-    if (retoid && retoidU) {
-        *retoid = strUtoW( retoidU );
-        if (!*retoid) ret = WLDAP32_LDAP_NO_MEMORY;
-        ldap_memfree( retoidU );
+    if (retdata && retdataU)
+    {
+        struct WLDAP32_berval *bv = bervalUtoW( retdataU );
+        if (bv) *retdata = bv;
+        else ret = WLDAP32_LDAP_NO_MEMORY;
+        ldap_funcs->ber_bvfree( retdataU );
     }
 
 exit:
     strfreeU( oidU );
+    bvfreeU( dataU );
     controlarrayfreeU( serverctrlsU );
     controlarrayfreeU( clientctrlsU );
-
-#endif
     return ret;
 }
diff --git a/dlls/wldap32/libldap.c b/dlls/wldap32/libldap.c
index c07a898e47cb..de6974570f6a 100644
--- a/dlls/wldap32/libldap.c
+++ b/dlls/wldap32/libldap.c
@@ -379,6 +379,21 @@ char ** CDECL wrap_ldap_explode_dn( const char *dn, int notypes )
     return ldap_explode_dn( dn, notypes );
 }
 
+int CDECL wrap_ldap_extended_operation( void *ld, const char *oid, struct bervalU *data, LDAPControlU **serverctrls,
+                                        LDAPControlU **clientctrls, ULONG *msg )
+{
+    int dummy;
+    return ldap_extended_operation( ld, oid ? oid : "", (struct berval *)data, (LDAPControl **)serverctrls,
+                                    (LDAPControl **)clientctrls, msg ? (int *)msg : &dummy );
+}
+
+int CDECL wrap_ldap_extended_operation_s( void *ld, const char *oid, struct bervalU *data, LDAPControlU **serverctrls,
+                                          LDAPControlU **clientctrls, char **retoid, struct bervalU **retdata )
+{
+    return ldap_extended_operation_s( ld, oid ? oid : "", (struct berval *)data, (LDAPControl **)serverctrls,
+                                      (LDAPControl **)clientctrls, retoid, (struct berval **)retdata );
+}
+
 char * CDECL wrap_ldap_get_dn( void *ld, void *entry )
 {
     return ldap_get_dn( ld, entry );
@@ -530,6 +545,8 @@ static const struct ldap_funcs funcs =
     wrap_ldap_delete_ext_s,
     wrap_ldap_dn2ufn,
     wrap_ldap_explode_dn,
+    wrap_ldap_extended_operation,
+    wrap_ldap_extended_operation_s,
     wrap_ldap_get_dn,
     wrap_ldap_first_attribute,
     wrap_ldap_first_entry,
diff --git a/dlls/wldap32/libldap.h b/dlls/wldap32/libldap.h
index b339ad752bcd..f3fc5796fdc1 100644
--- a/dlls/wldap32/libldap.h
+++ b/dlls/wldap32/libldap.h
@@ -114,6 +114,10 @@ extern int CDECL wrap_ldap_delete_ext(void *, const char *, LDAPControlU **, LDA
 extern int CDECL wrap_ldap_delete_ext_s(void *, const char *, LDAPControlU **, LDAPControlU **) DECLSPEC_HIDDEN;
 extern char * CDECL wrap_ldap_dn2ufn(const char *) DECLSPEC_HIDDEN;
 extern char ** CDECL wrap_ldap_explode_dn(const char *, int) DECLSPEC_HIDDEN;
+extern int CDECL wrap_ldap_extended_operation(void *, const char *, struct bervalU *, LDAPControlU **,
+                                              LDAPControlU **, ULONG *) DECLSPEC_HIDDEN;
+extern int CDECL wrap_ldap_extended_operation_s(void *, const char *, struct bervalU *, LDAPControlU **,
+                                                LDAPControlU **, char **, struct bervalU **) DECLSPEC_HIDDEN;
 extern char * CDECL wrap_ldap_get_dn(void *, void *) DECLSPEC_HIDDEN;
 extern char * CDECL wrap_ldap_first_attribute(void *, void *, void **) DECLSPEC_HIDDEN;
 extern void * CDECL wrap_ldap_first_entry(void *, void *) DECLSPEC_HIDDEN;
@@ -172,6 +176,10 @@ struct ldap_funcs
     int (CDECL *ldap_delete_ext_s)(void *, const char *, LDAPControlU **, LDAPControlU **);
     char * (CDECL *ldap_dn2ufn)(const char *);
     char ** (CDECL *ldap_explode_dn)(const char *, int);
+    int (CDECL *ldap_extended_operation)(void *, const char *, struct bervalU *, LDAPControlU **,
+                                         LDAPControlU **, ULONG *);
+    int (CDECL *ldap_extended_operation_s)(void *, const char *, struct bervalU *, LDAPControlU **,
+                                           LDAPControlU **, char **, struct bervalU **);
     char * (CDECL *ldap_get_dn)(void *, void *);
     char * (CDECL *ldap_first_attribute)(void *, void *, void **);
     void * (CDECL *ldap_first_entry)(void *, void *);
From b2ac9f4b751269c179f0f10ec9ec943590a403a3 Mon Sep 17 00:00:00 2001
From: Hans Leidekker <hans@codeweavers.com>
Date: Fri, 16 Apr 2021 09:59:14 +0200
Subject: [PATCH] wldap32: Move support for init functions to the Unix library.

Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/wldap32/init.c            | 218 ++++++++-------------------------
 dlls/wldap32/libldap.c         |  18 +++
 dlls/wldap32/libldap.h         |   6 +
 dlls/wldap32/winldap_private.h |   4 +
 4 files changed, 78 insertions(+), 168 deletions(-)

diff --git a/dlls/wldap32/init.c b/dlls/wldap32/init.c
index 6586caa0ef50..d65554afb3cf 100644
--- a/dlls/wldap32/init.c
+++ b/dlls/wldap32/init.c
@@ -18,25 +18,18 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#include "config.h"
-#include "wine/port.h"
-
-#include <stdio.h>
 #include <stdarg.h>
-#ifdef HAVE_LDAP_H
-#include <ldap.h>
-#endif
-
 #include "windef.h"
 #include "winbase.h"
 #include "winnls.h"
 #include "winternl.h"
 
-#include "winldap_private.h"
-#include "wldap32.h"
 #include "wine/debug.h"
+#include "wine/heap.h"
+#include "winldap_private.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(wldap32);
 
-#ifdef HAVE_LDAP
 /* Should eventually be determined by the algorithm documented on MSDN. */
 static const WCHAR defaulthost[] = { 'l','o','c','a','l','h','o','s','t',0 };
 
@@ -200,55 +193,41 @@ static char *urlify_hostnames( const char *scheme, char *hostnames, ULONG port )
     strarrayfreeU( strarray );
     return url;
 }
-#endif
 
-WINE_DEFAULT_DEBUG_CHANNEL(wldap32);
 
-#ifdef HAVE_LDAP
 static WLDAP32_LDAP *create_context( const char *url )
 {
     WLDAP32_LDAP *ld;
-    int version = LDAP_VERSION3;
+    int version = WLDAP32_LDAP_VERSION3;
 
-    ld = heap_alloc_zero( sizeof( *ld ));
-    if (!ld) return NULL;
-    if (ldap_initialize( (LDAP **)&ld->ld, url ) != LDAP_SUCCESS)
+    if (!(ld = heap_alloc_zero( sizeof( *ld )))) return NULL;
+    if (map_error( ldap_funcs->ldap_initialize( &ld->ld, url ) ) != WLDAP32_LDAP_SUCCESS)
     {
         heap_free( ld );
         return NULL;
     }
-    ldap_set_option( ld->ld, LDAP_OPT_PROTOCOL_VERSION, &version );
+    ldap_funcs->ldap_set_option( ld->ld, WLDAP32_LDAP_OPT_PROTOCOL_VERSION, &version );
     return ld;
 }
-#endif
 
 /***********************************************************************
  *      cldap_openA     (WLDAP32.@)
  *
  * See cldap_openW.
  */
-WLDAP32_LDAP * CDECL cldap_openA( PCHAR hostname, ULONG portnumber )
+WLDAP32_LDAP * CDECL cldap_openA( char *hostname, ULONG portnumber )
 {
-#ifdef HAVE_LDAP
-    WLDAP32_LDAP *ld = NULL;
+    WLDAP32_LDAP *ld;
     WCHAR *hostnameW = NULL;
 
     TRACE( "(%s, %d)\n", debugstr_a(hostname), portnumber );
 
-    if (hostname) {
-        hostnameW = strAtoW( hostname );
-        if (!hostnameW) goto exit;
-    }
+    if (hostname && !(hostnameW = strAtoW( hostname ))) return NULL;
 
     ld = cldap_openW( hostnameW, portnumber );
 
-exit:
     strfreeW( hostnameW );
     return ld;
-
-#else
-    return NULL;
-#endif
 }
 
 /***********************************************************************
@@ -272,25 +251,15 @@ WLDAP32_LDAP * CDECL cldap_openA( PCHAR hostname, ULONG portnumber )
  *  will take precedence over the port number supplied as a parameter
  *  to this function.
  */
-WLDAP32_LDAP * CDECL cldap_openW( PWCHAR hostname, ULONG portnumber )
+WLDAP32_LDAP * CDECL cldap_openW( WCHAR *hostname, ULONG portnumber )
 {
-#ifdef HAVE_LDAP
     WLDAP32_LDAP *ld = NULL;
-    char *hostnameU = NULL, *url = NULL;
+    char *hostnameU, *url = NULL;
 
     TRACE( "(%s, %d)\n", debugstr_w(hostname), portnumber );
 
-    if (hostname) {
-        hostnameU = strWtoU( hostname );
-        if (!hostnameU) goto exit;
-    }
-    else {
-        hostnameU = strWtoU( defaulthost );
-        if (!hostnameU) goto exit;
-    }
-
-    url = urlify_hostnames( "cldap://", hostnameU, portnumber );
-    if (!url) goto exit;
+    if (!(hostnameU = strWtoU( hostname ? hostname : defaulthost ))) return NULL;
+    if (!(url = urlify_hostnames( "cldap://", hostnameU, portnumber ))) goto exit;
 
     ld = create_context( url );
 
@@ -298,10 +267,6 @@ WLDAP32_LDAP * CDECL cldap_openW( PWCHAR hostname, ULONG portnumber )
     strfreeU( hostnameU );
     strfreeU( url );
     return ld;
-
-#else
-    return NULL;
-#endif
 }
 
 /***********************************************************************
@@ -337,26 +302,17 @@ ULONG CDECL ldap_connect( WLDAP32_LDAP *ld, struct l_timeval *timeout )
  */
 WLDAP32_LDAP *  CDECL ldap_initA( const PCHAR hostname, ULONG portnumber )
 {
-#ifdef HAVE_LDAP
-    WLDAP32_LDAP *ld = NULL;
+    WLDAP32_LDAP *ld;
     WCHAR *hostnameW = NULL;
 
     TRACE( "(%s, %d)\n", debugstr_a(hostname), portnumber );
 
-    if (hostname) {
-        hostnameW = strAtoW( hostname );
-        if (!hostnameW) goto exit;
-    }
+    if (hostname && !(hostnameW = strAtoW( hostname ))) return NULL;
 
     ld = ldap_initW( hostnameW, portnumber );
 
-exit:
     strfreeW( hostnameW );
     return ld;
-
-#else
-    return NULL;
-#endif
 }
 
 /***********************************************************************
@@ -383,23 +339,13 @@ WLDAP32_LDAP *  CDECL ldap_initA( const PCHAR hostname, ULONG portnumber )
  */
 WLDAP32_LDAP * CDECL ldap_initW( const PWCHAR hostname, ULONG portnumber )
 {
-#ifdef HAVE_LDAP
     WLDAP32_LDAP *ld = NULL;
-    char *hostnameU = NULL, *url = NULL;
+    char *hostnameU, *url = NULL;
 
     TRACE( "(%s, %d)\n", debugstr_w(hostname), portnumber );
 
-    if (hostname) {
-        hostnameU = strWtoU( hostname );
-        if (!hostnameU) goto exit;
-    }
-    else {
-        hostnameU = strWtoU( defaulthost );
-        if (!hostnameU) goto exit;
-    }
-
-    url = urlify_hostnames( "ldap://", hostnameU, portnumber );
-    if (!url) goto exit;
+    if (!(hostnameU = strWtoU( hostname ? hostname : defaulthost ))) return NULL;
+    if (!(url = urlify_hostnames( "ldap://", hostnameU, portnumber ))) goto exit;
 
     ld = create_context( url );
 
@@ -407,10 +353,6 @@ WLDAP32_LDAP * CDECL ldap_initW( const PWCHAR hostname, ULONG portnumber )
     strfreeU( hostnameU );
     strfreeU( url );
     return ld;
-
-#else
-    return NULL;
-#endif
 }
 
 /***********************************************************************
@@ -418,28 +360,19 @@ WLDAP32_LDAP * CDECL ldap_initW( const PWCHAR hostname, ULONG portnumber )
  *
  * See ldap_openW.
  */
-WLDAP32_LDAP * CDECL ldap_openA( PCHAR hostname, ULONG portnumber )
+WLDAP32_LDAP * CDECL ldap_openA( char *hostname, ULONG portnumber )
 {
-#ifdef HAVE_LDAP
-    WLDAP32_LDAP *ld = NULL;
+    WLDAP32_LDAP *ld;
     WCHAR *hostnameW = NULL;
 
     TRACE( "(%s, %d)\n", debugstr_a(hostname), portnumber );
 
-    if (hostname) {
-        hostnameW = strAtoW( hostname );
-        if (!hostnameW) goto exit;
-    }
+    if (hostname && !(hostnameW = strAtoW( hostname ))) return NULL;
 
     ld = ldap_openW( hostnameW, portnumber );
 
-exit:
     strfreeW( hostnameW );
     return ld;
-
-#else
-    return NULL;
-#endif
 }
 
 /***********************************************************************
@@ -463,25 +396,15 @@ WLDAP32_LDAP * CDECL ldap_openA( PCHAR hostname, ULONG portnumber )
  *  will take precedence over the port number supplied as a parameter
  *  to this function.
  */
-WLDAP32_LDAP * CDECL ldap_openW( PWCHAR hostname, ULONG portnumber )
+WLDAP32_LDAP * CDECL ldap_openW( WCHAR *hostname, ULONG portnumber )
 {
-#ifdef HAVE_LDAP
     WLDAP32_LDAP *ld = NULL;
-    char *hostnameU = NULL, *url = NULL;
+    char *hostnameU, *url = NULL;
 
     TRACE( "(%s, %d)\n", debugstr_w(hostname), portnumber );
 
-    if (hostname) {
-        hostnameU = strWtoU( hostname );
-        if (!hostnameU) goto exit;
-    }
-    else {
-        hostnameU = strWtoU( defaulthost );
-        if (!hostnameU) goto exit;
-    }
-
-    url = urlify_hostnames( "ldap://", hostnameU, portnumber );
-    if (!url) goto exit;
+    if (!(hostnameU = strWtoU( hostname ? hostname : defaulthost ))) return NULL;
+    if (!(url = urlify_hostnames( "ldap://", hostnameU, portnumber ))) goto exit;
 
     ld = create_context( url );
 
@@ -489,10 +412,6 @@ WLDAP32_LDAP * CDECL ldap_openW( PWCHAR hostname, ULONG portnumber )
     strfreeU( hostnameU );
     strfreeU( url );
     return ld;
-
-#else
-    return NULL;
-#endif
 }
 
 /***********************************************************************
@@ -500,27 +419,19 @@ WLDAP32_LDAP * CDECL ldap_openW( PWCHAR hostname, ULONG portnumber )
  *
  * See ldap_sslinitW.
  */
-WLDAP32_LDAP * CDECL ldap_sslinitA( PCHAR hostname, ULONG portnumber, int secure )
+WLDAP32_LDAP * CDECL ldap_sslinitA( char *hostname, ULONG portnumber, int secure )
 {
-#ifdef HAVE_LDAP
     WLDAP32_LDAP *ld;
     WCHAR *hostnameW = NULL;
 
     TRACE( "(%s, %d, 0x%08x)\n", debugstr_a(hostname), portnumber, secure );
 
-    if (hostname) {
-        hostnameW = strAtoW( hostname );
-        if (!hostnameW) return NULL;
-    }
+    if (hostname && !(hostnameW = strAtoW( hostname ))) return NULL;
 
     ld  = ldap_sslinitW( hostnameW, portnumber, secure );
 
     strfreeW( hostnameW );
     return ld;
-
-#else
-    return NULL;
-#endif
 }
 
 /***********************************************************************
@@ -546,22 +457,14 @@ WLDAP32_LDAP * CDECL ldap_sslinitA( PCHAR hostname, ULONG portnumber, int secure
  *  to this function. The connection will not be made until the first
  *  LDAP function that needs it is called.
  */
-WLDAP32_LDAP * CDECL ldap_sslinitW( PWCHAR hostname, ULONG portnumber, int secure )
+WLDAP32_LDAP * CDECL ldap_sslinitW( WCHAR *hostname, ULONG portnumber, int secure )
 {
-#ifdef HAVE_LDAP
     WLDAP32_LDAP *ld = NULL;
-    char *hostnameU = NULL, *url = NULL;
+    char *hostnameU, *url = NULL;
 
     TRACE( "(%s, %d, 0x%08x)\n", debugstr_w(hostname), portnumber, secure );
 
-    if (hostname) {
-        hostnameU = strWtoU( hostname );
-        if (!hostnameU) goto exit;
-    }
-    else {
-        hostnameU = strWtoU( defaulthost );
-        if (!hostnameU) goto exit;
-    }
+    if (!(hostnameU = strWtoU( hostname ? hostname : defaulthost ))) return NULL;
 
     if (secure)
         url = urlify_hostnames( "ldaps://", hostnameU, portnumber );
@@ -575,10 +478,6 @@ WLDAP32_LDAP * CDECL ldap_sslinitW( PWCHAR hostname, ULONG portnumber, int secur
     strfreeU( hostnameU );
     strfreeU( url );
     return ld;
-
-#else
-    return NULL;
-#endif
 }
 
 /***********************************************************************
@@ -586,35 +485,24 @@ WLDAP32_LDAP * CDECL ldap_sslinitW( PWCHAR hostname, ULONG portnumber, int secur
  *
  * See ldap_start_tls_sW.
  */
-ULONG CDECL ldap_start_tls_sA( WLDAP32_LDAP *ld, PULONG retval, WLDAP32_LDAPMessage **result,
-    PLDAPControlA *serverctrls, PLDAPControlA *clientctrls )
+ULONG CDECL ldap_start_tls_sA( WLDAP32_LDAP *ld, ULONG *retval, WLDAP32_LDAPMessage **result,
+    LDAPControlA **serverctrls, LDAPControlA **clientctrls )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
     LDAPControlW **serverctrlsW = NULL, **clientctrlsW = NULL;
 
-    ret = WLDAP32_LDAP_NO_MEMORY;
-
     TRACE( "(%p, %p, %p, %p, %p)\n", ld, retval, result, serverctrls, clientctrls );
 
     if (!ld) return ~0u;
 
-    if (serverctrls) {
-        serverctrlsW = controlarrayAtoW( serverctrls );
-        if (!serverctrlsW) goto exit;
-    }
-    if (clientctrls) {
-        clientctrlsW = controlarrayAtoW( clientctrls );
-        if (!clientctrlsW) goto exit;
-    }
+    if (serverctrls && !(serverctrlsW = controlarrayAtoW( serverctrls ))) goto exit;
+    if (clientctrls && !(clientctrlsW = controlarrayAtoW( clientctrls ))) goto exit;
 
     ret = ldap_start_tls_sW( ld, retval, result, serverctrlsW, clientctrlsW );
 
 exit:
     controlarrayfreeW( serverctrlsW );
     controlarrayfreeW( clientctrlsW );
-
-#endif
     return ret;
 }
 
@@ -637,42 +525,36 @@ ULONG CDECL ldap_start_tls_sA( WLDAP32_LDAP *ld, PULONG retval, WLDAP32_LDAPMess
  * NOTES
  *  LDAP function that needs it is called.
  */
-ULONG CDECL ldap_start_tls_sW( WLDAP32_LDAP *ld, PULONG retval, WLDAP32_LDAPMessage **result,
-    PLDAPControlW *serverctrls, PLDAPControlW *clientctrls )
+ULONG CDECL ldap_start_tls_sW( WLDAP32_LDAP *ld, ULONG *retval, WLDAP32_LDAPMessage **result,
+    LDAPControlW **serverctrls, LDAPControlW **clientctrls )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
-    LDAPControl **serverctrlsU = NULL, **clientctrlsU = NULL;
-
-    ret = WLDAP32_LDAP_NO_MEMORY;
+    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
+    LDAPControlU **serverctrlsU = NULL, **clientctrlsU = NULL;
 
     TRACE( "(%p, %p, %p, %p, %p)\n", ld, retval, result, serverctrls, clientctrls );
+    if (result)
+    {
+        FIXME( "result message not supported\n" );
+        *result = NULL;
+    }
 
     if (!ld) return ~0u;
 
-    if (serverctrls) {
-        serverctrlsU = controlarrayWtoU( serverctrls );
-        if (!serverctrlsU) goto exit;
-    }
-    if (clientctrls) {
-        clientctrlsU = controlarrayWtoU( clientctrls );
-        if (!clientctrlsU) goto exit;
-    }
+    if (serverctrls && !(serverctrlsU = controlarrayWtoU( serverctrls ))) goto exit;
+    if (clientctrls && !(clientctrlsU = controlarrayWtoU( clientctrls ))) goto exit;
 
-    ret = map_error( ldap_start_tls_s( ld->ld, serverctrlsU, clientctrlsU ));
+    ret = map_error( ldap_funcs->ldap_start_tls_s( ld->ld, serverctrlsU, clientctrlsU ) );
 
 exit:
     controlarrayfreeU( serverctrlsU );
     controlarrayfreeU( clientctrlsU );
-
-#endif
     return ret;
 }
 
 /***********************************************************************
  *      ldap_startup     (WLDAP32.@)
  */
-ULONG CDECL ldap_startup( PLDAP_VERSION_INFO version, HANDLE *instance )
+ULONG CDECL ldap_startup( LDAP_VERSION_INFO *version, HANDLE *instance )
 {
     TRACE( "(%p, %p)\n", version, instance );
     return WLDAP32_LDAP_SUCCESS;
diff --git a/dlls/wldap32/libldap.c b/dlls/wldap32/libldap.c
index de6974570f6a..cf2c2b7e38c0 100644
--- a/dlls/wldap32/libldap.c
+++ b/dlls/wldap32/libldap.c
@@ -414,6 +414,11 @@ void * CDECL wrap_ldap_first_reference( void *ld, void *chain )
     return ldap_first_reference( ld, chain );
 }
 
+int CDECL wrap_ldap_initialize( void **ld, const char *url )
+{
+    return ldap_initialize( (LDAP **)ld, url );
+}
+
 void CDECL wrap_ldap_memfree( void *ptr )
 {
     return ldap_memfree( ptr );
@@ -502,6 +507,16 @@ int CDECL wrap_ldap_search_ext_s( void *ld, const char *base, int scope, const c
                               (LDAPMessage **)result );
 }
 
+int CDECL wrap_ldap_set_option( void *ld, int option, const void *value )
+{
+    return ldap_set_option( ld, option, value );
+}
+
+int CDECL wrap_ldap_start_tls_s( void *ld, LDAPControlU **serverctrls, LDAPControlU **clientctrls )
+{
+    return ldap_start_tls_s( ld, (LDAPControl **)serverctrls, (LDAPControl **)clientctrls );
+}
+
 int CDECL wrap_ldap_unbind_ext( void *ld, LDAPControlU **serverctrls, LDAPControlU **clientctrls )
 {
     return ldap_unbind_ext( ld, (LDAPControl **)serverctrls, (LDAPControl **)clientctrls );
@@ -548,6 +563,7 @@ static const struct ldap_funcs funcs =
     wrap_ldap_extended_operation,
     wrap_ldap_extended_operation_s,
     wrap_ldap_get_dn,
+    wrap_ldap_initialize,
     wrap_ldap_first_attribute,
     wrap_ldap_first_entry,
     wrap_ldap_first_reference,
@@ -564,6 +580,8 @@ static const struct ldap_funcs funcs =
     wrap_ldap_sasl_interactive_bind_s,
     wrap_ldap_search_ext,
     wrap_ldap_search_ext_s,
+    wrap_ldap_set_option,
+    wrap_ldap_start_tls_s,
     wrap_ldap_unbind_ext,
     wrap_ldap_unbind_ext_s,
     wrap_ldap_value_free_len,
diff --git a/dlls/wldap32/libldap.h b/dlls/wldap32/libldap.h
index f3fc5796fdc1..9f26704d053c 100644
--- a/dlls/wldap32/libldap.h
+++ b/dlls/wldap32/libldap.h
@@ -119,6 +119,7 @@ extern int CDECL wrap_ldap_extended_operation(void *, const char *, struct berva
 extern int CDECL wrap_ldap_extended_operation_s(void *, const char *, struct bervalU *, LDAPControlU **,
                                                 LDAPControlU **, char **, struct bervalU **) DECLSPEC_HIDDEN;
 extern char * CDECL wrap_ldap_get_dn(void *, void *) DECLSPEC_HIDDEN;
+extern int CDECL wrap_ldap_initialize(void **, const char *) DECLSPEC_HIDDEN;
 extern char * CDECL wrap_ldap_first_attribute(void *, void *, void **) DECLSPEC_HIDDEN;
 extern void * CDECL wrap_ldap_first_entry(void *, void *) DECLSPEC_HIDDEN;
 extern void * CDECL wrap_ldap_first_reference(void *, void *) DECLSPEC_HIDDEN;
@@ -141,6 +142,8 @@ extern int CDECL wrap_ldap_search_ext(void *, const char *, int, const char *, c
                                       LDAPControlU **, struct timevalU *, int, ULONG *) DECLSPEC_HIDDEN;
 extern int CDECL wrap_ldap_search_ext_s(void *, const char *, int, const char *, char **, int, LDAPControlU **,
                                         LDAPControlU **, struct timevalU *, int, void **) DECLSPEC_HIDDEN;
+extern int CDECL wrap_ldap_set_option(void *, int, const void *) DECLSPEC_HIDDEN;
+extern int CDECL wrap_ldap_start_tls_s(void *, LDAPControlU **, LDAPControlU **) DECLSPEC_HIDDEN;
 extern int CDECL wrap_ldap_unbind_ext(void *, LDAPControlU **, LDAPControlU **) DECLSPEC_HIDDEN;
 extern int CDECL wrap_ldap_unbind_ext_s(void *, LDAPControlU **, LDAPControlU **) DECLSPEC_HIDDEN;
 extern void CDECL wrap_ldap_value_free_len(struct bervalU **) DECLSPEC_HIDDEN;
@@ -181,6 +184,7 @@ struct ldap_funcs
     int (CDECL *ldap_extended_operation_s)(void *, const char *, struct bervalU *, LDAPControlU **,
                                            LDAPControlU **, char **, struct bervalU **);
     char * (CDECL *ldap_get_dn)(void *, void *);
+    int (CDECL *ldap_initialize)(void **, const char *);
     char * (CDECL *ldap_first_attribute)(void *, void *, void **);
     void * (CDECL *ldap_first_entry)(void *, void *);
     void * (CDECL *ldap_first_reference)(void *, void *);
@@ -202,6 +206,8 @@ struct ldap_funcs
                                  LDAPControlU **, struct timevalU *, int, ULONG *);
     int (CDECL *ldap_search_ext_s)(void *, const char *, int, const char *, char **, int, LDAPControlU **,
                                    LDAPControlU **, struct timevalU *, int, void **);
+    int (CDECL *ldap_set_option)(void *, int, const void *);
+    int (CDECL *ldap_start_tls_s)(void *, LDAPControlU **, LDAPControlU **);
     int (CDECL *ldap_unbind_ext)(void *, LDAPControlU **, LDAPControlU **);
     int (CDECL *ldap_unbind_ext_s)(void *, LDAPControlU **, LDAPControlU **);
     void (CDECL *ldap_value_free_len)(struct bervalU **);
diff --git a/dlls/wldap32/winldap_private.h b/dlls/wldap32/winldap_private.h
index 20fc676c7e2a..7ac7e5a3f419 100644
--- a/dlls/wldap32/winldap_private.h
+++ b/dlls/wldap32/winldap_private.h
@@ -29,6 +29,10 @@
 
 #define WLDAP32_LBER_ERROR (~0L)
 
+#define WLDAP32_LDAP_VERSION1   1
+#define WLDAP32_LDAP_VERSION2   2
+#define WLDAP32_LDAP_VERSION3   3
+
 typedef enum {
     WLDAP32_LDAP_SUCCESS                 =   0x00,
     WLDAP32_LDAP_UNWILLING_TO_PERFORM    =   0x35,
From 512a51825fd753fa19cba4751adda2935c4d7a27 Mon Sep 17 00:00:00 2001
From: Hans Leidekker <hans@codeweavers.com>
Date: Fri, 16 Apr 2021 09:59:15 +0200
Subject: [PATCH] wldap32: Move support for modify functions to the Unix
 library.

Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/wldap32/libldap.c |  23 +++-
 dlls/wldap32/libldap.h |   6 +
 dlls/wldap32/modify.c  | 275 +++++++++--------------------------------
 3 files changed, 82 insertions(+), 222 deletions(-)

diff --git a/dlls/wldap32/libldap.c b/dlls/wldap32/libldap.c
index cf2c2b7e38c0..333ecc741c22 100644
--- a/dlls/wldap32/libldap.c
+++ b/dlls/wldap32/libldap.c
@@ -52,7 +52,7 @@ C_ASSERT( sizeof(LDAPSortKeyU) == sizeof(LDAPSortKey) );
 C_ASSERT( sizeof(LDAPVLVInfoU) == sizeof(LDAPVLVInfo) );
 C_ASSERT( sizeof(struct timevalU) == sizeof(struct timeval) );
 
-static LDAPMod *nullattrs[] = { NULL };
+static LDAPMod *nullmods[] = { NULL };
 
 static const struct ldap_callbacks *callbacks;
 
@@ -305,14 +305,14 @@ int CDECL wrap_ldap_add_ext( void *ld, const char *dn, LDAPModU **attrs, LDAPCon
                              LDAPControlU **clientctrls, ULONG *msg )
 {
     int dummy;
-    return ldap_add_ext( ld, dn ? dn : "", attrs ? (LDAPMod **)attrs : nullattrs, (LDAPControl **)serverctrls,
+    return ldap_add_ext( ld, dn ? dn : "", attrs ? (LDAPMod **)attrs : nullmods, (LDAPControl **)serverctrls,
                          (LDAPControl **)clientctrls, msg ? (int *)msg : &dummy );
 }
 
 int CDECL wrap_ldap_add_ext_s( void *ld, const char *dn, LDAPModU **attrs, LDAPControlU **serverctrls,
                                LDAPControlU **clientctrls )
 {
-    return ldap_add_ext_s( ld, dn ? dn : "", attrs ? (LDAPMod **)attrs : nullattrs, (LDAPControl **)serverctrls,
+    return ldap_add_ext_s( ld, dn ? dn : "", attrs ? (LDAPMod **)attrs : nullmods, (LDAPControl **)serverctrls,
                            (LDAPControl **)clientctrls );
 }
 
@@ -429,6 +429,21 @@ void CDECL wrap_ldap_memvfree( void **ptr )
     ldap_memvfree( ptr );
 }
 
+int CDECL wrap_ldap_modify_ext( void *ld, const char *dn, LDAPModU **mods, LDAPControlU **serverctrls,
+                                LDAPControlU **clientctrls, ULONG *msg )
+{
+    int dummy;
+    return ldap_modify_ext( ld, dn ? dn : "", mods ? (LDAPMod **)mods : nullmods, (LDAPControl **)serverctrls,
+                            (LDAPControl **)clientctrls, msg ? (int *)msg : &dummy );
+}
+
+int CDECL wrap_ldap_modify_ext_s( void *ld, const char *dn, LDAPModU **mods, LDAPControlU **serverctrls,
+                                  LDAPControlU **clientctrls )
+{
+    return ldap_modify_ext_s( ld, dn ? dn : "", mods ? (LDAPMod **)mods : nullmods, (LDAPControl **)serverctrls,
+                              (LDAPControl **)clientctrls );
+}
+
 int CDECL wrap_ldap_msgfree( void *msg )
 {
     return ldap_msgfree( msg );
@@ -569,6 +584,8 @@ static const struct ldap_funcs funcs =
     wrap_ldap_first_reference,
     wrap_ldap_memfree,
     wrap_ldap_memvfree,
+    wrap_ldap_modify_ext,
+    wrap_ldap_modify_ext_s,
     wrap_ldap_msgfree,
     wrap_ldap_next_attribute,
     wrap_ldap_next_entry,
diff --git a/dlls/wldap32/libldap.h b/dlls/wldap32/libldap.h
index 9f26704d053c..b99855e9d34c 100644
--- a/dlls/wldap32/libldap.h
+++ b/dlls/wldap32/libldap.h
@@ -125,6 +125,10 @@ extern void * CDECL wrap_ldap_first_entry(void *, void *) DECLSPEC_HIDDEN;
 extern void * CDECL wrap_ldap_first_reference(void *, void *) DECLSPEC_HIDDEN;
 extern void CDECL wrap_ldap_memfree(void *) DECLSPEC_HIDDEN;
 extern void CDECL wrap_ldap_memvfree(void **) DECLSPEC_HIDDEN;
+extern int CDECL wrap_ldap_modify_ext(void *, const char *, LDAPModU **, LDAPControlU **, LDAPControlU **,
+                                      ULONG *) DECLSPEC_HIDDEN;
+extern int CDECL wrap_ldap_modify_ext_s(void *, const char *, LDAPModU **, LDAPControlU **,
+                                        LDAPControlU **) DECLSPEC_HIDDEN;
 extern int CDECL wrap_ldap_msgfree(void *) DECLSPEC_HIDDEN;
 extern char * CDECL wrap_ldap_next_attribute(void *, void *, void *) DECLSPEC_HIDDEN;
 extern void * CDECL wrap_ldap_next_entry(void *, void *) DECLSPEC_HIDDEN;
@@ -190,6 +194,8 @@ struct ldap_funcs
     void * (CDECL *ldap_first_reference)(void *, void *);
     void (CDECL *ldap_memfree)(void *);
     void (CDECL *ldap_memvfree)(void **);
+    int (CDECL *ldap_modify_ext)(void *, const char *, LDAPModU **, LDAPControlU **, LDAPControlU **, ULONG *);
+    int (CDECL *ldap_modify_ext_s)(void *, const char *, LDAPModU **, LDAPControlU **, LDAPControlU **);
     int (CDECL *ldap_msgfree)(void *);
     char * (CDECL *ldap_next_attribute)(void *, void *, void *);
     void * (CDECL *ldap_next_entry)(void *, void *);
diff --git a/dlls/wldap32/modify.c b/dlls/wldap32/modify.c
index 7269df9da9f8..9655a0cf15e5 100644
--- a/dlls/wldap32/modify.c
+++ b/dlls/wldap32/modify.c
@@ -18,62 +18,39 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#include "config.h"
-#include "wine/port.h"
-
 #include <stdarg.h>
-#ifdef HAVE_LDAP_H
-#include <ldap.h>
-#endif
-
 #include "windef.h"
 #include "winbase.h"
 #include "winnls.h"
 
-#include "winldap_private.h"
-#include "wldap32.h"
 #include "wine/debug.h"
+#include "winldap_private.h"
 
-#ifdef HAVE_LDAP
 WINE_DEFAULT_DEBUG_CHANNEL(wldap32);
 
-static LDAPMod *nullmods[] = { NULL };
-#endif
-
 /***********************************************************************
  *      ldap_modifyA     (WLDAP32.@)
  *
  * See ldap_modifyW.
  */
-ULONG CDECL ldap_modifyA( WLDAP32_LDAP *ld, PCHAR dn, LDAPModA *mods[] )
+ULONG CDECL ldap_modifyA( WLDAP32_LDAP *ld, char *dn, LDAPModA **mods )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
     WCHAR *dnW = NULL;
     LDAPModW **modsW = NULL;
-    
-    ret = WLDAP32_LDAP_NO_MEMORY;
 
     TRACE( "(%p, %s, %p)\n", ld, debugstr_a(dn), mods );
 
     if (!ld) return ~0u;
 
-    if (dn) {
-        dnW = strAtoW( dn );
-        if (!dnW) goto exit;
-    }
-    if (mods) {
-        modsW = modarrayAtoW( mods );
-        if (!modsW) goto exit;
-    }
+    if (dn && !(dnW = strAtoW( dn ))) goto exit;
+    if (mods && !(modsW = modarrayAtoW( mods ))) goto exit;
 
     ret = ldap_modifyW( ld, dnW, modsW );
 
 exit:
     strfreeW( dnW );
     modarrayfreeW( modsW );
-
-#endif
     return ret;
 }
 
@@ -97,43 +74,15 @@ ULONG CDECL ldap_modifyA( WLDAP32_LDAP *ld, PCHAR dn, LDAPModA *mods[] )
  *  the operation. Cancel the operation by calling ldap_abandon
  *  with the message ID.
  */
-ULONG CDECL ldap_modifyW( WLDAP32_LDAP *ld, PWCHAR dn, LDAPModW *mods[] )
+ULONG CDECL ldap_modifyW( WLDAP32_LDAP *ld, WCHAR *dn, LDAPModW **mods )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
-    char *dnU = NULL;
-    LDAPMod **modsU = NULL;
-    int msg;
-
-    ret = WLDAP32_LDAP_NO_MEMORY;
+    ULONG ret, msg;
 
     TRACE( "(%p, %s, %p)\n", ld, debugstr_w(dn), mods );
 
-    if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
-
-    if (dn) {
-        dnU = strWtoU( dn );
-        if (!dnU) goto exit;
-    }
-    if (mods) {
-        modsU = modarrayWtoU( mods );
-        if (!modsU) goto exit;
-    }
-
-    ret = ldap_modify_ext( ld->ld, dn ? dnU : "", mods ? modsU : nullmods,
-                           NULL, NULL, &msg );
-
-    if (ret == LDAP_SUCCESS)
-        ret = msg;
-    else
-        ret = ~0u;
-
-exit:
-    strfreeU( dnU );
-    modarrayfreeU( modsU );
-
-#endif
-    return ret;
+    ret = ldap_modify_extW( ld, dn, mods, NULL, NULL, &msg );
+    if (ret == WLDAP32_LDAP_SUCCESS) return msg;
+    return ~0u;
 }
 
 /***********************************************************************
@@ -141,38 +90,22 @@ ULONG CDECL ldap_modifyW( WLDAP32_LDAP *ld, PWCHAR dn, LDAPModW *mods[] )
  *
  * See ldap_modify_extW.
  */
-ULONG CDECL ldap_modify_extA( WLDAP32_LDAP *ld, PCHAR dn, LDAPModA *mods[],
-    PLDAPControlA *serverctrls, PLDAPControlA *clientctrls, ULONG *message )
+ULONG CDECL ldap_modify_extA( WLDAP32_LDAP *ld, char *dn, LDAPModA **mods,
+    LDAPControlA **serverctrls, LDAPControlA **clientctrls, ULONG *message )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
     WCHAR *dnW = NULL;
     LDAPModW **modsW = NULL;
     LDAPControlW **serverctrlsW = NULL, **clientctrlsW = NULL;
 
-    ret = WLDAP32_LDAP_NO_MEMORY;
-
-    TRACE( "(%p, %s, %p, %p, %p, %p)\n", ld, debugstr_a(dn), mods,
-           serverctrls, clientctrls, message );
+    TRACE( "(%p, %s, %p, %p, %p, %p)\n", ld, debugstr_a(dn), mods, serverctrls, clientctrls, message );
 
     if (!ld) return ~0u;
 
-    if (dn) {
-        dnW = strAtoW( dn );
-        if (!dnW) goto exit;
-    }
-    if (mods) {
-        modsW = modarrayAtoW( mods );
-        if (!modsW) goto exit;
-    }
-    if (serverctrls) {
-        serverctrlsW = controlarrayAtoW( serverctrls );
-        if (!serverctrlsW) goto exit;
-    }
-    if (clientctrls) {
-        clientctrlsW = controlarrayAtoW( clientctrls );
-        if (!clientctrlsW) goto exit;
-    }
+    if (dn && !(dnW = strAtoW( dn ))) goto exit;
+    if (mods && !(modsW = modarrayAtoW( mods ))) goto exit;
+    if (serverctrls && !(serverctrlsW = controlarrayAtoW( serverctrls ))) goto exit;
+    if (clientctrls && !(clientctrlsW = controlarrayAtoW( clientctrls ))) goto exit;
 
     ret = ldap_modify_extW( ld, dnW, modsW, serverctrlsW, clientctrlsW, message );
 
@@ -181,8 +114,6 @@ ULONG CDECL ldap_modify_extA( WLDAP32_LDAP *ld, PCHAR dn, LDAPModA *mods[],
     modarrayfreeW( modsW );
     controlarrayfreeW( serverctrlsW );
     controlarrayfreeW( clientctrlsW );
-
-#endif
     return ret;
 }
 
@@ -209,50 +140,30 @@ ULONG CDECL ldap_modify_extA( WLDAP32_LDAP *ld, PCHAR dn, LDAPModA *mods[],
  *  the operation. The serverctrls and clientctrls parameters are
  *  optional and should be set to NULL if not used.
  */
-ULONG CDECL ldap_modify_extW( WLDAP32_LDAP *ld, PWCHAR dn, LDAPModW *mods[],
-    PLDAPControlW *serverctrls, PLDAPControlW *clientctrls, ULONG *message )
+ULONG CDECL ldap_modify_extW( WLDAP32_LDAP *ld, WCHAR *dn, LDAPModW **mods,
+    LDAPControlW **serverctrls, LDAPControlW **clientctrls, ULONG *message )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
     char *dnU = NULL;
-    LDAPMod **modsU = NULL;
-    LDAPControl **serverctrlsU = NULL, **clientctrlsU = NULL;
-    int dummy;
+    LDAPModU **modsU = NULL;
+    LDAPControlU **serverctrlsU = NULL, **clientctrlsU = NULL;
 
-    ret = WLDAP32_LDAP_NO_MEMORY;
-
-    TRACE( "(%p, %s, %p, %p, %p, %p)\n", ld, debugstr_w(dn), mods,
-           serverctrls, clientctrls, message );
+    TRACE( "(%p, %s, %p, %p, %p, %p)\n", ld, debugstr_w(dn), mods, serverctrls, clientctrls, message );
 
     if (!ld) return ~0u;
 
-    if (dn) {
-        dnU = strWtoU( dn );
-        if (!dnU) goto exit;
-    }
-    if (mods) {
-        modsU = modarrayWtoU( mods );
-        if (!modsU) goto exit;
-    }
-    if (serverctrls) {
-        serverctrlsU = controlarrayWtoU( serverctrls );
-        if (!serverctrlsU) goto exit;
-    }
-    if (clientctrls) {
-        clientctrlsU = controlarrayWtoU( clientctrls );
-        if (!clientctrlsU) goto exit;
-    }
-
-    ret = map_error( ldap_modify_ext( ld->ld, dn ? dnU : "", mods ? modsU : nullmods, serverctrlsU,
-                                      clientctrlsU, message ? (int *)message : &dummy ));
+    if (dn && !(dnU = strWtoU( dn ))) goto exit;
+    if (mods && !(modsU = modarrayWtoU( mods ))) goto exit;
+    if (serverctrls && !(serverctrlsU = controlarrayWtoU( serverctrls ))) goto exit;
+    if (clientctrls && !(clientctrlsU = controlarrayWtoU( clientctrls ))) goto exit;
+
+    ret = map_error( ldap_funcs->ldap_modify_ext( ld->ld, dnU, modsU, serverctrlsU, clientctrlsU, message ) );
 
 exit:
     strfreeU( dnU );
     modarrayfreeU( modsU );
     controlarrayfreeU( serverctrlsU );
     controlarrayfreeU( clientctrlsU );
-
-#endif
     return ret;
 }
 
@@ -261,38 +172,22 @@ ULONG CDECL ldap_modify_extW( WLDAP32_LDAP *ld, PWCHAR dn, LDAPModW *mods[],
  *
  * See ldap_modify_ext_sW.
  */
-ULONG CDECL ldap_modify_ext_sA( WLDAP32_LDAP *ld, PCHAR dn, LDAPModA *mods[],
-    PLDAPControlA *serverctrls, PLDAPControlA *clientctrls )
+ULONG CDECL ldap_modify_ext_sA( WLDAP32_LDAP *ld, char *dn, LDAPModA **mods,
+    LDAPControlA **serverctrls, LDAPControlA **clientctrls )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
     WCHAR *dnW = NULL;
     LDAPModW **modsW = NULL;
     LDAPControlW **serverctrlsW = NULL, **clientctrlsW = NULL;
 
-    ret = WLDAP32_LDAP_NO_MEMORY;
-
-    TRACE( "(%p, %s, %p, %p, %p)\n", ld, debugstr_a(dn), mods,
-           serverctrls, clientctrls );
+    TRACE( "(%p, %s, %p, %p, %p)\n", ld, debugstr_a(dn), mods, serverctrls, clientctrls );
 
     if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
 
-    if (dn) {
-        dnW = strAtoW( dn );
-        if (!dnW) goto exit;
-    }
-    if (mods) {
-        modsW = modarrayAtoW( mods );
-        if (!modsW) goto exit;
-    }
-    if (serverctrls) {
-        serverctrlsW = controlarrayAtoW( serverctrls );
-        if (!serverctrlsW) goto exit;
-    }
-    if (clientctrls) {
-        clientctrlsW = controlarrayAtoW( clientctrls );
-        if (!clientctrlsW) goto exit;
-    }
+    if (dn && !(dnW = strAtoW( dn ))) goto exit;
+    if (mods && !(modsW = modarrayAtoW( mods ))) goto exit;
+    if (serverctrls && !(serverctrlsW = controlarrayAtoW( serverctrls ))) goto exit;
+    if (clientctrls && !(clientctrlsW = controlarrayAtoW( clientctrls ))) goto exit;
 
     ret = ldap_modify_ext_sW( ld, dnW, modsW, serverctrlsW, clientctrlsW );
 
@@ -301,8 +196,6 @@ ULONG CDECL ldap_modify_ext_sA( WLDAP32_LDAP *ld, PCHAR dn, LDAPModA *mods[],
     modarrayfreeW( modsW );
     controlarrayfreeW( serverctrlsW );
     controlarrayfreeW( clientctrlsW );
-
-#endif
     return ret;
 }
 
@@ -327,49 +220,30 @@ ULONG CDECL ldap_modify_ext_sA( WLDAP32_LDAP *ld, PCHAR dn, LDAPModA *mods[],
  *  The serverctrls and clientctrls parameters are optional and
  *  should be set to NULL if not used.
  */
-ULONG CDECL ldap_modify_ext_sW( WLDAP32_LDAP *ld, PWCHAR dn, LDAPModW *mods[],
-    PLDAPControlW *serverctrls, PLDAPControlW *clientctrls )
+ULONG CDECL ldap_modify_ext_sW( WLDAP32_LDAP *ld, WCHAR *dn, LDAPModW **mods,
+    LDAPControlW **serverctrls, LDAPControlW **clientctrls )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
     char *dnU = NULL;
-    LDAPMod **modsU = NULL;
-    LDAPControl **serverctrlsU = NULL, **clientctrlsU = NULL;
+    LDAPModU **modsU = NULL;
+    LDAPControlU **serverctrlsU = NULL, **clientctrlsU = NULL;
 
-    ret = WLDAP32_LDAP_NO_MEMORY;
-
-    TRACE( "(%p, %s, %p, %p, %p)\n", ld, debugstr_w(dn), mods,
-           serverctrls, clientctrls );
+    TRACE( "(%p, %s, %p, %p, %p)\n", ld, debugstr_w(dn), mods, serverctrls, clientctrls );
 
     if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
 
-    if (dn) {
-        dnU = strWtoU( dn );
-        if (!dnU) goto exit;
-    }
-    if (mods) {
-        modsU = modarrayWtoU( mods );
-        if (!modsU) goto exit;
-    }
-    if (serverctrls) {
-        serverctrlsU = controlarrayWtoU( serverctrls );
-        if (!serverctrlsU) goto exit;
-    }
-    if (clientctrls) {
-        clientctrlsU = controlarrayWtoU( clientctrls );
-        if (!clientctrlsU) goto exit;
-    }
-
-    ret = map_error( ldap_modify_ext_s( ld->ld, dn ? dnU : "", mods ? modsU : nullmods,
-                                        serverctrlsU, clientctrlsU ));
+    if (dn && !(dnU = strWtoU( dn ))) goto exit;
+    if (mods && !(modsU = modarrayWtoU( mods ))) goto exit;
+    if (serverctrls && !(serverctrlsU = controlarrayWtoU( serverctrls ))) goto exit;
+    if (clientctrls && !(clientctrlsU = controlarrayWtoU( clientctrls ))) goto exit;
+
+    ret = map_error( ldap_funcs->ldap_modify_ext_s( ld->ld, dnU, modsU, serverctrlsU, clientctrlsU ) );
 
 exit:
     strfreeU( dnU );
     modarrayfreeU( modsU );
     controlarrayfreeU( serverctrlsU );
     controlarrayfreeU( clientctrlsU );
-
-#endif
     return ret;
 }
 
@@ -378,35 +252,24 @@ ULONG CDECL ldap_modify_ext_sW( WLDAP32_LDAP *ld, PWCHAR dn, LDAPModW *mods[],
  *
  * See ldap_modify_sW.
  */
-ULONG CDECL ldap_modify_sA( WLDAP32_LDAP *ld, PCHAR dn, LDAPModA *mods[] )
+ULONG CDECL ldap_modify_sA( WLDAP32_LDAP *ld, char *dn, LDAPModA **mods )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
     WCHAR *dnW = NULL;
     LDAPModW **modsW = NULL;
 
-    ret = WLDAP32_LDAP_NO_MEMORY;
-
     TRACE( "(%p, %s, %p)\n", ld, debugstr_a(dn), mods );
 
     if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
 
-    if (dn) {
-        dnW = strAtoW( dn );
-        if (!dnW) goto exit;
-    }
-    if (mods) {
-        modsW = modarrayAtoW( mods );
-        if (!modsW) goto exit;
-    }
+    if (dn && !(dnW = strAtoW( dn ))) goto exit;
+    if (mods && !(modsW = modarrayAtoW( mods ))) goto exit;
 
     ret = ldap_modify_sW( ld, dnW, modsW );
 
 exit:
     strfreeW( dnW );
     modarrayfreeW( modsW );
-
-#endif
     return ret;
 }
 
@@ -425,34 +288,8 @@ ULONG CDECL ldap_modify_sA( WLDAP32_LDAP *ld, PCHAR dn, LDAPModA *mods[] )
  *  Success: LDAP_SUCCESS
  *  Failure: An LDAP error code.
  */
-ULONG CDECL ldap_modify_sW( WLDAP32_LDAP *ld, PWCHAR dn, LDAPModW *mods[] )
+ULONG CDECL ldap_modify_sW( WLDAP32_LDAP *ld, WCHAR *dn, LDAPModW **mods )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
-    char *dnU = NULL;
-    LDAPMod **modsU = NULL;
-
-    ret = WLDAP32_LDAP_NO_MEMORY;
-
     TRACE( "(%p, %s, %p)\n", ld, debugstr_w(dn), mods );
-
-    if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
-
-    if (dn) {
-        dnU = strWtoU( dn );
-        if (!dnU) goto exit;
-    }
-    if (mods) {
-        modsU = modarrayWtoU( mods );
-        if (!modsU) goto exit;
-    }
-
-    ret = map_error( ldap_modify_ext_s( ld->ld, dn ? dnU : "", mods ? modsU : nullmods, NULL, NULL ));
-
-exit:
-    strfreeU( dnU );
-    modarrayfreeU( modsU );
-
-#endif
-    return ret;
+    return ldap_modify_ext_sW( ld, dn, mods, NULL, NULL );
 }
From d48a9495ce2379e919dceab9e7085cd7946a11e7 Mon Sep 17 00:00:00 2001
From: Hans Leidekker <hans@codeweavers.com>
Date: Fri, 16 Apr 2021 09:59:16 +0200
Subject: [PATCH] wldap32: Move support for modrdn functions to the Unix
 library.

Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/wldap32/libldap.c |  16 ++++
 dlls/wldap32/libldap.h |   7 ++
 dlls/wldap32/modrdn.c  | 199 ++++++++---------------------------------
 3 files changed, 60 insertions(+), 162 deletions(-)

diff --git a/dlls/wldap32/libldap.c b/dlls/wldap32/libldap.c
index 333ecc741c22..e9353e2e3f43 100644
--- a/dlls/wldap32/libldap.c
+++ b/dlls/wldap32/libldap.c
@@ -470,6 +470,20 @@ int CDECL wrap_ldap_parse_result( void *ld, void *res, int *errcode, char **matc
     return ldap_parse_result( ld, res, errcode, matcheddn, errmsg, referrals, (LDAPControl ***)serverctrls, free );
 }
 
+int CDECL wrap_ldap_rename( void *ld, const char *dn, const char *newrdn, const char *newparent, int delete,
+                            LDAPControlU **clientctrls, LDAPControlU **serverctrls, ULONG *msg )
+{
+    return ldap_rename( ld, dn ? dn : "", newrdn, newparent, delete, (LDAPControl **)clientctrls,
+                        (LDAPControl **)serverctrls, (int *)msg );
+}
+
+int CDECL wrap_ldap_rename_s( void *ld, const char *dn, const char *newrdn, const char *newparent, int delete,
+                              LDAPControlU **clientctrls, LDAPControlU **serverctrls )
+{
+    return ldap_rename_s( ld, dn ? dn : "", newrdn, newparent, delete, (LDAPControl **)clientctrls,
+                          (LDAPControl **)serverctrls );
+}
+
 int CDECL wrap_ldap_result( void *ld, int msgid, int all, struct timevalU *timeout, void **result )
 {
     return ldap_result( ld, msgid, all, (struct timeval *)timeout, (LDAPMessage **)result );
@@ -591,6 +605,8 @@ static const struct ldap_funcs funcs =
     wrap_ldap_next_entry,
     wrap_ldap_next_reference,
     wrap_ldap_parse_result,
+    wrap_ldap_rename,
+    wrap_ldap_rename_s,
     wrap_ldap_result,
     wrap_ldap_sasl_bind,
     wrap_ldap_sasl_bind_s,
diff --git a/dlls/wldap32/libldap.h b/dlls/wldap32/libldap.h
index b99855e9d34c..1b0a2be4ba17 100644
--- a/dlls/wldap32/libldap.h
+++ b/dlls/wldap32/libldap.h
@@ -135,6 +135,10 @@ extern void * CDECL wrap_ldap_next_entry(void *, void *) DECLSPEC_HIDDEN;
 extern void * CDECL wrap_ldap_next_reference(void *, void *) DECLSPEC_HIDDEN;
 extern int CDECL wrap_ldap_parse_result(void *, void *, int *, char **, char **, char ***, LDAPControlU ***,
                                         int) DECLSPEC_HIDDEN;
+extern int CDECL wrap_ldap_rename(void *, const char *, const char *, const char *, int, LDAPControlU **,
+                                  LDAPControlU **, ULONG *) DECLSPEC_HIDDEN;
+extern int CDECL wrap_ldap_rename_s(void *, const char *, const char *, const char *, int, LDAPControlU **,
+                                    LDAPControlU **) DECLSPEC_HIDDEN;
 extern int CDECL wrap_ldap_result(void *, int, int, struct timevalU *, void **) DECLSPEC_HIDDEN;
 extern int CDECL wrap_ldap_sasl_bind(void *, const char *, const char *, struct bervalU *, LDAPControlU **,
                                      LDAPControlU **, int *) DECLSPEC_HIDDEN;
@@ -201,6 +205,9 @@ struct ldap_funcs
     void * (CDECL *ldap_next_entry)(void *, void *);
     void * (CDECL *ldap_next_reference)(void *, void *);
     int (CDECL *ldap_parse_result)(void *, void *, int *, char **, char **, char ***, LDAPControlU ***, int);
+    int (CDECL *ldap_rename)(void *, const char *, const char *, const char *, int, LDAPControlU **, LDAPControlU **,
+                             ULONG *);
+    int (CDECL *ldap_rename_s)(void *, const char *, const char *, const char *, int, LDAPControlU **, LDAPControlU **);
     int (CDECL *ldap_result)(void *, int, int, struct timevalU *, void **);
     int (CDECL *ldap_sasl_bind)(void *, const char *, const char *, struct bervalU *, LDAPControlU **, LDAPControlU **,
                                 int *);
diff --git a/dlls/wldap32/modrdn.c b/dlls/wldap32/modrdn.c
index c9e232140ca9..c297c7e90b6f 100644
--- a/dlls/wldap32/modrdn.c
+++ b/dlls/wldap32/modrdn.c
@@ -18,58 +18,38 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#include "config.h"
-#include "wine/port.h"
-
 #include <stdarg.h>
-#ifdef HAVE_LDAP_H
-#include <ldap.h>
-#endif
-
 #include "windef.h"
 #include "winbase.h"
 #include "winnls.h"
 
-#include "winldap_private.h"
-#include "wldap32.h"
 #include "wine/debug.h"
+#include "winldap_private.h"
 
-#ifdef HAVE_LDAP
 WINE_DEFAULT_DEBUG_CHANNEL(wldap32);
-#endif
 
 /***********************************************************************
  *      ldap_modrdnA     (WLDAP32.@)
  *
  * See ldap_modrdnW.
  */
-ULONG CDECL ldap_modrdnA( WLDAP32_LDAP *ld, PCHAR dn, PCHAR newdn )
+ULONG CDECL ldap_modrdnA( WLDAP32_LDAP *ld, char *dn, char *newdn )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
     WCHAR *dnW = NULL, *newdnW = NULL;
 
-    ret = WLDAP32_LDAP_NO_MEMORY;
-
     TRACE( "(%p, %s, %s)\n", ld, debugstr_a(dn), debugstr_a(newdn) );
 
     if (!ld || !newdn) return ~0u;
 
-    if (dn) {
-        dnW = strAtoW( dn );
-        if (!dnW) goto exit;
-    }
-
-    newdnW = strAtoW( newdn );
-    if (!newdnW) goto exit;
+    if (dn && !(dnW = strAtoW( dn ))) goto exit;
+    if (!(newdnW = strAtoW( newdn ))) goto exit;
 
     ret = ldap_modrdnW( ld, dnW, newdnW );
 
 exit:
     strfreeW( dnW );
     strfreeW( newdnW );
-
-#endif
     return ret;
 }
 
@@ -81,7 +61,7 @@ ULONG CDECL ldap_modrdnA( WLDAP32_LDAP *ld, PCHAR dn, PCHAR newdn )
  * PARAMS
  *  ld      [I] Pointer to an LDAP context.
  *  dn      [I] DN of the entry to change.
- *  newdn   [I] New DN for the entry. 
+ *  newdn   [I] New DN for the entry.
  *
  * RETURNS
  *  Success: Message ID of the modrdn operation.
@@ -92,40 +72,10 @@ ULONG CDECL ldap_modrdnA( WLDAP32_LDAP *ld, PCHAR dn, PCHAR newdn )
  *  the operation. Cancel the operation by calling ldap_abandon
  *  with the message ID.
  */
-ULONG CDECL ldap_modrdnW( WLDAP32_LDAP *ld, PWCHAR dn, PWCHAR newdn )
+ULONG CDECL ldap_modrdnW( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *newdn )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
-    char *dnU = NULL, *newdnU = NULL;
-    int msg;
-
-    ret = WLDAP32_LDAP_NO_MEMORY;
-
     TRACE( "(%p, %s, %s)\n", ld, debugstr_w(dn), debugstr_w(newdn) );
-
-    if (!ld || !newdn) return ~0u;
-
-    if (dn) {
-        dnU = strWtoU( dn );
-        if (!dnU) goto exit;
-    }
-
-    newdnU = strWtoU( newdn );
-    if (!newdnU) goto exit;
-
-    ret = ldap_rename( ld->ld, dn ? dnU : "", newdnU, NULL, 1, NULL, NULL, &msg );
-
-    if (ret == LDAP_SUCCESS)
-        ret = msg;
-    else
-        ret = ~0u;
-
-exit:
-    strfreeU( dnU );
-    strfreeU( newdnU );
-
-#endif
-    return ret;
+    return ldap_modrdn2W( ld, dn, newdn, 1 );
 }
 
 /***********************************************************************
@@ -133,33 +83,23 @@ ULONG CDECL ldap_modrdnW( WLDAP32_LDAP *ld, PWCHAR dn, PWCHAR newdn )
  *
  * See ldap_modrdn2W.
  */
-ULONG CDECL ldap_modrdn2A( WLDAP32_LDAP *ld, PCHAR dn, PCHAR newdn, INT delete )
+ULONG CDECL ldap_modrdn2A( WLDAP32_LDAP *ld, char *dn, char *newdn, int delete )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
     WCHAR *dnW = NULL, *newdnW = NULL;
 
-    ret = WLDAP32_LDAP_NO_MEMORY;
-
     TRACE( "(%p, %s, %p, 0x%02x)\n", ld, debugstr_a(dn), newdn, delete );
 
     if (!ld || !newdn) return ~0u;
 
-    if (dn) {
-        dnW = strAtoW( dn );
-        if (!dnW) goto exit;
-    }
-
-    newdnW = strAtoW( newdn );
-    if (!newdnW) goto exit;
+    if (dn && !(dnW = strAtoW( dn ))) goto exit;
+    if (!(newdnW = strAtoW( newdn ))) goto exit;
 
     ret = ldap_modrdn2W( ld, dnW, newdnW, delete );
 
 exit:
     strfreeW( dnW );
     strfreeW( newdnW );
-
-#endif
     return ret;
 }
 
@@ -171,7 +111,7 @@ ULONG CDECL ldap_modrdn2A( WLDAP32_LDAP *ld, PCHAR dn, PCHAR newdn, INT delete )
  * PARAMS
  *  ld      [I] Pointer to an LDAP context.
  *  dn      [I] DN of the entry to change.
- *  newdn   [I] New DN for the entry. 
+ *  newdn   [I] New DN for the entry.
  *  delete  [I] Delete old DN?
  *
  * RETURNS
@@ -183,30 +123,21 @@ ULONG CDECL ldap_modrdn2A( WLDAP32_LDAP *ld, PCHAR dn, PCHAR newdn, INT delete )
  *  the operation. Cancel the operation by calling ldap_abandon
  *  with the message ID.
  */
-ULONG CDECL ldap_modrdn2W( WLDAP32_LDAP *ld, PWCHAR dn, PWCHAR newdn, INT delete )
+ULONG CDECL ldap_modrdn2W( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *newdn, int delete )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
     char *dnU = NULL, *newdnU = NULL;
-    int msg;
-
-    ret = WLDAP32_LDAP_NO_MEMORY;
+    ULONG msg;
 
     TRACE( "(%p, %s, %p, 0x%02x)\n", ld, debugstr_w(dn), newdn, delete );
 
     if (!ld || !newdn) return ~0u;
 
-    if (dn) {
-        dnU = strWtoU( dn );
-        if (!dnU) goto exit;
-    }
-
-    newdnU = strWtoU( newdn );
-    if (!newdnU) goto exit;
+    if (dn && !(dnU = strWtoU( dn ))) goto exit;
+    if (!(newdnU = strWtoU( newdn ))) goto exit;
 
-    ret = ldap_rename( ld->ld, dn ? dnU : "", newdnU, NULL, delete, NULL, NULL, &msg );
-
-    if (ret == LDAP_SUCCESS)
+    ret = ldap_funcs->ldap_rename( ld->ld, dnU, newdnU, NULL, delete, NULL, NULL, &msg );
+    if (ret == WLDAP32_LDAP_SUCCESS)
         ret = msg;
     else
         ret = ~0u;
@@ -214,8 +145,6 @@ ULONG CDECL ldap_modrdn2W( WLDAP32_LDAP *ld, PWCHAR dn, PWCHAR newdn, INT delete
 exit:
     strfreeU( dnU );
     strfreeU( newdnU );
-
-#endif
     return ret;
 }
 
@@ -224,33 +153,23 @@ ULONG CDECL ldap_modrdn2W( WLDAP32_LDAP *ld, PWCHAR dn, PWCHAR newdn, INT delete
  *
  * See ldap_modrdn2_sW.
  */
-ULONG CDECL ldap_modrdn2_sA( WLDAP32_LDAP *ld, PCHAR dn, PCHAR newdn, INT delete )
+ULONG CDECL ldap_modrdn2_sA( WLDAP32_LDAP *ld, char *dn, char *newdn, int delete )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
     WCHAR *dnW = NULL, *newdnW = NULL;
 
-    ret = WLDAP32_LDAP_NO_MEMORY;
-
     TRACE( "(%p, %s, %p, 0x%02x)\n", ld, debugstr_a(dn), newdn, delete );
 
     if (!ld || !newdn) return WLDAP32_LDAP_PARAM_ERROR;
 
-    if (dn) {
-        dnW = strAtoW( dn );
-        if (!dnW) goto exit;
-    }
-
-    newdnW = strAtoW( newdn );
-    if (!newdnW) goto exit;
+    if (dn && !(dnW = strAtoW( dn ))) goto exit;
+    if (!(newdnW = strAtoW( newdn ))) goto exit;
 
     ret = ldap_modrdn2_sW( ld, dnW, newdnW, delete );
 
 exit:
     strfreeW( dnW );
     strfreeW( newdnW );
-
-#endif
     return ret;
 }
 
@@ -262,40 +181,30 @@ ULONG CDECL ldap_modrdn2_sA( WLDAP32_LDAP *ld, PCHAR dn, PCHAR newdn, INT delete
  * PARAMS
  *  ld      [I] Pointer to an LDAP context.
  *  dn      [I] DN of the entry to change.
- *  newdn   [I] New DN for the entry. 
+ *  newdn   [I] New DN for the entry.
  *  delete  [I] Delete old DN?
  *
  * RETURNS
  *  Success: LDAP_SUCCESS
  *  Failure: An LDAP error code.
  */
-ULONG CDECL ldap_modrdn2_sW( WLDAP32_LDAP *ld, PWCHAR dn, PWCHAR newdn, INT delete )
+ULONG CDECL ldap_modrdn2_sW( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *newdn, int delete )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
     char *dnU = NULL, *newdnU = NULL;
 
-    ret = WLDAP32_LDAP_NO_MEMORY;
-
     TRACE( "(%p, %s, %p, 0x%02x)\n", ld, debugstr_w(dn), newdn, delete );
 
     if (!ld || !newdn) return WLDAP32_LDAP_PARAM_ERROR;
 
-    if (dn) {
-        dnU = strWtoU( dn );
-        if (!dnU) goto exit;
-    }
-
-    newdnU = strWtoU( newdn );
-    if (!newdnU) goto exit;
+    if (dn && !(dnU = strWtoU( dn ))) goto exit;
+    if (!(newdnU = strWtoU( newdn ))) goto exit;
 
-    ret = map_error( ldap_rename_s( ld->ld, dn ? dnU : "", newdnU, NULL, delete, NULL, NULL ));
+    ret = map_error( ldap_funcs->ldap_rename_s( ld->ld, dnU, newdnU, NULL, delete, NULL, NULL ));
 
 exit:
     strfreeU( dnU );
     strfreeU( newdnU );
-
-#endif
     return ret;
 }
 
@@ -304,33 +213,23 @@ ULONG CDECL ldap_modrdn2_sW( WLDAP32_LDAP *ld, PWCHAR dn, PWCHAR newdn, INT dele
  *
  * See ldap_modrdn_sW.
  */
-ULONG CDECL ldap_modrdn_sA( WLDAP32_LDAP *ld, PCHAR dn, PCHAR newdn )
+ULONG CDECL ldap_modrdn_sA( WLDAP32_LDAP *ld, char *dn, char *newdn )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
     WCHAR *dnW = NULL, *newdnW = NULL;
 
-    ret = WLDAP32_LDAP_NO_MEMORY;
-
     TRACE( "(%p, %s, %p)\n", ld, debugstr_a(dn), newdn );
 
     if (!ld || !newdn) return WLDAP32_LDAP_PARAM_ERROR;
 
-    if (dn) {
-        dnW = strAtoW( dn );
-        if (!dnW) goto exit;
-    }
-
-    newdnW = strAtoW( newdn );
-    if (!newdnW) goto exit;
+    if (dn && !(dnW = strAtoW( dn ))) goto exit;
+    if (!(newdnW = strAtoW( newdn ))) goto exit;
 
     ret = ldap_modrdn_sW( ld, dnW, newdnW );
 
 exit:
     strfreeW( dnW );
     strfreeW( newdnW );
-
-#endif
     return ret;
 }
 
@@ -342,38 +241,14 @@ ULONG CDECL ldap_modrdn_sA( WLDAP32_LDAP *ld, PCHAR dn, PCHAR newdn )
  * PARAMS
  *  ld      [I] Pointer to an LDAP context.
  *  dn      [I] DN of the entry to change.
- *  newdn   [I] New DN for the entry. 
+ *  newdn   [I] New DN for the entry.
  *
  * RETURNS
  *  Success: LDAP_SUCCESS
  *  Failure: An LDAP error code.
  */
-ULONG CDECL ldap_modrdn_sW( WLDAP32_LDAP *ld, PWCHAR dn, PWCHAR newdn )
+ULONG CDECL ldap_modrdn_sW( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *newdn )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
-    char *dnU = NULL, *newdnU = NULL;
-
-    ret = WLDAP32_LDAP_NO_MEMORY;
-
     TRACE( "(%p, %s, %p)\n", ld, debugstr_w(dn), newdn );
-
-    if (!ld || !newdn) return WLDAP32_LDAP_PARAM_ERROR;
-
-    if (dn) {
-        dnU = strWtoU( dn );
-        if (!dnU) goto exit;
-    }
-
-    newdnU = strWtoU( newdn );
-    if (!newdnU) goto exit;
-
-    ret = map_error( ldap_rename_s( ld->ld, dn ? dnU : "", newdnU, NULL, 1, NULL, NULL ));
-
-exit:
-    strfreeU( dnU );
-    strfreeU( newdnU );
-
-#endif
-    return ret;
+    return ldap_modrdn2_sW( ld, dn, newdn, 1 );
 }
From da4d701bb795233a971016d5bdc824b5738fc49b Mon Sep 17 00:00:00 2001
From: Hans Leidekker <hans@codeweavers.com>
Date: Fri, 16 Apr 2021 09:59:17 +0200
Subject: [PATCH] wldap32: Move support for option functions to the Unix
 library.

Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/wldap32/libldap.c         |  20 ++++
 dlls/wldap32/libldap.h         |  23 +++++
 dlls/wldap32/option.c          | 170 ++++++++++++---------------------
 dlls/wldap32/winldap_private.h |   7 ++
 4 files changed, 112 insertions(+), 108 deletions(-)

diff --git a/dlls/wldap32/libldap.c b/dlls/wldap32/libldap.c
index e9353e2e3f43..662edb4d3652 100644
--- a/dlls/wldap32/libldap.c
+++ b/dlls/wldap32/libldap.c
@@ -50,6 +50,8 @@ C_ASSERT( sizeof(LDAPModU) == sizeof(LDAPMod) );
 C_ASSERT( sizeof(LDAPControlU) == sizeof(LDAPControl) );
 C_ASSERT( sizeof(LDAPSortKeyU) == sizeof(LDAPSortKey) );
 C_ASSERT( sizeof(LDAPVLVInfoU) == sizeof(LDAPVLVInfo) );
+C_ASSERT( sizeof(LDAPAPIInfoU) == sizeof(LDAPAPIInfo) );
+C_ASSERT( sizeof(LDAPAPIFeatureInfoU) == sizeof(LDAPAPIFeatureInfo) );
 C_ASSERT( sizeof(struct timevalU) == sizeof(struct timeval) );
 
 static LDAPMod *nullmods[] = { NULL };
@@ -346,6 +348,11 @@ int CDECL wrap_ldap_count_references( void *ld, void *chain )
     return ldap_count_references( ld, chain );
 }
 
+int CDECL wrap_ldap_count_values_len( struct bervalU **values )
+{
+    return ldap_count_values_len( (struct berval **)values );
+}
+
 int CDECL wrap_ldap_create_sort_control( void *ld, LDAPSortKeyU **keylist, int critical, LDAPControlU **control )
 {
     return ldap_create_sort_control( ld, (LDAPSortKey **)keylist, critical, (LDAPControl **)control );
@@ -414,6 +421,16 @@ void * CDECL wrap_ldap_first_reference( void *ld, void *chain )
     return ldap_first_reference( ld, chain );
 }
 
+int CDECL wrap_ldap_get_option( void *ld, int option, void *value )
+{
+    return ldap_get_option( ld, option, value );
+}
+
+struct bervalU ** CDECL wrap_ldap_get_values_len( void *ld, void *entry, const char *attr )
+{
+    return (struct bervalU **)ldap_get_values_len( ld, entry, attr );
+}
+
 int CDECL wrap_ldap_initialize( void **ld, const char *url )
 {
     return ldap_initialize( (LDAP **)ld, url );
@@ -583,6 +600,7 @@ static const struct ldap_funcs funcs =
     wrap_ldap_control_free,
     wrap_ldap_count_entries,
     wrap_ldap_count_references,
+    wrap_ldap_count_values_len,
     wrap_ldap_create_sort_control,
     wrap_ldap_create_vlv_control,
     wrap_ldap_delete_ext,
@@ -592,6 +610,8 @@ static const struct ldap_funcs funcs =
     wrap_ldap_extended_operation,
     wrap_ldap_extended_operation_s,
     wrap_ldap_get_dn,
+    wrap_ldap_get_option,
+    wrap_ldap_get_values_len,
     wrap_ldap_initialize,
     wrap_ldap_first_attribute,
     wrap_ldap_first_entry,
diff --git a/dlls/wldap32/libldap.h b/dlls/wldap32/libldap.h
index 1b0a2be4ba17..8745eac3abcf 100644
--- a/dlls/wldap32/libldap.h
+++ b/dlls/wldap32/libldap.h
@@ -60,6 +60,23 @@ typedef struct
     void           *ldvlv_extradata;
 } LDAPVLVInfoU;
 
+typedef struct
+{
+    int    ldapai_info_version;
+    int    ldapai_api_version;
+    int    ldapai_protocol_version;
+    char **ldapai_extensions;
+    char  *ldapai_vendor_name;
+    int    ldapai_vendor_version;
+} LDAPAPIInfoU;
+
+typedef struct
+{
+    int   ldapaif_info_version;
+    char *ldapaif_name;
+    int   ldapaif_version;
+} LDAPAPIFeatureInfoU;
+
 typedef struct timevalU
 {
     unsigned long tv_sec;
@@ -108,6 +125,7 @@ extern int CDECL wrap_ldap_compare_ext_s(void *, const char *, const char *, str
 extern void CDECL wrap_ldap_control_free(LDAPControlU *) DECLSPEC_HIDDEN;
 extern int CDECL wrap_ldap_count_entries(void *, void *) DECLSPEC_HIDDEN;
 extern int CDECL wrap_ldap_count_references(void *, void *) DECLSPEC_HIDDEN;
+extern int CDECL wrap_ldap_count_values_len(struct bervalU **) DECLSPEC_HIDDEN;
 extern int CDECL wrap_ldap_create_sort_control(void *, LDAPSortKeyU **, int, LDAPControlU **) DECLSPEC_HIDDEN;
 extern int CDECL wrap_ldap_create_vlv_control(void *, LDAPVLVInfoU *, LDAPControlU **) DECLSPEC_HIDDEN;
 extern int CDECL wrap_ldap_delete_ext(void *, const char *, LDAPControlU **, LDAPControlU **, ULONG *) DECLSPEC_HIDDEN;
@@ -119,6 +137,8 @@ extern int CDECL wrap_ldap_extended_operation(void *, const char *, struct berva
 extern int CDECL wrap_ldap_extended_operation_s(void *, const char *, struct bervalU *, LDAPControlU **,
                                                 LDAPControlU **, char **, struct bervalU **) DECLSPEC_HIDDEN;
 extern char * CDECL wrap_ldap_get_dn(void *, void *) DECLSPEC_HIDDEN;
+extern int CDECL wrap_ldap_get_option(void *, int, void *) DECLSPEC_HIDDEN;
+extern struct bervalU ** CDECL wrap_ldap_get_values_len(void *, void *, const char *) DECLSPEC_HIDDEN;
 extern int CDECL wrap_ldap_initialize(void **, const char *) DECLSPEC_HIDDEN;
 extern char * CDECL wrap_ldap_first_attribute(void *, void *, void **) DECLSPEC_HIDDEN;
 extern void * CDECL wrap_ldap_first_entry(void *, void *) DECLSPEC_HIDDEN;
@@ -181,6 +201,7 @@ struct ldap_funcs
     void (CDECL *ldap_control_free)(LDAPControlU *);
     int (CDECL *ldap_count_entries)(void *, void *);
     int (CDECL *ldap_count_references)(void *, void *);
+    int (CDECL *ldap_count_values_len)(struct bervalU **);
     int (CDECL *ldap_create_sort_control)(void *, LDAPSortKeyU **, int, LDAPControlU **);
     int (CDECL *ldap_create_vlv_control)(void *, LDAPVLVInfoU *, LDAPControlU **);
     int (CDECL *ldap_delete_ext)(void *, const char *, LDAPControlU **, LDAPControlU **, ULONG *);
@@ -192,6 +213,8 @@ struct ldap_funcs
     int (CDECL *ldap_extended_operation_s)(void *, const char *, struct bervalU *, LDAPControlU **,
                                            LDAPControlU **, char **, struct bervalU **);
     char * (CDECL *ldap_get_dn)(void *, void *);
+    int (CDECL *ldap_get_option)(void *, int, void *);
+    struct bervalU ** (CDECL *ldap_get_values_len)(void *, void *, const char *);
     int (CDECL *ldap_initialize)(void **, const char *);
     char * (CDECL *ldap_first_attribute)(void *, void *, void **);
     void * (CDECL *ldap_first_entry)(void *, void *);
diff --git a/dlls/wldap32/option.c b/dlls/wldap32/option.c
index 8398dff67e46..49eac7d2e945 100644
--- a/dlls/wldap32/option.c
+++ b/dlls/wldap32/option.c
@@ -18,25 +18,15 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#include "config.h"
-#include "wine/port.h"
-
 #include <stdarg.h>
-#ifdef HAVE_LDAP_H
-#include <ldap.h>
-#endif
-
 #include "windef.h"
 #include "winbase.h"
 #include "winnls.h"
 
-#include "winldap_private.h"
-#include "wldap32.h"
 #include "wine/debug.h"
+#include "winldap_private.h"
 
-#ifdef HAVE_LDAP
 WINE_DEFAULT_DEBUG_CHANNEL(wldap32);
-#endif
 
 /***********************************************************************
  *      ldap_get_optionA     (WLDAP32.@)
@@ -45,8 +35,7 @@ WINE_DEFAULT_DEBUG_CHANNEL(wldap32);
  */
 ULONG CDECL ldap_get_optionA( WLDAP32_LDAP *ld, int option, void *value )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret;
 
     TRACE( "(%p, 0x%08x, %p)\n", ld, option, value );
 
@@ -62,14 +51,12 @@ ULONG CDECL ldap_get_optionA( WLDAP32_LDAP *ld, int option, void *value )
         if (!featureA->ldapaif_name) return WLDAP32_LDAP_PARAM_ERROR;
 
         featureW.ldapaif_info_version = featureA->ldapaif_info_version;
-        featureW.ldapaif_name = strAtoW( featureA->ldapaif_name );
+        if (!(featureW.ldapaif_name = strAtoW( featureA->ldapaif_name ))) return WLDAP32_LDAP_NO_MEMORY;
         featureW.ldapaif_version = 0;
 
-        if (!featureW.ldapaif_name) return WLDAP32_LDAP_NO_MEMORY;
-
         ret = ldap_get_optionW( ld, option, &featureW );
 
-        featureA->ldapaif_version = featureW.ldapaif_version;
+        if (ret == WLDAP32_LDAP_SUCCESS) featureA->ldapaif_version = featureW.ldapaif_version;
         strfreeW( featureW.ldapaif_name );
         return ret;
     }
@@ -78,32 +65,27 @@ ULONG CDECL ldap_get_optionA( WLDAP32_LDAP *ld, int option, void *value )
         LDAPAPIInfoW infoW;
         LDAPAPIInfoA *infoA = value;
 
-        memset( &infoW, 0, sizeof(LDAPAPIInfoW) );
+        memset( &infoW, 0, sizeof(infoW) );
         infoW.ldapai_info_version = infoA->ldapai_info_version;
 
         ret = ldap_get_optionW( ld, option, &infoW );
-
-        infoA->ldapai_api_version = infoW.ldapai_api_version;
-        infoA->ldapai_protocol_version = infoW.ldapai_protocol_version;
-
-        if (infoW.ldapai_extensions)
-        {
-            infoA->ldapai_extensions = strarrayWtoA( infoW.ldapai_extensions );
-            if (!infoA->ldapai_extensions) return WLDAP32_LDAP_NO_MEMORY;
-        }
-        if (infoW.ldapai_vendor_name)
+        if (ret == WLDAP32_LDAP_SUCCESS)
         {
-            infoA->ldapai_vendor_name = strWtoA( infoW.ldapai_vendor_name );
-            if (!infoA->ldapai_vendor_name)
+            infoA->ldapai_api_version = infoW.ldapai_api_version;
+            infoA->ldapai_protocol_version = infoW.ldapai_protocol_version;
+
+            if (infoW.ldapai_extensions && !(infoA->ldapai_extensions = strarrayWtoA( infoW.ldapai_extensions )))
+                return WLDAP32_LDAP_NO_MEMORY;
+            if (infoW.ldapai_vendor_name && !(infoA->ldapai_vendor_name = strWtoA( infoW.ldapai_vendor_name )))
             {
                 ldap_value_freeW( infoW.ldapai_extensions );
                 return WLDAP32_LDAP_NO_MEMORY;
             }
-        }
-        infoA->ldapai_vendor_version = infoW.ldapai_vendor_version;
+            infoA->ldapai_vendor_version = infoW.ldapai_vendor_version;
 
-        ldap_value_freeW( infoW.ldapai_extensions );
-        ldap_memfreeW( infoW.ldapai_vendor_name );
+            ldap_value_freeW( infoW.ldapai_extensions );
+            ldap_memfreeW( infoW.ldapai_vendor_name );
+        }
         return ret;
     }
 
@@ -124,7 +106,7 @@ ULONG CDECL ldap_get_optionA( WLDAP32_LDAP *ld, int option, void *value )
     case WLDAP32_LDAP_OPT_REBIND_FN:
     case WLDAP32_LDAP_OPT_RESTART:
     case WLDAP32_LDAP_OPT_THREAD_FN_PTRS:
-        return LDAP_LOCAL_ERROR;
+        return WLDAP32_LDAP_LOCAL_ERROR;
 
     case WLDAP32_LDAP_OPT_AREC_EXCLUSIVE:
     case WLDAP32_LDAP_OPT_AUTO_RECONNECT:
@@ -163,9 +145,6 @@ ULONG CDECL ldap_get_optionA( WLDAP32_LDAP *ld, int option, void *value )
         FIXME( "Unknown option: 0x%02x\n", option );
         return WLDAP32_LDAP_LOCAL_ERROR;
     }
-
-#endif
-    return ret;
 }
 
 /***********************************************************************
@@ -184,8 +163,7 @@ ULONG CDECL ldap_get_optionA( WLDAP32_LDAP *ld, int option, void *value )
  */
 ULONG CDECL ldap_get_optionW( WLDAP32_LDAP *ld, int option, void *value )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret;
 
     TRACE( "(%p, 0x%08x, %p)\n", ld, option, value );
 
@@ -195,54 +173,47 @@ ULONG CDECL ldap_get_optionW( WLDAP32_LDAP *ld, int option, void *value )
     {
     case WLDAP32_LDAP_OPT_API_FEATURE_INFO:
     {
-        LDAPAPIFeatureInfo featureU;
+        LDAPAPIFeatureInfoU featureU;
         LDAPAPIFeatureInfoW *featureW = value;
 
         if (!featureW->ldapaif_name) return WLDAP32_LDAP_PARAM_ERROR;
 
         featureU.ldapaif_info_version = featureW->ldapaif_info_version;
-        featureU.ldapaif_name = strWtoU( featureW->ldapaif_name );
+        if (!(featureU.ldapaif_name = strWtoU( featureW->ldapaif_name ))) return WLDAP32_LDAP_NO_MEMORY;
         featureU.ldapaif_version = 0;
 
-        if (!featureU.ldapaif_name) return WLDAP32_LDAP_NO_MEMORY;
-
-        ret = map_error( ldap_get_option( ld->ld, option, &featureU ));
+        ret = map_error( ldap_funcs->ldap_get_option( ld->ld, option, &featureU ) );
 
-        featureW->ldapaif_version = featureU.ldapaif_version;
+        if (ret == WLDAP32_LDAP_SUCCESS) featureW->ldapaif_version = featureU.ldapaif_version;
         strfreeU( featureU.ldapaif_name );
         return ret;
     }
     case WLDAP32_LDAP_OPT_API_INFO:
     {
-        LDAPAPIInfo infoU;
+        LDAPAPIInfoU infoU;
         LDAPAPIInfoW *infoW = value;
 
-        memset( &infoU, 0, sizeof(LDAPAPIInfo) );
+        memset( &infoU, 0, sizeof(infoU) );
         infoU.ldapai_info_version = infoW->ldapai_info_version;
 
-        ret = map_error( ldap_get_option( ld->ld, option, &infoU ));
-
-        infoW->ldapai_api_version = infoU.ldapai_api_version;
-        infoW->ldapai_protocol_version = infoU.ldapai_protocol_version;
-
-        if (infoU.ldapai_extensions)
-        {
-            infoW->ldapai_extensions = strarrayUtoW( infoU.ldapai_extensions );
-            if (!infoW->ldapai_extensions) return WLDAP32_LDAP_NO_MEMORY;
-        }
-        if (infoU.ldapai_vendor_name)
+        ret = map_error( ldap_funcs->ldap_get_option( ld->ld, option, &infoU ) );
+        if (ret == WLDAP32_LDAP_SUCCESS)
         {
-            infoW->ldapai_vendor_name = strUtoW( infoU.ldapai_vendor_name );
-            if (!infoW->ldapai_vendor_name)
+            infoW->ldapai_api_version = infoU.ldapai_api_version;
+            infoW->ldapai_protocol_version = infoU.ldapai_protocol_version;
+
+            if (infoU.ldapai_extensions && !(infoW->ldapai_extensions = strarrayUtoW( infoU.ldapai_extensions )))
+                return WLDAP32_LDAP_NO_MEMORY;
+            if (infoU.ldapai_vendor_name && !(infoW->ldapai_vendor_name = strUtoW( infoU.ldapai_vendor_name )))
             {
-                ldap_memvfree( (void **)infoU.ldapai_extensions );
+                ldap_funcs->ldap_memvfree( (void **)infoU.ldapai_extensions );
                 return WLDAP32_LDAP_NO_MEMORY;
             }
-        }
-        infoW->ldapai_vendor_version = infoU.ldapai_vendor_version;
+            infoW->ldapai_vendor_version = infoU.ldapai_vendor_version;
 
-        ldap_memvfree( (void **)infoU.ldapai_extensions );
-        ldap_memfree( infoU.ldapai_vendor_name );
+            ldap_funcs->ldap_memvfree( (void **)infoU.ldapai_extensions );
+            ldap_funcs->ldap_memfree( infoU.ldapai_vendor_name );
+        }
         return ret;
     }
 
@@ -253,7 +224,7 @@ ULONG CDECL ldap_get_optionW( WLDAP32_LDAP *ld, int option, void *value )
     case WLDAP32_LDAP_OPT_REFERRALS:
     case WLDAP32_LDAP_OPT_SIZELIMIT:
     case WLDAP32_LDAP_OPT_TIMELIMIT:
-        return map_error( ldap_get_option( ld->ld, option, value ));
+        return map_error( ldap_funcs->ldap_get_option( ld->ld, option, value ));
 
     case WLDAP32_LDAP_OPT_CACHE_ENABLE:
     case WLDAP32_LDAP_OPT_CACHE_FN_PTRS:
@@ -302,9 +273,6 @@ ULONG CDECL ldap_get_optionW( WLDAP32_LDAP *ld, int option, void *value )
         FIXME( "Unknown option: 0x%02x\n", option );
         return WLDAP32_LDAP_LOCAL_ERROR;
     }
-
-#endif
-    return ret;
 }
 
 /***********************************************************************
@@ -314,8 +282,7 @@ ULONG CDECL ldap_get_optionW( WLDAP32_LDAP *ld, int option, void *value )
  */
 ULONG CDECL ldap_set_optionA( WLDAP32_LDAP *ld, int option, void *value )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret;
 
     TRACE( "(%p, 0x%08x, %p)\n", ld, option, value );
 
@@ -326,10 +293,7 @@ ULONG CDECL ldap_set_optionA( WLDAP32_LDAP *ld, int option, void *value )
     case WLDAP32_LDAP_OPT_SERVER_CONTROLS:
     {
         LDAPControlW **ctrlsW;
-
-        ctrlsW = controlarrayAtoW( value );
-        if (!ctrlsW) return WLDAP32_LDAP_NO_MEMORY;
-
+        if (!(ctrlsW = controlarrayAtoW( value ))) return WLDAP32_LDAP_NO_MEMORY;
         ret = ldap_set_optionW( ld, option, ctrlsW );
         controlarrayfreeW( ctrlsW );
         return ret;
@@ -393,41 +357,37 @@ ULONG CDECL ldap_set_optionA( WLDAP32_LDAP *ld, int option, void *value )
         FIXME( "Unknown option: 0x%02x\n", option );
         return WLDAP32_LDAP_LOCAL_ERROR;
     }
-
-#endif
-    return ret;
 }
 
-#ifdef HAVE_LDAP
-
 static BOOL query_supported_server_ctrls( WLDAP32_LDAP *ld )
 {
     char *attrs[] = { (char *)"supportedControl", NULL };
-    LDAPMessage *res, *entry;
+    void *res, *entry;
+    ULONG ret;
 
-    if ( ld->ld_server_ctrls ) return TRUE;
+    if (ld->ld_server_ctrls) return TRUE;
 
-    if (ldap_search_ext_s( ld->ld, (char *)"", LDAP_SCOPE_BASE, (char *)"(objectClass=*)", attrs, FALSE,
-                           NULL, NULL, NULL, 0, &res ) != LDAP_SUCCESS)
-        return FALSE;
+    ret = map_error( ldap_funcs->ldap_search_ext_s( ld->ld, (char *)"", WLDAP32_LDAP_SCOPE_BASE,
+                                                    (char *)"(objectClass=*)", attrs, FALSE, NULL, NULL, NULL, 0, &res ) );
+    if (ret != WLDAP32_LDAP_SUCCESS) return FALSE;
 
-    entry = ldap_first_entry( ld->ld, res );
+    entry = ldap_funcs->ldap_first_entry( ld->ld, res );
     if (entry)
     {
         ULONG count, i;
 
-        ld->ld_server_ctrls = (struct bervalU **)ldap_get_values_len( ld->ld, entry, attrs[0] );
-        count = ldap_count_values_len( (struct berval **)ld->ld_server_ctrls );
+        ld->ld_server_ctrls = ldap_funcs->ldap_get_values_len( ld->ld, entry, attrs[0] );
+        count = ldap_funcs->ldap_count_values_len( ld->ld_server_ctrls );
         for (i = 0; i < count; i++)
             TRACE("%u: %s\n", i, debugstr_an( ld->ld_server_ctrls[i]->bv_val, ld->ld_server_ctrls[i]->bv_len ));
     }
 
-    ldap_msgfree( res );
+    ldap_funcs->ldap_msgfree( res );
 
     return ld->ld_server_ctrls != NULL;
 }
 
-static BOOL is_supported_server_ctrls( WLDAP32_LDAP *ld, LDAPControl **ctrls )
+static BOOL is_supported_server_ctrls( WLDAP32_LDAP *ld, LDAPControlU **ctrls )
 {
     ULONG user_count, server_count, i, n, supported = 0;
 
@@ -435,7 +395,7 @@ static BOOL is_supported_server_ctrls( WLDAP32_LDAP *ld, LDAPControl **ctrls )
         return TRUE; /* can't verify, let the server handle it on next query */
 
     user_count = controlarraylenU( ctrls );
-    server_count = ldap_count_values_len( (struct berval **)ld->ld_server_ctrls );
+    server_count = ldap_funcs->ldap_count_values_len( ld->ld_server_ctrls );
 
     for (n = 0; n < user_count; n++)
     {
@@ -453,7 +413,6 @@ static BOOL is_supported_server_ctrls( WLDAP32_LDAP *ld, LDAPControl **ctrls )
 
     return supported == user_count;
 }
-#endif
 
 /***********************************************************************
  *      ldap_set_optionW     (WLDAP32.@)
@@ -471,11 +430,10 @@ static BOOL is_supported_server_ctrls( WLDAP32_LDAP *ld, LDAPControl **ctrls )
  *
  * NOTES
  *  Set value to LDAP_OPT_ON or LDAP_OPT_OFF for on/off options.
- */ 
+ */
 ULONG CDECL ldap_set_optionW( WLDAP32_LDAP *ld, int option, void *value )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret;
 
     TRACE( "(%p, 0x%08x, %p)\n", ld, option, value );
 
@@ -485,26 +443,25 @@ ULONG CDECL ldap_set_optionW( WLDAP32_LDAP *ld, int option, void *value )
     {
     case WLDAP32_LDAP_OPT_SERVER_CONTROLS:
     {
-        LDAPControl **ctrlsU;
+        LDAPControlU **ctrlsU;
 
-        ctrlsU = controlarrayWtoU( value );
-        if (!ctrlsU) return WLDAP32_LDAP_NO_MEMORY;
+        if (!(ctrlsU = controlarrayWtoU( value ))) return WLDAP32_LDAP_NO_MEMORY;
 
         if (!is_supported_server_ctrls( ld, ctrlsU ))
             ret = WLDAP32_LDAP_PARAM_ERROR;
         else
-            ret = map_error( ldap_set_option( ld->ld, option, ctrlsU ));
+            ret = map_error( ldap_funcs->ldap_set_option( ld->ld, option, ctrlsU ) );
         controlarrayfreeU( ctrlsU );
         return ret;
     }
     case WLDAP32_LDAP_OPT_REFERRALS:
     {
-        void *openldap_referral = LDAP_OPT_ON;
-        if (value == LDAP_OPT_OFF)
-            openldap_referral = LDAP_OPT_OFF;
+        void *openldap_referral = WLDAP32_LDAP_OPT_ON;
+        if (value == WLDAP32_LDAP_OPT_OFF)
+            openldap_referral = WLDAP32_LDAP_OPT_OFF;
         else
             FIXME("upgrading referral value %p to LDAP_OPT_ON (OpenLDAP lacks sufficient granularity)\n", value);
-        return map_error( ldap_set_option( ld->ld, option, openldap_referral ));
+        return map_error( ldap_funcs->ldap_set_option( ld->ld, option, openldap_referral ) );
         break;
     }
     case WLDAP32_LDAP_OPT_DEREF:
@@ -513,7 +470,7 @@ ULONG CDECL ldap_set_optionW( WLDAP32_LDAP *ld, int option, void *value )
     case WLDAP32_LDAP_OPT_PROTOCOL_VERSION:
     case WLDAP32_LDAP_OPT_SIZELIMIT:
     case WLDAP32_LDAP_OPT_TIMELIMIT:
-        return map_error( ldap_set_option( ld->ld, option, value ));
+        return map_error( ldap_funcs->ldap_set_option( ld->ld, option, value ));
 
     case WLDAP32_LDAP_OPT_CACHE_ENABLE:
     case WLDAP32_LDAP_OPT_CACHE_FN_PTRS:
@@ -565,7 +522,4 @@ ULONG CDECL ldap_set_optionW( WLDAP32_LDAP *ld, int option, void *value )
         FIXME( "Unknown option: 0x%02x\n", option );
         return WLDAP32_LDAP_LOCAL_ERROR;
     }
-
-#endif
-    return ret;
 }
diff --git a/dlls/wldap32/winldap_private.h b/dlls/wldap32/winldap_private.h
index 7ac7e5a3f419..32ed3f5a2661 100644
--- a/dlls/wldap32/winldap_private.h
+++ b/dlls/wldap32/winldap_private.h
@@ -33,6 +33,13 @@
 #define WLDAP32_LDAP_VERSION2   2
 #define WLDAP32_LDAP_VERSION3   3
 
+#define WLDAP32_LDAP_OPT_ON  ((void *)1)
+#define WLDAP32_LDAP_OPT_OFF ((void *)0)
+
+#define WLDAP32_LDAP_SCOPE_BASE     0x00
+#define WLDAP32_LDAP_SCOPE_ONELEVEL 0x01
+#define WLDAP32_LDAP_SCOPE_SUBTREE  0x02
+
 typedef enum {
     WLDAP32_LDAP_SUCCESS                 =   0x00,
     WLDAP32_LDAP_UNWILLING_TO_PERFORM    =   0x35,
From 1c5b3f20015f379bbdfa9554fc4c9911062770ea Mon Sep 17 00:00:00 2001
From: Hans Leidekker <hans@codeweavers.com>
Date: Fri, 16 Apr 2021 09:59:18 +0200
Subject: [PATCH] wldap32: Move support for page functions to the Unix library.

Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/wldap32/ber.c             |   2 +-
 dlls/wldap32/page.c            | 281 +++++++++++----------------------
 dlls/wldap32/winldap_private.h |  76 +++++++++
 3 files changed, 169 insertions(+), 190 deletions(-)

diff --git a/dlls/wldap32/ber.c b/dlls/wldap32/ber.c
index ae5e9292e04e..c6dca7153a24 100644
--- a/dlls/wldap32/ber.c
+++ b/dlls/wldap32/ber.c
@@ -413,7 +413,7 @@ int WINAPIV WLDAP32_ber_printf( WLDAP32_BerElement *ber, char *fmt, ... )
  *  berelement must have been allocated with ber_init. This function
  *  can be called multiple times to decode data.
  */
-int WINAPIV WLDAP32_ber_scanf( WLDAP32_BerElement *ber, char *fmt, ... )
+ULONG WINAPIV WLDAP32_ber_scanf( WLDAP32_BerElement *ber, char *fmt, ... )
 {
     __ms_va_list list;
     int ret = 0;
diff --git a/dlls/wldap32/page.c b/dlls/wldap32/page.c
index 07f29be0d50a..5364280f271c 100644
--- a/dlls/wldap32/page.c
+++ b/dlls/wldap32/page.c
@@ -18,31 +18,20 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#include "config.h"
-#include "wine/port.h"
-
 #include <stdarg.h>
-#ifdef HAVE_LDAP_H
-#include <ldap.h>
-#endif
-#ifndef LDAP_MAXINT
-#define LDAP_MAXINT  2147483647
-#endif
-
 #include "windef.h"
 #include "winbase.h"
 #include "winnls.h"
 
-#include "winldap_private.h"
-#include "wldap32.h"
 #include "wine/debug.h"
+#include "wine/heap.h"
+#include "winldap_private.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(wldap32);
 
-#ifdef HAVE_LDAP
-static struct berval null_cookieU = { 0, NULL };
+#define LDAP_MAXINT (2^31)
+
 static struct WLDAP32_berval null_cookieW = { 0, NULL };
-#endif
 
 /***********************************************************************
  *      ldap_create_page_controlA     (WLDAP32.@)
@@ -50,84 +39,73 @@ static struct WLDAP32_berval null_cookieW = { 0, NULL };
  * See ldap_create_page_controlW.
  */
 ULONG CDECL ldap_create_page_controlA( WLDAP32_LDAP *ld, ULONG pagesize,
-    struct WLDAP32_berval *cookie, UCHAR critical, PLDAPControlA *control )
+    struct WLDAP32_berval *cookie, UCHAR critical, LDAPControlA **control )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret;
     LDAPControlW *controlW = NULL;
 
-    TRACE( "(%p, 0x%08x, %p, 0x%02x, %p)\n", ld, pagesize, cookie,
-           critical, control );
+    TRACE( "(%p, 0x%08x, %p, 0x%02x, %p)\n", ld, pagesize, cookie, critical, control );
 
-    if (!ld || !control || pagesize > LDAP_MAXINT)
-        return WLDAP32_LDAP_PARAM_ERROR;
+    if (!ld || !control || pagesize > LDAP_MAXINT) return WLDAP32_LDAP_PARAM_ERROR;
 
     ret = ldap_create_page_controlW( ld, pagesize, cookie, critical, &controlW );
-    if (ret == LDAP_SUCCESS)
+    if (ret == WLDAP32_LDAP_SUCCESS)
     {
         *control = controlWtoA( controlW );
         ldap_control_freeW( controlW );
     }
-
-#endif
     return ret;
 }
 
-#ifdef HAVE_LDAP
-
 /* create a page control by hand */
-static ULONG create_page_control( ULONG pagesize, struct berval *cookie,
-    UCHAR critical, PLDAPControlW *control )
+static ULONG create_page_control( ULONG pagesize, struct WLDAP32_berval *cookie, UCHAR critical, LDAPControlW **control )
 {
     LDAPControlW *ctrl;
-    BerElement *ber;
-    ber_tag_t tag;
-    struct berval *berval;
-    INT ret, len;
+    WLDAP32_BerElement *ber;
+    struct WLDAP32_berval *berval, *vec[2];
+    int ret, len;
     char *val;
 
-    ber = ber_alloc_t( LBER_USE_DER );
-    if (!ber) return WLDAP32_LDAP_NO_MEMORY;
+    if (!(ber = WLDAP32_ber_alloc_t( WLDAP32_LBER_USE_DER ))) return WLDAP32_LDAP_NO_MEMORY;
 
+    vec[1] = NULL;
     if (cookie)
-        tag = ber_printf( ber, "{iO}", (ber_int_t)pagesize, cookie );
+        vec[0] = cookie;
     else
-        tag = ber_printf( ber, "{iO}", (ber_int_t)pagesize, &null_cookieU );
+        vec[0] = &null_cookieW;
+    len = WLDAP32_ber_printf( ber, (char *)"{iV}", pagesize, vec );
 
-    ret = ber_flatten( ber, &berval );
-    ber_free( ber, 1 );
+    ret = WLDAP32_ber_flatten( ber, &berval );
+    WLDAP32_ber_free( ber, 1 );
 
-    if (tag == LBER_ERROR)
-        return WLDAP32_LDAP_ENCODING_ERROR;
-
-    if (ret == -1)
-        return WLDAP32_LDAP_NO_MEMORY;
+    if (len == WLDAP32_LBER_ERROR) return WLDAP32_LDAP_ENCODING_ERROR;
+    if (ret == -1) return WLDAP32_LDAP_NO_MEMORY;
 
     /* copy the berval so it can be properly freed by the caller */
     if (!(val = heap_alloc( berval->bv_len ))) return WLDAP32_LDAP_NO_MEMORY;
 
     len = berval->bv_len;
     memcpy( val, berval->bv_val, len );
-    ber_bvfree( berval );
+    WLDAP32_ber_bvfree( berval );
 
-    if (!(ctrl = heap_alloc( sizeof(LDAPControlW) )))
+    if (!(ctrl = heap_alloc( sizeof(*ctrl) )))
     {
         heap_free( val );
         return WLDAP32_LDAP_NO_MEMORY;
     }
-
-    ctrl->ldctl_oid = strAtoW( LDAP_PAGED_RESULT_OID_STRING );
+    if (!(ctrl->ldctl_oid = strAtoW( LDAP_PAGED_RESULT_OID_STRING )))
+    {
+        heap_free( ctrl );
+        return WLDAP32_LDAP_NO_MEMORY;
+    }
     ctrl->ldctl_value.bv_len = len;
     ctrl->ldctl_value.bv_val = val;
-    ctrl->ldctl_iscritical = critical;
+    ctrl->ldctl_iscritical   = critical;
 
     *control = ctrl;
-
     return WLDAP32_LDAP_SUCCESS;
 }
 
-#endif /* HAVE_LDAP */
-
 /***********************************************************************
  *      ldap_create_page_controlW     (WLDAP32.@)
  *
@@ -146,31 +124,16 @@ static ULONG create_page_control( ULONG pagesize, struct berval *cookie,
  *  Success: LDAP_SUCCESS
  *  Failure: An LDAP error code.
  */
-ULONG CDECL ldap_create_page_controlW( WLDAP32_LDAP *ld, ULONG pagesize,
-    struct WLDAP32_berval *cookie, UCHAR critical, PLDAPControlW *control )
+ULONG CDECL ldap_create_page_controlW( WLDAP32_LDAP *ld, ULONG pagesize, struct WLDAP32_berval *cookie,
+    UCHAR critical, LDAPControlW **control )
 {
-#ifdef HAVE_LDAP
-    struct berval *cookieU = NULL;
-    ULONG ret;
+    TRACE( "(%p, 0x%08x, %p, 0x%02x, %p)\n", ld, pagesize, cookie, critical, control );
 
-    TRACE( "(%p, 0x%08x, %p, 0x%02x, %p)\n", ld, pagesize, cookie,
-           critical, control );
-
-    if (!ld || !control || pagesize > LDAP_MAXINT)
-        return WLDAP32_LDAP_PARAM_ERROR;
-
-    if (cookie && !(cookieU = bervalWtoU( cookie ))) return WLDAP32_LDAP_NO_MEMORY;
-    ret = create_page_control( pagesize, cookieU, critical, control );
-    heap_free( cookieU );
-    return ret;
-
-#else
-    return WLDAP32_LDAP_NOT_SUPPORTED;
-#endif
+    if (!ld || !control || pagesize > LDAP_MAXINT) return WLDAP32_LDAP_PARAM_ERROR;
+    return create_page_control( pagesize, cookie, critical, control );
 }
 
-ULONG CDECL ldap_get_next_page( WLDAP32_LDAP *ld, PLDAPSearch search, ULONG pagesize,
-    ULONG *message )
+ULONG CDECL ldap_get_next_page( WLDAP32_LDAP *ld, LDAPSearch *search, ULONG pagesize, ULONG *message )
 {
     FIXME( "(%p, %p, 0x%08x, %p)\n", ld, search, pagesize, message );
 
@@ -178,18 +141,16 @@ ULONG CDECL ldap_get_next_page( WLDAP32_LDAP *ld, PLDAPSearch search, ULONG page
     return WLDAP32_LDAP_NOT_SUPPORTED;
 }
 
-ULONG CDECL ldap_get_next_page_s( WLDAP32_LDAP *ld, PLDAPSearch search,
-    struct l_timeval *timeout, ULONG pagesize, ULONG *count,
-    WLDAP32_LDAPMessage **results )
+ULONG CDECL ldap_get_next_page_s( WLDAP32_LDAP *ld, LDAPSearch *search, struct l_timeval *timeout, ULONG pagesize,
+    ULONG *count, WLDAP32_LDAPMessage **results )
 {
-#ifdef HAVE_LDAP
     ULONG ret;
 
-    TRACE( "(%p, %p, %p, %u, %p, %p)\n", ld, search, timeout,
-           pagesize, count, results );
+    TRACE( "(%p, %p, %p, %u, %p, %p)\n", ld, search, timeout, pagesize, count, results );
+
     if (!ld || !search || !count || !results) return ~0u;
 
-    if (search->cookie && search->cookie->bv_len == 0)
+    if (search->cookie && !search->cookie->bv_len)
     {
         /* end of paged results */
         *count = 0;
@@ -207,22 +168,16 @@ ULONG CDECL ldap_get_next_page_s( WLDAP32_LDAP *ld, PLDAPSearch search,
     ret = ldap_create_page_controlW( ld, pagesize, search->cookie, 1, &search->serverctrls[0] );
     if (ret != WLDAP32_LDAP_SUCCESS) return ret;
 
-    ret = ldap_search_ext_sW( ld, search->dn, search->scope,
-                              search->filter, search->attrs, search->attrsonly,
+    ret = ldap_search_ext_sW( ld, search->dn, search->scope, search->filter, search->attrs, search->attrsonly,
                               search->serverctrls, search->clientctrls,
                               search->timeout.tv_sec ? &search->timeout : NULL, search->sizelimit, results );
     if (ret != WLDAP32_LDAP_SUCCESS) return ret;
 
     return ldap_get_paged_count( ld, search, count, *results );
-
-#endif
-    return WLDAP32_LDAP_NOT_SUPPORTED;
 }
 
-ULONG CDECL ldap_get_paged_count( WLDAP32_LDAP *ld, PLDAPSearch search,
-    ULONG *count, WLDAP32_LDAPMessage *results )
+ULONG CDECL ldap_get_paged_count( WLDAP32_LDAP *ld, LDAPSearch *search, ULONG *count, WLDAP32_LDAPMessage *results )
 {
-#ifdef HAVE_LDAP
     ULONG ret;
     LDAPControlW **server_ctrls = NULL;
 
@@ -249,99 +204,68 @@ ULONG CDECL ldap_get_paged_count( WLDAP32_LDAP *ld, PLDAPSearch search,
         TRACE("new search->cookie: %s, count %u\n", debugstr_an(search->cookie->bv_val, search->cookie->bv_len), *count);
 
     ldap_controls_freeW( server_ctrls );
-
     return ret;
-
-#endif
-    return WLDAP32_LDAP_NOT_SUPPORTED;
 }
 
 /***********************************************************************
  *      ldap_parse_page_controlA      (WLDAP32.@)
  */
-ULONG CDECL ldap_parse_page_controlA( WLDAP32_LDAP *ld, PLDAPControlA *ctrls,
-    ULONG *count, struct WLDAP32_berval **cookie )
+ULONG CDECL ldap_parse_page_controlA( WLDAP32_LDAP *ld, LDAPControlA **ctrls, ULONG *count,
+    struct WLDAP32_berval **cookie )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret;
     LDAPControlW **ctrlsW = NULL;
 
     TRACE( "(%p, %p, %p, %p)\n", ld, ctrls, count, cookie );
 
-    if (!ld || !ctrls || !count || !cookie)
-        return WLDAP32_LDAP_PARAM_ERROR;
-
-    ctrlsW = controlarrayAtoW( ctrls );
-    if (!ctrlsW) return WLDAP32_LDAP_NO_MEMORY;
+    if (!ld || !ctrls || !count || !cookie) return WLDAP32_LDAP_PARAM_ERROR;
 
+    if (!(ctrlsW = controlarrayAtoW( ctrls ))) return WLDAP32_LDAP_NO_MEMORY;
     ret = ldap_parse_page_controlW( ld, ctrlsW, count, cookie );
     controlarrayfreeW( ctrlsW );
- 
-#endif
     return ret;
 }
 
 /***********************************************************************
  *      ldap_parse_page_controlW      (WLDAP32.@)
  */
-ULONG CDECL ldap_parse_page_controlW( WLDAP32_LDAP *ld, PLDAPControlW *ctrls,
-    ULONG *count, struct WLDAP32_berval **cookie )
+ULONG CDECL ldap_parse_page_controlW( WLDAP32_LDAP *ld, LDAPControlW **ctrls, ULONG *count,
+    struct WLDAP32_berval **cookie )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret;
     LDAPControlW *control = NULL;
-    struct berval *cookieU = NULL, *valueU;
-    BerElement *ber;
-    ber_tag_t tag;
+    WLDAP32_BerElement *ber;
+    struct WLDAP32_berval *vec[2];
+    int tag;
     ULONG i;
 
     TRACE( "(%p, %p, %p, %p)\n", ld, ctrls, count, cookie );
 
-    if (!ld || !ctrls || !count || !cookie)
-        return WLDAP32_LDAP_PARAM_ERROR;
+    if (!ld || !ctrls || !count || !cookie) return WLDAP32_LDAP_PARAM_ERROR;
 
     for (i = 0; ctrls[i]; i++)
     {
         if (!lstrcmpW( LDAP_PAGED_RESULT_OID_STRING_W, ctrls[i]->ldctl_oid ))
             control = ctrls[i];
     }
+    if (!control) return WLDAP32_LDAP_CONTROL_NOT_FOUND;
 
-    if (!control)
-        return WLDAP32_LDAP_CONTROL_NOT_FOUND;
-
-    if (cookie && !(cookieU = bervalWtoU( *cookie )))
-        return WLDAP32_LDAP_NO_MEMORY;
-
-    if (!(valueU = bervalWtoU( &control->ldctl_value )))
-    {
-        heap_free( cookieU );
-        return WLDAP32_LDAP_NO_MEMORY;
-    }
+    if (!(ber = WLDAP32_ber_init( &control->ldctl_value ))) return WLDAP32_LDAP_NO_MEMORY;
 
-    ber = ber_init( valueU );
-    heap_free( valueU );
-    if (!ber)
-    {
-        heap_free( cookieU );
-        return WLDAP32_LDAP_NO_MEMORY;
-    }
-
-    tag = ber_scanf( ber, "{iO}", count, &cookieU );
-    if (tag == LBER_ERROR)
+    vec[0] = *cookie;
+    vec[1] = 0;
+    tag = WLDAP32_ber_scanf( ber, (char *)"{iV}", count, vec );
+    if (tag == WLDAP32_LBER_ERROR)
         ret = WLDAP32_LDAP_DECODING_ERROR;
     else
         ret = WLDAP32_LDAP_SUCCESS;
 
-    heap_free( cookieU );
-    ber_free( ber, 1 );
-
-#endif
+    WLDAP32_ber_free( ber, 1 );
     return ret;
 }
 
-ULONG CDECL ldap_search_abandon_page( WLDAP32_LDAP *ld, PLDAPSearch search )
+ULONG CDECL ldap_search_abandon_page( WLDAP32_LDAP *ld, LDAPSearch *search )
 {
-#ifdef HAVE_LDAP
     LDAPControlW **ctrls;
 
     TRACE( "(%p, %p)\n", ld, search );
@@ -357,91 +281,70 @@ ULONG CDECL ldap_search_abandon_page( WLDAP32_LDAP *ld, PLDAPSearch search )
     while (*ctrls) controlfreeW( *ctrls++ );
     heap_free( search->serverctrls );
     controlarrayfreeW( search->clientctrls );
-    if (search->cookie && search->cookie != &null_cookieW)
-        heap_free( search->cookie );
+    if (search->cookie && search->cookie != &null_cookieW) heap_free( search->cookie );
     heap_free( search );
 
     return WLDAP32_LDAP_SUCCESS;
-
-#else
-    return WLDAP32_LDAP_NOT_SUPPORTED;
-#endif
 }
 
-PLDAPSearch CDECL ldap_search_init_pageA( WLDAP32_LDAP *ld, PCHAR dn, ULONG scope,
-    PCHAR filter, PCHAR attrs[], ULONG attrsonly, PLDAPControlA *serverctrls,
-    PLDAPControlA *clientctrls, ULONG timelimit, ULONG sizelimit, PLDAPSortKeyA *sortkeys )
+LDAPSearch * CDECL ldap_search_init_pageA( WLDAP32_LDAP *ld, char *dn, ULONG scope, char *filter, char **attrs,
+    ULONG attrsonly, LDAPControlA **serverctrls, LDAPControlA **clientctrls, ULONG timelimit, ULONG sizelimit,
+    LDAPSortKeyA **sortkeys )
 {
-    FIXME( "(%p, %s, 0x%08x, %s, %p, 0x%08x)\n", ld, debugstr_a(dn),
-           scope, debugstr_a(filter), attrs, attrsonly );
+    FIXME( "(%p, %s, 0x%08x, %s, %p, 0x%08x, %p, %p, 0x%08x, 0x%08x, %p)\n", ld, debugstr_a(dn), scope,
+           debugstr_a(filter), attrs, attrsonly, serverctrls, clientctrls, timelimit, sizelimit, sortkeys );
     return NULL;
 }
 
-PLDAPSearch CDECL ldap_search_init_pageW( WLDAP32_LDAP *ld, PWCHAR dn, ULONG scope,
-    PWCHAR filter, PWCHAR attrs[], ULONG attrsonly, PLDAPControlW *serverctrls,
-    PLDAPControlW *clientctrls, ULONG timelimit, ULONG sizelimit, PLDAPSortKeyW *sortkeys )
+LDAPSearch * CDECL ldap_search_init_pageW( WLDAP32_LDAP *ld, WCHAR *dn, ULONG scope, WCHAR *filter, WCHAR **attrs,
+    ULONG attrsonly, LDAPControlW **serverctrls, LDAPControlW **clientctrls, ULONG timelimit, ULONG sizelimit,
+    LDAPSortKeyW **sortkeys )
 {
-#ifdef HAVE_LDAP
     LDAPSearch *search;
     DWORD i, len;
 
-    TRACE( "(%p, %s, 0x%08x, %s, %p, 0x%08x, %p, %p, 0x%08x, 0x%08x, %p)\n",
-           ld, debugstr_w(dn), scope, debugstr_w(filter), attrs, attrsonly,
-           serverctrls, clientctrls, timelimit, sizelimit, sortkeys );
+    TRACE( "(%p, %s, 0x%08x, %s, %p, 0x%08x, %p, %p, 0x%08x, 0x%08x, %p)\n", ld, debugstr_w(dn), scope,
+           debugstr_w(filter), attrs, attrsonly, serverctrls, clientctrls, timelimit, sizelimit, sortkeys );
 
-    search = heap_alloc_zero( sizeof(*search) );
-    if (!search)
+    if (!(search = heap_alloc_zero( sizeof(*search) )))
     {
         ld->ld_errno = WLDAP32_LDAP_NO_MEMORY;
         return NULL;
     }
 
-    if (dn)
-    {
-        search->dn = strdupW( dn );
-        if (!search->dn) goto fail;
-    }
-    if (filter)
-    {
-        search->filter = strdupW( filter );
-        if (!search->filter) goto fail;
-    }
-    if (attrs)
-    {
-        search->attrs = strarraydupW( attrs );
-        if (!search->attrs) goto fail;
-    }
+    if (dn && !(search->dn = strdupW( dn ))) goto fail;
+    if (filter && !(search->filter = strdupW( filter ))) goto fail;
+    if (attrs && !(search->attrs = strarraydupW( attrs ))) goto fail;
 
     len = serverctrls ? controlarraylenW( serverctrls ) : 0;
-    search->serverctrls = heap_alloc( sizeof(LDAPControl *) * (len + 2) );
-    if (!search->serverctrls) goto fail;
+    if (!(search->serverctrls = heap_alloc( sizeof(LDAPControlW *) * (len + 2) ))) goto fail;
     search->serverctrls[0] = NULL; /* reserve 0 for page control */
     for (i = 0; i < len; i++)
     {
-        search->serverctrls[i + 1] = controldupW( serverctrls[i] );
-        if (!search->serverctrls[i + 1]) goto fail;
+        if (!(search->serverctrls[i + 1] = controldupW( serverctrls[i] )))
+        {
+            for (; i > 0; i--) controlfreeW( search->serverctrls[i] );
+            goto fail;
+        }
     }
     search->serverctrls[len + 1] = NULL;
 
-    if (clientctrls)
+    if (clientctrls && !(search->clientctrls = controlarraydupW( clientctrls )))
     {
-        search->clientctrls = controlarraydupW( clientctrls );
-        if (!search->clientctrls) goto fail;
+        for (i = 0; i < len; i++) controlfreeW( search->serverctrls[i] );
+        goto fail;
     }
 
-    search->scope = scope;
-    search->attrsonly = attrsonly;
-    search->timeout.tv_sec = timelimit;
+    search->scope           = scope;
+    search->attrsonly       = attrsonly;
+    search->timeout.tv_sec  = timelimit;
     search->timeout.tv_usec = 0;
-    search->sizelimit = sizelimit;
-    search->cookie = NULL;
-
+    search->sizelimit       = sizelimit;
+    search->cookie          = NULL;
     return search;
 
 fail:
     ldap_search_abandon_page( ld, search );
     ld->ld_errno = WLDAP32_LDAP_NO_MEMORY;
-
-#endif
     return NULL;
 }
diff --git a/dlls/wldap32/winldap_private.h b/dlls/wldap32/winldap_private.h
index 32ed3f5a2661..e488db954c81 100644
--- a/dlls/wldap32/winldap_private.h
+++ b/dlls/wldap32/winldap_private.h
@@ -40,6 +40,8 @@
 #define WLDAP32_LDAP_SCOPE_ONELEVEL 0x01
 #define WLDAP32_LDAP_SCOPE_SUBTREE  0x02
 
+#define WLDAP32_LBER_USE_DER 0x01
+
 typedef enum {
     WLDAP32_LDAP_SUCCESS                 =   0x00,
     WLDAP32_LDAP_UNWILLING_TO_PERFORM    =   0x35,
@@ -312,6 +314,14 @@ typedef struct ldap_apifeature_infoW
     int ldapaif_version;
 } LDAPAPIFeatureInfoW;
 
+WLDAP32_BerElement * CDECL WLDAP32_ber_alloc_t(int);
+void CDECL WLDAP32_ber_bvfree(BERVAL *);
+int CDECL WLDAP32_ber_flatten(WLDAP32_BerElement *, BERVAL **);
+void CDECL WLDAP32_ber_free(WLDAP32_BerElement *, int);
+WLDAP32_BerElement * CDECL WLDAP32_ber_init(BERVAL *);
+int WINAPIV WLDAP32_ber_printf(WLDAP32_BerElement *, char *, ...);
+ULONG WINAPIV WLDAP32_ber_scanf(WLDAP32_BerElement *, char *, ...);
+
 WLDAP32_LDAP * CDECL cldap_openA(PCHAR,ULONG);
 WLDAP32_LDAP * CDECL cldap_openW(PWCHAR,ULONG);
 ULONG CDECL WLDAP32_ldap_abandon(WLDAP32_LDAP*,ULONG);
@@ -614,6 +624,26 @@ static inline char **strarrayWtoU( WCHAR **strarray )
     return strarrayU;
 }
 
+static inline WCHAR **strarraydupW( WCHAR **strarray )
+{
+    WCHAR **strarrayW = NULL;
+    DWORD size;
+
+    if (strarray)
+    {
+        size = sizeof(WCHAR *) * (strarraylenW( strarray ) + 1);
+        if ((strarrayW = RtlAllocateHeap( GetProcessHeap(), 0, size )))
+        {
+            WCHAR **p = strarray;
+            WCHAR **q = strarrayW;
+
+            while (*p) *q++ = strdupW( *p++ );
+            *q = NULL;
+        }
+    }
+    return strarrayW;
+}
+
 static inline char *strWtoA( const WCHAR *str )
 {
     char *ret = NULL;
@@ -1161,6 +1191,52 @@ static inline DWORD controlarraylenU( LDAPControlU **controlarray )
     return p - controlarray;
 }
 
+static inline LDAPControlW *controldupW( LDAPControlW *control )
+{
+    LDAPControlW *controlW;
+    DWORD len = control->ldctl_value.bv_len;
+    char *val = NULL;
+
+    if (control->ldctl_value.bv_val)
+    {
+        if (!(val = RtlAllocateHeap( GetProcessHeap(), 0, len ))) return NULL;
+        memcpy( val, control->ldctl_value.bv_val, len );
+    }
+
+    if (!(controlW = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(LDAPControlW) )))
+    {
+        RtlFreeHeap( GetProcessHeap(), 0, val );
+        return NULL;
+    }
+
+    controlW->ldctl_oid = strdupW( control->ldctl_oid );
+    controlW->ldctl_value.bv_len = len;
+    controlW->ldctl_value.bv_val = val;
+    controlW->ldctl_iscritical = control->ldctl_iscritical;
+
+    return controlW;
+}
+
+static inline LDAPControlW **controlarraydupW( LDAPControlW **controlarray )
+{
+    LDAPControlW **controlarrayW = NULL;
+    DWORD size;
+
+    if (controlarray)
+    {
+        size = sizeof(LDAPControlW *) * (controlarraylenW( controlarray ) + 1);
+        if ((controlarrayW = RtlAllocateHeap( GetProcessHeap(), 0, size )))
+        {
+            LDAPControlW **p = controlarray;
+            LDAPControlW **q = controlarrayW;
+
+            while (*p) *q++ = controldupW( *p++ );
+            *q = NULL;
+        }
+    }
+    return controlarrayW;
+}
+
 static inline WCHAR *strUtoW( const char *str )
 {
     WCHAR *ret = NULL;
From 4bdf8f928ac2b85de76f74420dcc8059d25b9422 Mon Sep 17 00:00:00 2001
From: Huw Davies <huw@codeweavers.com>
Date: Fri, 16 Apr 2021 11:43:42 +0100
Subject: [PATCH] wldap32: Remove unnecessary test of sortkey.

Signed-off-by: Huw Davies <huw@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/wldap32/control.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/wldap32/control.c b/dlls/wldap32/control.c
index 42098fc814a1..b012648797c9 100644
--- a/dlls/wldap32/control.c
+++ b/dlls/wldap32/control.c
@@ -152,7 +152,7 @@ ULONG CDECL ldap_create_sort_controlW( WLDAP32_LDAP *ld, LDAPSortKeyW **sortkey,
 
     if (!ld || !sortkey || !control) return WLDAP32_LDAP_PARAM_ERROR;
 
-    if (sortkey && !(sortkeyU = sortkeyarrayWtoU( sortkey ))) return WLDAP32_LDAP_NO_MEMORY;
+    if (!(sortkeyU = sortkeyarrayWtoU( sortkey ))) return WLDAP32_LDAP_NO_MEMORY;
 
     ret = map_error( ldap_funcs->ldap_create_sort_control( ld->ld, sortkeyU, critical, &controlU ) );
     if (ret == WLDAP32_LDAP_SUCCESS)
From 274e3991213d7c65c4a7e0fc4a0228d563fd7de2 Mon Sep 17 00:00:00 2001
From: Hans Leidekker <hans@codeweavers.com>
Date: Mon, 19 Apr 2021 10:04:47 +0200
Subject: [PATCH] wldap32: Move support for parse functions to the Unix
 library.

Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/wldap32/libldap.c         |  32 ++++
 dlls/wldap32/libldap.h         |  11 ++
 dlls/wldap32/parse.c           | 286 +++++++++++++--------------------
 dlls/wldap32/winldap_private.h |  40 +++++
 4 files changed, 199 insertions(+), 170 deletions(-)

diff --git a/dlls/wldap32/libldap.c b/dlls/wldap32/libldap.c
index 662edb4d3652..f71970e2a59e 100644
--- a/dlls/wldap32/libldap.c
+++ b/dlls/wldap32/libldap.c
@@ -338,6 +338,11 @@ void CDECL wrap_ldap_control_free( LDAPControlU *control )
     ldap_control_free( (LDAPControl *)control );
 }
 
+void CDECL wrap_ldap_controls_free( LDAPControlU **control )
+{
+    ldap_controls_free( (LDAPControl **)control );
+}
+
 int CDECL wrap_ldap_count_entries( void *ld, void *chain )
 {
     return ldap_count_entries( ld, chain );
@@ -481,12 +486,34 @@ void * CDECL wrap_ldap_next_reference( void *ld, void *entry )
     return ldap_next_reference( ld, entry );
 }
 
+int CDECL wrap_ldap_parse_extended_result( void *ld, void *result, char **retoid, struct bervalU **retdata, int free )
+{
+    return ldap_parse_extended_result( ld, result, retoid, (struct berval **)retdata, free );
+}
+
+int CDECL wrap_ldap_parse_reference( void *ld, void *ref, char ***referrals, LDAPControlU ***serverctrls, int free )
+{
+    return ldap_parse_reference( ld, ref, referrals, (LDAPControl ***)serverctrls, free );
+}
+
 int CDECL wrap_ldap_parse_result( void *ld, void *res, int *errcode, char **matcheddn, char **errmsg,
                                   char ***referrals, LDAPControlU ***serverctrls, int free )
 {
     return ldap_parse_result( ld, res, errcode, matcheddn, errmsg, referrals, (LDAPControl ***)serverctrls, free );
 }
 
+int CDECL wrap_ldap_parse_sortresponse_control( void *ld, LDAPControlU *ctrl, int *result, char **attr )
+{
+    return ldap_parse_sortresponse_control( ld, (LDAPControl *)ctrl, result, attr );
+}
+
+int CDECL wrap_ldap_parse_vlvresponse_control( void *ld, LDAPControlU *ctrls, int *target_pos, int *list_count,
+                                               struct bervalU **ctx, int *errcode )
+{
+    return ldap_parse_vlvresponse_control( ld, (LDAPControl *)ctrls, target_pos, list_count, (struct berval **)ctx,
+                                           errcode );
+}
+
 int CDECL wrap_ldap_rename( void *ld, const char *dn, const char *newrdn, const char *newparent, int delete,
                             LDAPControlU **clientctrls, LDAPControlU **serverctrls, ULONG *msg )
 {
@@ -598,6 +625,7 @@ static const struct ldap_funcs funcs =
     wrap_ldap_compare_ext,
     wrap_ldap_compare_ext_s,
     wrap_ldap_control_free,
+    wrap_ldap_controls_free,
     wrap_ldap_count_entries,
     wrap_ldap_count_references,
     wrap_ldap_count_values_len,
@@ -624,7 +652,11 @@ static const struct ldap_funcs funcs =
     wrap_ldap_next_attribute,
     wrap_ldap_next_entry,
     wrap_ldap_next_reference,
+    wrap_ldap_parse_extended_result,
+    wrap_ldap_parse_reference,
     wrap_ldap_parse_result,
+    wrap_ldap_parse_sortresponse_control,
+    wrap_ldap_parse_vlvresponse_control,
     wrap_ldap_rename,
     wrap_ldap_rename_s,
     wrap_ldap_result,
diff --git a/dlls/wldap32/libldap.h b/dlls/wldap32/libldap.h
index 8745eac3abcf..1dfadf7e3bce 100644
--- a/dlls/wldap32/libldap.h
+++ b/dlls/wldap32/libldap.h
@@ -123,6 +123,7 @@ extern int CDECL wrap_ldap_compare_ext(void *, const char *, const char *, struc
 extern int CDECL wrap_ldap_compare_ext_s(void *, const char *, const char *, struct bervalU *, LDAPControlU **,
                                          LDAPControlU **) DECLSPEC_HIDDEN;
 extern void CDECL wrap_ldap_control_free(LDAPControlU *) DECLSPEC_HIDDEN;
+extern void CDECL wrap_ldap_controls_free(LDAPControlU **) DECLSPEC_HIDDEN;
 extern int CDECL wrap_ldap_count_entries(void *, void *) DECLSPEC_HIDDEN;
 extern int CDECL wrap_ldap_count_references(void *, void *) DECLSPEC_HIDDEN;
 extern int CDECL wrap_ldap_count_values_len(struct bervalU **) DECLSPEC_HIDDEN;
@@ -153,8 +154,13 @@ extern int CDECL wrap_ldap_msgfree(void *) DECLSPEC_HIDDEN;
 extern char * CDECL wrap_ldap_next_attribute(void *, void *, void *) DECLSPEC_HIDDEN;
 extern void * CDECL wrap_ldap_next_entry(void *, void *) DECLSPEC_HIDDEN;
 extern void * CDECL wrap_ldap_next_reference(void *, void *) DECLSPEC_HIDDEN;
+extern int CDECL wrap_ldap_parse_extended_result(void *, void *, char **, struct bervalU **, int) DECLSPEC_HIDDEN;
+extern int CDECL wrap_ldap_parse_reference(void *, void *, char ***, LDAPControlU ***, int) DECLSPEC_HIDDEN;
 extern int CDECL wrap_ldap_parse_result(void *, void *, int *, char **, char **, char ***, LDAPControlU ***,
                                         int) DECLSPEC_HIDDEN;
+extern int CDECL wrap_ldap_parse_sortresponse_control(void *, LDAPControlU *, int *, char **) DECLSPEC_HIDDEN;
+extern int CDECL wrap_ldap_parse_vlvresponse_control(void *, LDAPControlU *, int *, int *, struct bervalU **,
+                                                     int *) DECLSPEC_HIDDEN;
 extern int CDECL wrap_ldap_rename(void *, const char *, const char *, const char *, int, LDAPControlU **,
                                   LDAPControlU **, ULONG *) DECLSPEC_HIDDEN;
 extern int CDECL wrap_ldap_rename_s(void *, const char *, const char *, const char *, int, LDAPControlU **,
@@ -199,6 +205,7 @@ struct ldap_funcs
     int (CDECL *ldap_compare_ext_s)(void *, const char *, const char *, struct bervalU *, LDAPControlU **,
                                     LDAPControlU **);
     void (CDECL *ldap_control_free)(LDAPControlU *);
+    void (CDECL *ldap_controls_free)(LDAPControlU **);
     int (CDECL *ldap_count_entries)(void *, void *);
     int (CDECL *ldap_count_references)(void *, void *);
     int (CDECL *ldap_count_values_len)(struct bervalU **);
@@ -227,7 +234,11 @@ struct ldap_funcs
     char * (CDECL *ldap_next_attribute)(void *, void *, void *);
     void * (CDECL *ldap_next_entry)(void *, void *);
     void * (CDECL *ldap_next_reference)(void *, void *);
+    int (CDECL *ldap_parse_extended_result)(void *, void *, char **, struct bervalU **, int);
+    int (CDECL *ldap_parse_reference)(void *, void *, char ***, LDAPControlU ***, int);
     int (CDECL *ldap_parse_result)(void *, void *, int *, char **, char **, char ***, LDAPControlU ***, int);
+    int (CDECL *ldap_parse_sortresponse_control)(void *, LDAPControlU *, int *, char **);
+    int (CDECL *ldap_parse_vlvresponse_control)(void *, LDAPControlU *, int *, int *, struct bervalU **, int *);
     int (CDECL *ldap_rename)(void *, const char *, const char *, const char *, int, LDAPControlU **, LDAPControlU **,
                              ULONG *);
     int (CDECL *ldap_rename_s)(void *, const char *, const char *, const char *, int, LDAPControlU **, LDAPControlU **);
diff --git a/dlls/wldap32/parse.c b/dlls/wldap32/parse.c
index bbaa7b1f842d..1b6994352237 100644
--- a/dlls/wldap32/parse.c
+++ b/dlls/wldap32/parse.c
@@ -18,36 +18,25 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#include "config.h"
-#include "wine/port.h"
-
 #include <stdarg.h>
-#ifdef HAVE_LDAP_H
-#include <ldap.h>
-#endif
-
 #include "windef.h"
 #include "winbase.h"
 #include "winnls.h"
 
-#include "winldap_private.h"
-#include "wldap32.h"
 #include "wine/debug.h"
+#include "winldap_private.h"
 
-#ifdef HAVE_LDAP
 WINE_DEFAULT_DEBUG_CHANNEL(wldap32);
-#endif
 
 /***********************************************************************
  *      ldap_parse_extended_resultA     (WLDAP32.@)
  *
  * See ldap_parse_extended_resultW.
  */
-ULONG CDECL ldap_parse_extended_resultA( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *result,
-    PCHAR *oid, struct WLDAP32_berval **data, BOOLEAN free )
+ULONG CDECL ldap_parse_extended_resultA( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *result, char **oid,
+    struct WLDAP32_berval **data, BOOLEAN free )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret;
     WCHAR *oidW = NULL;
 
     TRACE( "(%p, %p, %p, %p, 0x%02x)\n", ld, result, oid, data, free );
@@ -56,21 +45,20 @@ ULONG CDECL ldap_parse_extended_resultA( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *
     if (!result) return WLDAP32_LDAP_NO_RESULTS_RETURNED;
 
     ret = ldap_parse_extended_resultW( ld, result, &oidW, data, free );
-
-    if (oid) {
-        *oid = strWtoA( oidW );
-        if (!*oid) ret = WLDAP32_LDAP_NO_MEMORY;
+    if (oid && oidW)
+    {
+        char *str;
+        if ((str = strWtoA( oidW ))) *oid = str;
+        else ret = WLDAP32_LDAP_NO_MEMORY;
         ldap_memfreeW( oidW );
     }
-
-#endif
     return ret;
 }
 
 /***********************************************************************
  *      ldap_parse_extended_resultW     (WLDAP32.@)
  *
- * Parse the result of an extended operation. 
+ * Parse the result of an extended operation.
  *
  * PARAMS
  *  ld      [I] Pointer to an LDAP context.
@@ -88,26 +76,33 @@ ULONG CDECL ldap_parse_extended_resultA( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *
  *  value for 'free' or call ldap_msgfree to free the result message.
  */
 ULONG CDECL ldap_parse_extended_resultW( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *result,
-    PWCHAR *oid, struct WLDAP32_berval **data, BOOLEAN free )
+    WCHAR **oid, struct WLDAP32_berval **data, BOOLEAN free )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret;
     char *oidU = NULL;
+    struct bervalU *dataU = NULL;
 
     TRACE( "(%p, %p, %p, %p, 0x%02x)\n", ld, result, oid, data, free );
 
     if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
     if (!result) return WLDAP32_LDAP_NO_RESULTS_RETURNED;
 
-    ret = map_error( ldap_parse_extended_result( ld->ld, result->Request, &oidU, (struct berval **)data, free ) );
-
-    if (oid) {
-        *oid = strUtoW( oidU );
-        if (!*oid) ret = WLDAP32_LDAP_NO_MEMORY;
-        ldap_memfree( oidU );
+    ret = map_error( ldap_funcs->ldap_parse_extended_result( ld->ld, result, &oidU, &dataU, free ) );
+    if (oid && oidU)
+    {
+        WCHAR *str;
+        if ((str = strUtoW( oidU ))) *oid = str;
+        else ret = WLDAP32_LDAP_NO_MEMORY;
+        ldap_funcs->ldap_memfree( oidU );
+    }
+    if (data && dataU)
+    {
+        struct WLDAP32_berval *bv;
+        if ((bv = bervalUtoW( dataU ))) *data = bv;
+        else ret = WLDAP32_LDAP_NO_MEMORY;
+        ldap_funcs->ber_bvfree( dataU );
     }
 
-#endif
     return ret;
 }
 
@@ -116,11 +111,9 @@ ULONG CDECL ldap_parse_extended_resultW( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *
  *
  * See ldap_parse_referenceW.
  */
-ULONG CDECL ldap_parse_referenceA( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *message,
-    PCHAR **referrals )
+ULONG CDECL ldap_parse_referenceA( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *message, char ***referrals )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret;
     WCHAR **referralsW = NULL;
 
     TRACE( "(%p, %p, %p)\n", ld, message, referrals );
@@ -128,11 +121,13 @@ ULONG CDECL ldap_parse_referenceA( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *messag
     if (!ld) return ~0u;
 
     ret = ldap_parse_referenceW( ld, message, &referralsW );
-
-    *referrals = strarrayWtoA( referralsW );
-    ldap_value_freeW( referralsW );
-
-#endif 
+    if (referralsW)
+    {
+        char **ref;
+        if ((ref = strarrayWtoA( referralsW ))) *referrals = ref;
+        else ret = WLDAP32_LDAP_NO_MEMORY;
+        ldap_value_freeW( referralsW );
+    }
     return ret;
 }
 
@@ -153,23 +148,23 @@ ULONG CDECL ldap_parse_referenceA( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *messag
  * NOTES
  *  Free the referrals with ldap_value_free.
  */
-ULONG CDECL ldap_parse_referenceW( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *result,
-    PWCHAR **referrals )
+ULONG CDECL ldap_parse_referenceW( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *message, WCHAR ***referrals )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP_PARSE_REFERENCE
+    ULONG ret;
     char **referralsU = NULL;
 
-    TRACE( "(%p, %p, %p)\n", ld, result, referrals );
+    TRACE( "(%p, %p, %p)\n", ld, message, referrals );
 
     if (!ld) return ~0u;
 
-    ret = map_error( ldap_parse_reference( ld->ld, result->Request, &referralsU, NULL, 0 ));
-
-    *referrals = strarrayUtoW( referralsU );
-    ldap_memfree( referralsU );
-
-#endif
+    ret = map_error( ldap_funcs->ldap_parse_reference( ld->ld, message, &referralsU, NULL, 0 ) );
+    if (referralsU)
+    {
+        WCHAR **ref;
+        if ((ref = strarrayUtoW( referralsU ))) *referrals = ref;
+        else ret = WLDAP32_LDAP_NO_MEMORY;
+        ldap_funcs->ldap_memfree( referralsU );
+    }
     return ret;
 }
 
@@ -178,26 +173,22 @@ ULONG CDECL ldap_parse_referenceW( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *result
  *
  * See ldap_parse_resultW.
  */
-ULONG CDECL ldap_parse_resultA( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *result,
-    ULONG *retcode, PCHAR *matched, PCHAR *error, PCHAR **referrals,
-    PLDAPControlA **serverctrls, BOOLEAN free )
+ULONG CDECL ldap_parse_resultA( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *result, ULONG *retcode, char **matched,
+    char **error, char ***referrals, LDAPControlA ***serverctrls, BOOLEAN free )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret;
     WCHAR *matchedW = NULL, *errorW = NULL, **referralsW = NULL;
     LDAPControlW **serverctrlsW = NULL;
 
-    TRACE( "(%p, %p, %p, %p, %p, %p, %p, 0x%02x)\n", ld, result, retcode,
-           matched, error, referrals, serverctrls, free );
+    TRACE( "(%p, %p, %p, %p, %p, %p, %p, 0x%02x)\n", ld, result, retcode, matched, error, referrals, serverctrls,
+           free );
 
     if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
 
-    ret = ldap_parse_resultW( ld, result, retcode, &matchedW, &errorW,
-                              &referralsW, &serverctrlsW, free );
+    ret = ldap_parse_resultW( ld, result, retcode, &matchedW, &errorW, &referralsW, &serverctrlsW, free );
 
     if (matched) *matched = strWtoA( matchedW );
     if (error) *error = strWtoA( errorW );
-
     if (referrals) *referrals = strarrayWtoA( referralsW );
     if (serverctrls) *serverctrls = controlarrayWtoA( serverctrlsW );
 
@@ -205,15 +196,13 @@ ULONG CDECL ldap_parse_resultA( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *result,
     ldap_memfreeW( errorW );
     ldap_value_freeW( referralsW );
     ldap_controls_freeW( serverctrlsW );
-
-#endif
     return ret;
 }
 
 /***********************************************************************
  *      ldap_parse_resultW     (WLDAP32.@)
  *
- * Parse a result message. 
+ * Parse a result message.
  *
  * PARAMS
  *  ld           [I] Pointer to an LDAP context.
@@ -235,35 +224,30 @@ ULONG CDECL ldap_parse_resultA( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *result,
  *  ldap_controls_free. Pass a nonzero value for 'free' or call
  *  ldap_msgfree to free the result message.
  */
-ULONG CDECL ldap_parse_resultW( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *result,
-    ULONG *retcode, PWCHAR *matched, PWCHAR *error, PWCHAR **referrals,
-    PLDAPControlW **serverctrls, BOOLEAN free )
+ULONG CDECL ldap_parse_resultW( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *result, ULONG *retcode, WCHAR **matched,
+    WCHAR **error, WCHAR ***referrals, LDAPControlW ***serverctrls, BOOLEAN free )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret;
     char *matchedU = NULL, *errorU = NULL, **referralsU = NULL;
-    LDAPControl **serverctrlsU = NULL;
+    LDAPControlU **serverctrlsU = NULL;
 
-    TRACE( "(%p, %p, %p, %p, %p, %p, %p, 0x%02x)\n", ld, result, retcode,
-           matched, error, referrals, serverctrls, free );
+    TRACE( "(%p, %p, %p, %p, %p, %p, %p, 0x%02x)\n", ld, result, retcode, matched, error, referrals, serverctrls,
+           free );
 
     if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
 
-    ret = map_error( ldap_parse_result( ld->ld, result->Request, (int *)retcode, &matchedU, &errorU,
-                                        &referralsU, &serverctrlsU, free ));
+    ret = map_error( ldap_funcs->ldap_parse_result( ld->ld, result->Request, (int *)retcode, &matchedU, &errorU,
+                                                    &referralsU, &serverctrlsU, free ) );
 
     if (matched) *matched = strUtoW( matchedU );
     if (error) *error = strUtoW( errorU );
-
     if (referrals) *referrals = strarrayUtoW( referralsU );
     if (serverctrls) *serverctrls = controlarrayUtoW( serverctrlsU );
 
-    ldap_memfree( matchedU );
-    ldap_memfree( errorU );
-    ldap_memvfree( (void **)referralsU );
-    ldap_controls_free( serverctrlsU );
-
-#endif
+    ldap_funcs->ldap_memfree( matchedU );
+    ldap_funcs->ldap_memfree( errorU );
+    ldap_funcs->ldap_memvfree( (void **)referralsU );
+    ldap_funcs->ldap_controls_free( serverctrlsU );
     return ret;
 }
 
@@ -272,11 +256,9 @@ ULONG CDECL ldap_parse_resultW( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *result,
  *
  * See ldap_parse_sort_controlW.
  */
-ULONG CDECL ldap_parse_sort_controlA( WLDAP32_LDAP *ld, PLDAPControlA *control,
-    ULONG *result, PCHAR *attr )
+ULONG CDECL ldap_parse_sort_controlA( WLDAP32_LDAP *ld, LDAPControlA **control, ULONG *result, char **attr )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret;
     WCHAR *attrW = NULL;
     LDAPControlW **controlW = NULL;
 
@@ -284,16 +266,12 @@ ULONG CDECL ldap_parse_sort_controlA( WLDAP32_LDAP *ld, PLDAPControlA *control,
 
     if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
     if (!control) return WLDAP32_LDAP_CONTROL_NOT_FOUND;
-
-    controlW = controlarrayAtoW( control );
-    if (!controlW) return WLDAP32_LDAP_NO_MEMORY;
+    if (!(controlW = controlarrayAtoW( control ))) return WLDAP32_LDAP_NO_MEMORY;
 
     ret = ldap_parse_sort_controlW( ld, controlW, result, &attrW );
 
     *attr = strWtoA( attrW );
     controlarrayfreeW( controlW );
-
-#endif
     return ret;
 }
 
@@ -315,36 +293,20 @@ ULONG CDECL ldap_parse_sort_controlA( WLDAP32_LDAP *ld, PLDAPControlA *control,
  * NOTES
  *  If the function fails, free the failing attribute with ldap_memfree.
  */
-ULONG CDECL ldap_parse_sort_controlW( WLDAP32_LDAP *ld, PLDAPControlW *control,
-    ULONG *result, PWCHAR *attr )
+ULONG CDECL ldap_parse_sort_controlW( WLDAP32_LDAP *ld, LDAPControlW **control, ULONG *result, WCHAR **attr )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret;
     char *attrU = NULL;
-    LDAPControl **controlU = NULL;
-#ifdef HAVE_LDAP_PARSE_SORT_CONTROL
-    unsigned long res;
-#elif defined(HAVE_LDAP_PARSE_SORTRESPONSE_CONTROL)
-    ber_int_t res;
-    LDAPControl *sortcontrol = NULL;
+    LDAPControlU **controlU, *sortcontrol = NULL;
+    int res;
     unsigned int i;
-#endif
 
     TRACE( "(%p, %p, %p, %p)\n", ld, control, result, attr );
 
     if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
     if (!control) return WLDAP32_LDAP_CONTROL_NOT_FOUND;
+    if (!(controlU = controlarrayWtoU( control ))) return WLDAP32_LDAP_NO_MEMORY;
 
-    controlU = controlarrayWtoU( control );
-    if (!controlU) return WLDAP32_LDAP_NO_MEMORY;
-
-#ifdef HAVE_LDAP_PARSE_SORT_CONTROL
-    if (!(ret = ldap_parse_sort_control( ld->ld, controlU, &res, &attrU )))
-    {
-        *result = res;
-        *attr = strUtoW( attrU );
-    }
-#elif defined(HAVE_LDAP_PARSE_SORTRESPONSE_CONTROL)
     for (i = 0; controlU[i]; i++)
     {
         if (!strcmp( LDAP_SERVER_RESP_SORT_OID, controlU[i]->ldctl_oid ))
@@ -355,16 +317,22 @@ ULONG CDECL ldap_parse_sort_controlW( WLDAP32_LDAP *ld, PLDAPControlW *control,
         controlarrayfreeU( controlU );
         return WLDAP32_LDAP_CONTROL_NOT_FOUND;
     }
-    if (!(ret = ldap_parse_sortresponse_control( ld->ld, sortcontrol, &res, &attrU )))
+
+    ret = map_error( ldap_funcs->ldap_parse_sortresponse_control( ld->ld, sortcontrol, &res, &attrU ) );
+    if (ret == WLDAP32_LDAP_SUCCESS)
     {
-        *result = res;
-        *attr = strUtoW( attrU );
+        WCHAR *str;
+        if ((str = strUtoW( attrU )))
+        {
+            *attr = str;
+            *result = res;
+        }
+        else ret = WLDAP32_LDAP_NO_MEMORY;
+        ldap_funcs->ldap_memfree( attrU );
     }
-#endif
-    controlarrayfreeU( controlU );
 
-#endif
-    return map_error( ret );
+    controlarrayfreeU( controlU );
+    return ret;
 }
 
 /***********************************************************************
@@ -372,30 +340,19 @@ ULONG CDECL ldap_parse_sort_controlW( WLDAP32_LDAP *ld, PLDAPControlW *control,
  *
  * See ldap_parse_vlv_controlW.
  */
-INT CDECL ldap_parse_vlv_controlA( WLDAP32_LDAP *ld, PLDAPControlA *control,
-    PULONG targetpos, PULONG listcount,
-    struct WLDAP32_berval **context, PINT errcode )
+int CDECL ldap_parse_vlv_controlA( WLDAP32_LDAP *ld, LDAPControlA **control, ULONG *targetpos, ULONG *listcount,
+    struct WLDAP32_berval **context, int *errcode )
 {
-    int ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    int ret;
     LDAPControlW **controlW = NULL;
 
-    TRACE( "(%p, %p, %p, %p, %p, %p)\n", ld, control, targetpos,
-           listcount, context, errcode );
+    TRACE( "(%p, %p, %p, %p, %p, %p)\n", ld, control, targetpos, listcount, context, errcode );
 
     if (!ld) return ~0u;
 
-    if (control) {
-        controlW = controlarrayAtoW( control );
-        if (!controlW) return WLDAP32_LDAP_NO_MEMORY;
-    }
-
-    ret = ldap_parse_vlv_controlW( ld, controlW, targetpos, listcount,
-                                   context, errcode );
-
+    if (control && !(controlW = controlarrayAtoW( control ))) return WLDAP32_LDAP_NO_MEMORY;
+    ret = ldap_parse_vlv_controlW( ld, controlW, targetpos, listcount, context, errcode );
     controlarrayfreeW( controlW );
-
-#endif
     return ret;
 }
 
@@ -419,56 +376,45 @@ INT CDECL ldap_parse_vlv_controlA( WLDAP32_LDAP *ld, PLDAPControlA *control,
  * NOTES
  *  Free the server context with ber_bvfree.
  */
-INT CDECL ldap_parse_vlv_controlW( WLDAP32_LDAP *ld, PLDAPControlW *control,
-    PULONG targetpos, PULONG listcount,
-    struct WLDAP32_berval **context, PINT errcode )
+int CDECL ldap_parse_vlv_controlW( WLDAP32_LDAP *ld, LDAPControlW **control, ULONG *targetpos, ULONG *listcount,
+    struct WLDAP32_berval **context, int *errcode )
 {
-    int ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
-    LDAPControl **controlU = NULL;
-#ifdef HAVE_LDAP_PARSE_VLV_CONTROL
-    unsigned long pos, count;
-#elif defined(HAVE_LDAP_PARSE_VLVRESPONSE_CONTROL)
-    ber_int_t pos, count;
-    LDAPControl *vlvcontrol = NULL;
+    int ret, pos, count;
+    LDAPControlU **controlU, *vlvcontrolU = NULL;
+    struct bervalU *ctxU;
     unsigned int i;
-#endif
 
-    TRACE( "(%p, %p, %p, %p, %p, %p)\n", ld, control, targetpos,
-           listcount, context, errcode );
+    TRACE( "(%p, %p, %p, %p, %p, %p)\n", ld, control, targetpos, listcount, context, errcode );
 
     if (!ld || !control) return ~0u;
 
-    controlU = controlarrayWtoU( control );
-    if (!controlU) return WLDAP32_LDAP_NO_MEMORY;
+    if (!(controlU = controlarrayWtoU( control ))) return WLDAP32_LDAP_NO_MEMORY;
 
-#ifdef HAVE_LDAP_PARSE_VLV_CONTROL
-    if (!(ret = ldap_parse_vlv_control( ld->ld, controlU, &pos, &count,
-                                        (struct berval **)context, errcode )))
-    {
-        *targetpos = pos;
-        *listcount = count;
-    }
-#elif defined(HAVE_LDAP_PARSE_VLVRESPONSE_CONTROL)
     for (i = 0; controlU[i]; i++)
     {
         if (!strcmp( LDAP_CONTROL_VLVRESPONSE, controlU[i]->ldctl_oid ))
-            vlvcontrol = controlU[i];
+            vlvcontrolU = controlU[i];
     }
-    if (!vlvcontrol)
+    if (!vlvcontrolU)
     {
         controlarrayfreeU( controlU );
         return WLDAP32_LDAP_CONTROL_NOT_FOUND;
     }
-    if (!(ret = ldap_parse_vlvresponse_control( ld->ld, vlvcontrol, &pos, &count,
-                                                (struct berval **)context, errcode )))
+
+    ret = map_error( ldap_funcs->ldap_parse_vlvresponse_control( ld->ld, vlvcontrolU, &pos, &count, &ctxU, errcode ) );
+    if (ret == WLDAP32_LDAP_SUCCESS)
     {
-        *targetpos = pos;
-        *listcount = count;
+        struct WLDAP32_berval *bv;
+        if ((bv = bervalUtoW( ctxU )))
+        {
+            *context = bv;
+            *targetpos = pos;
+            *listcount = count;
+        }
+        else ret = WLDAP32_LDAP_NO_MEMORY;
+        ldap_funcs->ber_bvfree( ctxU );
     }
-#endif
-    controlarrayfreeU( controlU );
 
-#endif
-    return map_error( ret );
+    controlarrayfreeU( controlU );
+    return ret;
 }
diff --git a/dlls/wldap32/winldap_private.h b/dlls/wldap32/winldap_private.h
index e488db954c81..c80401492901 100644
--- a/dlls/wldap32/winldap_private.h
+++ b/dlls/wldap32/winldap_private.h
@@ -1237,6 +1237,26 @@ static inline LDAPControlW **controlarraydupW( LDAPControlW **controlarray )
     return controlarrayW;
 }
 
+static inline LDAPControlA **controlarrayWtoA( LDAPControlW **controlarray )
+{
+    LDAPControlA **controlarrayA = NULL;
+    DWORD size;
+
+    if (controlarray)
+    {
+        size = sizeof(LDAPControlA *) * (controlarraylenW( controlarray ) + 1);
+        if ((controlarrayA = RtlAllocateHeap( GetProcessHeap(), 0, size )))
+        {
+            LDAPControlW **p = controlarray;
+            LDAPControlA **q = controlarrayA;
+
+            while (*p) *q++ = controlWtoA( *p++ );
+            *q = NULL;
+        }
+    }
+    return controlarrayA;
+}
+
 static inline WCHAR *strUtoW( const char *str )
 {
     WCHAR *ret = NULL;
@@ -1322,6 +1342,26 @@ static inline LDAPControlW *controlUtoW( const LDAPControlU *control )
     return controlW;
 }
 
+static inline LDAPControlW **controlarrayUtoW( LDAPControlU **controlarray )
+{
+    LDAPControlW **controlarrayW = NULL;
+    DWORD size;
+
+    if (controlarray)
+    {
+        size = sizeof(LDAPControlW *) * (controlarraylenU( controlarray ) + 1);
+        if ((controlarrayW = RtlAllocateHeap( GetProcessHeap(), 0, size )))
+        {
+            LDAPControlU **p = controlarray;
+            LDAPControlW **q = controlarrayW;
+
+            while (*p) *q++ = controlUtoW( *p++ );
+            *q = NULL;
+        }
+    }
+    return controlarrayW;
+}
+
 static inline DWORD sortkeyarraylenA( LDAPSortKeyA **sortkeyarray )
 {
     LDAPSortKeyA **p = sortkeyarray;
From 91355dae9355318f0123fd14b611797315282fce Mon Sep 17 00:00:00 2001
From: Hans Leidekker <hans@codeweavers.com>
Date: Mon, 19 Apr 2021 10:04:48 +0200
Subject: [PATCH] wldap32: Move support for rename functions to the Unix
 library.

Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/wldap32/rename.c | 202 +++++++++++-------------------------------
 1 file changed, 50 insertions(+), 152 deletions(-)

diff --git a/dlls/wldap32/rename.c b/dlls/wldap32/rename.c
index b978daa8ab2f..cba4cdd7b666 100644
--- a/dlls/wldap32/rename.c
+++ b/dlls/wldap32/rename.c
@@ -18,71 +18,40 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#include "config.h"
-#include "wine/port.h"
-
 #include <stdarg.h>
-#ifdef HAVE_LDAP_H
-#include <ldap.h>
-#endif
-
 #include "windef.h"
 #include "winbase.h"
 #include "winnls.h"
 
-#include "winldap_private.h"
-#include "wldap32.h"
 #include "wine/debug.h"
+#include "winldap_private.h"
 
-#ifdef HAVE_LDAP
 WINE_DEFAULT_DEBUG_CHANNEL(wldap32);
-#endif
 
 /***********************************************************************
  *      ldap_rename_extA     (WLDAP32.@)
  *
  *  See ldap_rename_extW.
  */
-ULONG CDECL ldap_rename_extA( WLDAP32_LDAP *ld, PCHAR dn, PCHAR newrdn,
-    PCHAR newparent, INT delete, PLDAPControlA *serverctrls,
-    PLDAPControlA *clientctrls, ULONG *message )
+ULONG CDECL ldap_rename_extA( WLDAP32_LDAP *ld, char *dn, char *newrdn, char *newparent, int delete,
+    LDAPControlA **serverctrls, LDAPControlA **clientctrls, ULONG *message )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
     WCHAR *dnW = NULL, *newrdnW = NULL, *newparentW = NULL;
     LDAPControlW **serverctrlsW = NULL, **clientctrlsW = NULL;
 
-    ret = WLDAP32_LDAP_NO_MEMORY;
-
-    TRACE( "(%p, %s, %s, %s, 0x%02x, %p, %p, %p)\n", ld, debugstr_a(dn),
-           debugstr_a(newrdn), debugstr_a(newparent), delete,
-           serverctrls, clientctrls, message );
+    TRACE( "(%p, %s, %s, %s, 0x%02x, %p, %p, %p)\n", ld, debugstr_a(dn), debugstr_a(newrdn), debugstr_a(newparent),
+           delete, serverctrls, clientctrls, message );
 
     if (!ld || !message) return WLDAP32_LDAP_PARAM_ERROR;
 
-    if (dn) {
-        dnW = strAtoW( dn );
-        if (!dnW) goto exit;
-    }
-    if (newrdn) {
-        newrdnW = strAtoW( newrdn );
-        if (!newrdnW) goto exit;
-    }
-    if (newparent) {
-        newparentW = strAtoW( newparent );
-        if (!newparentW) goto exit;
-    }
-    if (serverctrls) {
-        serverctrlsW = controlarrayAtoW( serverctrls );
-        if (!serverctrlsW) goto exit;
-    }
-    if (clientctrls) {
-        clientctrlsW = controlarrayAtoW( clientctrls );
-        if (!clientctrlsW) goto exit;
-    }
+    if (dn && !(dnW = strAtoW( dn ))) goto exit;
+    if (newrdn && !(newrdnW = strAtoW( newrdn ))) goto exit;
+    if (newparent && !(newparentW = strAtoW( newparent ))) goto exit;
+    if (serverctrls && !(serverctrlsW = controlarrayAtoW( serverctrls ))) goto exit;
+    if (clientctrls && !(clientctrlsW = controlarrayAtoW( clientctrls ))) goto exit;
 
-    ret = ldap_rename_extW( ld, dnW, newrdnW, newparentW, delete,
-                            serverctrlsW, clientctrlsW, message );
+    ret = ldap_rename_extW( ld, dnW, newrdnW, newparentW, delete, serverctrlsW, clientctrlsW, message );
 
 exit:
     strfreeW( dnW );
@@ -90,8 +59,6 @@ ULONG CDECL ldap_rename_extA( WLDAP32_LDAP *ld, PCHAR dn, PCHAR newrdn,
     strfreeW( newparentW );
     controlarrayfreeW( serverctrlsW );
     controlarrayfreeW( clientctrlsW );
-
-#endif
     return ret;
 }
 
@@ -119,55 +86,32 @@ ULONG CDECL ldap_rename_extA( WLDAP32_LDAP *ld, PCHAR dn, PCHAR newrdn,
  *  the operation. Cancel the operation by calling ldap_abandon
  *  with the message ID.
  */
-ULONG CDECL ldap_rename_extW( WLDAP32_LDAP *ld, PWCHAR dn, PWCHAR newrdn,
-    PWCHAR newparent, INT delete, PLDAPControlW *serverctrls,
-    PLDAPControlW *clientctrls, ULONG *message )
+ULONG CDECL ldap_rename_extW( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *newrdn, WCHAR *newparent, int delete,
+    LDAPControlW **serverctrls, LDAPControlW **clientctrls, ULONG *message )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
     char *dnU = NULL, *newrdnU = NULL, *newparentU = NULL;
-    LDAPControl **serverctrlsU = NULL, **clientctrlsU = NULL;
+    LDAPControlU **serverctrlsU = NULL, **clientctrlsU = NULL;
 
-    ret = WLDAP32_LDAP_NO_MEMORY;
-
-    TRACE( "(%p, %s, %s, %s, 0x%02x, %p, %p, %p)\n", ld, debugstr_w(dn),
-           debugstr_w(newrdn), debugstr_w(newparent), delete,
-           serverctrls, clientctrls, message );
+    TRACE( "(%p, %s, %s, %s, 0x%02x, %p, %p, %p)\n", ld, debugstr_w(dn), debugstr_w(newrdn), debugstr_w(newparent),
+           delete, serverctrls, clientctrls, message );
 
     if (!ld || !message) return WLDAP32_LDAP_PARAM_ERROR;
 
-    if (dn) {
-        dnU = strWtoU( dn );
-        if (!dnU) goto exit;
-    }
-    if (newrdn) {
-        newrdnU = strWtoU( newrdn );
-        if (!newrdnU) goto exit;
-    }
-    if (newparent) {
-        newparentU = strWtoU( newparent );
-        if (!newparentU) goto exit;
-    }
-    if (serverctrls) {
-        serverctrlsU = controlarrayWtoU( serverctrls );
-        if (!serverctrlsU) goto exit;
-    }
-    if (clientctrls) {
-        clientctrlsU = controlarrayWtoU( clientctrls );
-        if (!clientctrlsU) goto exit;
-    }
-
-    ret = map_error( ldap_rename( ld->ld, dn ? dnU : "", newrdn ? newrdnU : "", newparentU,
-                                  delete, serverctrlsU, clientctrlsU, (int *)message ));
+    if (dn && !(dnU = strWtoU( dn ))) goto exit;
+    if (newrdn && !(newrdnU = strWtoU( newrdn ))) goto exit;
+    if (newparent && !(newparentU = strWtoU( newparent ))) goto exit;
+    if (serverctrls && !(serverctrlsU = controlarrayWtoU( serverctrls ))) goto exit;
+    if (clientctrls && !(clientctrlsU = controlarrayWtoU( clientctrls ))) goto exit;
 
+    ret = map_error( ldap_funcs->ldap_rename( ld->ld, dnU, newrdnU, newparentU, delete, serverctrlsU, clientctrlsU,
+                                              message ) );
 exit:
     strfreeU( dnU );
     strfreeU( newrdnU );
     strfreeU( newparentU );
     controlarrayfreeU( serverctrlsU );
     controlarrayfreeU( clientctrlsU );
-
-#endif
     return ret;
 }
 
@@ -176,46 +120,25 @@ ULONG CDECL ldap_rename_extW( WLDAP32_LDAP *ld, PWCHAR dn, PWCHAR newrdn,
  *
  *  See ldap_rename_ext_sW.
  */
-ULONG CDECL ldap_rename_ext_sA( WLDAP32_LDAP *ld, PCHAR dn, PCHAR newrdn,
-    PCHAR newparent, INT delete, PLDAPControlA *serverctrls,
-    PLDAPControlA *clientctrls )
+ULONG CDECL ldap_rename_ext_sA( WLDAP32_LDAP *ld, char *dn, char *newrdn, char *newparent, int delete,
+    LDAPControlA **serverctrls, LDAPControlA **clientctrls )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
     WCHAR *dnW = NULL, *newrdnW = NULL, *newparentW = NULL;
     LDAPControlW **serverctrlsW = NULL, **clientctrlsW = NULL;
 
-    ret = WLDAP32_LDAP_NO_MEMORY;
-
-    TRACE( "(%p, %s, %s, %s, 0x%02x, %p, %p)\n", ld, debugstr_a(dn),
-           debugstr_a(newrdn), debugstr_a(newparent), delete,
-           serverctrls, clientctrls );
+    TRACE( "(%p, %s, %s, %s, 0x%02x, %p, %p)\n", ld, debugstr_a(dn), debugstr_a(newrdn), debugstr_a(newparent),
+           delete, serverctrls, clientctrls );
 
     if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
 
-    if (dn) {
-        dnW = strAtoW( dn );
-        if (!dnW) goto exit;
-    }
-    if (newrdn) {
-        newrdnW = strAtoW( newrdn );
-        if (!newrdnW) goto exit;
-    }
-    if (newparent) {
-        newparentW = strAtoW( newparent );
-        if (!newparentW) goto exit;
-    }
-    if (serverctrls) {
-        serverctrlsW = controlarrayAtoW( serverctrls );
-        if (!serverctrlsW) goto exit;
-    }
-    if (clientctrls) {
-        clientctrlsW = controlarrayAtoW( clientctrls );
-        if (!clientctrlsW) goto exit;
-    }
+    if (dn && !(dnW = strAtoW( dn ))) goto exit;
+    if (newrdn && !(newrdnW = strAtoW( newrdn ))) goto exit;
+    if (newparent && !(newparentW = strAtoW( newparent ))) goto exit;
+    if (serverctrls && !(serverctrlsW = controlarrayAtoW( serverctrls ))) goto exit;
+    if (clientctrls && !(clientctrlsW = controlarrayAtoW( clientctrls ))) goto exit;
 
-    ret = ldap_rename_ext_sW( ld, dnW, newrdnW, newparentW, delete,
-                              serverctrlsW, clientctrlsW );
+    ret = ldap_rename_ext_sW( ld, dnW, newrdnW, newparentW, delete, serverctrlsW, clientctrlsW );
 
 exit:
     strfreeW( dnW );
@@ -223,8 +146,6 @@ ULONG CDECL ldap_rename_ext_sA( WLDAP32_LDAP *ld, PCHAR dn, PCHAR newrdn,
     strfreeW( newparentW );
     controlarrayfreeW( serverctrlsW );
     controlarrayfreeW( clientctrlsW );
-
-#endif
     return ret;
 }
 /***********************************************************************
@@ -244,55 +165,32 @@ ULONG CDECL ldap_rename_ext_sA( WLDAP32_LDAP *ld, PCHAR dn, PCHAR newrdn,
  * RETURNS
  *  Success: LDAP_SUCCESS
  *  Failure: An LDAP error code.
- */ 
-ULONG CDECL ldap_rename_ext_sW( WLDAP32_LDAP *ld, PWCHAR dn, PWCHAR newrdn,
-    PWCHAR newparent, INT delete, PLDAPControlW *serverctrls,
-    PLDAPControlW *clientctrls )
+ */
+ULONG CDECL ldap_rename_ext_sW( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *newrdn, WCHAR *newparent, int delete,
+    LDAPControlW **serverctrls, LDAPControlW **clientctrls )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret = WLDAP32_LDAP_PARAM_ERROR;
     char *dnU = NULL, *newrdnU = NULL, *newparentU = NULL;
-    LDAPControl **serverctrlsU = NULL, **clientctrlsU = NULL;
+    LDAPControlU **serverctrlsU = NULL, **clientctrlsU = NULL;
 
-    ret = WLDAP32_LDAP_NO_MEMORY;
-
-    TRACE( "(%p, %s, %s, %s, 0x%02x, %p, %p)\n", ld, debugstr_w(dn),
-           debugstr_w(newrdn), debugstr_w(newparent), delete,
-           serverctrls, clientctrls );
+    TRACE( "(%p, %s, %s, %s, 0x%02x, %p, %p)\n", ld, debugstr_w(dn), debugstr_w(newrdn), debugstr_w(newparent),
+           delete, serverctrls, clientctrls );
 
     if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
 
-    if (dn) {
-        dnU = strWtoU( dn );
-        if (!dnU) goto exit;
-    }
-    if (newrdn) {
-        newrdnU = strWtoU( newrdn );
-        if (!newrdnU) goto exit;
-    }
-    if (newparent) {
-        newparentU = strWtoU( newparent );
-        if (!newparentU) goto exit;
-    }
-    if (serverctrls) {
-        serverctrlsU = controlarrayWtoU( serverctrls );
-        if (!serverctrlsU) goto exit;
-    }
-    if (clientctrls) {
-        clientctrlsU = controlarrayWtoU( clientctrls );
-        if (!clientctrlsU) goto exit;
-    }
-
-    ret = map_error( ldap_rename_s( ld->ld, dn ? dnU : "", newrdn ? newrdnU : "", newparentU,
-                                    delete, serverctrlsU, clientctrlsU ));
+    if (dn && !(dnU = strWtoU( dn ))) goto exit;
+    if (newrdn && !(newrdnU = strWtoU( newrdn ))) goto exit;
+    if (newparent && !(newparentU = strWtoU( newparent ))) goto exit;
+    if (serverctrls && !(serverctrlsU = controlarrayWtoU( serverctrls ))) goto exit;
+    if (clientctrls && !(clientctrlsU = controlarrayWtoU( clientctrls ))) goto exit;
 
+    ret = map_error( ldap_funcs->ldap_rename_s( ld->ld, dnU, newrdnU, newparentU, delete, serverctrlsU,
+                                                clientctrlsU ) );
 exit:
     strfreeU( dnU );
     strfreeU( newrdnU );
     strfreeU( newparentU );
     controlarrayfreeU( serverctrlsU );
     controlarrayfreeU( clientctrlsU );
-
-#endif
     return ret;
 }
From 5a236e55c30f015055844caa04ddb70fe4193314 Mon Sep 17 00:00:00 2001
From: Hans Leidekker <hans@codeweavers.com>
Date: Mon, 19 Apr 2021 10:04:49 +0200
Subject: [PATCH] wldap32: Don't depend on libldap for the value functions.

Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/wldap32/value.c           | 174 ++++++++++++---------------------
 dlls/wldap32/winldap_private.h |  10 ++
 2 files changed, 72 insertions(+), 112 deletions(-)

diff --git a/dlls/wldap32/value.c b/dlls/wldap32/value.c
index a7d7d44244f4..249a2fae6050 100644
--- a/dlls/wldap32/value.c
+++ b/dlls/wldap32/value.c
@@ -18,21 +18,14 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#include "config.h"
-#include "wine/port.h"
-
 #include <stdarg.h>
-#ifdef HAVE_LDAP_H
-#include <ldap.h>
-#endif
-
 #include "windef.h"
 #include "winbase.h"
 #include "winnls.h"
 
-#include "winldap_private.h"
-#include "wldap32.h"
 #include "wine/debug.h"
+#include "wine/heap.h"
+#include "winldap_private.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(wldap32);
 
@@ -42,7 +35,7 @@ WINE_DEFAULT_DEBUG_CHANNEL(wldap32);
  * Count the number of values in an array of berval structures.
  *
  * PARAMS
- *  vals  [I] Pointer to an array of berval structures.
+ *  values  [I] Pointer to an array of berval structures.
  *
  * RETURNS
  *  Success: The number of values counted.
@@ -52,15 +45,15 @@ WINE_DEFAULT_DEBUG_CHANNEL(wldap32);
  *  Call ldap_count_values_len with the result of a call to
  *  ldap_get_values_len.
  */
-ULONG CDECL WLDAP32_ldap_count_values_len( struct WLDAP32_berval **vals )
+ULONG CDECL WLDAP32_ldap_count_values_len( struct WLDAP32_berval **values )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
+    ULONG ret = 0;
+    struct WLDAP32_berval **ptr = values;
 
-    TRACE( "(%p)\n", vals );
-    ret = ldap_count_values_len( (struct berval **)vals );
+    TRACE( "(%p)\n", values );
 
-#endif
+    if (!values) return 0;
+    while (*ptr++) ret++;
     return ret;
 }
 
@@ -69,23 +62,15 @@ ULONG CDECL WLDAP32_ldap_count_values_len( struct WLDAP32_berval **vals )
  *
  * See ldap_count_valuesW.
  */
-ULONG CDECL ldap_count_valuesA( PCHAR *vals )
+ULONG CDECL ldap_count_valuesA( char **values )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
-    WCHAR **valsW = NULL;
-
-    TRACE( "(%p)\n", vals );
-
-    if (!vals) return 0;
-
-    valsW = strarrayAtoW( vals );
-    if (!valsW) return WLDAP32_LDAP_NO_MEMORY;
+    ULONG ret = 0;
+    char **ptr = values;
 
-    ret = ldap_count_valuesW( valsW );
-    strarrayfreeW( valsW );
+    TRACE( "(%p)\n", values );
 
-#endif
+    if (!values) return 0;
+    while (*ptr++) ret++;
     return ret;
 }
 
@@ -95,7 +80,7 @@ ULONG CDECL ldap_count_valuesA( PCHAR *vals )
  * Count the number of values in a string array.
  *
  * PARAMS
- *  vals  [I] Pointer to an array of strings.
+ *  values  [I] Pointer to an array of strings.
  *
  * RETURNS
  *  Success: The number of values counted.
@@ -105,20 +90,15 @@ ULONG CDECL ldap_count_valuesA( PCHAR *vals )
  *  Call ldap_count_valuesW with the result of a call to
  *  ldap_get_valuesW.
  */
-ULONG CDECL ldap_count_valuesW( PWCHAR *vals )
+ULONG CDECL ldap_count_valuesW( WCHAR **values )
 {
-    ULONG ret = WLDAP32_LDAP_NOT_SUPPORTED;
-#ifdef HAVE_LDAP
-    WCHAR **p = vals;
+    ULONG ret = 0;
+    WCHAR **p = values;
 
-    TRACE( "(%p)\n", vals );
+    TRACE( "(%p)\n", values );
 
-    if (!vals) return 0;
-
-    ret = 0;
+    if (!values) return 0;
     while (*p++) ret++;
-
-#endif
     return ret;
 }
 
@@ -127,31 +107,24 @@ ULONG CDECL ldap_count_valuesW( PWCHAR *vals )
  *
  * See ldap_get_valuesW.
  */
-PCHAR * CDECL ldap_get_valuesA( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *entry, PCHAR attr )
+char ** CDECL ldap_get_valuesA( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *entry, char *attr )
 {
-    PCHAR *ret = NULL;
-#ifdef HAVE_LDAP
+    char **ret;
     WCHAR *attrW = NULL, **retW;
 
     TRACE( "(%p, %p, %s)\n", ld, entry, debugstr_a(attr) );
 
-    if (!ld || !entry || !attr) return NULL;
-
-    attrW = strAtoW( attr );
-    if (!attrW) return NULL;
+    if (!ld || !entry || !attr || !(attrW = strAtoW( attr ))) return NULL;
 
     retW = ldap_get_valuesW( ld, entry, attrW );
-
     ret = strarrayWtoA( retW );
+
     ldap_value_freeW( retW );
     strfreeW( attrW );
-
-#endif
     return ret;
 }
 
-#ifdef HAVE_LDAP
-static char *bv2str( struct berval *bv )
+static char *bv2str( struct bervalU *bv )
 {
     char *str = NULL;
     unsigned int len = bv->bv_len;
@@ -164,10 +137,10 @@ static char *bv2str( struct berval *bv )
     return str;
 }
 
-static char **bv2str_array( struct berval **bv )
+static char **bv2str_array( struct bervalU **bv )
 {
     unsigned int len = 0, i = 0;
-    struct berval **p = bv;
+    struct bervalU **p = bv;
     char **str;
 
     while (*p)
@@ -186,14 +159,13 @@ static char **bv2str_array( struct berval **bv )
             while (i > 0) heap_free( str[--i] );
             heap_free( str );
             return NULL;
-        } 
+        }
         i++;
-        p++; 
+        p++;
     }
     str[i] = NULL;
     return str;
 }
-#endif
 
 /***********************************************************************
  *      ldap_get_valuesW     (WLDAP32.@)
@@ -214,32 +186,26 @@ static char **bv2str_array( struct berval **bv )
  *  ldap_first_entry or ldap_next_entry. Free the returned
  *  array with a call to ldap_value_freeW.
  */
-PWCHAR * CDECL ldap_get_valuesW( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *entry, PWCHAR attr )
+WCHAR ** CDECL ldap_get_valuesW( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *entry, WCHAR *attr )
 {
-    PWCHAR *ret = NULL;
-#ifdef HAVE_LDAP
-    char *attrU = NULL, **retU;
-    struct berval **bv;
+    WCHAR **ret = NULL;
+    char *attrU, **retU;
+    struct bervalU **bv;
 
     TRACE( "(%p, %p, %s)\n", ld, entry, debugstr_w(attr) );
 
-    if (!ld || !entry || !attr) return NULL;
-
-    attrU = strWtoU( attr );
-    if (!attrU) return NULL;
+    if (!ld || !entry || !attr || !(attrU = strWtoU( attr ))) return NULL;
 
-    bv = ldap_get_values_len( ld->ld, entry->Request, attrU );
-    if (bv)
+    if ((bv = ldap_funcs->ldap_get_values_len( ld->ld, entry->Request, attrU )))
     {
         retU = bv2str_array( bv );
         ret = strarrayUtoW( retU );
 
-        ldap_value_free_len( bv );
+        ldap_funcs->ldap_value_free_len( bv );
         strarrayfreeU( retU );
     }
-    strfreeU( attrU );
 
-#endif
+    strfreeU( attrU );
     return ret;
 }
 
@@ -248,28 +214,19 @@ PWCHAR * CDECL ldap_get_valuesW( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *entry, P
  *
  * See ldap_get_values_lenW.
  */
-struct WLDAP32_berval ** CDECL ldap_get_values_lenA( WLDAP32_LDAP *ld,
-    WLDAP32_LDAPMessage *message, PCHAR attr )
+struct WLDAP32_berval ** CDECL ldap_get_values_lenA( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *message, char *attr )
 {
-#ifdef HAVE_LDAP
-    WCHAR *attrW = NULL;
+    WCHAR *attrW;
     struct WLDAP32_berval **ret;
 
     TRACE( "(%p, %p, %s)\n", ld, message, debugstr_a(attr) );
 
-    if (!ld || !message || !attr) return NULL;
-
-    attrW = strAtoW( attr );
-    if (!attrW) return NULL;
+    if (!ld || !message || !attr || !(attrW = strAtoW( attr ))) return NULL;
 
     ret = ldap_get_values_lenW( ld, message, attrW );
 
     strfreeW( attrW );
     return ret;
-
-#else
-    return NULL;
-#endif
 }
 
 /***********************************************************************
@@ -291,28 +248,24 @@ struct WLDAP32_berval ** CDECL ldap_get_values_lenA( WLDAP32_LDAP *ld,
  *  ldap_first_entry or ldap_next_entry. Free the returned
  *  array with a call to ldap_value_free_len.
  */
-struct WLDAP32_berval ** CDECL ldap_get_values_lenW( WLDAP32_LDAP *ld,
-    WLDAP32_LDAPMessage *message, PWCHAR attr )
+struct WLDAP32_berval ** CDECL ldap_get_values_lenW( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *message, WCHAR *attr )
 {
-#ifdef HAVE_LDAP
     char *attrU = NULL;
-    struct berval **ret;
+    struct bervalU **retU;
+    struct WLDAP32_berval **ret = NULL;
 
     TRACE( "(%p, %p, %s)\n", ld, message, debugstr_w(attr) );
 
-    if (!ld || !message || !attr) return NULL;
+    if (!ld || !message || !attr || !(attrU = strWtoU( attr ))) return NULL;
 
-    attrU = strWtoU( attr );
-    if (!attrU) return NULL;
-
-    ret = ldap_get_values_len( ld->ld, message->Request, attrU );
+    if ((retU = ldap_funcs->ldap_get_values_len( ld->ld, message->Request, attrU )))
+    {
+        ret = bvarrayUtoW( retU );
+        bvarrayfreeU( retU );
+    }
 
     strfreeU( attrU );
-    return (struct WLDAP32_berval **)ret;
-
-#else
-    return NULL;
-#endif
+    return ret;
 }
 
 /***********************************************************************
@@ -321,20 +274,17 @@ struct WLDAP32_berval ** CDECL ldap_get_values_lenW( WLDAP32_LDAP *ld,
  * Free an array of berval structures.
  *
  * PARAMS
- *  vals  [I] Array of berval structures.
+ *  values  [I] Array of berval structures.
  *
  * RETURNS
  *  Success: LDAP_SUCCESS
  *  Failure: An LDAP error code.
  */
-ULONG CDECL WLDAP32_ldap_value_free_len( struct WLDAP32_berval **vals )
+ULONG CDECL WLDAP32_ldap_value_free_len( struct WLDAP32_berval **values )
 {
-#ifdef HAVE_LDAP
-
-    TRACE( "(%p)\n", vals );
-    ldap_value_free_len( (struct berval **)vals );
+    TRACE( "(%p)\n", values );
 
-#endif
+    bvarrayfreeW( values );
     return WLDAP32_LDAP_SUCCESS;
 }
 
@@ -343,11 +293,11 @@ ULONG CDECL WLDAP32_ldap_value_free_len( struct WLDAP32_berval **vals )
  *
  * See ldap_value_freeW.
  */
-ULONG CDECL ldap_value_freeA( PCHAR *vals )
+ULONG CDECL ldap_value_freeA( char **values )
 {
-    TRACE( "(%p)\n", vals );
+    TRACE( "(%p)\n", values );
 
-    strarrayfreeA( vals );
+    strarrayfreeA( values );
     return WLDAP32_LDAP_SUCCESS;
 }
 
@@ -357,16 +307,16 @@ ULONG CDECL ldap_value_freeA( PCHAR *vals )
  * Free an array of string values.
  *
  * PARAMS
- *  vals  [I] Array of string values.
+ *  values  [I] Array of string values.
  *
  * RETURNS
  *  Success: LDAP_SUCCESS
  *  Failure: An LDAP error code.
  */
-ULONG CDECL ldap_value_freeW( PWCHAR *vals )
+ULONG CDECL ldap_value_freeW( WCHAR **values )
 {
-    TRACE( "(%p)\n", vals );
+    TRACE( "(%p)\n", values );
 
-    strarrayfreeW( vals );
+    strarrayfreeW( values );
     return WLDAP32_LDAP_SUCCESS;
 }
diff --git a/dlls/wldap32/winldap_private.h b/dlls/wldap32/winldap_private.h
index c80401492901..a59071d50dca 100644
--- a/dlls/wldap32/winldap_private.h
+++ b/dlls/wldap32/winldap_private.h
@@ -1098,6 +1098,16 @@ static inline void strfreeA( char *str )
     RtlFreeHeap( GetProcessHeap(), 0, str );
 }
 
+static inline void strarrayfreeA( char **strarray )
+{
+    if (strarray)
+    {
+        char **p = strarray;
+        while (*p) strfreeA( *p++ );
+        RtlFreeHeap( GetProcessHeap(), 0, strarray );
+    }
+}
+
 static inline void controlfreeA( LDAPControlA *control )
 {
     if (control)
From aa9f3e6e96780af3d6b028cf40fd48617ff803ab Mon Sep 17 00:00:00 2001
From: Hans Leidekker <hans@codeweavers.com>
Date: Mon, 19 Apr 2021 10:04:50 +0200
Subject: [PATCH] wldap32: Get rid of wldap32.h.

Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/wldap32/winldap_private.h |    2 -
 dlls/wldap32/wldap32.h         | 1010 --------------------------------
 2 files changed, 1012 deletions(-)
 delete mode 100644 dlls/wldap32/wldap32.h

diff --git a/dlls/wldap32/winldap_private.h b/dlls/wldap32/winldap_private.h
index a59071d50dca..2f5b4dcff72f 100644
--- a/dlls/wldap32/winldap_private.h
+++ b/dlls/wldap32/winldap_private.h
@@ -513,7 +513,6 @@ static inline char *strdupU( const char *src )
     return dst;
 }
 
-#ifndef HAVE_LDAP
 static inline WCHAR *strdupW( const WCHAR *src )
 {
     WCHAR *dst;
@@ -1525,4 +1524,3 @@ static inline void vlvinfofreeU( LDAPVLVInfoU *info )
     RtlFreeHeap( GetProcessHeap(), 0, info->ldvlv_context );
     RtlFreeHeap( GetProcessHeap(), 0, info );
 }
-#endif
diff --git a/dlls/wldap32/wldap32.h b/dlls/wldap32/wldap32.h
deleted file mode 100644
index 17132ff80c1c..000000000000
--- a/dlls/wldap32/wldap32.h
+++ /dev/null
@@ -1,1010 +0,0 @@
-/*
- * WLDAP32 - LDAP support for Wine
- *
- * Copyright 2005 Hans Leidekker
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-#include <assert.h>
-#include "wine/heap.h"
-#include "wine/unicode.h"
-
-extern HINSTANCE hwldap32 DECLSPEC_HIDDEN;
-
-ULONG map_error( int ) DECLSPEC_HIDDEN;
-
-/* A set of helper functions to convert LDAP data structures
- * to and from ansi (A), wide character (W) and utf8 (U) encodings.
- */
-
-#ifdef HAVE_LDAP
-static inline WCHAR *strdupW( const WCHAR *src )
-{
-    WCHAR *dst;
-    if (!src) return NULL;
-    if ((dst = heap_alloc( (strlenW( src ) + 1) * sizeof(WCHAR) ))) strcpyW( dst, src );
-    return dst;
-}
-
-static inline LPWSTR strAtoW( LPCSTR str )
-{
-    LPWSTR ret = NULL;
-    if (str)
-    {
-        DWORD len = MultiByteToWideChar( CP_ACP, 0, str, -1, NULL, 0 );
-        if ((ret = heap_alloc( len * sizeof(WCHAR) )))
-            MultiByteToWideChar( CP_ACP, 0, str, -1, ret, len );
-    }
-    return ret;
-}
-
-static inline LPSTR strWtoA( LPCWSTR str )
-{
-    LPSTR ret = NULL;
-    if (str)
-    {
-        DWORD len = WideCharToMultiByte( CP_ACP, 0, str, -1, NULL, 0, NULL, NULL );
-        if ((ret = heap_alloc( len )))
-            WideCharToMultiByte( CP_ACP, 0, str, -1, ret, len, NULL, NULL );
-    }
-    return ret;
-}
-
-static inline char *strWtoU( LPCWSTR str )
-{
-    LPSTR ret = NULL;
-    if (str)
-    {
-        DWORD len = WideCharToMultiByte( CP_UTF8, 0, str, -1, NULL, 0, NULL, NULL );
-        if ((ret = heap_alloc( len )))
-            WideCharToMultiByte( CP_UTF8, 0, str, -1, ret, len, NULL, NULL );
-    }
-    return ret;
-}
-
-static inline LPWSTR strUtoW( char *str )
-{
-    LPWSTR ret = NULL;
-    if (str)
-    {
-        DWORD len = MultiByteToWideChar( CP_UTF8, 0, str, -1, NULL, 0 );
-        if ((ret = heap_alloc( len * sizeof(WCHAR) )))
-            MultiByteToWideChar( CP_UTF8, 0, str, -1, ret, len );
-    }
-    return ret;
-}
-
-static inline LPWSTR strnAtoW( LPCSTR str, DWORD inlen, DWORD *outlen )
-{
-    LPWSTR ret = NULL;
-    *outlen = 0;
-    if (str)
-    {
-        DWORD len = MultiByteToWideChar( CP_ACP, 0, str, inlen, NULL, 0 );
-        if ((ret = heap_alloc( (len+1) * sizeof(WCHAR) )))
-        {
-            MultiByteToWideChar( CP_ACP, 0, str, inlen, ret, len );
-            ret[len] = 0;
-            *outlen = len;
-        }
-    }
-    return ret;
-}
-
-static inline char *strnWtoU( LPCWSTR str, DWORD inlen, DWORD *outlen )
-{
-    LPSTR ret = NULL;
-    *outlen = 0;
-    if (str)
-    {
-        DWORD len = WideCharToMultiByte( CP_UTF8, 0, str, inlen, NULL, 0, NULL, NULL );
-        if ((ret = heap_alloc( len + 1 )))
-        {
-            WideCharToMultiByte( CP_UTF8, 0, str, inlen, ret, len, NULL, NULL );
-            ret[len] = 0;
-            *outlen = len;
-        }
-    }
-    return ret;
-}
-
-static inline void strfreeA( LPSTR str )
-{
-    heap_free( str );
-}
-
-static inline void strfreeW( LPWSTR str )
-{
-    heap_free( str );
-}
-
-static inline void strfreeU( char *str )
-{
-    heap_free( str );
-}
-
-static inline DWORD strarraylenA( LPSTR *strarray )
-{
-    LPSTR *p = strarray;
-    while (*p) p++;
-    return p - strarray;
-}
-
-static inline DWORD strarraylenW( LPWSTR *strarray )
-{
-    LPWSTR *p = strarray;
-    while (*p) p++;
-    return p - strarray;
-}
-
-static inline DWORD strarraylenU( char **strarray )
-{
-    char **p = strarray;
-    while (*p) p++;
-    return p - strarray;
-}
-
-static inline LPWSTR *strarrayAtoW( LPSTR *strarray )
-{
-    LPWSTR *strarrayW = NULL;
-    DWORD size;
-
-    if (strarray)
-    {
-        size  = sizeof(WCHAR*) * (strarraylenA( strarray ) + 1);
-        if ((strarrayW = heap_alloc( size )))
-        {
-            LPSTR *p = strarray;
-            LPWSTR *q = strarrayW;
-
-            while (*p) *q++ = strAtoW( *p++ );
-            *q = NULL;
-        }
-    }
-    return strarrayW;
-}
-
-static inline LPSTR *strarrayWtoA( LPWSTR *strarray )
-{
-    LPSTR *strarrayA = NULL;
-    DWORD size;
-
-    if (strarray)
-    {
-        size = sizeof(LPSTR) * (strarraylenW( strarray ) + 1);
-        if ((strarrayA = heap_alloc( size )))
-        {
-            LPWSTR *p = strarray;
-            LPSTR *q = strarrayA;
-
-            while (*p) *q++ = strWtoA( *p++ );
-            *q = NULL;
-        }
-    }
-    return strarrayA;
-}
-
-static inline char **strarrayWtoU( LPWSTR *strarray )
-{
-    char **strarrayU = NULL;
-    DWORD size;
-
-    if (strarray)
-    {
-        size = sizeof(char*) * (strarraylenW( strarray ) + 1);
-        if ((strarrayU = heap_alloc( size )))
-        {
-            LPWSTR *p = strarray;
-            char **q = strarrayU;
-
-            while (*p) *q++ = strWtoU( *p++ );
-            *q = NULL;
-        }
-    }
-    return strarrayU;
-}
-
-static inline LPWSTR *strarrayUtoW( char **strarray )
-{
-    LPWSTR *strarrayW = NULL;
-    DWORD size;
-
-    if (strarray)
-    {
-        size = sizeof(WCHAR*) * (strarraylenU( strarray ) + 1);
-        if ((strarrayW = heap_alloc( size )))
-        {
-            char **p = strarray;
-            LPWSTR *q = strarrayW;
-
-            while (*p) *q++ = strUtoW( *p++ );
-            *q = NULL;
-        }
-    }
-    return strarrayW;
-}
-
-static inline LPWSTR *strarraydupW( LPWSTR *strarray )
-{
-    LPWSTR *strarrayW = NULL;
-    DWORD size;
-
-    if (strarray)
-    {
-        size = sizeof(WCHAR*) * (strarraylenW( strarray ) + 1);
-        if ((strarrayW = heap_alloc( size )))
-        {
-            LPWSTR *p = strarray;
-            LPWSTR *q = strarrayW;
-
-            while (*p) *q++ = strdupW( *p++ );
-            *q = NULL;
-        }
-    }
-    return strarrayW;
-}
-
-static inline void strarrayfreeW( LPWSTR *strarray )
-{
-    if (strarray)
-    {
-        LPWSTR *p = strarray;
-        while (*p) strfreeW( *p++ );
-        heap_free( strarray );
-    }
-}
-
-static inline void strarrayfreeU( char **strarray )
-{
-    if (strarray)
-    {
-        char **p = strarray;
-        while (*p) strfreeU( *p++ );
-        heap_free( strarray );
-    }
-}
-
-static inline struct WLDAP32_berval *bervalWtoW( struct WLDAP32_berval *bv )
-{
-    struct WLDAP32_berval *berval;
-    DWORD size = sizeof(*berval) + bv->bv_len;
-
-    if ((berval = heap_alloc( size )))
-    {
-        char *val = (char *)(berval + 1);
-
-        berval->bv_len = bv->bv_len;
-        berval->bv_val = val;
-        memcpy( val, bv->bv_val, bv->bv_len );
-    }
-    return berval;
-}
-
-static inline void bvarrayfreeW( struct WLDAP32_berval **bv )
-{
-    struct WLDAP32_berval **p = bv;
-    while (*p) heap_free( *p++ );
-    heap_free( bv );
-}
-#endif
-
-static inline void strarrayfreeA( LPSTR *strarray )
-{
-    if (strarray)
-    {
-        LPSTR *p = strarray;
-        while (*p) strfreeA( *p++ );
-        heap_free( strarray );
-    }
-}
-
-#ifdef HAVE_LDAP
-
-static inline struct berval *bervalWtoU( struct WLDAP32_berval *bv )
-{
-    struct berval *berval;
-    DWORD size = sizeof(*berval) + bv->bv_len;
-
-    if ((berval = heap_alloc( size )))
-    {
-        char *val = (char *)(berval + 1);
-
-        berval->bv_len = bv->bv_len;
-        berval->bv_val = val;
-        memcpy( val, bv->bv_val, bv->bv_len );
-    }
-    return berval;
-}
-
-static inline struct WLDAP32_berval *bervalUtoW( struct berval *bv )
-{
-    struct WLDAP32_berval *berval;
-    DWORD size = sizeof(*berval) + bv->bv_len;
-
-    assert( bv->bv_len <= ~0u );
-
-    if ((berval = heap_alloc( size )))
-    {
-        char *val = (char *)(berval + 1);
-
-        berval->bv_len = bv->bv_len;
-        berval->bv_val = val;
-        memcpy( val, bv->bv_val, bv->bv_len );
-    }
-    return berval;
-}
-
-static inline DWORD bvarraylenU( struct berval **bv )
-{
-    struct berval **p = bv;
-    while (*p) p++;
-    return p - bv;
-}
-
-static inline DWORD bvarraylenW( struct WLDAP32_berval **bv )
-{
-    struct WLDAP32_berval **p = bv;
-    while (*p) p++;
-    return p - bv;
-}
-
-static inline struct WLDAP32_berval **bvarrayWtoW( struct WLDAP32_berval **bv )
-{
-    struct WLDAP32_berval **berval = NULL;
-    DWORD size;
-
-    if (bv)
-    {
-        size = sizeof(*berval) * (bvarraylenW( bv ) + 1);
-        if ((berval = heap_alloc( size )))
-        {
-            struct WLDAP32_berval **p = bv;
-            struct WLDAP32_berval **q = berval;
-
-            while (*p) *q++ = bervalWtoW( *p++ );
-            *q = NULL;
-        }
-    }
-    return berval;
-}
-
-static inline struct berval **bvarrayWtoU( struct WLDAP32_berval **bv )
-{
-    struct berval **berval = NULL;
-    DWORD size;
-
-    if (bv)
-    {
-        size = sizeof(*berval) * (bvarraylenW( bv ) + 1);
-        if ((berval = heap_alloc( size )))
-        {
-            struct WLDAP32_berval **p = bv;
-            struct berval **q = berval;
-
-            while (*p) *q++ = bervalWtoU( *p++ );
-            *q = NULL;
-        }
-    }
-    return berval;
-}
-
-static inline struct WLDAP32_berval **bvarrayUtoW( struct berval **bv )
-{
-    struct WLDAP32_berval **berval = NULL;
-    DWORD size;
-
-    if (bv)
-    {
-        size = sizeof(*berval) * (bvarraylenU( bv ) + 1);
-        if ((berval = heap_alloc( size )))
-        {
-            struct berval **p = bv;
-            struct WLDAP32_berval **q = berval;
-
-            while (*p) *q++ = bervalUtoW( *p++ );
-            *q = NULL;
-        }
-    }
-    return berval;
-}
-
-static inline void bvarrayfreeU( struct berval **bv )
-{
-    struct berval **p = bv;
-    while (*p) heap_free( *p++ );
-    heap_free( bv );
-}
-
-static inline LDAPModW *modAtoW( LDAPModA *mod )
-{
-    LDAPModW *modW;
-
-    if ((modW = heap_alloc( sizeof(LDAPModW) )))
-    {
-        modW->mod_op = mod->mod_op;
-        modW->mod_type = strAtoW( mod->mod_type );
-
-        if (mod->mod_op & LDAP_MOD_BVALUES)
-            modW->mod_vals.modv_bvals = bvarrayWtoW( mod->mod_vals.modv_bvals );
-        else
-            modW->mod_vals.modv_strvals = strarrayAtoW( mod->mod_vals.modv_strvals );
-    }
-    return modW;
-}
-
-static inline LDAPMod *modWtoU( LDAPModW *mod )
-{
-    LDAPMod *modU;
-
-    if ((modU = heap_alloc( sizeof(LDAPMod) )))
-    {
-        modU->mod_op = mod->mod_op;
-        modU->mod_type = strWtoU( mod->mod_type );
-
-        if (mod->mod_op & LDAP_MOD_BVALUES)
-            modU->mod_vals.modv_bvals = bvarrayWtoU( mod->mod_vals.modv_bvals );
-        else
-            modU->mod_vals.modv_strvals = strarrayWtoU( mod->mod_vals.modv_strvals );
-    }
-    return modU;
-}
-
-static inline void modfreeW( LDAPModW *mod )
-{
-    if (mod->mod_op & LDAP_MOD_BVALUES)
-        bvarrayfreeW( mod->mod_vals.modv_bvals );
-    else
-        strarrayfreeW( mod->mod_vals.modv_strvals );
-    heap_free( mod );
-}
-
-static inline void modfreeU( LDAPMod *mod )
-{
-    if (mod->mod_op & LDAP_MOD_BVALUES)
-        bvarrayfreeU( mod->mod_vals.modv_bvals );
-    else
-        strarrayfreeU( mod->mod_vals.modv_strvals );
-    heap_free( mod );
-}
-
-static inline DWORD modarraylenA( LDAPModA **modarray )
-{
-    LDAPModA **p = modarray;
-    while (*p) p++;
-    return p - modarray;
-}
-
-static inline DWORD modarraylenW( LDAPModW **modarray )
-{
-    LDAPModW **p = modarray;
-    while (*p) p++;
-    return p - modarray;
-}
-
-static inline LDAPModW **modarrayAtoW( LDAPModA **modarray )
-{
-    LDAPModW **modarrayW = NULL;
-    DWORD size;
-
-    if (modarray)
-    {
-        size = sizeof(LDAPModW*) * (modarraylenA( modarray ) + 1);
-        if ((modarrayW = heap_alloc( size )))
-        {
-            LDAPModA **p = modarray;
-            LDAPModW **q = modarrayW;
-
-            while (*p) *q++ = modAtoW( *p++ );
-            *q = NULL;
-        }
-    }
-    return modarrayW;
-}
-
-static inline LDAPMod **modarrayWtoU( LDAPModW **modarray )
-{
-    LDAPMod **modarrayU = NULL;
-    DWORD size;
-
-    if (modarray)
-    {
-        size = sizeof(LDAPMod*) * (modarraylenW( modarray ) + 1);
-        if ((modarrayU = heap_alloc( size )))
-        {
-            LDAPModW **p = modarray;
-            LDAPMod **q = modarrayU;
-
-            while (*p) *q++ = modWtoU( *p++ );
-            *q = NULL;
-        }
-    }
-    return modarrayU;
-}
-
-static inline void modarrayfreeW( LDAPModW **modarray )
-{
-    if (modarray)
-    {
-        LDAPModW **p = modarray;
-        while (*p) modfreeW( *p++ );
-        heap_free( modarray );
-    }
-}
-
-static inline void modarrayfreeU( LDAPMod **modarray )
-{
-    if (modarray)
-    {
-        LDAPMod **p = modarray;
-        while (*p) modfreeU( *p++ );
-        heap_free( modarray );
-    }
-}
-
-static inline LDAPControlW *controlAtoW( LDAPControlA *control )
-{
-    LDAPControlW *controlW;
-    DWORD len = control->ldctl_value.bv_len;
-    char *val = NULL;
-
-    if (control->ldctl_value.bv_val)
-    {
-        if (!(val = heap_alloc( len ))) return NULL;
-        memcpy( val, control->ldctl_value.bv_val, len );
-    }
-
-    if (!(controlW = heap_alloc( sizeof(LDAPControlW) )))
-    {
-        heap_free( val );
-        return NULL;
-    }
-
-    controlW->ldctl_oid = strAtoW( control->ldctl_oid );
-    controlW->ldctl_value.bv_len = len; 
-    controlW->ldctl_value.bv_val = val; 
-    controlW->ldctl_iscritical = control->ldctl_iscritical;
-
-    return controlW;
-}
-
-static inline LDAPControlA *controlWtoA( LDAPControlW *control )
-{
-    LDAPControlA *controlA;
-    DWORD len = control->ldctl_value.bv_len;
-    char *val = NULL;
-
-    if (control->ldctl_value.bv_val)
-    {
-        if (!(val = heap_alloc( len ))) return NULL;
-        memcpy( val, control->ldctl_value.bv_val, len );
-    }
-
-    if (!(controlA = heap_alloc( sizeof(LDAPControlA) )))
-    {
-        heap_free( val );
-        return NULL;
-    }
-
-    controlA->ldctl_oid = strWtoA( control->ldctl_oid );
-    controlA->ldctl_value.bv_len = len; 
-    controlA->ldctl_value.bv_val = val;
-    controlA->ldctl_iscritical = control->ldctl_iscritical;
-
-    return controlA;
-}
-
-static inline LDAPControl *controlWtoU( LDAPControlW *control )
-{
-    LDAPControl *controlU;
-    DWORD len = control->ldctl_value.bv_len;
-    char *val = NULL;
-
-    if (control->ldctl_value.bv_val)
-    {
-        if (!(val = heap_alloc( len ))) return NULL;
-        memcpy( val, control->ldctl_value.bv_val, len );
-    }
-
-    if (!(controlU = heap_alloc( sizeof(LDAPControl) )))
-    {
-        heap_free( val );
-        return NULL;
-    }
-
-    controlU->ldctl_oid = strWtoU( control->ldctl_oid );
-    controlU->ldctl_value.bv_len = len; 
-    controlU->ldctl_value.bv_val = val; 
-    controlU->ldctl_iscritical = control->ldctl_iscritical;
-
-    return controlU;
-}
-
-static inline LDAPControlW *controlUtoW( LDAPControl *control )
-{
-    LDAPControlW *controlW;
-    DWORD len = control->ldctl_value.bv_len;
-    char *val = NULL;
-
-    if (control->ldctl_value.bv_val)
-    {
-        if (!(val = heap_alloc( len ))) return NULL;
-        memcpy( val, control->ldctl_value.bv_val, len );
-    }
-
-    if (!(controlW = heap_alloc( sizeof(LDAPControlW) )))
-    {
-        heap_free( val );
-        return NULL;
-    }
-
-    controlW->ldctl_oid = strUtoW( control->ldctl_oid );
-    controlW->ldctl_value.bv_len = len;
-    controlW->ldctl_value.bv_val = val;
-    controlW->ldctl_iscritical = control->ldctl_iscritical;
-
-    return controlW;
-}
-
-static inline LDAPControlW *controldupW( LDAPControlW *control )
-{
-    LDAPControlW *controlW;
-    DWORD len = control->ldctl_value.bv_len;
-    char *val = NULL;
-
-    if (control->ldctl_value.bv_val)
-    {
-        if (!(val = heap_alloc( len ))) return NULL;
-        memcpy( val, control->ldctl_value.bv_val, len );
-    }
-
-    if (!(controlW = heap_alloc( sizeof(LDAPControlW) )))
-    {
-        heap_free( val );
-        return NULL;
-    }
-
-    controlW->ldctl_oid = strdupW( control->ldctl_oid );
-    controlW->ldctl_value.bv_len = len;
-    controlW->ldctl_value.bv_val = val;
-    controlW->ldctl_iscritical = control->ldctl_iscritical;
-
-    return controlW;
-}
-
-static inline void controlfreeA( LDAPControlA *control )
-{
-    if (control)
-    {
-        strfreeA( control->ldctl_oid );
-        heap_free( control->ldctl_value.bv_val );
-        heap_free( control );
-    }
-}
-
-static inline void controlfreeW( LDAPControlW *control )
-{
-    if (control)
-    {
-        strfreeW( control->ldctl_oid );
-        heap_free( control->ldctl_value.bv_val );
-        heap_free( control );
-    }
-}
-
-static inline void controlfreeU( LDAPControl *control )
-{
-    if (control)
-    {
-        strfreeU( control->ldctl_oid );
-        heap_free( control->ldctl_value.bv_val );
-        heap_free( control );
-    }
-}
-
-static inline DWORD controlarraylenA( LDAPControlA **controlarray )
-{
-    LDAPControlA **p = controlarray;
-    while (*p) p++;
-    return p - controlarray;
-}
-
-static inline DWORD controlarraylenW( LDAPControlW **controlarray )
-{
-    LDAPControlW **p = controlarray;
-    while (*p) p++;
-    return p - controlarray;
-}
-
-static inline DWORD controlarraylenU( LDAPControl **controlarray )
-{
-    LDAPControl **p = controlarray;
-    while (*p) p++;
-    return p - controlarray;
-}
-
-static inline LDAPControlW **controlarrayAtoW( LDAPControlA **controlarray )
-{
-    LDAPControlW **controlarrayW = NULL;
-    DWORD size;
-
-    if (controlarray)
-    {
-        size = sizeof(LDAPControlW*) * (controlarraylenA( controlarray ) + 1);
-        if ((controlarrayW = heap_alloc( size )))
-        {
-            LDAPControlA **p = controlarray;
-            LDAPControlW **q = controlarrayW;
-
-            while (*p) *q++ = controlAtoW( *p++ );
-            *q = NULL;
-        }
-    }
-    return controlarrayW;
-}
-
-static inline LDAPControlA **controlarrayWtoA( LDAPControlW **controlarray )
-{
-    LDAPControlA **controlarrayA = NULL;
-    DWORD size;
-
-    if (controlarray)
-    {
-        size = sizeof(LDAPControl*) * (controlarraylenW( controlarray ) + 1);
-        if ((controlarrayA = heap_alloc( size )))
-        {
-            LDAPControlW **p = controlarray;
-            LDAPControlA **q = controlarrayA;
-
-            while (*p) *q++ = controlWtoA( *p++ );
-            *q = NULL;
-        }
-    }
-    return controlarrayA;
-}
-
-static inline LDAPControl **controlarrayWtoU( LDAPControlW **controlarray )
-{
-    LDAPControl **controlarrayU = NULL;
-    DWORD size;
-
-    if (controlarray)
-    {
-        size = sizeof(LDAPControl*) * (controlarraylenW( controlarray ) + 1);
-        if ((controlarrayU = heap_alloc( size )))
-        {
-            LDAPControlW **p = controlarray;
-            LDAPControl **q = controlarrayU;
-
-            while (*p) *q++ = controlWtoU( *p++ );
-            *q = NULL;
-        }
-    }
-    return controlarrayU;
-}
-
-static inline LDAPControlW **controlarrayUtoW( LDAPControl **controlarray )
-{
-    LDAPControlW **controlarrayW = NULL;
-    DWORD size;
-
-    if (controlarray)
-    {
-        size = sizeof(LDAPControlW*) * (controlarraylenU( controlarray ) + 1);
-        if ((controlarrayW = heap_alloc( size )))
-        {
-            LDAPControl **p = controlarray;
-            LDAPControlW **q = controlarrayW;
-
-            while (*p) *q++ = controlUtoW( *p++ );
-            *q = NULL;
-        }
-    }
-    return controlarrayW;
-}
-
-static inline LDAPControlW **controlarraydupW( LDAPControlW **controlarray )
-{
-    LDAPControlW **controlarrayW = NULL;
-    DWORD size;
-
-    if (controlarray)
-    {
-        size = sizeof(LDAPControlW*) * (controlarraylenW( controlarray ) + 1);
-        if ((controlarrayW = heap_alloc( size )))
-        {
-            LDAPControlW **p = controlarray;
-            LDAPControlW **q = controlarrayW;
-
-            while (*p) *q++ = controldupW( *p++ );
-            *q = NULL;
-        }
-    }
-    return controlarrayW;
-}
-
-static inline void controlarrayfreeA( LDAPControlA **controlarray )
-{
-    if (controlarray)
-    {
-        LDAPControlA **p = controlarray;
-        while (*p) controlfreeA( *p++ );
-        heap_free( controlarray );
-    }
-}
-
-static inline void controlarrayfreeW( LDAPControlW **controlarray )
-{
-    if (controlarray)
-    {
-        LDAPControlW **p = controlarray;
-        while (*p) controlfreeW( *p++ );
-        heap_free( controlarray );
-    }
-}
-
-static inline void controlarrayfreeU( LDAPControl **controlarray )
-{
-    if (controlarray)
-    {
-        LDAPControl **p = controlarray;
-        while (*p) controlfreeU( *p++ );
-        heap_free( controlarray );
-    }
-}
-
-static inline LDAPSortKeyW *sortkeyAtoW( LDAPSortKeyA *sortkey )
-{
-    LDAPSortKeyW *sortkeyW;
-
-    if ((sortkeyW = heap_alloc( sizeof(LDAPSortKeyW) )))
-    {
-        sortkeyW->sk_attrtype = strAtoW( sortkey->sk_attrtype );
-        sortkeyW->sk_matchruleoid = strAtoW( sortkey->sk_matchruleoid );
-        sortkeyW->sk_reverseorder = sortkey->sk_reverseorder;
-    }
-    return sortkeyW;
-}
-
-static inline LDAPSortKeyA *sortkeyWtoA( LDAPSortKeyW *sortkey )
-{
-    LDAPSortKeyA *sortkeyA;
-
-    if ((sortkeyA = heap_alloc( sizeof(LDAPSortKeyA) )))
-    {
-        sortkeyA->sk_attrtype = strWtoA( sortkey->sk_attrtype );
-        sortkeyA->sk_matchruleoid = strWtoA( sortkey->sk_matchruleoid );
-        sortkeyA->sk_reverseorder = sortkey->sk_reverseorder;
-    }
-    return sortkeyA;
-}
-
-static inline LDAPSortKey *sortkeyWtoU( LDAPSortKeyW *sortkey )
-{
-    LDAPSortKey *sortkeyU;
-
-    if ((sortkeyU = heap_alloc( sizeof(LDAPSortKey) )))
-    {
-        sortkeyU->attributeType = strWtoU( sortkey->sk_attrtype );
-        sortkeyU->orderingRule = strWtoU( sortkey->sk_matchruleoid );
-        sortkeyU->reverseOrder = sortkey->sk_reverseorder;
-    }
-    return sortkeyU;
-}
-
-static inline void sortkeyfreeA( LDAPSortKeyA *sortkey )
-{
-    if (sortkey)
-    {
-        strfreeA( sortkey->sk_attrtype );
-        strfreeA( sortkey->sk_matchruleoid );
-        heap_free( sortkey );
-    }
-}
-
-static inline void sortkeyfreeW( LDAPSortKeyW *sortkey )
-{
-    if (sortkey)
-    {
-        strfreeW( sortkey->sk_attrtype );
-        strfreeW( sortkey->sk_matchruleoid );
-        heap_free( sortkey );
-    }
-}
-
-static inline void sortkeyfreeU( LDAPSortKey *sortkey )
-{
-    if (sortkey)
-    {
-        strfreeU( sortkey->attributeType );
-        strfreeU( sortkey->orderingRule );
-        heap_free( sortkey );
-    }
-}
-
-static inline DWORD sortkeyarraylenA( LDAPSortKeyA **sortkeyarray )
-{
-    LDAPSortKeyA **p = sortkeyarray;
-    while (*p) p++;
-    return p - sortkeyarray;
-}
-
-static inline DWORD sortkeyarraylenW( LDAPSortKeyW **sortkeyarray )
-{
-    LDAPSortKeyW **p = sortkeyarray;
-    while (*p) p++;
-    return p - sortkeyarray;
-}
-
-static inline LDAPSortKeyW **sortkeyarrayAtoW( LDAPSortKeyA **sortkeyarray )
-{
-    LDAPSortKeyW **sortkeyarrayW = NULL;
-    DWORD size;
-
-    if (sortkeyarray)
-    {
-        size = sizeof(LDAPSortKeyW*) * (sortkeyarraylenA( sortkeyarray ) + 1);
-        if ((sortkeyarrayW = heap_alloc( size )))
-        {
-            LDAPSortKeyA **p = sortkeyarray;
-            LDAPSortKeyW **q = sortkeyarrayW;
-
-            while (*p) *q++ = sortkeyAtoW( *p++ );
-            *q = NULL;
-        }
-    }
-    return sortkeyarrayW;
-}
-
-static inline LDAPSortKey **sortkeyarrayWtoU( LDAPSortKeyW **sortkeyarray )
-{
-    LDAPSortKey **sortkeyarrayU = NULL;
-    DWORD size;
-
-    if (sortkeyarray)
-    {
-        size = sizeof(LDAPSortKey*) * (sortkeyarraylenW( sortkeyarray ) + 1);
-        if ((sortkeyarrayU = heap_alloc( size )))
-        {
-            LDAPSortKeyW **p = sortkeyarray;
-            LDAPSortKey **q = sortkeyarrayU;
-
-            while (*p) *q++ = sortkeyWtoU( *p++ );
-            *q = NULL;
-        }
-    }
-    return sortkeyarrayU;
-}
-
-static inline void sortkeyarrayfreeW( LDAPSortKeyW **sortkeyarray )
-{
-    if (sortkeyarray)
-    {
-        LDAPSortKeyW **p = sortkeyarray;
-        while (*p) sortkeyfreeW( *p++ );
-        heap_free( sortkeyarray );
-    }
-}
-
-static inline void sortkeyarrayfreeU( LDAPSortKey **sortkeyarray )
-{
-    if (sortkeyarray)
-    {
-        LDAPSortKey **p = sortkeyarray;
-        while (*p) sortkeyfreeU( *p++ );
-        heap_free( sortkeyarray );
-    }
-}
-#endif /* HAVE_LDAP */
From e5f1c0f7fc0fb5fa550756fc71398c9a71906d62 Mon Sep 17 00:00:00 2001
From: Hans Leidekker <hans@codeweavers.com>
Date: Mon, 19 Apr 2021 10:04:51 +0200
Subject: [PATCH] wldap32: Build with msvcrt.

Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/wldap32/Makefile.in |  2 ++
 dlls/wldap32/libldap.h   | 10 +++++-----
 dlls/wldap32/page.c      |  2 +-
 3 files changed, 8 insertions(+), 6 deletions(-)

diff --git a/dlls/wldap32/Makefile.in b/dlls/wldap32/Makefile.in
index 18a37151f998..831c00d65e1f 100644
--- a/dlls/wldap32/Makefile.in
+++ b/dlls/wldap32/Makefile.in
@@ -4,6 +4,8 @@ IMPORTS   = user32
 EXTRAINCL = $(LDAP_CFLAGS)
 EXTRALIBS = $(LDAP_LIBS)
 
+EXTRADLLFLAGS = -mno-cygwin
+
 C_SRCS = \
 	add.c \
 	ber.c \
diff --git a/dlls/wldap32/libldap.h b/dlls/wldap32/libldap.h
index 1dfadf7e3bce..cc247e8fd824 100644
--- a/dlls/wldap32/libldap.h
+++ b/dlls/wldap32/libldap.h
@@ -19,8 +19,8 @@
 /* compatible with structures defined in ldap.h */
 typedef struct bervalU
 {
-    unsigned long bv_len;
-    char         *bv_val;
+    ULONG_PTR bv_len;
+    char     *bv_val;
 } BerValueU;
 
 typedef struct
@@ -79,8 +79,8 @@ typedef struct
 
 typedef struct timevalU
 {
-    unsigned long tv_sec;
-    unsigned long tv_usec;
+    LONG_PTR tv_sec;
+    LONG_PTR tv_usec;
 } LDAP_TIMEVALU;
 
 #ifndef SASL_CB_LIST_END
@@ -92,7 +92,7 @@ typedef struct timevalU
 
 typedef struct sasl_interactU
 {
-    unsigned long id;
+    ULONG_PTR     id;
     const char   *challenge;
     const char   *prompt;
     const char   *defresult;
diff --git a/dlls/wldap32/page.c b/dlls/wldap32/page.c
index 5364280f271c..49be2203b3f4 100644
--- a/dlls/wldap32/page.c
+++ b/dlls/wldap32/page.c
@@ -245,7 +245,7 @@ ULONG CDECL ldap_parse_page_controlW( WLDAP32_LDAP *ld, LDAPControlW **ctrls, UL
 
     for (i = 0; ctrls[i]; i++)
     {
-        if (!lstrcmpW( LDAP_PAGED_RESULT_OID_STRING_W, ctrls[i]->ldctl_oid ))
+        if (!wcscmp( LDAP_PAGED_RESULT_OID_STRING_W, ctrls[i]->ldctl_oid ))
             control = ctrls[i];
     }
     if (!control) return WLDAP32_LDAP_CONTROL_NOT_FOUND;
From 8a52b16e0d3f407d101f073c5d1b2c0ebaa8c7e7 Mon Sep 17 00:00:00 2001
From: Hans Leidekker <hans@codeweavers.com>
Date: Mon, 19 Apr 2021 10:04:52 +0200
Subject: [PATCH] wldap32: Use CRT memory allocators.

Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/wldap32/add.c             |  12 +-
 dlls/wldap32/ber.c             |  20 ++--
 dlls/wldap32/bind.c            |  66 +++++------
 dlls/wldap32/compare.c         |  36 +++---
 dlls/wldap32/delete.c          |  12 +-
 dlls/wldap32/dn.c              |  12 +-
 dlls/wldap32/extended.c        |   8 +-
 dlls/wldap32/init.c            |  46 ++++----
 dlls/wldap32/misc.c            |  18 +--
 dlls/wldap32/modify.c          |  12 +-
 dlls/wldap32/modrdn.c          |  24 ++--
 dlls/wldap32/option.c          |   4 +-
 dlls/wldap32/page.c            |  26 ++---
 dlls/wldap32/rename.c          |  24 ++--
 dlls/wldap32/search.c          |  32 +++---
 dlls/wldap32/value.c           |  18 +--
 dlls/wldap32/winldap_private.h | 200 +++++++++++++++------------------
 17 files changed, 275 insertions(+), 295 deletions(-)

diff --git a/dlls/wldap32/add.c b/dlls/wldap32/add.c
index cce7726a2415..605c1535914a 100644
--- a/dlls/wldap32/add.c
+++ b/dlls/wldap32/add.c
@@ -49,7 +49,7 @@ ULONG CDECL ldap_addA( WLDAP32_LDAP *ld, char *dn, LDAPModA **attrs )
     ret = ldap_addW( ld, dnW, attrsW );
 
 exit:
-    strfreeW( dnW );
+    free( dnW );
     modarrayfreeW( attrsW );
     return ret;
 }
@@ -110,7 +110,7 @@ ULONG CDECL ldap_add_extA( WLDAP32_LDAP *ld, char *dn, LDAPModA **attrs, LDAPCon
     ret = ldap_add_extW( ld, dnW, attrsW, serverctrlsW, clientctrlsW, message );
 
 exit:
-    strfreeW( dnW );
+    free( dnW );
     modarrayfreeW( attrsW );
     controlarrayfreeW( serverctrlsW );
     controlarrayfreeW( clientctrlsW );
@@ -160,7 +160,7 @@ ULONG CDECL ldap_add_extW( WLDAP32_LDAP *ld, WCHAR *dn, LDAPModW **attrs, LDAPCo
     ret = map_error( ldap_funcs->ldap_add_ext( ld->ld, dnU, attrsU, serverctrlsU, clientctrlsU, message ) );
 
 exit:
-    strfreeU( dnU );
+    free( dnU );
     modarrayfreeU( attrsU );
     controlarrayfreeU( serverctrlsU );
     controlarrayfreeU( clientctrlsU );
@@ -192,7 +192,7 @@ ULONG CDECL ldap_add_ext_sA( WLDAP32_LDAP *ld, char *dn, LDAPModA **attrs, LDAPC
     ret = ldap_add_ext_sW( ld, dnW, attrsW, serverctrlsW, clientctrlsW );
 
 exit:
-    strfreeW( dnW );
+    free( dnW );
     modarrayfreeW( attrsW );
     controlarrayfreeW( serverctrlsW );
     controlarrayfreeW( clientctrlsW );
@@ -240,7 +240,7 @@ ULONG CDECL ldap_add_ext_sW( WLDAP32_LDAP *ld, WCHAR *dn, LDAPModW **attrs, LDAP
     ret = map_error( ldap_funcs->ldap_add_ext_s( ld->ld, dnU, attrsU, serverctrlsU, clientctrlsU ) );
 
 exit:
-    strfreeU( dnU );
+    free( dnU );
     modarrayfreeU( attrsU );
     controlarrayfreeU( serverctrlsU );
     controlarrayfreeU( clientctrlsU );
@@ -268,7 +268,7 @@ ULONG CDECL ldap_add_sA( WLDAP32_LDAP *ld, char *dn, LDAPModA **attrs )
     ret = ldap_add_sW( ld, dnW, attrsW );
 
 exit:
-    strfreeW( dnW );
+    free( dnW );
     modarrayfreeW( attrsW );
     return ret;
 }
diff --git a/dlls/wldap32/ber.c b/dlls/wldap32/ber.c
index c6dca7153a24..ffb8e862d0e9 100644
--- a/dlls/wldap32/ber.c
+++ b/dlls/wldap32/ber.c
@@ -19,12 +19,12 @@
  */
 
 #include <stdarg.h>
+#include <stdlib.h>
 #include "windef.h"
 #include "winbase.h"
 #include "winnls.h"
 
 #include "wine/debug.h"
-#include "wine/heap.h"
 #include "winldap_private.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(wldap32);
@@ -48,10 +48,10 @@ WLDAP32_BerElement * CDECL WLDAP32_ber_alloc_t( int options )
 {
     WLDAP32_BerElement *ret;
 
-    if (!(ret = heap_alloc( sizeof(*ret) ))) return NULL;
+    if (!(ret = malloc( sizeof(*ret) ))) return NULL;
     if (!(ret->opaque = ldap_funcs->ber_alloc_t( options )))
     {
-        heap_free( ret );
+        free( ret );
         return NULL;
     }
     return ret;
@@ -117,7 +117,7 @@ void CDECL WLDAP32_ber_bvecfree( BERVAL **berval )
  */
 void CDECL WLDAP32_ber_bvfree( BERVAL *berval )
 {
-    heap_free( berval );
+    free( berval );
 }
 
 
@@ -194,7 +194,7 @@ int CDECL WLDAP32_ber_flatten( WLDAP32_BerElement *ber, BERVAL **berval )
 void CDECL WLDAP32_ber_free( WLDAP32_BerElement *ber, int freebuf )
 {
     ldap_funcs->ber_free( ber->opaque, freebuf );
-    heap_free( ber );
+    free( ber );
 }
 
 
@@ -218,18 +218,18 @@ WLDAP32_BerElement * CDECL WLDAP32_ber_init( BERVAL *berval )
     struct bervalU *bervalU;
     WLDAP32_BerElement *ret;
 
-    if (!(ret = heap_alloc( sizeof(*ret) ))) return NULL;
+    if (!(ret = malloc( sizeof(*ret) ))) return NULL;
     if (!(bervalU = bervalWtoU( berval )))
     {
-        heap_free( ret );
+        free( ret );
         return NULL;
     }
     if (!(ret->opaque = ldap_funcs->ber_init( bervalU )))
     {
-        heap_free( ret );
+        free( ret );
         ret = NULL;
     }
-    heap_free( bervalU );
+    free( bervalU );
     return ret;
 }
 
@@ -467,7 +467,7 @@ ULONG WINAPIV WLDAP32_ber_scanf( WLDAP32_BerElement *ber, char *fmt, ... )
             char *strU, **str = va_arg( list, char ** );
             int *len = va_arg( list, int * );
             if ((ret = ldap_funcs->ber_scanf( ber->opaque, new_fmt, &strU, len )) == -1) break;
-            *str = heap_alloc( *len );
+            *str = malloc( *len );
             memcpy( *str, strU, *len );
             ldap_funcs->ldap_memfree( strU );
             break;
diff --git a/dlls/wldap32/bind.c b/dlls/wldap32/bind.c
index 0078b532e669..c9a597e88689 100644
--- a/dlls/wldap32/bind.c
+++ b/dlls/wldap32/bind.c
@@ -19,13 +19,13 @@
  */
 
 #include <stdarg.h>
+#include <stdlib.h>
 #include "windef.h"
 #include "winbase.h"
 #include "winnls.h"
 #include "rpc.h"
 
 #include "wine/debug.h"
-#include "wine/heap.h"
 #include "winldap_private.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(wldap32);
@@ -50,8 +50,8 @@ ULONG CDECL ldap_bindA( WLDAP32_LDAP *ld, char *dn, char *cred, ULONG method )
     ret = ldap_bindW( ld, dnW, credW, method );
 
 exit:
-    strfreeW( dnW );
-    strfreeW( credW );
+    free( dnW );
+    free( credW );
     return ret;
 }
 
@@ -100,8 +100,8 @@ ULONG CDECL ldap_bindW( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *cred, ULONG method )
         ret = ~0u;
 
 exit:
-    strfreeU( dnU );
-    strfreeU( credU );
+    free( dnU );
+    free( credU );
     return ret;
 }
 
@@ -132,8 +132,8 @@ ULONG CDECL ldap_bind_sA( WLDAP32_LDAP *ld, char *dn, char *cred, ULONG method )
     ret = ldap_bind_sW( ld, dnW, credW, method );
 
 exit:
-    strfreeW( dnW );
-    if (credW != (WCHAR *)cred) strfreeW( credW );
+    free( dnW );
+    if (credW != (WCHAR *)cred) free( credW );
     return ret;
 }
 
@@ -235,14 +235,14 @@ ULONG CDECL ldap_bind_sW( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *cred, ULONG method
 
         if (id && (id->Flags & SEC_WINNT_AUTH_IDENTITY_ANSI))
         {
-            strfreeW( (WCHAR *)idW.Domain );
-            strfreeW( (WCHAR *)idW.User );
-            strfreeW( (WCHAR *)idW.Password );
+            free( (WCHAR *)idW.Domain );
+            free( (WCHAR *)idW.User );
+            free( (WCHAR *)idW.Password );
         }
 
-        strfreeU( (char *)idU.Domain );
-        strfreeU( (char *)idU.User );
-        strfreeU( (char *)idU.Password );
+        free( (char *)idU.Domain );
+        free( (char *)idU.User );
+        free( (char *)idU.Password );
     }
     else
     {
@@ -251,8 +251,8 @@ ULONG CDECL ldap_bind_sW( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *cred, ULONG method
     }
 
 exit:
-    strfreeU( dnU );
-    strfreeU( credU );
+    free( dnU );
+    free( credU );
     return ret;
 }
 
@@ -282,8 +282,8 @@ ULONG CDECL ldap_sasl_bindA( WLDAP32_LDAP *ld, const PCHAR dn, const PCHAR mecha
     ret = ldap_sasl_bindW( ld, dnW, mechanismW, cred, serverctrlsW, clientctrlsW, message );
 
 exit:
-    strfreeW( dnW );
-    strfreeW( mechanismW );
+    free( dnW );
+    free( mechanismW );
     controlarrayfreeW( serverctrlsW );
     controlarrayfreeW( clientctrlsW );
     return ret;
@@ -336,8 +336,8 @@ ULONG CDECL ldap_sasl_bindW( WLDAP32_LDAP *ld, const PWCHAR dn, const PWCHAR mec
     ret = map_error( ldap_funcs->ldap_sasl_bind( ld->ld, dnU, mechanismU, &credU, serverctrlsU, clientctrlsU, message ) );
 
 exit:
-    strfreeU( dnU );
-    strfreeU( mechanismU );
+    free( dnU );
+    free( mechanismU );
     controlarrayfreeU( serverctrlsU );
     controlarrayfreeU( clientctrlsU );
     return ret;
@@ -369,8 +369,8 @@ ULONG CDECL ldap_sasl_bind_sA( WLDAP32_LDAP *ld, const PCHAR dn, const PCHAR mec
     ret = ldap_sasl_bind_sW( ld, dnW, mechanismW, cred, serverctrlsW, clientctrlsW, serverdata );
 
 exit:
-    strfreeW( dnW );
-    strfreeW( mechanismW );
+    free( dnW );
+    free( mechanismW );
     controlarrayfreeW( serverctrlsW );
     controlarrayfreeW( clientctrlsW );
     return ret;
@@ -431,8 +431,8 @@ ULONG CDECL ldap_sasl_bind_sW( WLDAP32_LDAP *ld, const PWCHAR dn,
     }
 
 exit:
-    strfreeU( dnU );
-    strfreeU( mechanismU );
+    free( dnU );
+    free( mechanismU );
     controlarrayfreeU( serverctrlsU );
     controlarrayfreeU( clientctrlsU );
     return ret;
@@ -458,8 +458,8 @@ ULONG CDECL ldap_simple_bindA( WLDAP32_LDAP *ld, char *dn, char *passwd )
     ret = ldap_simple_bindW( ld, dnW, passwdW );
 
 exit:
-    strfreeW( dnW );
-    strfreeW( passwdW );
+    free( dnW );
+    free( passwdW );
     return ret;
 }
 
@@ -506,8 +506,8 @@ ULONG CDECL ldap_simple_bindW( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *passwd )
         ret = ~0u;
 
 exit:
-    strfreeU( dnU );
-    strfreeU( passwdU );
+    free( dnU );
+    free( passwdU );
     return ret;
 }
 
@@ -531,8 +531,8 @@ ULONG CDECL ldap_simple_bind_sA( WLDAP32_LDAP *ld, char *dn, char *passwd )
     ret = ldap_simple_bind_sW( ld, dnW, passwdW );
 
 exit:
-    strfreeW( dnW );
-    strfreeW( passwdW );
+    free( dnW );
+    free( passwdW );
     return ret;
 }
 
@@ -574,8 +574,8 @@ ULONG CDECL ldap_simple_bind_sW( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *passwd )
     ret = map_error( ldap_funcs->ldap_sasl_bind_s( ld->ld, dnU, 0, &pwd, NULL, NULL, NULL ) );
 
 exit:
-    strfreeU( dnU );
-    strfreeU( passwdU );
+    free( dnU );
+    free( passwdU );
     return ret;
 }
 
@@ -602,7 +602,7 @@ ULONG CDECL WLDAP32_ldap_unbind( WLDAP32_LDAP *ld )
     ret = map_error( ldap_funcs->ldap_unbind_ext( ld->ld, NULL, NULL ));
     if (ld->ld_server_ctrls) ldap_funcs->ldap_value_free_len( ld->ld_server_ctrls );
 
-    heap_free( ld );
+    free( ld );
     return ret;
 }
 
@@ -629,6 +629,6 @@ ULONG CDECL WLDAP32_ldap_unbind_s( WLDAP32_LDAP *ld )
     ret = map_error( ldap_funcs->ldap_unbind_ext_s( ld->ld, NULL, NULL ) );
     if (ld->ld_server_ctrls) ldap_funcs->ldap_value_free_len( ld->ld_server_ctrls );
 
-    heap_free( ld );
+    free( ld );
     return ret;
 }
diff --git a/dlls/wldap32/compare.c b/dlls/wldap32/compare.c
index 7a366572dc9c..63b56ef9f4c9 100644
--- a/dlls/wldap32/compare.c
+++ b/dlls/wldap32/compare.c
@@ -49,9 +49,9 @@ ULONG CDECL ldap_compareA( WLDAP32_LDAP *ld, char *dn, char *attr, char *value )
     ret = ldap_compareW( ld, dnW, attrW, valueW );
 
 exit:
-    strfreeW( dnW );
-    strfreeW( attrW );
-    strfreeW( valueW );
+    free( dnW );
+    free( attrW );
+    free( valueW );
     return ret;
 }
 
@@ -108,9 +108,9 @@ ULONG CDECL ldap_compare_extA( WLDAP32_LDAP *ld, char *dn, char *attr, char *val
     ret = ldap_compare_extW( ld, dnW, attrW, valueW, data, serverctrlsW, clientctrlsW, message );
 
 exit:
-    strfreeW( dnW );
-    strfreeW( attrW );
-    strfreeW( valueW );
+    free( dnW );
+    free( attrW );
+    free( valueW );
     controlarrayfreeW( serverctrlsW );
     controlarrayfreeW( clientctrlsW );
     return ret;
@@ -173,9 +173,9 @@ ULONG CDECL ldap_compare_extW( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *attr, WCHAR *
     ret = map_error( ldap_funcs->ldap_compare_ext( ld->ld, dnU, attrU, dataU ? dataU : &val, serverctrlsU,
                                                    clientctrlsU, message ) );
 exit:
-    strfreeU( dnU );
-    strfreeU( attrU );
-    strfreeU( valueU );
+    free( dnU );
+    free( attrU );
+    free( valueU );
     bvfreeU( dataU );
     controlarrayfreeU( serverctrlsU );
     controlarrayfreeU( clientctrlsU );
@@ -208,9 +208,9 @@ ULONG CDECL ldap_compare_ext_sA( WLDAP32_LDAP *ld, char *dn, char *attr, char *v
     ret = ldap_compare_ext_sW( ld, dnW, attrW, valueW, data, serverctrlsW, clientctrlsW );
 
 exit:
-    strfreeW( dnW );
-    strfreeW( attrW );
-    strfreeW( valueW );
+    free( dnW );
+    free( attrW );
+    free( valueW );
     controlarrayfreeW( serverctrlsW );
     controlarrayfreeW( clientctrlsW );
     return ret;
@@ -271,9 +271,9 @@ ULONG CDECL ldap_compare_ext_sW( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *attr, WCHAR
     ret = map_error( ldap_funcs->ldap_compare_ext_s( ld->ld, dnU, attrU, dataU ? dataU : &val, serverctrlsU,
                                                      clientctrlsU ) );
 exit:
-    strfreeU( dnU );
-    strfreeU( attrU );
-    strfreeU( valueU );
+    free( dnU );
+    free( attrU );
+    free( valueU );
     bvfreeU( dataU );
     controlarrayfreeU( serverctrlsU );
     controlarrayfreeU( clientctrlsU );
@@ -301,9 +301,9 @@ ULONG CDECL ldap_compare_sA( WLDAP32_LDAP *ld, PCHAR dn, PCHAR attr, PCHAR value
     ret = ldap_compare_sW( ld, dnW, attrW, valueW );
 
 exit:
-    strfreeW( dnW );
-    strfreeW( attrW );
-    strfreeW( valueW );
+    free( dnW );
+    free( attrW );
+    free( valueW );
     return ret;
 }
 
diff --git a/dlls/wldap32/delete.c b/dlls/wldap32/delete.c
index 9f2b107f62cf..2f3d078629fe 100644
--- a/dlls/wldap32/delete.c
+++ b/dlls/wldap32/delete.c
@@ -44,7 +44,7 @@ ULONG CDECL ldap_deleteA( WLDAP32_LDAP *ld, char *dn )
     if (dn && !(dnW = strAtoW( dn ))) return WLDAP32_LDAP_NO_MEMORY;
 
     ret = ldap_deleteW( ld, dnW );
-    strfreeW( dnW );
+    free( dnW );
     return ret;
 }
 
@@ -100,7 +100,7 @@ ULONG CDECL ldap_delete_extA( WLDAP32_LDAP *ld, char *dn, LDAPControlA **serverc
     ret = ldap_delete_extW( ld, dnW, serverctrlsW, clientctrlsW, message );
 
 exit:
-    strfreeW( dnW );
+    free( dnW );
     controlarrayfreeW( serverctrlsW );
     controlarrayfreeW( clientctrlsW );
     return ret;
@@ -145,7 +145,7 @@ ULONG CDECL ldap_delete_extW( WLDAP32_LDAP *ld, WCHAR *dn, LDAPControlW **server
     ret = map_error( ldap_funcs->ldap_delete_ext( ld->ld, dnU, serverctrlsU, clientctrlsU, message ) );
 
 exit:
-    strfreeU( dnU );
+    free( dnU );
     controlarrayfreeU( serverctrlsU );
     controlarrayfreeU( clientctrlsU );
     return ret;
@@ -174,7 +174,7 @@ ULONG CDECL ldap_delete_ext_sA( WLDAP32_LDAP *ld, char *dn, LDAPControlA **serve
     ret = ldap_delete_ext_sW( ld, dnW, serverctrlsW, clientctrlsW );
 
 exit:
-    strfreeW( dnW );
+    free( dnW );
     controlarrayfreeW( serverctrlsW );
     controlarrayfreeW( clientctrlsW );
     return ret;
@@ -217,7 +217,7 @@ ULONG CDECL ldap_delete_ext_sW( WLDAP32_LDAP *ld, WCHAR *dn, LDAPControlW **serv
     ret = map_error( ldap_funcs->ldap_delete_ext_s( ld->ld, dnU, serverctrlsU, clientctrlsU ) );
 
 exit:
-    strfreeU( dnU );
+    free( dnU );
     controlarrayfreeU( serverctrlsU );
     controlarrayfreeU( clientctrlsU );
     return ret;
@@ -239,7 +239,7 @@ ULONG CDECL ldap_delete_sA( WLDAP32_LDAP *ld, char *dn )
     if (dn && !(dnW = strAtoW( dn ))) return WLDAP32_LDAP_NO_MEMORY;
 
     ret = ldap_delete_sW( ld, dnW );
-    strfreeW( dnW );
+    free( dnW );
     return ret;
 }
 
diff --git a/dlls/wldap32/dn.c b/dlls/wldap32/dn.c
index 61d421ee2333..e9a6be999a8e 100644
--- a/dlls/wldap32/dn.c
+++ b/dlls/wldap32/dn.c
@@ -45,7 +45,7 @@ char * CDECL ldap_dn2ufnA( char *dn )
     retW = ldap_dn2ufnW( dnW );
     ret = strWtoA( retW );
 
-    strfreeW( dnW );
+    free( dnW );
     ldap_memfreeW( retW );
     return ret;
 }
@@ -77,7 +77,7 @@ WCHAR * CDECL ldap_dn2ufnW( WCHAR *dn )
     retU = ldap_funcs->ldap_dn2ufn( dnU );
     ret = strUtoW( retU );
 
-    strfreeU( dnU );
+    free( dnU );
     ldap_funcs->ldap_memfree( retU );
     return ret;
 }
@@ -99,7 +99,7 @@ char ** CDECL ldap_explode_dnA( char *dn, ULONG notypes )
     retW = ldap_explode_dnW( dnW, notypes );
     ret = strarrayWtoA( retW );
 
-    strfreeW( dnW );
+    free( dnW );
     ldap_value_freeW( retW );
     return ret;
 }
@@ -133,7 +133,7 @@ WCHAR ** CDECL ldap_explode_dnW( WCHAR *dn, ULONG notypes )
     retU = ldap_funcs->ldap_explode_dn( dnU, notypes );
     ret = strarrayUtoW( retU );
 
-    strfreeU( dnU );
+    free( dnU );
     ldap_funcs->ldap_memvfree( (void **)retU );
     return ret;
 }
@@ -216,7 +216,7 @@ ULONG CDECL ldap_ufn2dnA( char *ufn, char **dn )
         else *dn = str;
     }
 
-    strfreeW( ufnW );
+    free( ufnW );
     ldap_memfreeW( dnW );
     return ret;
 }
@@ -257,6 +257,6 @@ ULONG CDECL ldap_ufn2dnW( WCHAR *ufn, WCHAR **dn )
         else *dn = str;
     }
 
-    strfreeU( ufnU );
+    free( ufnU );
     return ret;
 }
diff --git a/dlls/wldap32/extended.c b/dlls/wldap32/extended.c
index e09d90fdc60e..2a71ce59acf4 100644
--- a/dlls/wldap32/extended.c
+++ b/dlls/wldap32/extended.c
@@ -76,7 +76,7 @@ ULONG CDECL ldap_extended_operationA( WLDAP32_LDAP *ld, char *oid, struct WLDAP3
     ret = ldap_extended_operationW( ld, oidW, data, serverctrlsW, clientctrlsW, message );
 
 exit:
-    strfreeW( oidW );
+    free( oidW );
     controlarrayfreeW( serverctrlsW );
     controlarrayfreeW( clientctrlsW );
     return ret;
@@ -127,7 +127,7 @@ ULONG CDECL ldap_extended_operationW( WLDAP32_LDAP *ld, WCHAR *oid, struct WLDAP
     ret = map_error( ldap_funcs->ldap_extended_operation( ld->ld, oidU, dataU, serverctrlsU, clientctrlsU, message ) );
 
 exit:
-    strfreeU( oidU );
+    free( oidU );
     bvfreeU( dataU );
     controlarrayfreeU( serverctrlsU );
     controlarrayfreeU( clientctrlsU );
@@ -164,7 +164,7 @@ ULONG CDECL ldap_extended_operation_sA( WLDAP32_LDAP *ld, char *oid, struct WLDA
     }
 
 exit:
-    strfreeW( oidW );
+    free( oidW );
     controlarrayfreeW( serverctrlsW );
     controlarrayfreeW( clientctrlsW );
     return ret;
@@ -229,7 +229,7 @@ ULONG CDECL ldap_extended_operation_sW( WLDAP32_LDAP *ld, WCHAR *oid, struct WLD
     }
 
 exit:
-    strfreeU( oidU );
+    free( oidU );
     bvfreeU( dataU );
     controlarrayfreeU( serverctrlsU );
     controlarrayfreeU( clientctrlsU );
diff --git a/dlls/wldap32/init.c b/dlls/wldap32/init.c
index d65554afb3cf..28e62ba6de22 100644
--- a/dlls/wldap32/init.c
+++ b/dlls/wldap32/init.c
@@ -19,13 +19,13 @@
  */
 
 #include <stdarg.h>
+#include <stdlib.h>
 #include "windef.h"
 #include "winbase.h"
 #include "winnls.h"
 #include "winternl.h"
 
 #include "wine/debug.h"
-#include "wine/heap.h"
 #include "winldap_private.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(wldap32);
@@ -56,9 +56,9 @@ static char **split_hostnames( const char *hostnames )
         p++;
     }
 
-    if (!(res = heap_alloc( (i + 1) * sizeof(char *) )))
+    if (!(res = malloc( (i + 1) * sizeof(char *) )))
     {
-        heap_free( str );
+        free( str );
         return NULL;
     }
 
@@ -93,15 +93,13 @@ static char **split_hostnames( const char *hostnames )
     }
     res[i] = NULL;
 
-    heap_free( str );
+    free( str );
     return res;
 
 oom:
-    while (i > 0) strfreeU( res[--i] );
-
-    heap_free( res );
-    heap_free( str );
-
+    while (i > 0) free( res[--i] );
+    free( res );
+    free( str );
     return NULL;
 }
 
@@ -147,7 +145,7 @@ static char *join_hostnames( const char *scheme, char **hostnames, ULONG portnum
     }
 
     size += (i - 1) * strlen( sep );
-    if (!(res = heap_alloc( size + 1 ))) return NULL;
+    if (!(res = malloc( size + 1 ))) return NULL;
 
     p = res;
     for (v = hostnames; *v; v++)
@@ -200,10 +198,10 @@ static WLDAP32_LDAP *create_context( const char *url )
     WLDAP32_LDAP *ld;
     int version = WLDAP32_LDAP_VERSION3;
 
-    if (!(ld = heap_alloc_zero( sizeof( *ld )))) return NULL;
+    if (!(ld = calloc( 1, sizeof( *ld )))) return NULL;
     if (map_error( ldap_funcs->ldap_initialize( &ld->ld, url ) ) != WLDAP32_LDAP_SUCCESS)
     {
-        heap_free( ld );
+        free( ld );
         return NULL;
     }
     ldap_funcs->ldap_set_option( ld->ld, WLDAP32_LDAP_OPT_PROTOCOL_VERSION, &version );
@@ -226,7 +224,7 @@ WLDAP32_LDAP * CDECL cldap_openA( char *hostname, ULONG portnumber )
 
     ld = cldap_openW( hostnameW, portnumber );
 
-    strfreeW( hostnameW );
+    free( hostnameW );
     return ld;
 }
 
@@ -264,8 +262,8 @@ WLDAP32_LDAP * CDECL cldap_openW( WCHAR *hostname, ULONG portnumber )
     ld = create_context( url );
 
 exit:
-    strfreeU( hostnameU );
-    strfreeU( url );
+    free( hostnameU );
+    free( url );
     return ld;
 }
 
@@ -311,7 +309,7 @@ WLDAP32_LDAP *  CDECL ldap_initA( const PCHAR hostname, ULONG portnumber )
 
     ld = ldap_initW( hostnameW, portnumber );
 
-    strfreeW( hostnameW );
+    free( hostnameW );
     return ld;
 }
 
@@ -350,8 +348,8 @@ WLDAP32_LDAP * CDECL ldap_initW( const PWCHAR hostname, ULONG portnumber )
     ld = create_context( url );
 
 exit:
-    strfreeU( hostnameU );
-    strfreeU( url );
+    free( hostnameU );
+    free( url );
     return ld;
 }
 
@@ -371,7 +369,7 @@ WLDAP32_LDAP * CDECL ldap_openA( char *hostname, ULONG portnumber )
 
     ld = ldap_openW( hostnameW, portnumber );
 
-    strfreeW( hostnameW );
+    free( hostnameW );
     return ld;
 }
 
@@ -409,8 +407,8 @@ WLDAP32_LDAP * CDECL ldap_openW( WCHAR *hostname, ULONG portnumber )
     ld = create_context( url );
 
 exit:
-    strfreeU( hostnameU );
-    strfreeU( url );
+    free( hostnameU );
+    free( url );
     return ld;
 }
 
@@ -430,7 +428,7 @@ WLDAP32_LDAP * CDECL ldap_sslinitA( char *hostname, ULONG portnumber, int secure
 
     ld  = ldap_sslinitW( hostnameW, portnumber, secure );
 
-    strfreeW( hostnameW );
+    free( hostnameW );
     return ld;
 }
 
@@ -475,8 +473,8 @@ WLDAP32_LDAP * CDECL ldap_sslinitW( WCHAR *hostname, ULONG portnumber, int secur
     ld = create_context( url );
 
 exit:
-    strfreeU( hostnameU );
-    strfreeU( url );
+    free( hostnameU );
+    free( url );
     return ld;
 }
 
diff --git a/dlls/wldap32/misc.c b/dlls/wldap32/misc.c
index 234b84d42f9e..330355e573c2 100644
--- a/dlls/wldap32/misc.c
+++ b/dlls/wldap32/misc.c
@@ -19,12 +19,12 @@
  */
 
 #include <stdarg.h>
+#include <stdlib.h>
 #include "windef.h"
 #include "winbase.h"
 #include "winnls.h"
 
 #include "wine/debug.h"
-#include "wine/heap.h"
 #include "winldap_private.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(wldap32);
@@ -67,7 +67,7 @@ ULONG CDECL ldap_check_filterA( WLDAP32_LDAP *ld, char *filter )
 
     ret = ldap_check_filterW( ld, filterW );
 
-    strfreeW( filterW );
+    free( filterW );
     return ret;
 }
 
@@ -299,7 +299,7 @@ WCHAR * CDECL ldap_first_attributeW( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *entr
     if (!ld || !entry) return NULL;
 
     retU = ldap_funcs->ldap_first_attribute( ld->ld, entry->Request, &berU );
-    if (retU && (ber = heap_alloc( sizeof(*ber) )))
+    if (retU && (ber = malloc( sizeof(*ber) )))
     {
         ber->opaque = (char *)berU;
         *ptr = ber;
@@ -383,7 +383,7 @@ WLDAP32_LDAPMessage * CDECL WLDAP32_ldap_first_reference( WLDAP32_LDAP *ld, WLDA
 void CDECL ldap_memfreeA( char *block )
 {
     TRACE( "(%p)\n", block );
-    strfreeA( block );
+    free( block );
 }
 
 /***********************************************************************
@@ -397,7 +397,7 @@ void CDECL ldap_memfreeA( char *block )
 void CDECL ldap_memfreeW( WCHAR *block )
 {
     TRACE( "(%p)\n", block );
-    strfreeW( block );
+    free( block );
 }
 
 /***********************************************************************
@@ -421,7 +421,7 @@ ULONG CDECL WLDAP32_ldap_msgfree( WLDAP32_LDAPMessage *res )
     {
         entry = list;
         list = entry->lm_next;
-        heap_free( entry );
+        free( entry );
     }
 
     return WLDAP32_LDAP_SUCCESS;
@@ -516,7 +516,7 @@ WLDAP32_LDAPMessage * CDECL WLDAP32_ldap_next_entry( WLDAP32_LDAP *ld, WLDAP32_L
     if (entry->lm_next) return entry->lm_next;
 
     msgU = ldap_funcs->ldap_next_entry( ld->ld, entry->Request );
-    if (msgU && (msg = heap_alloc_zero( sizeof(*msg) )))
+    if (msgU && (msg = calloc( 1, sizeof(*msg) )))
     {
         msg->Request = msgU;
         entry->lm_next = msg;
@@ -553,7 +553,7 @@ WLDAP32_LDAPMessage * CDECL WLDAP32_ldap_next_reference( WLDAP32_LDAP *ld, WLDAP
     if (entry->lm_next) return entry->lm_next;
 
     msgU = ldap_funcs->ldap_next_reference( ld->ld, entry->Request );
-    if (msgU && (msg = heap_alloc_zero( sizeof(*msg) )))
+    if (msgU && (msg = calloc( 1, sizeof(*msg) )))
     {
         msg->Request = msgU;
         entry->lm_next = msg;
@@ -617,7 +617,7 @@ ULONG CDECL WLDAP32_ldap_result( WLDAP32_LDAP *ld, ULONG msgid, ULONG all, struc
     }
 
     ret = ldap_funcs->ldap_result( ld->ld, msgid, all, timeout ? &timeval : NULL, &msgU );
-    if (msgU && (msg = heap_alloc_zero( sizeof(*msg) )))
+    if (msgU && (msg = calloc( 1, sizeof(*msg) )))
     {
         msg->Request = msgU;
         *res = msg;
diff --git a/dlls/wldap32/modify.c b/dlls/wldap32/modify.c
index 9655a0cf15e5..280989f88b4a 100644
--- a/dlls/wldap32/modify.c
+++ b/dlls/wldap32/modify.c
@@ -49,7 +49,7 @@ ULONG CDECL ldap_modifyA( WLDAP32_LDAP *ld, char *dn, LDAPModA **mods )
     ret = ldap_modifyW( ld, dnW, modsW );
 
 exit:
-    strfreeW( dnW );
+    free( dnW );
     modarrayfreeW( modsW );
     return ret;
 }
@@ -110,7 +110,7 @@ ULONG CDECL ldap_modify_extA( WLDAP32_LDAP *ld, char *dn, LDAPModA **mods,
     ret = ldap_modify_extW( ld, dnW, modsW, serverctrlsW, clientctrlsW, message );
 
 exit:
-    strfreeW( dnW );
+    free( dnW );
     modarrayfreeW( modsW );
     controlarrayfreeW( serverctrlsW );
     controlarrayfreeW( clientctrlsW );
@@ -160,7 +160,7 @@ ULONG CDECL ldap_modify_extW( WLDAP32_LDAP *ld, WCHAR *dn, LDAPModW **mods,
     ret = map_error( ldap_funcs->ldap_modify_ext( ld->ld, dnU, modsU, serverctrlsU, clientctrlsU, message ) );
 
 exit:
-    strfreeU( dnU );
+    free( dnU );
     modarrayfreeU( modsU );
     controlarrayfreeU( serverctrlsU );
     controlarrayfreeU( clientctrlsU );
@@ -192,7 +192,7 @@ ULONG CDECL ldap_modify_ext_sA( WLDAP32_LDAP *ld, char *dn, LDAPModA **mods,
     ret = ldap_modify_ext_sW( ld, dnW, modsW, serverctrlsW, clientctrlsW );
 
 exit:
-    strfreeW( dnW );
+    free( dnW );
     modarrayfreeW( modsW );
     controlarrayfreeW( serverctrlsW );
     controlarrayfreeW( clientctrlsW );
@@ -240,7 +240,7 @@ ULONG CDECL ldap_modify_ext_sW( WLDAP32_LDAP *ld, WCHAR *dn, LDAPModW **mods,
     ret = map_error( ldap_funcs->ldap_modify_ext_s( ld->ld, dnU, modsU, serverctrlsU, clientctrlsU ) );
 
 exit:
-    strfreeU( dnU );
+    free( dnU );
     modarrayfreeU( modsU );
     controlarrayfreeU( serverctrlsU );
     controlarrayfreeU( clientctrlsU );
@@ -268,7 +268,7 @@ ULONG CDECL ldap_modify_sA( WLDAP32_LDAP *ld, char *dn, LDAPModA **mods )
     ret = ldap_modify_sW( ld, dnW, modsW );
 
 exit:
-    strfreeW( dnW );
+    free( dnW );
     modarrayfreeW( modsW );
     return ret;
 }
diff --git a/dlls/wldap32/modrdn.c b/dlls/wldap32/modrdn.c
index c297c7e90b6f..937bd651f5ee 100644
--- a/dlls/wldap32/modrdn.c
+++ b/dlls/wldap32/modrdn.c
@@ -48,8 +48,8 @@ ULONG CDECL ldap_modrdnA( WLDAP32_LDAP *ld, char *dn, char *newdn )
     ret = ldap_modrdnW( ld, dnW, newdnW );
 
 exit:
-    strfreeW( dnW );
-    strfreeW( newdnW );
+    free( dnW );
+    free( newdnW );
     return ret;
 }
 
@@ -98,8 +98,8 @@ ULONG CDECL ldap_modrdn2A( WLDAP32_LDAP *ld, char *dn, char *newdn, int delete )
     ret = ldap_modrdn2W( ld, dnW, newdnW, delete );
 
 exit:
-    strfreeW( dnW );
-    strfreeW( newdnW );
+    free( dnW );
+    free( newdnW );
     return ret;
 }
 
@@ -143,8 +143,8 @@ ULONG CDECL ldap_modrdn2W( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *newdn, int delete
         ret = ~0u;
 
 exit:
-    strfreeU( dnU );
-    strfreeU( newdnU );
+    free( dnU );
+    free( newdnU );
     return ret;
 }
 
@@ -168,8 +168,8 @@ ULONG CDECL ldap_modrdn2_sA( WLDAP32_LDAP *ld, char *dn, char *newdn, int delete
     ret = ldap_modrdn2_sW( ld, dnW, newdnW, delete );
 
 exit:
-    strfreeW( dnW );
-    strfreeW( newdnW );
+    free( dnW );
+    free( newdnW );
     return ret;
 }
 
@@ -203,8 +203,8 @@ ULONG CDECL ldap_modrdn2_sW( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *newdn, int dele
     ret = map_error( ldap_funcs->ldap_rename_s( ld->ld, dnU, newdnU, NULL, delete, NULL, NULL ));
 
 exit:
-    strfreeU( dnU );
-    strfreeU( newdnU );
+    free( dnU );
+    free( newdnU );
     return ret;
 }
 
@@ -228,8 +228,8 @@ ULONG CDECL ldap_modrdn_sA( WLDAP32_LDAP *ld, char *dn, char *newdn )
     ret = ldap_modrdn_sW( ld, dnW, newdnW );
 
 exit:
-    strfreeW( dnW );
-    strfreeW( newdnW );
+    free( dnW );
+    free( newdnW );
     return ret;
 }
 
diff --git a/dlls/wldap32/option.c b/dlls/wldap32/option.c
index 49eac7d2e945..f307837d83a4 100644
--- a/dlls/wldap32/option.c
+++ b/dlls/wldap32/option.c
@@ -57,7 +57,7 @@ ULONG CDECL ldap_get_optionA( WLDAP32_LDAP *ld, int option, void *value )
         ret = ldap_get_optionW( ld, option, &featureW );
 
         if (ret == WLDAP32_LDAP_SUCCESS) featureA->ldapaif_version = featureW.ldapaif_version;
-        strfreeW( featureW.ldapaif_name );
+        free( featureW.ldapaif_name );
         return ret;
     }
     case WLDAP32_LDAP_OPT_API_INFO:
@@ -185,7 +185,7 @@ ULONG CDECL ldap_get_optionW( WLDAP32_LDAP *ld, int option, void *value )
         ret = map_error( ldap_funcs->ldap_get_option( ld->ld, option, &featureU ) );
 
         if (ret == WLDAP32_LDAP_SUCCESS) featureW->ldapaif_version = featureU.ldapaif_version;
-        strfreeU( featureU.ldapaif_name );
+        free( featureU.ldapaif_name );
         return ret;
     }
     case WLDAP32_LDAP_OPT_API_INFO:
diff --git a/dlls/wldap32/page.c b/dlls/wldap32/page.c
index 49be2203b3f4..19110aa10ce9 100644
--- a/dlls/wldap32/page.c
+++ b/dlls/wldap32/page.c
@@ -19,12 +19,12 @@
  */
 
 #include <stdarg.h>
+#include <stdlib.h>
 #include "windef.h"
 #include "winbase.h"
 #include "winnls.h"
 
 #include "wine/debug.h"
-#include "wine/heap.h"
 #include "winldap_private.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(wldap32);
@@ -82,20 +82,20 @@ static ULONG create_page_control( ULONG pagesize, struct WLDAP32_berval *cookie,
     if (ret == -1) return WLDAP32_LDAP_NO_MEMORY;
 
     /* copy the berval so it can be properly freed by the caller */
-    if (!(val = heap_alloc( berval->bv_len ))) return WLDAP32_LDAP_NO_MEMORY;
+    if (!(val = malloc( berval->bv_len ))) return WLDAP32_LDAP_NO_MEMORY;
 
     len = berval->bv_len;
     memcpy( val, berval->bv_val, len );
     WLDAP32_ber_bvfree( berval );
 
-    if (!(ctrl = heap_alloc( sizeof(*ctrl) )))
+    if (!(ctrl = malloc( sizeof(*ctrl) )))
     {
-        heap_free( val );
+        free( val );
         return WLDAP32_LDAP_NO_MEMORY;
     }
     if (!(ctrl->ldctl_oid = strAtoW( LDAP_PAGED_RESULT_OID_STRING )))
     {
-        heap_free( ctrl );
+        free( ctrl );
         return WLDAP32_LDAP_NO_MEMORY;
     }
     ctrl->ldctl_value.bv_len = len;
@@ -196,7 +196,7 @@ ULONG CDECL ldap_get_paged_count( WLDAP32_LDAP *ld, LDAPSearch *search, ULONG *c
         return WLDAP32_LDAP_SUCCESS;
     }
 
-    heap_free( search->cookie );
+    free( search->cookie );
     search->cookie = NULL;
 
     ret = ldap_parse_page_controlW( ld, server_ctrls, count, &search->cookie );
@@ -272,17 +272,17 @@ ULONG CDECL ldap_search_abandon_page( WLDAP32_LDAP *ld, LDAPSearch *search )
 
     if (!ld || !search) return ~0u;
 
-    strfreeW( search->dn );
-    strfreeW( search->filter );
+    free( search->dn );
+    free( search->filter );
     strarrayfreeW( search->attrs );
     ctrls = search->serverctrls;
     controlfreeW( ctrls[0] ); /* page control */
     ctrls++;
     while (*ctrls) controlfreeW( *ctrls++ );
-    heap_free( search->serverctrls );
+    free( search->serverctrls );
     controlarrayfreeW( search->clientctrls );
-    if (search->cookie && search->cookie != &null_cookieW) heap_free( search->cookie );
-    heap_free( search );
+    if (search->cookie && search->cookie != &null_cookieW) free( search->cookie );
+    free( search );
 
     return WLDAP32_LDAP_SUCCESS;
 }
@@ -306,7 +306,7 @@ LDAPSearch * CDECL ldap_search_init_pageW( WLDAP32_LDAP *ld, WCHAR *dn, ULONG sc
     TRACE( "(%p, %s, 0x%08x, %s, %p, 0x%08x, %p, %p, 0x%08x, 0x%08x, %p)\n", ld, debugstr_w(dn), scope,
            debugstr_w(filter), attrs, attrsonly, serverctrls, clientctrls, timelimit, sizelimit, sortkeys );
 
-    if (!(search = heap_alloc_zero( sizeof(*search) )))
+    if (!(search = calloc( 1, sizeof(*search) )))
     {
         ld->ld_errno = WLDAP32_LDAP_NO_MEMORY;
         return NULL;
@@ -317,7 +317,7 @@ LDAPSearch * CDECL ldap_search_init_pageW( WLDAP32_LDAP *ld, WCHAR *dn, ULONG sc
     if (attrs && !(search->attrs = strarraydupW( attrs ))) goto fail;
 
     len = serverctrls ? controlarraylenW( serverctrls ) : 0;
-    if (!(search->serverctrls = heap_alloc( sizeof(LDAPControlW *) * (len + 2) ))) goto fail;
+    if (!(search->serverctrls = malloc( sizeof(LDAPControlW *) * (len + 2) ))) goto fail;
     search->serverctrls[0] = NULL; /* reserve 0 for page control */
     for (i = 0; i < len; i++)
     {
diff --git a/dlls/wldap32/rename.c b/dlls/wldap32/rename.c
index cba4cdd7b666..b5e06f3f7dd6 100644
--- a/dlls/wldap32/rename.c
+++ b/dlls/wldap32/rename.c
@@ -54,9 +54,9 @@ ULONG CDECL ldap_rename_extA( WLDAP32_LDAP *ld, char *dn, char *newrdn, char *ne
     ret = ldap_rename_extW( ld, dnW, newrdnW, newparentW, delete, serverctrlsW, clientctrlsW, message );
 
 exit:
-    strfreeW( dnW );
-    strfreeW( newrdnW );
-    strfreeW( newparentW );
+    free( dnW );
+    free( newrdnW );
+    free( newparentW );
     controlarrayfreeW( serverctrlsW );
     controlarrayfreeW( clientctrlsW );
     return ret;
@@ -107,9 +107,9 @@ ULONG CDECL ldap_rename_extW( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *newrdn, WCHAR
     ret = map_error( ldap_funcs->ldap_rename( ld->ld, dnU, newrdnU, newparentU, delete, serverctrlsU, clientctrlsU,
                                               message ) );
 exit:
-    strfreeU( dnU );
-    strfreeU( newrdnU );
-    strfreeU( newparentU );
+    free( dnU );
+    free( newrdnU );
+    free( newparentU );
     controlarrayfreeU( serverctrlsU );
     controlarrayfreeU( clientctrlsU );
     return ret;
@@ -141,9 +141,9 @@ ULONG CDECL ldap_rename_ext_sA( WLDAP32_LDAP *ld, char *dn, char *newrdn, char *
     ret = ldap_rename_ext_sW( ld, dnW, newrdnW, newparentW, delete, serverctrlsW, clientctrlsW );
 
 exit:
-    strfreeW( dnW );
-    strfreeW( newrdnW );
-    strfreeW( newparentW );
+    free( dnW );
+    free( newrdnW );
+    free( newparentW );
     controlarrayfreeW( serverctrlsW );
     controlarrayfreeW( clientctrlsW );
     return ret;
@@ -187,9 +187,9 @@ ULONG CDECL ldap_rename_ext_sW( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *newrdn, WCHA
     ret = map_error( ldap_funcs->ldap_rename_s( ld->ld, dnU, newrdnU, newparentU, delete, serverctrlsU,
                                                 clientctrlsU ) );
 exit:
-    strfreeU( dnU );
-    strfreeU( newrdnU );
-    strfreeU( newparentU );
+    free( dnU );
+    free( newrdnU );
+    free( newparentU );
     controlarrayfreeU( serverctrlsU );
     controlarrayfreeU( clientctrlsU );
     return ret;
diff --git a/dlls/wldap32/search.c b/dlls/wldap32/search.c
index b4bf204f8176..7a496e02af38 100644
--- a/dlls/wldap32/search.c
+++ b/dlls/wldap32/search.c
@@ -19,12 +19,12 @@
  */
 
 #include <stdarg.h>
+#include <stdlib.h>
 #include "windef.h"
 #include "winbase.h"
 #include "winnls.h"
 
 #include "wine/debug.h"
-#include "wine/heap.h"
 #include "winldap_private.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(wldap32);
@@ -50,8 +50,8 @@ ULONG CDECL ldap_searchA( WLDAP32_LDAP *ld, char *base, ULONG scope, char *filte
     ret = ldap_searchW( ld, baseW, scope, filterW, attrsW, attrsonly );
 
 exit:
-    strfreeW( baseW );
-    strfreeW( filterW );
+    free( baseW );
+    free( filterW );
     strarrayfreeW( attrsW );
     return ret;
 }
@@ -116,8 +116,8 @@ ULONG CDECL ldap_search_extA( WLDAP32_LDAP *ld, char *base, ULONG scope, char *f
                             sizelimit, message );
 
 exit:
-    strfreeW( baseW );
-    strfreeW( filterW );
+    free( baseW );
+    free( filterW );
     strarrayfreeW( attrsW );
     controlarrayfreeW( serverctrlsW );
     controlarrayfreeW( clientctrlsW );
@@ -179,8 +179,8 @@ ULONG CDECL ldap_search_extW( WLDAP32_LDAP *ld, WCHAR *base, ULONG scope, WCHAR
                                                   serverctrlsU, clientctrlsU, timelimit ? &timevalU : NULL, sizelimit,
                                                   message ) );
 exit:
-    strfreeU( baseU );
-    strfreeU( filterU );
+    free( baseU );
+    free( filterU );
     strarrayfreeU( attrsU );
     controlarrayfreeU( serverctrlsU );
     controlarrayfreeU( clientctrlsU );
@@ -215,8 +215,8 @@ ULONG CDECL ldap_search_ext_sA( WLDAP32_LDAP *ld, char *base, ULONG scope, char
                               sizelimit, res );
 
 exit:
-    strfreeW( baseW );
-    strfreeW( filterW );
+    free( baseW );
+    free( filterW );
     strarrayfreeW( attrsW );
     controlarrayfreeW( serverctrlsW );
     controlarrayfreeW( clientctrlsW );
@@ -280,7 +280,7 @@ ULONG CDECL ldap_search_ext_sW( WLDAP32_LDAP *ld, WCHAR *base, ULONG scope, WCHA
                                                     clientctrlsU, timeout ? &timevalU : NULL, sizelimit, &msgU ) );
     if (msgU)
     {
-        WLDAP32_LDAPMessage *msg = heap_alloc_zero( sizeof(*msg) );
+        WLDAP32_LDAPMessage *msg = calloc( 1, sizeof(*msg) );
         if (msg)
         {
             msg->Request = msgU;
@@ -294,8 +294,8 @@ ULONG CDECL ldap_search_ext_sW( WLDAP32_LDAP *ld, WCHAR *base, ULONG scope, WCHA
     }
 
 exit:
-    strfreeU( baseU );
-    strfreeU( filterU );
+    free( baseU );
+    free( filterU );
     strarrayfreeU( attrsU );
     controlarrayfreeU( serverctrlsU );
     controlarrayfreeU( clientctrlsU );
@@ -325,8 +325,8 @@ ULONG CDECL ldap_search_sA( WLDAP32_LDAP *ld, char *base, ULONG scope, char *fil
     ret = ldap_search_sW( ld, baseW, scope, filterW, attrsW, attrsonly, res );
 
 exit:
-    strfreeW( baseW );
-    strfreeW( filterW );
+    free( baseW );
+    free( filterW );
     strarrayfreeW( attrsW );
     return ret;
 }
@@ -384,8 +384,8 @@ ULONG CDECL ldap_search_stA( WLDAP32_LDAP *ld, const PCHAR base, ULONG scope, co
     ret = ldap_search_stW( ld, baseW, scope, filterW, attrsW, attrsonly, timeout, res );
 
 exit:
-    strfreeW( baseW );
-    strfreeW( filterW );
+    free( baseW );
+    free( filterW );
     strarrayfreeW( attrsW );
     return ret;
 }
diff --git a/dlls/wldap32/value.c b/dlls/wldap32/value.c
index 249a2fae6050..b2111557afb9 100644
--- a/dlls/wldap32/value.c
+++ b/dlls/wldap32/value.c
@@ -19,12 +19,12 @@
  */
 
 #include <stdarg.h>
+#include <stdlib.h>
 #include "windef.h"
 #include "winbase.h"
 #include "winnls.h"
 
 #include "wine/debug.h"
-#include "wine/heap.h"
 #include "winldap_private.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(wldap32);
@@ -120,7 +120,7 @@ char ** CDECL ldap_get_valuesA( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *entry, ch
     ret = strarrayWtoA( retW );
 
     ldap_value_freeW( retW );
-    strfreeW( attrW );
+    free( attrW );
     return ret;
 }
 
@@ -129,7 +129,7 @@ static char *bv2str( struct bervalU *bv )
     char *str = NULL;
     unsigned int len = bv->bv_len;
 
-    if ((str = heap_alloc( len + 1 )))
+    if ((str = malloc( len + 1 )))
     {
         memcpy( str, bv->bv_val, len );
         str[len] = '\0';
@@ -148,7 +148,7 @@ static char **bv2str_array( struct bervalU **bv )
         len++;
         p++;
     }
-    if (!(str = heap_alloc( (len + 1) * sizeof(char *) ))) return NULL;
+    if (!(str = malloc( (len + 1) * sizeof(char *) ))) return NULL;
 
     p = bv;
     while (*p)
@@ -156,8 +156,8 @@ static char **bv2str_array( struct bervalU **bv )
         str[i] = bv2str( *p );
         if (!str[i])
         {
-            while (i > 0) heap_free( str[--i] );
-            heap_free( str );
+            while (i > 0) free( str[--i] );
+            free( str );
             return NULL;
         }
         i++;
@@ -205,7 +205,7 @@ WCHAR ** CDECL ldap_get_valuesW( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *entry, W
         strarrayfreeU( retU );
     }
 
-    strfreeU( attrU );
+    free( attrU );
     return ret;
 }
 
@@ -225,7 +225,7 @@ struct WLDAP32_berval ** CDECL ldap_get_values_lenA( WLDAP32_LDAP *ld, WLDAP32_L
 
     ret = ldap_get_values_lenW( ld, message, attrW );
 
-    strfreeW( attrW );
+    free( attrW );
     return ret;
 }
 
@@ -264,7 +264,7 @@ struct WLDAP32_berval ** CDECL ldap_get_values_lenW( WLDAP32_LDAP *ld, WLDAP32_L
         bvarrayfreeU( retU );
     }
 
-    strfreeU( attrU );
+    free( attrU );
     return ret;
 }
 
diff --git a/dlls/wldap32/winldap_private.h b/dlls/wldap32/winldap_private.h
index 2f5b4dcff72f..6777c114d81b 100644
--- a/dlls/wldap32/winldap_private.h
+++ b/dlls/wldap32/winldap_private.h
@@ -23,6 +23,7 @@
  */
 
 #include <assert.h>
+#include <stdlib.h>
 #include "winternl.h"
 #include "winnls.h"
 #include "libldap.h"
@@ -509,7 +510,7 @@ static inline char *strdupU( const char *src )
 {
     char *dst;
     if (!src) return NULL;
-    if ((dst = RtlAllocateHeap( GetProcessHeap(), 0, (strlen( src ) + 1) * sizeof(char) ))) strcpy( dst, src );
+    if ((dst = malloc( strlen( src ) + 1 ))) strcpy( dst, src );
     return dst;
 }
 
@@ -517,7 +518,7 @@ static inline WCHAR *strdupW( const WCHAR *src )
 {
     WCHAR *dst;
     if (!src) return NULL;
-    if ((dst = RtlAllocateHeap( GetProcessHeap(), 0, (lstrlenW( src ) + 1) * sizeof(WCHAR) ))) lstrcpyW( dst, src );
+    if ((dst = malloc( (lstrlenW( src ) + 1) * sizeof(WCHAR) ))) lstrcpyW( dst, src );
     return dst;
 }
 
@@ -527,8 +528,7 @@ static inline char *strWtoU( const WCHAR *str )
     if (str)
     {
         int len = WideCharToMultiByte( CP_UTF8, 0, str, -1, NULL, 0, NULL, NULL );
-        if ((ret = RtlAllocateHeap( GetProcessHeap(), 0, len )))
-            WideCharToMultiByte( CP_UTF8, 0, str, -1, ret, len, NULL, NULL );
+        if ((ret = malloc( len ))) WideCharToMultiByte( CP_UTF8, 0, str, -1, ret, len, NULL, NULL );
     }
     return ret;
 }
@@ -540,7 +540,7 @@ static inline char *strnWtoU( const WCHAR *str, DWORD in_len, DWORD *out_len )
     if (str)
     {
         DWORD len = WideCharToMultiByte( CP_UTF8, 0, str, in_len, NULL, 0, NULL, NULL );
-        if ((ret = RtlAllocateHeap( GetProcessHeap(), 0, len + 1 )))
+        if ((ret = malloc( len + 1 )))
         {
             WideCharToMultiByte( CP_UTF8, 0, str, in_len, ret, len, NULL, NULL );
             ret[len] = 0;
@@ -550,28 +550,17 @@ static inline char *strnWtoU( const WCHAR *str, DWORD in_len, DWORD *out_len )
     return ret;
 }
 
-static inline void strfreeU( char *str )
-{
-    RtlFreeHeap( GetProcessHeap(), 0, str );
-}
-
 static inline WCHAR *strAtoW( const char *str )
 {
     WCHAR *ret = NULL;
     if (str)
     {
         DWORD len = MultiByteToWideChar( CP_ACP, 0, str, -1, NULL, 0 );
-        if ((ret = RtlAllocateHeap( GetProcessHeap(), 0, len * sizeof(WCHAR) )))
-            MultiByteToWideChar( CP_ACP, 0, str, -1, ret, len );
+        if ((ret = malloc( len * sizeof(WCHAR) ))) MultiByteToWideChar( CP_ACP, 0, str, -1, ret, len );
     }
     return ret;
 }
 
-static inline void strfreeW( WCHAR *str )
-{
-    RtlFreeHeap( GetProcessHeap(), 0, str );
-}
-
 static inline WCHAR *strnAtoW( const char *str, DWORD in_len, DWORD *out_len )
 {
     WCHAR *ret = NULL;
@@ -579,7 +568,7 @@ static inline WCHAR *strnAtoW( const char *str, DWORD in_len, DWORD *out_len )
     if (str)
     {
         DWORD len = MultiByteToWideChar( CP_ACP, 0, str, in_len, NULL, 0 );
-        if ((ret = RtlAllocateHeap( GetProcessHeap(), 0, (len + 1) * sizeof(WCHAR) )))
+        if ((ret = malloc( (len + 1) * sizeof(WCHAR) )))
         {
             MultiByteToWideChar( CP_ACP, 0, str, in_len, ret, len );
             ret[len] = 0;
@@ -611,7 +600,7 @@ static inline char **strarrayWtoU( WCHAR **strarray )
     if (strarray)
     {
         size = sizeof(char *) * (strarraylenW( strarray ) + 1);
-        if ((strarrayU = RtlAllocateHeap( GetProcessHeap(), 0, size )))
+        if ((strarrayU = malloc( size )))
         {
             WCHAR **p = strarray;
             char **q = strarrayU;
@@ -631,7 +620,7 @@ static inline WCHAR **strarraydupW( WCHAR **strarray )
     if (strarray)
     {
         size = sizeof(WCHAR *) * (strarraylenW( strarray ) + 1);
-        if ((strarrayW = RtlAllocateHeap( GetProcessHeap(), 0, size )))
+        if ((strarrayW = malloc( size )))
         {
             WCHAR **p = strarray;
             WCHAR **q = strarrayW;
@@ -649,8 +638,7 @@ static inline char *strWtoA( const WCHAR *str )
     if (str)
     {
         DWORD len = WideCharToMultiByte( CP_ACP, 0, str, -1, NULL, 0, NULL, NULL );
-        if ((ret = RtlAllocateHeap( GetProcessHeap(), 0, len )))
-            WideCharToMultiByte( CP_ACP, 0, str, -1, ret, len, NULL, NULL );
+        if ((ret = malloc( len ))) WideCharToMultiByte( CP_ACP, 0, str, -1, ret, len, NULL, NULL );
     }
     return ret;
 }
@@ -663,7 +651,7 @@ static inline char **strarrayWtoA( WCHAR **strarray )
     if (strarray)
     {
         size = sizeof(char *) * (strarraylenW( strarray ) + 1);
-        if ((strarrayA = RtlAllocateHeap( GetProcessHeap(), 0, size )))
+        if ((strarrayA = malloc( size )))
         {
             WCHAR **p = strarray;
             char **q = strarrayA;
@@ -689,7 +677,7 @@ static inline struct bervalU *bervalWtoU( const struct WLDAP32_berval *bv )
     struct bervalU *berval;
     DWORD size = sizeof(*berval) + bv->bv_len;
 
-    if ((berval = RtlAllocateHeap( GetProcessHeap(), 0, size )))
+    if ((berval = malloc( size )))
     {
         char *val = (char *)(berval + 1);
 
@@ -714,7 +702,7 @@ static inline struct WLDAP32_berval *bervalUtoW( const struct bervalU *bv )
 
     assert( bv->bv_len <= ~0u );
 
-    if ((berval = RtlAllocateHeap( GetProcessHeap(), 0, size )))
+    if ((berval = malloc( size )))
     {
         char *val = (char *)(berval + 1);
 
@@ -733,7 +721,7 @@ static inline struct WLDAP32_berval **bvarrayUtoW( struct bervalU **bv )
     if (bv)
     {
         size = sizeof(*berval) * (bvarraylenU( bv ) + 1);
-        if ((berval = RtlAllocateHeap( GetProcessHeap(), 0, size )))
+        if ((berval = malloc( size )))
         {
             struct bervalU **p = bv;
             struct WLDAP32_berval **q = berval;
@@ -747,7 +735,7 @@ static inline struct WLDAP32_berval **bvarrayUtoW( struct bervalU **bv )
 
 static inline void bvfreeU( struct bervalU *berval )
 {
-    RtlFreeHeap( GetProcessHeap(), 0, berval );
+    free( berval );
 }
 
 static inline struct bervalU **bvarrayWtoU( struct WLDAP32_berval **bv )
@@ -758,7 +746,7 @@ static inline struct bervalU **bvarrayWtoU( struct WLDAP32_berval **bv )
     if (bv)
     {
         size = sizeof(*berval) * (bvarraylenW( bv ) + 1);
-        if ((berval = RtlAllocateHeap( GetProcessHeap(), 0, size )))
+        if ((berval = malloc( size )))
         {
             struct WLDAP32_berval **p = bv;
             struct bervalU **q = berval;
@@ -774,7 +762,7 @@ static inline LDAPModU *modWtoU( const LDAPModW *mod )
 {
     LDAPModU *modU;
 
-    if ((modU = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(LDAPModU) )))
+    if ((modU = malloc( sizeof(*modU) )))
     {
         modU->mod_op = mod->mod_op;
         modU->mod_type = strWtoU( mod->mod_type );
@@ -795,7 +783,7 @@ static inline LDAPModU **modarrayWtoU( LDAPModW **modarray )
     if (modarray)
     {
         size = sizeof(LDAPModU *) * (modarraylenW( modarray ) + 1);
-        if ((modarrayU = RtlAllocateHeap( GetProcessHeap(), 0, size )))
+        if ((modarrayU = malloc( size )))
         {
             LDAPModW **p = modarray;
             LDAPModU **q = modarrayU;
@@ -810,8 +798,8 @@ static inline LDAPModU **modarrayWtoU( LDAPModW **modarray )
 static inline void bvarrayfreeU( struct bervalU **bv )
 {
     struct bervalU **p = bv;
-    while (*p) RtlFreeHeap( GetProcessHeap(), 0, *p++ );
-    RtlFreeHeap( GetProcessHeap(), 0, bv );
+    while (*p) free( *p++ );
+    free( bv );
 }
 
 static inline void strarrayfreeU( char **strarray )
@@ -819,8 +807,8 @@ static inline void strarrayfreeU( char **strarray )
     if (strarray)
     {
         char **p = strarray;
-        while (*p) strfreeU( *p++ );
-        RtlFreeHeap( GetProcessHeap(), 0, strarray );
+        while (*p) free( *p++ );
+        free( strarray );
     }
 }
 
@@ -830,7 +818,7 @@ static inline void modfreeU( LDAPModU *mod )
         bvarrayfreeU( mod->mod_vals.modv_bvals );
     else
         strarrayfreeU( mod->mod_vals.modv_strvals );
-    RtlFreeHeap( GetProcessHeap(), 0, mod );
+    free( mod );
 }
 
 static inline void modarrayfreeU( LDAPModU **modarray )
@@ -839,7 +827,7 @@ static inline void modarrayfreeU( LDAPModU **modarray )
     {
         LDAPModU **p = modarray;
         while (*p) modfreeU( *p++ );
-        RtlFreeHeap( GetProcessHeap(), 0, modarray );
+        free( modarray );
     }
 }
 
@@ -855,7 +843,7 @@ static inline struct WLDAP32_berval *bervalWtoW( const struct WLDAP32_berval *bv
     struct WLDAP32_berval *berval;
     DWORD size = sizeof(*berval) + bv->bv_len;
 
-    if ((berval = RtlAllocateHeap( GetProcessHeap(), 0, size )))
+    if ((berval = malloc( size )))
     {
         char *val = (char *)(berval + 1);
 
@@ -874,7 +862,7 @@ static inline struct WLDAP32_berval **bvarrayWtoW( struct WLDAP32_berval **bv )
     if (bv)
     {
         size = sizeof(*berval) * (bvarraylenW( bv ) + 1);
-        if ((berval = RtlAllocateHeap( GetProcessHeap(), 0, size )))
+        if ((berval = malloc( size )))
         {
             struct WLDAP32_berval **p = bv;
             struct WLDAP32_berval **q = berval;
@@ -901,7 +889,7 @@ static inline WCHAR **strarrayAtoW( char **strarray )
     if (strarray)
     {
         size  = sizeof(WCHAR *) * (strarraylenA( strarray ) + 1);
-        if ((strarrayW = RtlAllocateHeap( GetProcessHeap(), 0, size )))
+        if ((strarrayW = malloc( size )))
         {
             char **p = strarray;
             WCHAR **q = strarrayW;
@@ -917,7 +905,7 @@ static inline LDAPModW *modAtoW( const LDAPModA *mod )
 {
     LDAPModW *modW;
 
-    if ((modW = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(LDAPModW) )))
+    if ((modW = malloc( sizeof(*modW) )))
     {
         modW->mod_op = mod->mod_op;
         modW->mod_type = strAtoW( mod->mod_type );
@@ -938,7 +926,7 @@ static inline LDAPModW **modarrayAtoW( LDAPModA **modarray )
     if (modarray)
     {
         size = sizeof(LDAPModW *) * (modarraylenA( modarray ) + 1);
-        if ((modarrayW = RtlAllocateHeap( GetProcessHeap(), 0, size )))
+        if ((modarrayW = malloc( size )))
         {
             LDAPModA **p = modarray;
             LDAPModW **q = modarrayW;
@@ -953,8 +941,8 @@ static inline LDAPModW **modarrayAtoW( LDAPModA **modarray )
 static inline void bvarrayfreeW( struct WLDAP32_berval **bv )
 {
     struct WLDAP32_berval **p = bv;
-    while (*p) RtlFreeHeap( GetProcessHeap(), 0, *p++ );
-    RtlFreeHeap( GetProcessHeap(), 0, bv );
+    while (*p) free( *p++ );
+    free( bv );
 }
 
 static inline void strarrayfreeW( WCHAR **strarray )
@@ -962,8 +950,8 @@ static inline void strarrayfreeW( WCHAR **strarray )
     if (strarray)
     {
         WCHAR **p = strarray;
-        while (*p) strfreeW( *p++ );
-        RtlFreeHeap( GetProcessHeap(), 0, strarray );
+        while (*p) free( *p++ );
+        free( strarray );
     }
 }
 
@@ -973,7 +961,7 @@ static inline void modfreeW( LDAPModW *mod )
         bvarrayfreeW( mod->mod_vals.modv_bvals );
     else
         strarrayfreeW( mod->mod_vals.modv_strvals );
-    RtlFreeHeap( GetProcessHeap(), 0, mod );
+    free( mod );
 }
 
 static inline void modarrayfreeW( LDAPModW **modarray )
@@ -982,7 +970,7 @@ static inline void modarrayfreeW( LDAPModW **modarray )
     {
         LDAPModW **p = modarray;
         while (*p) modfreeW( *p++ );
-        RtlFreeHeap( GetProcessHeap(), 0, modarray );
+        free( modarray );
     }
 }
 
@@ -1001,13 +989,13 @@ static inline LDAPControlW *controlAtoW( const LDAPControlA *control )
 
     if (control->ldctl_value.bv_val)
     {
-        if (!(val = RtlAllocateHeap( GetProcessHeap(), 0, len ))) return NULL;
+        if (!(val = malloc( len ))) return NULL;
         memcpy( val, control->ldctl_value.bv_val, len );
     }
 
-    if (!(controlW = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(LDAPControlW) )))
+    if (!(controlW = malloc( sizeof(*controlW) )))
     {
-        RtlFreeHeap( GetProcessHeap(), 0, val );
+        free( val );
         return NULL;
     }
 
@@ -1027,7 +1015,7 @@ static inline LDAPControlW **controlarrayAtoW( LDAPControlA **controlarray )
     if (controlarray)
     {
         size = sizeof(LDAPControlW *) * (controlarraylenA( controlarray ) + 1);
-        if ((controlarrayW = RtlAllocateHeap( GetProcessHeap(), 0, size )))
+        if ((controlarrayW = malloc( size )))
         {
             LDAPControlA **p = controlarray;
             LDAPControlW **q = controlarrayW;
@@ -1043,9 +1031,9 @@ static inline void controlfreeW( LDAPControlW *control )
 {
     if (control)
     {
-        strfreeW( control->ldctl_oid );
-        RtlFreeHeap( GetProcessHeap(), 0, control->ldctl_value.bv_val );
-        RtlFreeHeap( GetProcessHeap(), 0, control );
+        free( control->ldctl_oid );
+        free( control->ldctl_value.bv_val );
+        free( control );
     }
 }
 
@@ -1055,7 +1043,7 @@ static inline void controlarrayfreeW( LDAPControlW **controlarray )
     {
         LDAPControlW **p = controlarray;
         while (*p) controlfreeW( *p++ );
-        RtlFreeHeap( GetProcessHeap(), 0, controlarray );
+        free( controlarray );
     }
 }
 
@@ -1074,13 +1062,13 @@ static inline LDAPControlA *controlWtoA( const LDAPControlW *control )
 
     if (control->ldctl_value.bv_val)
     {
-        if (!(val = RtlAllocateHeap( GetProcessHeap(), 0, len ))) return NULL;
+        if (!(val = malloc( len ))) return NULL;
         memcpy( val, control->ldctl_value.bv_val, len );
     }
 
-    if (!(controlA = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(LDAPControlA) )))
+    if (!(controlA = malloc( sizeof(*controlA) )))
     {
-        RtlFreeHeap( GetProcessHeap(), 0, val );
+        free( val );
         return NULL;
     }
 
@@ -1092,18 +1080,13 @@ static inline LDAPControlA *controlWtoA( const LDAPControlW *control )
     return controlA;
 }
 
-static inline void strfreeA( char *str )
-{
-    RtlFreeHeap( GetProcessHeap(), 0, str );
-}
-
 static inline void strarrayfreeA( char **strarray )
 {
     if (strarray)
     {
         char **p = strarray;
-        while (*p) strfreeA( *p++ );
-        RtlFreeHeap( GetProcessHeap(), 0, strarray );
+        while (*p) free( *p++ );
+        free( strarray );
     }
 }
 
@@ -1111,9 +1094,9 @@ static inline void controlfreeA( LDAPControlA *control )
 {
     if (control)
     {
-        strfreeA( control->ldctl_oid );
-        RtlFreeHeap( GetProcessHeap(), 0, control->ldctl_value.bv_val );
-        RtlFreeHeap( GetProcessHeap(), 0, control );
+        free( control->ldctl_oid );
+        free( control->ldctl_value.bv_val );
+        free( control );
     }
 }
 
@@ -1123,7 +1106,7 @@ static inline void controlarrayfreeA( LDAPControlA **controlarray )
     {
         LDAPControlA **p = controlarray;
         while (*p) controlfreeA( *p++ );
-        RtlFreeHeap( GetProcessHeap(), 0, controlarray );
+        free( controlarray );
     }
 }
 
@@ -1135,13 +1118,13 @@ static inline LDAPControlU *controlWtoU( const LDAPControlW *control )
 
     if (control->ldctl_value.bv_val)
     {
-        if (!(val = RtlAllocateHeap( GetProcessHeap(), 0, len ))) return NULL;
+        if (!(val = malloc( len ))) return NULL;
         memcpy( val, control->ldctl_value.bv_val, len );
     }
 
-    if (!(controlU = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(LDAPControlU) )))
+    if (!(controlU = malloc( sizeof(*controlU) )))
     {
-        RtlFreeHeap( GetProcessHeap(), 0, val );
+        free( val );
         return NULL;
     }
 
@@ -1161,7 +1144,7 @@ static inline LDAPControlU **controlarrayWtoU( LDAPControlW **controlarray )
     if (controlarray)
     {
         size = sizeof(LDAPControlU *) * (controlarraylenW( controlarray ) + 1);
-        if ((controlarrayU = RtlAllocateHeap( GetProcessHeap(), 0, size )))
+        if ((controlarrayU = malloc( size )))
         {
             LDAPControlW **p = controlarray;
             LDAPControlU **q = controlarrayU;
@@ -1177,9 +1160,9 @@ static inline void controlfreeU( LDAPControlU *control )
 {
     if (control)
     {
-        strfreeU( control->ldctl_oid );
-        RtlFreeHeap( GetProcessHeap(), 0, control->ldctl_value.bv_val );
-        RtlFreeHeap( GetProcessHeap(), 0, control );
+        free( control->ldctl_oid );
+        free( control->ldctl_value.bv_val );
+        free( control );
     }
 }
 
@@ -1189,7 +1172,7 @@ static inline void controlarrayfreeU( LDAPControlU **controlarray )
     {
         LDAPControlU **p = controlarray;
         while (*p) controlfreeU( *p++ );
-        RtlFreeHeap( GetProcessHeap(), 0, controlarray );
+        free( controlarray );
     }
 }
 
@@ -1208,13 +1191,13 @@ static inline LDAPControlW *controldupW( LDAPControlW *control )
 
     if (control->ldctl_value.bv_val)
     {
-        if (!(val = RtlAllocateHeap( GetProcessHeap(), 0, len ))) return NULL;
+        if (!(val = malloc( len ))) return NULL;
         memcpy( val, control->ldctl_value.bv_val, len );
     }
 
-    if (!(controlW = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(LDAPControlW) )))
+    if (!(controlW = malloc( sizeof(*controlW) )))
     {
-        RtlFreeHeap( GetProcessHeap(), 0, val );
+        free( val );
         return NULL;
     }
 
@@ -1234,7 +1217,7 @@ static inline LDAPControlW **controlarraydupW( LDAPControlW **controlarray )
     if (controlarray)
     {
         size = sizeof(LDAPControlW *) * (controlarraylenW( controlarray ) + 1);
-        if ((controlarrayW = RtlAllocateHeap( GetProcessHeap(), 0, size )))
+        if ((controlarrayW = malloc( size )))
         {
             LDAPControlW **p = controlarray;
             LDAPControlW **q = controlarrayW;
@@ -1254,7 +1237,7 @@ static inline LDAPControlA **controlarrayWtoA( LDAPControlW **controlarray )
     if (controlarray)
     {
         size = sizeof(LDAPControlA *) * (controlarraylenW( controlarray ) + 1);
-        if ((controlarrayA = RtlAllocateHeap( GetProcessHeap(), 0, size )))
+        if ((controlarrayA = malloc( size )))
         {
             LDAPControlW **p = controlarray;
             LDAPControlA **q = controlarrayA;
@@ -1272,8 +1255,7 @@ static inline WCHAR *strUtoW( const char *str )
     if (str)
     {
         DWORD len = MultiByteToWideChar( CP_UTF8, 0, str, -1, NULL, 0 );
-        if ((ret = RtlAllocateHeap( GetProcessHeap(), 0, len * sizeof(WCHAR) )))
-            MultiByteToWideChar( CP_UTF8, 0, str, -1, ret, len );
+        if ((ret = malloc( len * sizeof(WCHAR) ))) MultiByteToWideChar( CP_UTF8, 0, str, -1, ret, len );
     }
     return ret;
 }
@@ -1293,7 +1275,7 @@ static inline WCHAR **strarrayUtoW( char **strarray )
     if (strarray)
     {
         size = sizeof(WCHAR *) * (strarraylenU( strarray ) + 1);
-        if ((strarrayW = RtlAllocateHeap( GetProcessHeap(), 0, size )))
+        if ((strarrayW = malloc( size )))
         {
             char **p = strarray;
             WCHAR **q = strarrayW;
@@ -1313,7 +1295,7 @@ static inline char **strarrayUtoU( char **strarray )
     if (strarray)
     {
         size = sizeof(char *) * (strarraylenU( strarray ) + 1);
-        if ((strarrayU = RtlAllocateHeap( GetProcessHeap(), 0, size )))
+        if ((strarrayU = malloc( size )))
         {
             char **p = strarray;
             char **q = strarrayU;
@@ -1333,13 +1315,13 @@ static inline LDAPControlW *controlUtoW( const LDAPControlU *control )
 
     if (control->ldctl_value.bv_val)
     {
-        if (!(val = RtlAllocateHeap( GetProcessHeap(), 0, len ))) return NULL;
+        if (!(val = malloc( len ))) return NULL;
         memcpy( val, control->ldctl_value.bv_val, len );
     }
 
-    if (!(controlW = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(LDAPControlW) )))
+    if (!(controlW = malloc( sizeof(*controlW) )))
     {
-        RtlFreeHeap( GetProcessHeap(), 0, val );
+        free( val );
         return NULL;
     }
 
@@ -1359,7 +1341,7 @@ static inline LDAPControlW **controlarrayUtoW( LDAPControlU **controlarray )
     if (controlarray)
     {
         size = sizeof(LDAPControlW *) * (controlarraylenU( controlarray ) + 1);
-        if ((controlarrayW = RtlAllocateHeap( GetProcessHeap(), 0, size )))
+        if ((controlarrayW = malloc( size )))
         {
             LDAPControlU **p = controlarray;
             LDAPControlW **q = controlarrayW;
@@ -1382,7 +1364,7 @@ static inline LDAPSortKeyW *sortkeyAtoW( const LDAPSortKeyA *sortkey )
 {
     LDAPSortKeyW *sortkeyW;
 
-    if ((sortkeyW = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(LDAPSortKeyW) )))
+    if ((sortkeyW = malloc( sizeof(*sortkeyW) )))
     {
         sortkeyW->sk_attrtype = strAtoW( sortkey->sk_attrtype );
         sortkeyW->sk_matchruleoid = strAtoW( sortkey->sk_matchruleoid );
@@ -1399,7 +1381,7 @@ static inline LDAPSortKeyW **sortkeyarrayAtoW( LDAPSortKeyA **sortkeyarray )
     if (sortkeyarray)
     {
         size = sizeof(LDAPSortKeyW *) * (sortkeyarraylenA( sortkeyarray ) + 1);
-        if ((sortkeyarrayW = RtlAllocateHeap( GetProcessHeap(), 0, size )))
+        if ((sortkeyarrayW = malloc( size )))
         {
             LDAPSortKeyA **p = sortkeyarray;
             LDAPSortKeyW **q = sortkeyarrayW;
@@ -1415,9 +1397,9 @@ static inline void sortkeyfreeW( LDAPSortKeyW *sortkey )
 {
     if (sortkey)
     {
-        strfreeW( sortkey->sk_attrtype );
-        strfreeW( sortkey->sk_matchruleoid );
-        RtlFreeHeap( GetProcessHeap(), 0, sortkey );
+        free( sortkey->sk_attrtype );
+        free( sortkey->sk_matchruleoid );
+        free( sortkey );
     }
 }
 
@@ -1427,7 +1409,7 @@ static inline void sortkeyarrayfreeW( LDAPSortKeyW **sortkeyarray )
     {
         LDAPSortKeyW **p = sortkeyarray;
         while (*p) sortkeyfreeW( *p++ );
-        RtlFreeHeap( GetProcessHeap(), 0, sortkeyarray );
+        free( sortkeyarray );
     }
 }
 
@@ -1442,7 +1424,7 @@ static inline LDAPSortKeyU *sortkeyWtoU( const LDAPSortKeyW *sortkey )
 {
     LDAPSortKeyU *sortkeyU;
 
-    if ((sortkeyU = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(LDAPSortKeyU) )))
+    if ((sortkeyU = malloc( sizeof(*sortkeyU) )))
     {
         sortkeyU->attributeType = strWtoU( sortkey->sk_attrtype );
         sortkeyU->orderingRule = strWtoU( sortkey->sk_matchruleoid );
@@ -1459,7 +1441,7 @@ static inline LDAPSortKeyU **sortkeyarrayWtoU( LDAPSortKeyW **sortkeyarray )
     if (sortkeyarray)
     {
         size = sizeof(LDAPSortKeyU *) * (sortkeyarraylenW( sortkeyarray ) + 1);
-        if ((sortkeyarrayU = RtlAllocateHeap( GetProcessHeap(), 0, size )))
+        if ((sortkeyarrayU = malloc( size )))
         {
             LDAPSortKeyW **p = sortkeyarray;
             LDAPSortKeyU **q = sortkeyarrayU;
@@ -1475,9 +1457,9 @@ static inline void sortkeyfreeU( LDAPSortKeyU *sortkey )
 {
     if (sortkey)
     {
-        strfreeU( sortkey->attributeType );
-        strfreeU( sortkey->orderingRule );
-        RtlFreeHeap( GetProcessHeap(), 0, sortkey );
+        free( sortkey->attributeType );
+        free( sortkey->orderingRule );
+        free( sortkey );
     }
 }
 
@@ -1487,7 +1469,7 @@ static inline void sortkeyarrayfreeU( LDAPSortKeyU **sortkeyarray )
     {
         LDAPSortKeyU **p = sortkeyarray;
         while (*p) sortkeyfreeU( *p++ );
-        RtlFreeHeap( GetProcessHeap(), 0, sortkeyarray );
+        free( sortkeyarray );
     }
 }
 
@@ -1495,7 +1477,7 @@ static inline LDAPVLVInfoU *vlvinfoWtoU( const WLDAP32_LDAPVLVInfo *info )
 {
     LDAPVLVInfoU *infoU;
 
-    if ((infoU = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(*infoU) )))
+    if ((infoU = malloc( sizeof(*infoU) )))
     {
         infoU->ldvlv_version       = info->ldvlv_version;
         infoU->ldvlv_before_count  = info->ldvlv_before_count;
@@ -1504,13 +1486,13 @@ static inline LDAPVLVInfoU *vlvinfoWtoU( const WLDAP32_LDAPVLVInfo *info )
         infoU->ldvlv_count         = info->ldvlv_count;
         if (!(infoU->ldvlv_attrvalue = bervalWtoU( info->ldvlv_attrvalue )))
         {
-            RtlFreeHeap( GetProcessHeap(), 0, infoU );
+            free( infoU );
             return NULL;
         }
         if (!(infoU->ldvlv_context = bervalWtoU( info->ldvlv_context )))
         {
-            RtlFreeHeap( GetProcessHeap(), 0, infoU->ldvlv_attrvalue );
-            RtlFreeHeap( GetProcessHeap(), 0, infoU );
+            free( infoU->ldvlv_attrvalue );
+            free( infoU );
             return NULL;
         }
         infoU->ldvlv_extradata     = info->ldvlv_extradata;
@@ -1520,7 +1502,7 @@ static inline LDAPVLVInfoU *vlvinfoWtoU( const WLDAP32_LDAPVLVInfo *info )
 
 static inline void vlvinfofreeU( LDAPVLVInfoU *info )
 {
-    RtlFreeHeap( GetProcessHeap(), 0, info->ldvlv_attrvalue );
-    RtlFreeHeap( GetProcessHeap(), 0, info->ldvlv_context );
-    RtlFreeHeap( GetProcessHeap(), 0, info );
+    free( info->ldvlv_attrvalue );
+    free( info->ldvlv_context );
+    free( info );
 }
From 81e418efaf5ded55311385d3868c36a01dc9e432 Mon Sep 17 00:00:00 2001
From: Hans Leidekker <hans@codeweavers.com>
Date: Mon, 19 Apr 2021 10:04:53 +0200
Subject: [PATCH] wldap32: Use wide character string literals.

Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/wldap32/init.c            | 11 ++++-------
 dlls/wldap32/winldap_private.h |  6 ------
 2 files changed, 4 insertions(+), 13 deletions(-)

diff --git a/dlls/wldap32/init.c b/dlls/wldap32/init.c
index 28e62ba6de22..8043164ad307 100644
--- a/dlls/wldap32/init.c
+++ b/dlls/wldap32/init.c
@@ -30,9 +30,6 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(wldap32);
 
-/* Should eventually be determined by the algorithm documented on MSDN. */
-static const WCHAR defaulthost[] = { 'l','o','c','a','l','h','o','s','t',0 };
-
 /* Split a space separated string of hostnames into a string array */
 static char **split_hostnames( const char *hostnames )
 {
@@ -256,7 +253,7 @@ WLDAP32_LDAP * CDECL cldap_openW( WCHAR *hostname, ULONG portnumber )
 
     TRACE( "(%s, %d)\n", debugstr_w(hostname), portnumber );
 
-    if (!(hostnameU = strWtoU( hostname ? hostname : defaulthost ))) return NULL;
+    if (!(hostnameU = strWtoU( hostname ? hostname : L"localhost" ))) return NULL;
     if (!(url = urlify_hostnames( "cldap://", hostnameU, portnumber ))) goto exit;
 
     ld = create_context( url );
@@ -342,7 +339,7 @@ WLDAP32_LDAP * CDECL ldap_initW( const PWCHAR hostname, ULONG portnumber )
 
     TRACE( "(%s, %d)\n", debugstr_w(hostname), portnumber );
 
-    if (!(hostnameU = strWtoU( hostname ? hostname : defaulthost ))) return NULL;
+    if (!(hostnameU = strWtoU( hostname ? hostname : L"localhost" ))) return NULL;
     if (!(url = urlify_hostnames( "ldap://", hostnameU, portnumber ))) goto exit;
 
     ld = create_context( url );
@@ -401,7 +398,7 @@ WLDAP32_LDAP * CDECL ldap_openW( WCHAR *hostname, ULONG portnumber )
 
     TRACE( "(%s, %d)\n", debugstr_w(hostname), portnumber );
 
-    if (!(hostnameU = strWtoU( hostname ? hostname : defaulthost ))) return NULL;
+    if (!(hostnameU = strWtoU( hostname ? hostname : L"localhost" ))) return NULL;
     if (!(url = urlify_hostnames( "ldap://", hostnameU, portnumber ))) goto exit;
 
     ld = create_context( url );
@@ -462,7 +459,7 @@ WLDAP32_LDAP * CDECL ldap_sslinitW( WCHAR *hostname, ULONG portnumber, int secur
 
     TRACE( "(%s, %d, 0x%08x)\n", debugstr_w(hostname), portnumber, secure );
 
-    if (!(hostnameU = strWtoU( hostname ? hostname : defaulthost ))) return NULL;
+    if (!(hostnameU = strWtoU( hostname ? hostname : L"localhost" ))) return NULL;
 
     if (secure)
         url = urlify_hostnames( "ldaps://", hostnameU, portnumber );
diff --git a/dlls/wldap32/winldap_private.h b/dlls/wldap32/winldap_private.h
index 6777c114d81b..0d528471b0cd 100644
--- a/dlls/wldap32/winldap_private.h
+++ b/dlls/wldap32/winldap_private.h
@@ -220,15 +220,9 @@ typedef struct ldap_version_info
 #define LDAP_SERVER_RESP_SORT_OID "1.2.840.113556.1.4.474"
 #define LDAP_CONTROL_VLVRESPONSE "2.16.840.1.113730.3.4.10"
 
-#if defined(_MSC_VER) || defined(__MINGW32__)
 #define LDAP_PAGED_RESULT_OID_STRING_W L"1.2.840.113556.1.4.319"
 #define LDAP_SERVER_RESP_SORT_OID_W L"1.2.840.113556.1.4.474"
 #define LDAP_CONTROL_VLVRESPONSE_W L"2.16.840.1.113730.3.4.10"
-#else
-static const WCHAR LDAP_PAGED_RESULT_OID_STRING_W[] = {'1','.','2','.','8','4','0','.','1','1','3','5','5','6','.','1','.','4','.','3','1','9',0};
-static const WCHAR LDAP_SERVER_RESP_SORT_OID_W[] = {'1','.','2','.','8','4','0','.','1','1','3','5','5','6','.','1','.','4','.','4','7','4',0};
-static const WCHAR LDAP_CONTROL_VLVRESPONSE_W[] = {'2','.','1','6','.','8','4','0','.','1','.','1','1','3','7','3','0','.','3','.','4','.','1','0',0};
-#endif
 
 typedef struct ldapcontrolA
 {
From 8db46756ca91695c7242e05d24a3e5ec4340c10c Mon Sep 17 00:00:00 2001
From: Hans Leidekker <hans@codeweavers.com>
Date: Mon, 19 Apr 2021 10:04:54 +0200
Subject: [PATCH] wldap32: Get rid of the WLDAP32_ prefix.

We can now include the public header without conflicts.

Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/wldap32/add.c             |  45 +--
 dlls/wldap32/ber.c             | 104 +++----
 dlls/wldap32/bind.c            | 132 ++++-----
 dlls/wldap32/compare.c         |  57 ++--
 dlls/wldap32/control.c         |  65 ++--
 dlls/wldap32/delete.c          |  51 ++--
 dlls/wldap32/dn.c              |  31 +-
 dlls/wldap32/error.c           |  59 ++--
 dlls/wldap32/extended.c        |  58 ++--
 dlls/wldap32/init.c            |  67 ++---
 dlls/wldap32/libldap.c         |   5 +-
 dlls/wldap32/libldap.h         | 147 ++++-----
 dlls/wldap32/misc.c            | 106 +++----
 dlls/wldap32/modify.c          |  49 +--
 dlls/wldap32/modrdn.c          |  41 +--
 dlls/wldap32/option.c          | 525 ++++++++++++++++----------------
 dlls/wldap32/page.c            | 112 +++----
 dlls/wldap32/parse.c           | 118 ++++----
 dlls/wldap32/rename.c          |  33 ++-
 dlls/wldap32/search.c          |  76 ++---
 dlls/wldap32/value.c           |  31 +-
 dlls/wldap32/winldap_private.h | 527 +++------------------------------
 dlls/wldap32/wldap32.spec      |  56 ++--
 include/winber.h               |   2 +-
 include/winldap.h              |  10 +-
 25 files changed, 1039 insertions(+), 1468 deletions(-)

diff --git a/dlls/wldap32/add.c b/dlls/wldap32/add.c
index 605c1535914a..e9684f2d209f 100644
--- a/dlls/wldap32/add.c
+++ b/dlls/wldap32/add.c
@@ -22,6 +22,7 @@
 #include "windef.h"
 #include "winbase.h"
 #include "winnls.h"
+#include "winldap.h"
 
 #include "wine/debug.h"
 #include "winldap_private.h"
@@ -33,9 +34,9 @@ WINE_DEFAULT_DEBUG_CHANNEL(wldap32);
  *
  * See ldap_addW.
  */
-ULONG CDECL ldap_addA( WLDAP32_LDAP *ld, char *dn, LDAPModA **attrs )
+ULONG CDECL ldap_addA( LDAP *ld, char *dn, LDAPModA **attrs )
 {
-    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
+    ULONG ret = LDAP_NO_MEMORY;
     WCHAR *dnW = NULL;
     LDAPModW **attrsW = NULL;
 
@@ -74,14 +75,14 @@ ULONG CDECL ldap_addA( WLDAP32_LDAP *ld, char *dn, LDAPModA **attrs )
  *  the operation. Cancel the operation by calling ldap_abandon
  *  with the message ID.
  */
-ULONG CDECL ldap_addW( WLDAP32_LDAP *ld, WCHAR *dn, LDAPModW **attrs )
+ULONG CDECL ldap_addW( LDAP *ld, WCHAR *dn, LDAPModW **attrs )
 {
     ULONG ret, msg;
 
     TRACE( "(%p, %s, %p)\n", ld, debugstr_w(dn), attrs );
 
     ret = ldap_add_extW( ld, dn, attrs, NULL, NULL, &msg );
-    if (ret == WLDAP32_LDAP_SUCCESS) return msg;
+    if (ret == LDAP_SUCCESS) return msg;
     return ~0u;
 }
 
@@ -90,17 +91,17 @@ ULONG CDECL ldap_addW( WLDAP32_LDAP *ld, WCHAR *dn, LDAPModW **attrs )
  *
  * See ldap_add_extW.
  */
-ULONG CDECL ldap_add_extA( WLDAP32_LDAP *ld, char *dn, LDAPModA **attrs, LDAPControlA **serverctrls,
+ULONG CDECL ldap_add_extA( LDAP *ld, char *dn, LDAPModA **attrs, LDAPControlA **serverctrls,
                            LDAPControlA **clientctrls, ULONG *message )
 {
-    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
+    ULONG ret = LDAP_NO_MEMORY;
     WCHAR *dnW = NULL;
     LDAPModW **attrsW = NULL;
     LDAPControlW **serverctrlsW = NULL, **clientctrlsW = NULL;
 
     TRACE( "(%p, %s, %p, %p, %p, %p)\n", ld, debugstr_a(dn), attrs, serverctrls, clientctrls, message );
 
-    if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
+    if (!ld) return LDAP_PARAM_ERROR;
 
     if (dn && !(dnW = strAtoW( dn ))) goto exit;
     if (attrs && !(attrsW = modarrayAtoW( attrs ))) goto exit;
@@ -140,24 +141,24 @@ ULONG CDECL ldap_add_extA( WLDAP32_LDAP *ld, char *dn, LDAPModA **attrs, LDAPCon
  *  the operation. The serverctrls and clientctrls parameters are
  *  optional and should be set to NULL if not used.
  */
-ULONG CDECL ldap_add_extW( WLDAP32_LDAP *ld, WCHAR *dn, LDAPModW **attrs, LDAPControlW **serverctrls,
+ULONG CDECL ldap_add_extW( LDAP *ld, WCHAR *dn, LDAPModW **attrs, LDAPControlW **serverctrls,
                            LDAPControlW **clientctrls, ULONG *message )
 {
-    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
+    ULONG ret = LDAP_NO_MEMORY;
     char *dnU = NULL;
     LDAPModU **attrsU = NULL;
     LDAPControlU **serverctrlsU = NULL, **clientctrlsU = NULL;
 
     TRACE( "(%p, %s, %p, %p, %p, %p)\n", ld, debugstr_w(dn), attrs, serverctrls, clientctrls, message );
 
-    if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
+    if (!ld) return LDAP_PARAM_ERROR;
 
     if (dn && !(dnU = strWtoU( dn ))) goto exit;
     if (attrs && !(attrsU = modarrayWtoU( attrs ))) goto exit;
     if (serverctrls && !(serverctrlsU = controlarrayWtoU( serverctrls ))) goto exit;
     if (clientctrls && !(clientctrlsU = controlarrayWtoU( clientctrls ))) goto exit;
 
-    ret = map_error( ldap_funcs->ldap_add_ext( ld->ld, dnU, attrsU, serverctrlsU, clientctrlsU, message ) );
+    ret = map_error( ldap_funcs->fn_ldap_add_ext( CTX(ld), dnU, attrsU, serverctrlsU, clientctrlsU, message ) );
 
 exit:
     free( dnU );
@@ -172,17 +173,17 @@ ULONG CDECL ldap_add_extW( WLDAP32_LDAP *ld, WCHAR *dn, LDAPModW **attrs, LDAPCo
  *
  * See ldap_add_ext_sW.
  */
-ULONG CDECL ldap_add_ext_sA( WLDAP32_LDAP *ld, char *dn, LDAPModA **attrs, LDAPControlA **serverctrls,
+ULONG CDECL ldap_add_ext_sA( LDAP *ld, char *dn, LDAPModA **attrs, LDAPControlA **serverctrls,
                              LDAPControlA **clientctrls )
 {
-    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
+    ULONG ret = LDAP_NO_MEMORY;
     WCHAR *dnW = NULL;
     LDAPModW **attrsW = NULL;
     LDAPControlW **serverctrlsW = NULL, **clientctrlsW = NULL;
 
     TRACE( "(%p, %s, %p, %p, %p)\n", ld, debugstr_a(dn), attrs, serverctrls, clientctrls );
 
-    if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
+    if (!ld) return LDAP_PARAM_ERROR;
 
     if (dn && !(dnW = strAtoW( dn ))) goto exit;
     if (attrs && !(attrsW = modarrayAtoW( attrs ))) goto exit;
@@ -220,24 +221,24 @@ ULONG CDECL ldap_add_ext_sA( WLDAP32_LDAP *ld, char *dn, LDAPModA **attrs, LDAPC
  *  The serverctrls and clientctrls parameters are optional and
  *  should be set to NULL if not used.
  */
-ULONG CDECL ldap_add_ext_sW( WLDAP32_LDAP *ld, WCHAR *dn, LDAPModW **attrs, LDAPControlW **serverctrls,
+ULONG CDECL ldap_add_ext_sW( LDAP *ld, WCHAR *dn, LDAPModW **attrs, LDAPControlW **serverctrls,
                              LDAPControlW **clientctrls )
 {
-    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
+    ULONG ret = LDAP_NO_MEMORY;
     char *dnU = NULL;
     LDAPModU **attrsU = NULL;
     LDAPControlU **serverctrlsU = NULL, **clientctrlsU = NULL;
 
     TRACE( "(%p, %s, %p, %p, %p)\n", ld, debugstr_w(dn), attrs, serverctrls, clientctrls );
 
-    if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
+    if (!ld) return LDAP_PARAM_ERROR;
 
     if (dn && !(dnU = strWtoU( dn ))) goto exit;
     if (attrs && !(attrsU = modarrayWtoU( attrs ))) goto exit;
     if (serverctrls && !(serverctrlsU = controlarrayWtoU( serverctrls ))) goto exit;
     if (clientctrls && !(clientctrlsU = controlarrayWtoU( clientctrls ))) goto exit;
 
-    ret = map_error( ldap_funcs->ldap_add_ext_s( ld->ld, dnU, attrsU, serverctrlsU, clientctrlsU ) );
+    ret = map_error( ldap_funcs->fn_ldap_add_ext_s( CTX(ld), dnU, attrsU, serverctrlsU, clientctrlsU ) );
 
 exit:
     free( dnU );
@@ -252,15 +253,15 @@ ULONG CDECL ldap_add_ext_sW( WLDAP32_LDAP *ld, WCHAR *dn, LDAPModW **attrs, LDAP
  *
  * See ldap_add_sW.
  */
-ULONG CDECL ldap_add_sA( WLDAP32_LDAP *ld, char *dn, LDAPModA **attrs )
+ULONG CDECL ldap_add_sA( LDAP *ld, char *dn, LDAPModA **attrs )
 {
-    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
+    ULONG ret = LDAP_NO_MEMORY;
     WCHAR *dnW = NULL;
     LDAPModW **attrsW = NULL;
 
     TRACE( "(%p, %s, %p)\n", ld, debugstr_a(dn), attrs );
 
-    if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
+    if (!ld) return LDAP_PARAM_ERROR;
 
     if (dn && !(dnW = strAtoW( dn ))) goto exit;
     if (attrs && !(attrsW = modarrayAtoW( attrs ))) goto exit;
@@ -288,7 +289,7 @@ ULONG CDECL ldap_add_sA( WLDAP32_LDAP *ld, char *dn, LDAPModA **attrs )
  *  Success: LDAP_SUCCESS
  *  Failure: An LDAP error code.
  */
-ULONG CDECL ldap_add_sW( WLDAP32_LDAP *ld, WCHAR *dn, LDAPModW **attrs )
+ULONG CDECL ldap_add_sW( LDAP *ld, WCHAR *dn, LDAPModW **attrs )
 {
     TRACE( "(%p, %s, %p)\n", ld, debugstr_w(dn), attrs );
     return ldap_add_ext_sW( ld, dn, attrs, NULL, NULL );
diff --git a/dlls/wldap32/ber.c b/dlls/wldap32/ber.c
index ffb8e862d0e9..ca5bbc305c50 100644
--- a/dlls/wldap32/ber.c
+++ b/dlls/wldap32/ber.c
@@ -23,6 +23,8 @@
 #include "windef.h"
 #include "winbase.h"
 #include "winnls.h"
+#include "winldap.h"
+#include "winber.h"
 
 #include "wine/debug.h"
 #include "winldap_private.h"
@@ -44,12 +46,12 @@ WINE_DEFAULT_DEBUG_CHANNEL(wldap32);
  * NOTES
  *  Free the berelement structure with ber_free.
  */
-WLDAP32_BerElement * CDECL WLDAP32_ber_alloc_t( int options )
+BerElement * CDECL ber_alloc_t( int options )
 {
-    WLDAP32_BerElement *ret;
+    BerElement *ret;
 
     if (!(ret = malloc( sizeof(*ret) ))) return NULL;
-    if (!(ret->opaque = ldap_funcs->ber_alloc_t( options )))
+    if (!(BER(ret) = ldap_funcs->fn_ber_alloc_t( options )))
     {
         free( ret );
         return NULL;
@@ -73,7 +75,7 @@ WLDAP32_BerElement * CDECL WLDAP32_ber_alloc_t( int options )
  * NOTES
  *  Free the copy with ber_bvfree.
  */
-BERVAL * CDECL WLDAP32_ber_bvdup( BERVAL *berval )
+BERVAL * CDECL ber_bvdup( BERVAL *berval )
 {
     return bervalWtoW( berval );
 }
@@ -94,7 +96,7 @@ BERVAL * CDECL WLDAP32_ber_bvdup( BERVAL *berval )
  *  Use this function only to free an array of berval structures
  *  returned by a call to ber_scanf with a 'V' in the format string.
  */
-void CDECL WLDAP32_ber_bvecfree( BERVAL **berval )
+void CDECL ber_bvecfree( BERVAL **berval )
 {
     bvarrayfreeW( berval );
 }
@@ -115,7 +117,7 @@ void CDECL WLDAP32_ber_bvecfree( BERVAL **berval )
  *  Use this function only to free berval structures allocated by
  *  an LDAP API.
  */
-void CDECL WLDAP32_ber_bvfree( BERVAL *berval )
+void CDECL ber_bvfree( BERVAL *berval )
 {
     free( berval );
 }
@@ -138,9 +140,9 @@ void CDECL WLDAP32_ber_bvfree( BERVAL *berval )
  * NOTES
  *  len and cookie should be passed to ber_next_element.
  */
-ULONG CDECL WLDAP32_ber_first_element( WLDAP32_BerElement *ber, ULONG *len, char **opaque )
+ULONG CDECL ber_first_element( BerElement *ber, ULONG *len, char **opaque )
 {
-    return ldap_funcs->ber_first_element( ber->opaque, len, opaque );
+    return ldap_funcs->fn_ber_first_element( BER(ber), len, opaque );
 }
 
 
@@ -160,16 +162,16 @@ ULONG CDECL WLDAP32_ber_first_element( WLDAP32_BerElement *ber, ULONG *len, char
  * NOTES
  *  Free the berval structure with ber_bvfree.
  */
-int CDECL WLDAP32_ber_flatten( WLDAP32_BerElement *ber, BERVAL **berval )
+int CDECL ber_flatten( BerElement *ber, BERVAL **berval )
 {
     struct bervalU *bervalU;
-    struct WLDAP32_berval *bervalW;
+    struct berval *bervalW;
 
-    if (ldap_funcs->ber_flatten( ber->opaque, &bervalU )) return WLDAP32_LBER_ERROR;
+    if (ldap_funcs->fn_ber_flatten( BER(ber), &bervalU )) return LBER_ERROR;
 
-    if (!(bervalW = bervalUtoW( bervalU ))) return WLDAP32_LBER_ERROR;
-    ldap_funcs->ber_bvfree( bervalU );
-    if (!bervalW) return WLDAP32_LBER_ERROR;
+    if (!(bervalW = bervalUtoW( bervalU ))) return LBER_ERROR;
+    ldap_funcs->fn_ber_bvfree( bervalU );
+    if (!bervalW) return LBER_ERROR;
     *berval = bervalW;
     return 0;
 }
@@ -191,9 +193,9 @@ int CDECL WLDAP32_ber_flatten( WLDAP32_BerElement *ber, BERVAL **berval )
  *  Set buf to 0 if the berelement was allocated with ldap_first_attribute
  *  or ldap_next_attribute, otherwise set it to 1.
  */
-void CDECL WLDAP32_ber_free( WLDAP32_BerElement *ber, int freebuf )
+void CDECL ber_free( BerElement *ber, int freebuf )
 {
-    ldap_funcs->ber_free( ber->opaque, freebuf );
+    ldap_funcs->fn_ber_free( BER(ber), freebuf );
     free( ber );
 }
 
@@ -213,10 +215,10 @@ void CDECL WLDAP32_ber_free( WLDAP32_BerElement *ber, int freebuf )
  * NOTES
  *  Call ber_free to free the returned berelement structure.
  */
-WLDAP32_BerElement * CDECL WLDAP32_ber_init( BERVAL *berval )
+BerElement * CDECL ber_init( BERVAL *berval )
 {
     struct bervalU *bervalU;
-    WLDAP32_BerElement *ret;
+    BerElement *ret;
 
     if (!(ret = malloc( sizeof(*ret) ))) return NULL;
     if (!(bervalU = bervalWtoU( berval )))
@@ -224,7 +226,7 @@ WLDAP32_BerElement * CDECL WLDAP32_ber_init( BERVAL *berval )
         free( ret );
         return NULL;
     }
-    if (!(ret->opaque = ldap_funcs->ber_init( bervalU )))
+    if (!(BER(ret) = ldap_funcs->fn_ber_init( bervalU )))
     {
         free( ret );
         ret = NULL;
@@ -252,9 +254,9 @@ WLDAP32_BerElement * CDECL WLDAP32_ber_init( BERVAL *berval )
  *  len and cookie are initialized by ber_first_element and should
  *  be passed on in subsequent calls to ber_next_element.
  */
-ULONG CDECL WLDAP32_ber_next_element( WLDAP32_BerElement *ber, ULONG *len, char *opaque )
+ULONG CDECL ber_next_element( BerElement *ber, ULONG *len, char *opaque )
 {
-    return ldap_funcs->ber_next_element( ber->opaque, len, opaque );
+    return ldap_funcs->fn_ber_next_element( BER(ber), len, opaque );
 }
 
 
@@ -271,9 +273,9 @@ ULONG CDECL WLDAP32_ber_next_element( WLDAP32_BerElement *ber, ULONG *len, char
  *  Success: Tag of the next element.
  *  Failure: LBER_DEFAULT (no more data).
  */
-ULONG CDECL WLDAP32_ber_peek_tag( WLDAP32_BerElement *ber, ULONG *len )
+ULONG CDECL ber_peek_tag( BerElement *ber, ULONG *len )
 {
-    return ldap_funcs->ber_peek_tag( ber->opaque, len );
+    return ldap_funcs->fn_ber_peek_tag( BER(ber), len );
 }
 
 
@@ -290,9 +292,9 @@ ULONG CDECL WLDAP32_ber_peek_tag( WLDAP32_BerElement *ber, ULONG *len )
  *  Success: Tag of the next element.
  *  Failure: LBER_DEFAULT (no more data).
  */
-ULONG CDECL WLDAP32_ber_skip_tag( WLDAP32_BerElement *ber, ULONG *len )
+ULONG CDECL ber_skip_tag( BerElement *ber, ULONG *len )
 {
-    return ldap_funcs->ber_skip_tag( ber->opaque, len );
+    return ldap_funcs->fn_ber_skip_tag( BER(ber), len );
 }
 
 
@@ -314,7 +316,7 @@ ULONG CDECL WLDAP32_ber_skip_tag( WLDAP32_BerElement *ber, ULONG *len )
  *  berelement must have been allocated with ber_alloc_t. This function
  *  can be called multiple times to append data.
  */
-int WINAPIV WLDAP32_ber_printf( WLDAP32_BerElement *ber, char *fmt, ... )
+int WINAPIV ber_printf( BerElement *ber, char *fmt, ... )
 {
     __ms_va_list list;
     int ret = 0;
@@ -332,38 +334,38 @@ int WINAPIV WLDAP32_ber_printf( WLDAP32_BerElement *ber, char *fmt, ... )
         case 'i':
         {
             int i = va_arg( list, int );
-            ret = ldap_funcs->ber_printf( ber->opaque, new_fmt, i );
+            ret = ldap_funcs->fn_ber_printf( BER(ber), new_fmt, i );
             break;
         }
         case 'o':
         case 's':
         {
             char *str = va_arg( list, char * );
-            ret = ldap_funcs->ber_printf( ber->opaque, new_fmt, str );
+            ret = ldap_funcs->fn_ber_printf( BER(ber), new_fmt, str );
             break;
         }
         case 't':
         {
             unsigned int tag = va_arg( list, unsigned int );
-            ret = ldap_funcs->ber_printf( ber->opaque, new_fmt, tag );
+            ret = ldap_funcs->fn_ber_printf( BER(ber), new_fmt, tag );
             break;
         }
         case 'v':
         {
             char **array = va_arg( list, char ** );
-            ret = ldap_funcs->ber_printf( ber->opaque, new_fmt, array );
+            ret = ldap_funcs->fn_ber_printf( BER(ber), new_fmt, array );
             break;
         }
         case 'V':
         {
-            struct WLDAP32_berval **array = va_arg( list, struct WLDAP32_berval ** );
+            struct berval **array = va_arg( list, struct berval ** );
             struct bervalU **arrayU;
             if (!(arrayU = bvarrayWtoU( array )))
             {
                 ret = -1;
                 break;
             }
-            ret = ldap_funcs->ber_printf( ber->opaque, new_fmt, arrayU );
+            ret = ldap_funcs->fn_ber_printf( BER(ber), new_fmt, arrayU );
             bvarrayfreeU( arrayU );
             break;
         }
@@ -372,7 +374,7 @@ int WINAPIV WLDAP32_ber_printf( WLDAP32_BerElement *ber, char *fmt, ... )
             char *str = va_arg( list, char * );
             int len = va_arg( list, int );
             new_fmt[0] = 'B';  /* 'X' is deprecated */
-            ret = ldap_funcs->ber_printf( ber->opaque, new_fmt, str, len );
+            ret = ldap_funcs->fn_ber_printf( BER(ber), new_fmt, str, len );
             break;
         }
         case 'n':
@@ -380,7 +382,7 @@ int WINAPIV WLDAP32_ber_printf( WLDAP32_BerElement *ber, char *fmt, ... )
         case '}':
         case '[':
         case ']':
-            ret = ldap_funcs->ber_printf( ber->opaque, new_fmt );
+            ret = ldap_funcs->fn_ber_printf( BER(ber), new_fmt );
             break;
 
         default:
@@ -413,7 +415,7 @@ int WINAPIV WLDAP32_ber_printf( WLDAP32_BerElement *ber, char *fmt, ... )
  *  berelement must have been allocated with ber_init. This function
  *  can be called multiple times to decode data.
  */
-ULONG WINAPIV WLDAP32_ber_scanf( WLDAP32_BerElement *ber, char *fmt, ... )
+ULONG WINAPIV ber_scanf( BerElement *ber, char *fmt, ... )
 {
     __ms_va_list list;
     int ret = 0;
@@ -429,9 +431,9 @@ ULONG WINAPIV WLDAP32_ber_scanf( WLDAP32_BerElement *ber, char *fmt, ... )
         case 'a':
         {
             char *str, **ptr = va_arg( list, char ** );
-            if ((ret = ldap_funcs->ber_scanf( ber->opaque, new_fmt, &str )) == -1) break;
+            if ((ret = ldap_funcs->fn_ber_scanf( BER(ber), new_fmt, &str )) == -1) break;
             *ptr = strdupU( str );
-            ldap_funcs->ldap_memfree( str );
+            ldap_funcs->fn_ldap_memfree( str );
             break;
         }
         case 'b':
@@ -439,55 +441,55 @@ ULONG WINAPIV WLDAP32_ber_scanf( WLDAP32_BerElement *ber, char *fmt, ... )
         case 'i':
         {
             int *i = va_arg( list, int * );
-            ret = ldap_funcs->ber_scanf( ber->opaque, new_fmt, i );
+            ret = ldap_funcs->fn_ber_scanf( BER(ber), new_fmt, i );
             break;
         }
         case 't':
         {
             unsigned int *tag = va_arg( list, unsigned int * );
-            ret = ldap_funcs->ber_scanf( ber->opaque, new_fmt, tag );
+            ret = ldap_funcs->fn_ber_scanf( BER(ber), new_fmt, tag );
             break;
         }
         case 'v':
         {
             char *str, **arrayU, **ptr, ***array = va_arg( list, char *** );
-            if ((ret = ldap_funcs->ber_scanf( ber->opaque, new_fmt, &arrayU )) == -1) break;
+            if ((ret = ldap_funcs->fn_ber_scanf( BER(ber), new_fmt, &arrayU )) == -1) break;
             *array = strarrayUtoU( arrayU );
             ptr = arrayU;
             while ((str = *ptr))
             {
-                ldap_funcs->ldap_memfree( str );
+                ldap_funcs->fn_ldap_memfree( str );
                 ptr++;
             }
-            ldap_funcs->ldap_memfree( arrayU );
+            ldap_funcs->fn_ldap_memfree( arrayU );
             break;
         }
         case 'B':
         {
             char *strU, **str = va_arg( list, char ** );
             int *len = va_arg( list, int * );
-            if ((ret = ldap_funcs->ber_scanf( ber->opaque, new_fmt, &strU, len )) == -1) break;
+            if ((ret = ldap_funcs->fn_ber_scanf( BER(ber), new_fmt, &strU, len )) == -1) break;
             *str = malloc( *len );
             memcpy( *str, strU, *len );
-            ldap_funcs->ldap_memfree( strU );
+            ldap_funcs->fn_ldap_memfree( strU );
             break;
         }
         case 'O':
         {
-            struct WLDAP32_berval **berval = va_arg( list, struct WLDAP32_berval ** );
+            struct berval **berval = va_arg( list, struct berval ** );
             struct bervalU *bervalU;
-            if ((ret = ldap_funcs->ber_scanf( ber->opaque, new_fmt, &bervalU )) == -1) break;
+            if ((ret = ldap_funcs->fn_ber_scanf( BER(ber), new_fmt, &bervalU )) == -1) break;
             *berval = bervalUtoW( bervalU );
-            ldap_funcs->ber_bvfree( bervalU );
+            ldap_funcs->fn_ber_bvfree( bervalU );
             break;
         }
         case 'V':
         {
-            struct WLDAP32_berval ***array = va_arg( list, struct WLDAP32_berval *** );
+            struct berval ***array = va_arg( list, struct berval *** );
             struct bervalU **arrayU;
-            if ((ret = ldap_funcs->ber_scanf( ber->opaque, new_fmt, &arrayU )) == -1) break;
+            if ((ret = ldap_funcs->fn_ber_scanf( BER(ber), new_fmt, &arrayU )) == -1) break;
             *array = bvarrayUtoW( arrayU );
-            ldap_funcs->ber_bvecfree( arrayU );
+            ldap_funcs->fn_ber_bvecfree( arrayU );
             break;
         }
         case 'n':
@@ -496,7 +498,7 @@ ULONG WINAPIV WLDAP32_ber_scanf( WLDAP32_BerElement *ber, char *fmt, ... )
         case '}':
         case '[':
         case ']':
-            ret = ldap_funcs->ber_scanf( ber->opaque, new_fmt );
+            ret = ldap_funcs->fn_ber_scanf( BER(ber), new_fmt );
             break;
 
         default:
diff --git a/dlls/wldap32/bind.c b/dlls/wldap32/bind.c
index c9a597e88689..d45ed5d60e04 100644
--- a/dlls/wldap32/bind.c
+++ b/dlls/wldap32/bind.c
@@ -24,6 +24,7 @@
 #include "winbase.h"
 #include "winnls.h"
 #include "rpc.h"
+#include "winldap.h"
 
 #include "wine/debug.h"
 #include "winldap_private.h"
@@ -35,9 +36,9 @@ WINE_DEFAULT_DEBUG_CHANNEL(wldap32);
  *
  * See ldap_bindW.
  */
-ULONG CDECL ldap_bindA( WLDAP32_LDAP *ld, char *dn, char *cred, ULONG method )
+ULONG CDECL ldap_bindA( LDAP *ld, char *dn, char *cred, ULONG method )
 {
-    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
+    ULONG ret = LDAP_NO_MEMORY;
     WCHAR *dnW = NULL, *credW = NULL;
 
     TRACE( "(%p, %s, %p, 0x%08x)\n", ld, debugstr_a(dn), cred, method );
@@ -73,9 +74,9 @@ ULONG CDECL ldap_bindA( WLDAP32_LDAP *ld, char *dn, char *cred, ULONG method )
  * NOTES
  *  Only LDAP_AUTH_SIMPLE is supported (just like native).
  */
-ULONG CDECL ldap_bindW( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *cred, ULONG method )
+ULONG CDECL ldap_bindW( LDAP *ld, WCHAR *dn, WCHAR *cred, ULONG method )
 {
-    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
+    ULONG ret = LDAP_NO_MEMORY;
     char *dnU = NULL, *credU = NULL;
     struct bervalU pwd = { 0, NULL };
     int msg;
@@ -83,7 +84,7 @@ ULONG CDECL ldap_bindW( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *cred, ULONG method )
     TRACE( "(%p, %s, %p, 0x%08x)\n", ld, debugstr_w(dn), cred, method );
 
     if (!ld) return ~0u;
-    if (method != WLDAP32_LDAP_AUTH_SIMPLE) return WLDAP32_LDAP_PARAM_ERROR;
+    if (method != LDAP_AUTH_SIMPLE) return LDAP_PARAM_ERROR;
 
     if (dn && !(dnU = strWtoU( dn ))) goto exit;
     if (cred)
@@ -93,8 +94,8 @@ ULONG CDECL ldap_bindW( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *cred, ULONG method )
         pwd.bv_val = credU;
     }
 
-    ret = map_error( ldap_funcs->ldap_sasl_bind( ld->ld, dnU, 0, &pwd, NULL, NULL, &msg ) );
-    if (ret == WLDAP32_LDAP_SUCCESS)
+    ret = map_error( ldap_funcs->fn_ldap_sasl_bind( CTX(ld), dnU, 0, &pwd, NULL, NULL, &msg ) );
+    if (ret == LDAP_SUCCESS)
         ret = msg;
     else
         ret = ~0u;
@@ -110,19 +111,19 @@ ULONG CDECL ldap_bindW( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *cred, ULONG method )
  *
  * See ldap_bind_sW.
  */
-ULONG CDECL ldap_bind_sA( WLDAP32_LDAP *ld, char *dn, char *cred, ULONG method )
+ULONG CDECL ldap_bind_sA( LDAP *ld, char *dn, char *cred, ULONG method )
 {
-    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
+    ULONG ret = LDAP_NO_MEMORY;
     WCHAR *dnW = NULL, *credW = NULL;
 
     TRACE( "(%p, %s, %p, 0x%08x)\n", ld, debugstr_a(dn), cred, method );
 
-    if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
+    if (!ld) return LDAP_PARAM_ERROR;
 
     if (dn && !(dnW = strAtoW( dn ))) goto exit;
     if (cred)
     {
-        if (method == WLDAP32_LDAP_AUTH_SIMPLE)
+        if (method == LDAP_AUTH_SIMPLE)
         {
             if (!(credW = strAtoW( cred ))) goto exit;
         }
@@ -166,7 +167,7 @@ int CDECL sasl_interact_cb( void *ld, unsigned flags, void *defaults, void *inte
         sasl++;
     }
 
-    return WLDAP32_LDAP_SUCCESS;
+    return LDAP_SUCCESS;
 }
 
 /***********************************************************************
@@ -184,17 +185,17 @@ int CDECL sasl_interact_cb( void *ld, unsigned flags, void *defaults, void *inte
  *  Success: LDAP_SUCCESS
  *  Failure: An LDAP error code.
  */
-ULONG CDECL ldap_bind_sW( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *cred, ULONG method )
+ULONG CDECL ldap_bind_sW( LDAP *ld, WCHAR *dn, WCHAR *cred, ULONG method )
 {
-    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
+    ULONG ret = LDAP_NO_MEMORY;
     char *dnU = NULL, *credU = NULL;
     struct bervalU pwd = { 0, NULL };
 
     TRACE( "(%p, %s, %p, 0x%08x)\n", ld, debugstr_w(dn), cred, method );
 
-    if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
+    if (!ld) return LDAP_PARAM_ERROR;
 
-    if (method == WLDAP32_LDAP_AUTH_SIMPLE)
+    if (method == LDAP_AUTH_SIMPLE)
     {
         if (dn && !(dnU = strWtoU( dn ))) goto exit;
         if (cred)
@@ -204,9 +205,9 @@ ULONG CDECL ldap_bind_sW( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *cred, ULONG method
             pwd.bv_val = credU;
         }
 
-        ret = map_error( ldap_funcs->ldap_sasl_bind_s( ld->ld, dnU, 0, &pwd, NULL, NULL, NULL ) );
+        ret = map_error( ldap_funcs->fn_ldap_sasl_bind_s( CTX(ld), dnU, 0, &pwd, NULL, NULL, NULL ) );
     }
-    else if (method == WLDAP32_LDAP_AUTH_NEGOTIATE)
+    else if (method == LDAP_AUTH_NEGOTIATE)
     {
         SEC_WINNT_AUTH_IDENTITY_A idU;
         SEC_WINNT_AUTH_IDENTITY_W idW;
@@ -228,10 +229,10 @@ ULONG CDECL ldap_bind_sW( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *cred, ULONG method
             idU.Password = (unsigned char *)strnWtoU( id->Password, id->PasswordLength, &idU.PasswordLength );
         }
 
-        ret = map_error( ldap_funcs->ldap_sasl_interactive_bind_s( ld->ld,
-                                                                   NULL /* server will ignore DN anyway */,
-                                                                   NULL /* query supportedSASLMechanisms */,
-                                                                   NULL, NULL, 2 /* LDAP_SASL_QUIET */, &idU ) );
+        ret = map_error( ldap_funcs->fn_ldap_sasl_interactive_bind_s( CTX(ld),
+                                                                      NULL /* server will ignore DN anyway */,
+                                                                      NULL /* query supportedSASLMechanisms */,
+                                                                      NULL, NULL, 2 /* LDAP_SASL_QUIET */, &idU ) );
 
         if (id && (id->Flags & SEC_WINNT_AUTH_IDENTITY_ANSI))
         {
@@ -247,7 +248,7 @@ ULONG CDECL ldap_bind_sW( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *cred, ULONG method
     else
     {
         FIXME( "method %#x not supported\n", method );
-        return WLDAP32_LDAP_PARAM_ERROR;
+        return LDAP_PARAM_ERROR;
     }
 
 exit:
@@ -261,18 +262,17 @@ ULONG CDECL ldap_bind_sW( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *cred, ULONG method
  *
  * See ldap_sasl_bindW.
  */
-ULONG CDECL ldap_sasl_bindA( WLDAP32_LDAP *ld, const PCHAR dn, const PCHAR mechanism, const BERVAL *cred,
+ULONG CDECL ldap_sasl_bindA( LDAP *ld, const PCHAR dn, const PCHAR mechanism, const BERVAL *cred,
     LDAPControlA **serverctrls, LDAPControlA **clientctrls, int *message )
 {
-    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
+    ULONG ret = LDAP_NO_MEMORY;
     WCHAR *dnW, *mechanismW = NULL;
     LDAPControlW **serverctrlsW = NULL, **clientctrlsW = NULL;
 
     TRACE( "(%p, %s, %s, %p, %p, %p, %p)\n", ld, debugstr_a(dn),
            debugstr_a(mechanism), cred, serverctrls, clientctrls, message );
 
-    if (!ld || !dn || !mechanism || !cred || !message)
-        return WLDAP32_LDAP_PARAM_ERROR;
+    if (!ld || !dn || !mechanism || !cred || !message) return LDAP_PARAM_ERROR;
 
     if (!(dnW = strAtoW( dn ))) goto exit;
     if (!(mechanismW = strAtoW( mechanism ))) goto exit;
@@ -311,10 +311,10 @@ ULONG CDECL ldap_sasl_bindA( WLDAP32_LDAP *ld, const PCHAR dn, const PCHAR mecha
  *  The serverctrls and clientctrls parameters are optional and should
  *  be set to NULL if not used.
  */
-ULONG CDECL ldap_sasl_bindW( WLDAP32_LDAP *ld, const PWCHAR dn, const PWCHAR mechanism, const BERVAL *cred,
+ULONG CDECL ldap_sasl_bindW( LDAP *ld, const PWCHAR dn, const PWCHAR mechanism, const BERVAL *cred,
     LDAPControlW **serverctrls, LDAPControlW **clientctrls, int *message )
 {
-    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
+    ULONG ret = LDAP_NO_MEMORY;
     char *dnU, *mechanismU = NULL;
     LDAPControlU **serverctrlsU = NULL, **clientctrlsU = NULL;
     struct bervalU credU;
@@ -322,8 +322,7 @@ ULONG CDECL ldap_sasl_bindW( WLDAP32_LDAP *ld, const PWCHAR dn, const PWCHAR mec
     TRACE( "(%p, %s, %s, %p, %p, %p, %p)\n", ld, debugstr_w(dn),
            debugstr_w(mechanism), cred, serverctrls, clientctrls, message );
 
-    if (!ld || !dn || !mechanism || !cred || !message)
-        return WLDAP32_LDAP_PARAM_ERROR;
+    if (!ld || !dn || !mechanism || !cred || !message) return LDAP_PARAM_ERROR;
 
     if (!(dnU = strWtoU( dn ))) goto exit;
     if (!(mechanismU = strWtoU( mechanism ))) goto exit;
@@ -333,7 +332,8 @@ ULONG CDECL ldap_sasl_bindW( WLDAP32_LDAP *ld, const PWCHAR dn, const PWCHAR mec
     credU.bv_len = cred->bv_len;
     credU.bv_val = cred->bv_val;
 
-    ret = map_error( ldap_funcs->ldap_sasl_bind( ld->ld, dnU, mechanismU, &credU, serverctrlsU, clientctrlsU, message ) );
+    ret = map_error( ldap_funcs->fn_ldap_sasl_bind( CTX(ld), dnU, mechanismU, &credU, serverctrlsU, clientctrlsU,
+                                                    message ) );
 
 exit:
     free( dnU );
@@ -348,18 +348,17 @@ ULONG CDECL ldap_sasl_bindW( WLDAP32_LDAP *ld, const PWCHAR dn, const PWCHAR mec
  *
  * See ldap_sasl_bind_sW.
  */
-ULONG CDECL ldap_sasl_bind_sA( WLDAP32_LDAP *ld, const PCHAR dn, const PCHAR mechanism, const BERVAL *cred,
+ULONG CDECL ldap_sasl_bind_sA( LDAP *ld, const PCHAR dn, const PCHAR mechanism, const BERVAL *cred,
     LDAPControlA **serverctrls, LDAPControlA **clientctrls, BERVAL **serverdata )
 {
-    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
+    ULONG ret = LDAP_NO_MEMORY;
     WCHAR *dnW, *mechanismW = NULL;
     LDAPControlW **serverctrlsW = NULL, **clientctrlsW = NULL;
 
     TRACE( "(%p, %s, %s, %p, %p, %p, %p)\n", ld, debugstr_a(dn),
            debugstr_a(mechanism), cred, serverctrls, clientctrls, serverdata );
 
-    if (!ld || !dn || !mechanism || !cred || !serverdata)
-        return WLDAP32_LDAP_PARAM_ERROR;
+    if (!ld || !dn || !mechanism || !cred || !serverdata) return LDAP_PARAM_ERROR;
 
     if (!(dnW = strAtoW( dn ))) goto exit;
     if (!(mechanismW = strAtoW( mechanism ))) goto exit;
@@ -398,11 +397,10 @@ ULONG CDECL ldap_sasl_bind_sA( WLDAP32_LDAP *ld, const PCHAR dn, const PCHAR mec
  *  The serverctrls and clientctrls parameters are optional and should
  *  be set to NULL if not used.
  */
-ULONG CDECL ldap_sasl_bind_sW( WLDAP32_LDAP *ld, const PWCHAR dn,
-    const PWCHAR mechanism, const BERVAL *cred, LDAPControlW **serverctrls,
-    LDAPControlW **clientctrls, BERVAL **serverdata )
+ULONG CDECL ldap_sasl_bind_sW( LDAP *ld, const PWCHAR dn, const PWCHAR mechanism, const BERVAL *cred,
+    LDAPControlW **serverctrls, LDAPControlW **clientctrls, BERVAL **serverdata )
 {
-    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
+    ULONG ret = LDAP_NO_MEMORY;
     char *dnU, *mechanismU = NULL;
     LDAPControlU **serverctrlsU = NULL, **clientctrlsU = NULL;
     struct bervalU *dataU, credU;
@@ -410,8 +408,7 @@ ULONG CDECL ldap_sasl_bind_sW( WLDAP32_LDAP *ld, const PWCHAR dn,
     TRACE( "(%p, %s, %s, %p, %p, %p, %p)\n", ld, debugstr_w(dn),
            debugstr_w(mechanism), cred, serverctrls, clientctrls, serverdata );
 
-    if (!ld || !dn || !mechanism || !cred || !serverdata)
-        return WLDAP32_LDAP_PARAM_ERROR;
+    if (!ld || !dn || !mechanism || !cred || !serverdata) return LDAP_PARAM_ERROR;
 
     if (!(dnU = strWtoU( dn ))) goto exit;
     if (!(mechanismU = strWtoU( mechanism ))) goto exit;
@@ -421,13 +418,14 @@ ULONG CDECL ldap_sasl_bind_sW( WLDAP32_LDAP *ld, const PWCHAR dn,
     credU.bv_len = cred->bv_len;
     credU.bv_val = cred->bv_val;
 
-    ret = map_error( ldap_funcs->ldap_sasl_bind_s( ld->ld, dnU, mechanismU, &credU, serverctrlsU, clientctrlsU, &dataU ) );
-    if (ret == WLDAP32_LDAP_SUCCESS)
+    ret = map_error( ldap_funcs->fn_ldap_sasl_bind_s( CTX(ld), dnU, mechanismU, &credU, serverctrlsU, clientctrlsU,
+                                                      &dataU ) );
+    if (ret == LDAP_SUCCESS)
     {
         BERVAL *ptr;
-        if (!(ptr = bervalUtoW( dataU ))) ret = WLDAP32_LDAP_NO_MEMORY;
+        if (!(ptr = bervalUtoW( dataU ))) ret = LDAP_NO_MEMORY;
         else *serverdata = ptr;
-        ldap_funcs->ber_bvfree( dataU );
+        ldap_funcs->fn_ber_bvfree( dataU );
     }
 
 exit:
@@ -443,9 +441,9 @@ ULONG CDECL ldap_sasl_bind_sW( WLDAP32_LDAP *ld, const PWCHAR dn,
  *
  * See ldap_simple_bindW.
  */
-ULONG CDECL ldap_simple_bindA( WLDAP32_LDAP *ld, char *dn, char *passwd )
+ULONG CDECL ldap_simple_bindA( LDAP *ld, char *dn, char *passwd )
 {
-    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
+    ULONG ret = LDAP_NO_MEMORY;
     WCHAR *dnW = NULL, *passwdW = NULL;
 
     TRACE( "(%p, %s, %p)\n", ld, debugstr_a(dn), passwd );
@@ -480,9 +478,9 @@ ULONG CDECL ldap_simple_bindA( WLDAP32_LDAP *ld, char *dn, char *passwd )
  * NOTES
  *  Set dn and passwd to NULL to bind as an anonymous user.
  */
-ULONG CDECL ldap_simple_bindW( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *passwd )
+ULONG CDECL ldap_simple_bindW( LDAP *ld, WCHAR *dn, WCHAR *passwd )
 {
-    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
+    ULONG ret = LDAP_NO_MEMORY;
     char *dnU = NULL, *passwdU = NULL;
     struct bervalU pwd = { 0, NULL };
     int msg;
@@ -499,8 +497,8 @@ ULONG CDECL ldap_simple_bindW( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *passwd )
         pwd.bv_val = passwdU;
     }
 
-    ret = map_error( ldap_funcs->ldap_sasl_bind( ld->ld, dnU, 0, &pwd, NULL, NULL, &msg ) );
-    if (ret == WLDAP32_LDAP_SUCCESS)
+    ret = map_error( ldap_funcs->fn_ldap_sasl_bind( CTX(ld), dnU, 0, &pwd, NULL, NULL, &msg ) );
+    if (ret == LDAP_SUCCESS)
         ret = msg;
     else
         ret = ~0u;
@@ -516,14 +514,14 @@ ULONG CDECL ldap_simple_bindW( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *passwd )
  *
  * See ldap_simple_bind_sW.
  */
-ULONG CDECL ldap_simple_bind_sA( WLDAP32_LDAP *ld, char *dn, char *passwd )
+ULONG CDECL ldap_simple_bind_sA( LDAP *ld, char *dn, char *passwd )
 {
-    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
+    ULONG ret = LDAP_NO_MEMORY;
     WCHAR *dnW = NULL, *passwdW = NULL;
 
     TRACE( "(%p, %s, %p)\n", ld, debugstr_a(dn), passwd );
 
-    if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
+    if (!ld) return LDAP_PARAM_ERROR;
 
     if (dn && !(dnW = strAtoW( dn ))) goto exit;
     if (passwd && !(passwdW = strAtoW( passwd ))) goto exit;
@@ -553,15 +551,15 @@ ULONG CDECL ldap_simple_bind_sA( WLDAP32_LDAP *ld, char *dn, char *passwd )
  * NOTES
  *  Set dn and passwd to NULL to bind as an anonymous user.
  */
-ULONG CDECL ldap_simple_bind_sW( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *passwd )
+ULONG CDECL ldap_simple_bind_sW( LDAP *ld, WCHAR *dn, WCHAR *passwd )
 {
-    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
+    ULONG ret = LDAP_NO_MEMORY;
     char *dnU = NULL, *passwdU = NULL;
     struct bervalU pwd = { 0, NULL };
 
     TRACE( "(%p, %s, %p)\n", ld, debugstr_w(dn), passwd );
 
-    if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
+    if (!ld) return LDAP_PARAM_ERROR;
 
     if (dn && !(dnU = strWtoU( dn ))) goto exit;
     if (passwd)
@@ -571,7 +569,7 @@ ULONG CDECL ldap_simple_bind_sW( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *passwd )
         pwd.bv_val = passwdU;
     }
 
-    ret = map_error( ldap_funcs->ldap_sasl_bind_s( ld->ld, dnU, 0, &pwd, NULL, NULL, NULL ) );
+    ret = map_error( ldap_funcs->fn_ldap_sasl_bind_s( CTX(ld), dnU, 0, &pwd, NULL, NULL, NULL ) );
 
 exit:
     free( dnU );
@@ -591,16 +589,16 @@ ULONG CDECL ldap_simple_bind_sW( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *passwd )
  *  Success: LDAP_SUCCESS
  *  Failure: An LDAP error code.
  */
-ULONG CDECL WLDAP32_ldap_unbind( WLDAP32_LDAP *ld )
+ULONG CDECL ldap_unbind( LDAP *ld )
 {
     ULONG ret;
 
     TRACE( "(%p)\n", ld );
 
-    if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
+    if (!ld) return LDAP_PARAM_ERROR;
 
-    ret = map_error( ldap_funcs->ldap_unbind_ext( ld->ld, NULL, NULL ));
-    if (ld->ld_server_ctrls) ldap_funcs->ldap_value_free_len( ld->ld_server_ctrls );
+    ret = map_error( ldap_funcs->fn_ldap_unbind_ext( CTX(ld), NULL, NULL ));
+    if (SERVER_CTRLS(ld)) ldap_funcs->fn_ldap_value_free_len( SERVER_CTRLS(ld) );
 
     free( ld );
     return ret;
@@ -618,16 +616,16 @@ ULONG CDECL WLDAP32_ldap_unbind( WLDAP32_LDAP *ld )
  *  Success: LDAP_SUCCESS
  *  Failure: An LDAP error code.
  */
-ULONG CDECL WLDAP32_ldap_unbind_s( WLDAP32_LDAP *ld )
+ULONG CDECL ldap_unbind_s( LDAP *ld )
 {
     ULONG ret;
 
     TRACE( "(%p)\n", ld );
 
-    if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
+    if (!ld) return LDAP_PARAM_ERROR;
 
-    ret = map_error( ldap_funcs->ldap_unbind_ext_s( ld->ld, NULL, NULL ) );
-    if (ld->ld_server_ctrls) ldap_funcs->ldap_value_free_len( ld->ld_server_ctrls );
+    ret = map_error( ldap_funcs->fn_ldap_unbind_ext_s( CTX(ld), NULL, NULL ) );
+    if (SERVER_CTRLS(ld)) ldap_funcs->fn_ldap_value_free_len( SERVER_CTRLS(ld) );
 
     free( ld );
     return ret;
diff --git a/dlls/wldap32/compare.c b/dlls/wldap32/compare.c
index 63b56ef9f4c9..3d68da0a7928 100644
--- a/dlls/wldap32/compare.c
+++ b/dlls/wldap32/compare.c
@@ -22,6 +22,7 @@
 #include "windef.h"
 #include "winbase.h"
 #include "winnls.h"
+#include "winldap.h"
 
 #include "wine/debug.h"
 #include "winldap_private.h"
@@ -33,7 +34,7 @@ WINE_DEFAULT_DEBUG_CHANNEL(wldap32);
  *
  * See ldap_compareW.
  */
-ULONG CDECL ldap_compareA( WLDAP32_LDAP *ld, char *dn, char *attr, char *value )
+ULONG CDECL ldap_compareA( LDAP *ld, char *dn, char *attr, char *value )
 {
     ULONG ret = ~0u;
     WCHAR *dnW = NULL, *attrW = NULL, *valueW = NULL;
@@ -70,14 +71,14 @@ ULONG CDECL ldap_compareA( WLDAP32_LDAP *ld, char *dn, char *attr, char *value )
  *  Success: Message ID of the compare operation.
  *  Failure: An LDAP error code.
  */
-ULONG CDECL ldap_compareW( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *attr, WCHAR *value )
+ULONG CDECL ldap_compareW( LDAP *ld, WCHAR *dn, WCHAR *attr, WCHAR *value )
 {
     ULONG msg, ret;
 
     TRACE( "(%p, %s, %s, %s)\n", ld, debugstr_w(dn), debugstr_w(attr), debugstr_w(value) );
 
     ret = ldap_compare_extW( ld, dn, attr, value, NULL, NULL, NULL, &msg );
-    if (ret == WLDAP32_LDAP_SUCCESS) return msg;
+    if (ret == LDAP_SUCCESS) return msg;
     return ~0u;
 }
 
@@ -86,18 +87,18 @@ ULONG CDECL ldap_compareW( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *attr, WCHAR *valu
  *
  * See ldap_compare_extW.
  */
-ULONG CDECL ldap_compare_extA( WLDAP32_LDAP *ld, char *dn, char *attr, char *value,
-    struct WLDAP32_berval *data, LDAPControlA **serverctrls, LDAPControlA **clientctrls,
+ULONG CDECL ldap_compare_extA( LDAP *ld, char *dn, char *attr, char *value,
+    struct berval *data, LDAPControlA **serverctrls, LDAPControlA **clientctrls,
     ULONG *message )
 {
-    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
+    ULONG ret = LDAP_NO_MEMORY;
     WCHAR *dnW = NULL, *attrW = NULL, *valueW = NULL;
     LDAPControlW **serverctrlsW = NULL, **clientctrlsW = NULL;
 
     TRACE( "(%p, %s, %s, %s, %p, %p, %p, %p)\n", ld, debugstr_a(dn), debugstr_a(attr), debugstr_a(value),
            data, serverctrls, clientctrls, message );
 
-    if (!ld || !message) return WLDAP32_LDAP_PARAM_ERROR;
+    if (!ld || !message) return LDAP_PARAM_ERROR;
 
     if (dn && !(dnW = strAtoW( dn ))) goto exit;
     if (attr && !(attrW = strAtoW( attr ))) goto exit;
@@ -140,10 +141,10 @@ ULONG CDECL ldap_compare_extA( WLDAP32_LDAP *ld, char *dn, char *attr, char *val
  *  both are non-NULL, data will be used. The serverctrls and clientctrls
  *  parameters are optional and should be set to NULL if not used.
  */
-ULONG CDECL ldap_compare_extW( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *attr, WCHAR *value,
-    struct WLDAP32_berval *data, LDAPControlW **serverctrls, LDAPControlW **clientctrls, ULONG *message )
+ULONG CDECL ldap_compare_extW( LDAP *ld, WCHAR *dn, WCHAR *attr, WCHAR *value, struct berval *data,
+    LDAPControlW **serverctrls, LDAPControlW **clientctrls, ULONG *message )
 {
-    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
+    ULONG ret = LDAP_NO_MEMORY;
     char *dnU = NULL, *attrU = NULL, *valueU = NULL;
     LDAPControlU **serverctrlsU = NULL, **clientctrlsU = NULL;
     struct bervalU *dataU = NULL, val = { 0, NULL };
@@ -151,8 +152,8 @@ ULONG CDECL ldap_compare_extW( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *attr, WCHAR *
     TRACE( "(%p, %s, %s, %s, %p, %p, %p, %p)\n", ld, debugstr_w(dn), debugstr_w(attr), debugstr_w(value),
            data, serverctrls, clientctrls, message );
 
-    if (!ld || !message) return WLDAP32_LDAP_PARAM_ERROR;
-    if (!attr) return WLDAP32_LDAP_NO_MEMORY;
+    if (!ld || !message) return LDAP_PARAM_ERROR;
+    if (!attr) return LDAP_NO_MEMORY;
 
     if (dn && !(dnU = strWtoU( dn ))) goto exit;
     if (!(attrU = strWtoU( attr ))) goto exit;
@@ -170,8 +171,8 @@ ULONG CDECL ldap_compare_extW( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *attr, WCHAR *
     if (serverctrls && !(serverctrlsU = controlarrayWtoU( serverctrls ))) goto exit;
     if (clientctrls && !(clientctrlsU = controlarrayWtoU( clientctrls ))) goto exit;
 
-    ret = map_error( ldap_funcs->ldap_compare_ext( ld->ld, dnU, attrU, dataU ? dataU : &val, serverctrlsU,
-                                                   clientctrlsU, message ) );
+    ret = map_error( ldap_funcs->fn_ldap_compare_ext( CTX(ld), dnU, attrU, dataU ? dataU : &val, serverctrlsU,
+                                                      clientctrlsU, message ) );
 exit:
     free( dnU );
     free( attrU );
@@ -187,17 +188,17 @@ ULONG CDECL ldap_compare_extW( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *attr, WCHAR *
  *
  * See ldap_compare_ext_sW.
  */
-ULONG CDECL ldap_compare_ext_sA( WLDAP32_LDAP *ld, char *dn, char *attr, char *value,
-    struct WLDAP32_berval *data, LDAPControlA **serverctrls, LDAPControlA **clientctrls )
+ULONG CDECL ldap_compare_ext_sA( LDAP *ld, char *dn, char *attr, char *value, struct berval *data,
+    LDAPControlA **serverctrls, LDAPControlA **clientctrls )
 {
-    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
+    ULONG ret = LDAP_NO_MEMORY;
     WCHAR *dnW = NULL, *attrW = NULL, *valueW = NULL;
     LDAPControlW **serverctrlsW = NULL, **clientctrlsW = NULL;
 
     TRACE( "(%p, %s, %s, %s, %p, %p, %p)\n", ld, debugstr_a(dn), debugstr_a(attr), debugstr_a(value),
            data, serverctrls, clientctrls );
 
-    if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
+    if (!ld) return LDAP_PARAM_ERROR;
 
     if (dn && !(dnW = strAtoW( dn ))) goto exit;
     if (attr && !(attrW = strAtoW( attr ))) goto exit;
@@ -239,10 +240,10 @@ ULONG CDECL ldap_compare_ext_sA( WLDAP32_LDAP *ld, char *dn, char *attr, char *v
  *  both are non-NULL, data will be used. The serverctrls and clientctrls
  *  parameters are optional and should be set to NULL if not used.
  */
-ULONG CDECL ldap_compare_ext_sW( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *attr, WCHAR *value,
-    struct WLDAP32_berval *data, LDAPControlW **serverctrls, LDAPControlW **clientctrls )
+ULONG CDECL ldap_compare_ext_sW( LDAP *ld, WCHAR *dn, WCHAR *attr, WCHAR *value, struct berval *data,
+    LDAPControlW **serverctrls, LDAPControlW **clientctrls )
 {
-    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
+    ULONG ret = LDAP_NO_MEMORY;
     char *dnU = NULL, *attrU = NULL, *valueU = NULL;
     LDAPControlU **serverctrlsU = NULL, **clientctrlsU = NULL;
     struct bervalU *dataU = NULL, val = { 0, NULL };
@@ -250,7 +251,7 @@ ULONG CDECL ldap_compare_ext_sW( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *attr, WCHAR
     TRACE( "(%p, %s, %s, %s, %p, %p, %p)\n", ld, debugstr_w(dn), debugstr_w(attr), debugstr_w(value), data,
            serverctrls, clientctrls );
 
-    if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
+    if (!ld) return LDAP_PARAM_ERROR;
 
     if (dn && !(dnU = strWtoU( dn ))) goto exit;
     if (attr && !(attrU = strWtoU( attr ))) goto exit;
@@ -268,8 +269,8 @@ ULONG CDECL ldap_compare_ext_sW( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *attr, WCHAR
     if (serverctrls && !(serverctrlsU = controlarrayWtoU( serverctrls ))) goto exit;
     if (clientctrls && !(clientctrlsU = controlarrayWtoU( clientctrls ))) goto exit;
 
-    ret = map_error( ldap_funcs->ldap_compare_ext_s( ld->ld, dnU, attrU, dataU ? dataU : &val, serverctrlsU,
-                                                     clientctrlsU ) );
+    ret = map_error( ldap_funcs->fn_ldap_compare_ext_s( CTX(ld), dnU, attrU, dataU ? dataU : &val, serverctrlsU,
+                                                        clientctrlsU ) );
 exit:
     free( dnU );
     free( attrU );
@@ -285,14 +286,14 @@ ULONG CDECL ldap_compare_ext_sW( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *attr, WCHAR
  *
  * See ldap_compare_sW.
  */
-ULONG CDECL ldap_compare_sA( WLDAP32_LDAP *ld, PCHAR dn, PCHAR attr, PCHAR value )
+ULONG CDECL ldap_compare_sA( LDAP *ld, PCHAR dn, PCHAR attr, PCHAR value )
 {
-    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
+    ULONG ret = LDAP_NO_MEMORY;
     WCHAR *dnW = NULL, *attrW = NULL, *valueW = NULL;
 
     TRACE( "(%p, %s, %s, %s)\n", ld, debugstr_a(dn), debugstr_a(attr), debugstr_a(value) );
 
-    if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
+    if (!ld) return LDAP_PARAM_ERROR;
 
     if (dn && !(dnW = strAtoW( dn ))) goto exit;
     if (attr && !(attrW = strAtoW( attr ))) goto exit;
@@ -322,7 +323,7 @@ ULONG CDECL ldap_compare_sA( WLDAP32_LDAP *ld, PCHAR dn, PCHAR attr, PCHAR value
  *  Success: LDAP_SUCCESS
  *  Failure: An LDAP error code.
  */
-ULONG CDECL ldap_compare_sW( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *attr, WCHAR *value )
+ULONG CDECL ldap_compare_sW( LDAP *ld, WCHAR *dn, WCHAR *attr, WCHAR *value )
 {
     TRACE( "(%p, %s, %s, %s)\n", ld, debugstr_w(dn), debugstr_w(attr), debugstr_w(value) );
     return ldap_compare_ext_sW( ld, dn, attr, value, NULL, NULL, NULL );
diff --git a/dlls/wldap32/control.c b/dlls/wldap32/control.c
index b012648797c9..3afd0ddecf0b 100644
--- a/dlls/wldap32/control.c
+++ b/dlls/wldap32/control.c
@@ -22,6 +22,7 @@
 #include "windef.h"
 #include "winbase.h"
 #include "winnls.h"
+#include "winldap.h"
 
 #include "wine/debug.h"
 #include "winldap_private.h"
@@ -37,7 +38,7 @@ ULONG CDECL ldap_control_freeA( LDAPControlA *control )
 {
     TRACE( "(%p)\n", control );
     controlfreeA( control );
-    return WLDAP32_LDAP_SUCCESS;
+    return LDAP_SUCCESS;
 }
 
 /***********************************************************************
@@ -55,7 +56,7 @@ ULONG CDECL ldap_control_freeW( LDAPControlW *control )
 {
     TRACE( "(%p)\n", control );
     controlfreeW( control );
-    return WLDAP32_LDAP_SUCCESS;
+    return LDAP_SUCCESS;
 }
 
 /***********************************************************************
@@ -67,7 +68,7 @@ ULONG CDECL ldap_controls_freeA( LDAPControlA **controls )
 {
     TRACE( "(%p)\n", controls );
     controlarrayfreeA( controls );
-    return WLDAP32_LDAP_SUCCESS;
+    return LDAP_SUCCESS;
 }
 
 /***********************************************************************
@@ -85,7 +86,7 @@ ULONG CDECL ldap_controls_freeW( LDAPControlW **controls )
 {
     TRACE( "(%p)\n", controls );
     controlarrayfreeW( controls );
-    return WLDAP32_LDAP_SUCCESS;
+    return LDAP_SUCCESS;
 }
 
 /***********************************************************************
@@ -93,8 +94,7 @@ ULONG CDECL ldap_controls_freeW( LDAPControlW **controls )
  *
  * See ldap_create_sort_controlW.
  */
-ULONG CDECL ldap_create_sort_controlA( WLDAP32_LDAP *ld, LDAPSortKeyA **sortkey, UCHAR critical,
-    LDAPControlA **control )
+ULONG CDECL ldap_create_sort_controlA( LDAP *ld, LDAPSortKeyA **sortkey, UCHAR critical, LDAPControlA **control )
 {
     ULONG ret;
     LDAPSortKeyW **sortkeyW;
@@ -102,16 +102,16 @@ ULONG CDECL ldap_create_sort_controlA( WLDAP32_LDAP *ld, LDAPSortKeyA **sortkey,
 
     TRACE( "(%p, %p, 0x%02x, %p)\n", ld, sortkey, critical, control );
 
-    if (!ld || !sortkey || !control) return WLDAP32_LDAP_PARAM_ERROR;
+    if (!ld || !sortkey || !control) return LDAP_PARAM_ERROR;
 
-    if (!(sortkeyW = sortkeyarrayAtoW( sortkey ))) return WLDAP32_LDAP_NO_MEMORY;
+    if (!(sortkeyW = sortkeyarrayAtoW( sortkey ))) return LDAP_NO_MEMORY;
 
     ret = ldap_create_sort_controlW( ld, sortkeyW, critical, &controlW );
-    if (ret == WLDAP32_LDAP_SUCCESS)
+    if (ret == LDAP_SUCCESS)
     {
         LDAPControlA *controlA = controlWtoA( controlW );
         if (controlA) *control = controlA;
-        else ret = WLDAP32_LDAP_NO_MEMORY;
+        else ret = LDAP_NO_MEMORY;
         ldap_control_freeW( controlW );
     }
 
@@ -141,8 +141,7 @@ ULONG CDECL ldap_create_sort_controlA( WLDAP32_LDAP *ld, LDAPSortKeyA **sortkey,
  *  Pass the created control as a server control in subsequent calls
  *  to ldap_search_ext(_s) to obtain sorted search results.
  */
-ULONG CDECL ldap_create_sort_controlW( WLDAP32_LDAP *ld, LDAPSortKeyW **sortkey, UCHAR critical,
-    LDAPControlW **control )
+ULONG CDECL ldap_create_sort_controlW( LDAP *ld, LDAPSortKeyW **sortkey, UCHAR critical, LDAPControlW **control )
 {
     ULONG ret;
     LDAPSortKeyU **sortkeyU;
@@ -150,17 +149,17 @@ ULONG CDECL ldap_create_sort_controlW( WLDAP32_LDAP *ld, LDAPSortKeyW **sortkey,
 
     TRACE( "(%p, %p, 0x%02x, %p)\n", ld, sortkey, critical, control );
 
-    if (!ld || !sortkey || !control) return WLDAP32_LDAP_PARAM_ERROR;
+    if (!ld || !sortkey || !control) return LDAP_PARAM_ERROR;
 
-    if (!(sortkeyU = sortkeyarrayWtoU( sortkey ))) return WLDAP32_LDAP_NO_MEMORY;
+    if (!(sortkeyU = sortkeyarrayWtoU( sortkey ))) return LDAP_NO_MEMORY;
 
-    ret = map_error( ldap_funcs->ldap_create_sort_control( ld->ld, sortkeyU, critical, &controlU ) );
-    if (ret == WLDAP32_LDAP_SUCCESS)
+    ret = map_error( ldap_funcs->fn_ldap_create_sort_control( CTX(ld), sortkeyU, critical, &controlU ) );
+    if (ret == LDAP_SUCCESS)
     {
         LDAPControlW *controlW = controlUtoW( controlU );
         if (controlW) *control = controlW;
-        else ret = WLDAP32_LDAP_NO_MEMORY;
-        ldap_funcs->ldap_control_free( controlU );
+        else ret = LDAP_NO_MEMORY;
+        ldap_funcs->fn_ldap_control_free( controlU );
     }
 
     sortkeyarrayfreeU( sortkeyU );
@@ -172,8 +171,7 @@ ULONG CDECL ldap_create_sort_controlW( WLDAP32_LDAP *ld, LDAPSortKeyW **sortkey,
  *
  * See ldap_create_vlv_controlW.
  */
-INT CDECL ldap_create_vlv_controlA( WLDAP32_LDAP *ld, WLDAP32_LDAPVLVInfo *info, UCHAR critical,
-    LDAPControlA **control )
+INT CDECL ldap_create_vlv_controlA( LDAP *ld, LDAPVLVInfo *info, UCHAR critical, LDAPControlA **control )
 {
     INT ret;
     LDAPControlW *controlW;
@@ -183,11 +181,11 @@ INT CDECL ldap_create_vlv_controlA( WLDAP32_LDAP *ld, WLDAP32_LDAPVLVInfo *info,
     if (!ld || !control) return ~0u;
 
     ret = ldap_create_vlv_controlW( ld, info, critical, &controlW );
-    if (ret == WLDAP32_LDAP_SUCCESS)
+    if (ret == LDAP_SUCCESS)
     {
         LDAPControlA *controlA = controlWtoA( controlW );
         if (controlA) *control = controlA;
-        else ret = WLDAP32_LDAP_NO_MEMORY;
+        else ret = LDAP_NO_MEMORY;
         ldap_control_freeW( controlW );
     }
 
@@ -216,8 +214,7 @@ INT CDECL ldap_create_vlv_controlA( WLDAP32_LDAP *ld, WLDAP32_LDAPVLVInfo *info,
  *  server will then return a sorted, contiguous subset of results
  *  that meets the criteria specified in the LDAPVLVInfo structure.
  */
-INT CDECL ldap_create_vlv_controlW( WLDAP32_LDAP *ld, WLDAP32_LDAPVLVInfo *info, UCHAR critical,
-    LDAPControlW **control )
+INT CDECL ldap_create_vlv_controlW( LDAP *ld, LDAPVLVInfo *info, UCHAR critical, LDAPControlW **control )
 {
     ULONG ret;
     LDAPVLVInfoU *infoU = NULL;
@@ -227,22 +224,22 @@ INT CDECL ldap_create_vlv_controlW( WLDAP32_LDAP *ld, WLDAP32_LDAPVLVInfo *info,
 
     if (!ld || !control) return ~0u;
 
-    if (info && !(infoU = vlvinfoWtoU( info ))) return WLDAP32_LDAP_NO_MEMORY;
+    if (info && !(infoU = vlvinfoWtoU( info ))) return LDAP_NO_MEMORY;
 
-    ret = map_error( ldap_funcs->ldap_create_vlv_control( ld->ld, infoU, &controlU ) );
-    if (ret == WLDAP32_LDAP_SUCCESS)
+    ret = map_error( ldap_funcs->fn_ldap_create_vlv_control( CTX(ld), infoU, &controlU ) );
+    if (ret == LDAP_SUCCESS)
     {
         LDAPControlW *controlW = controlUtoW( controlU );
         if (controlW) *control = controlW;
-        else ret = WLDAP32_LDAP_NO_MEMORY;
-        ldap_funcs->ldap_control_free( controlU );
+        else ret = LDAP_NO_MEMORY;
+        ldap_funcs->fn_ldap_control_free( controlU );
     }
 
     vlvinfofreeU( infoU );
     return ret;
 }
 
-static inline void bv_val_dup( const struct WLDAP32_berval *src, struct WLDAP32_berval *dst )
+static inline void bv_val_dup( const struct berval *src, struct berval *dst )
 {
     if ((dst->bv_val = RtlAllocateHeap( GetProcessHeap(), 0 , src->bv_len )))
     {
@@ -258,12 +255,12 @@ static inline void bv_val_dup( const struct WLDAP32_berval *src, struct WLDAP32_
  *
  * See ldap_encode_sort_controlW.
  */
-ULONG CDECL ldap_encode_sort_controlA( WLDAP32_LDAP *ld, LDAPSortKeyA **sortkeys, LDAPControlA *ret, BOOLEAN critical )
+ULONG CDECL ldap_encode_sort_controlA( LDAP *ld, LDAPSortKeyA **sortkeys, LDAPControlA *ret, BOOLEAN critical )
 {
     LDAPControlA *control;
     ULONG result;
 
-    if ((result = ldap_create_sort_controlA( ld, sortkeys, critical, &control )) == WLDAP32_LDAP_SUCCESS)
+    if ((result = ldap_create_sort_controlA( ld, sortkeys, critical, &control )) == LDAP_SUCCESS)
     {
         ret->ldctl_oid = strdupU(control->ldctl_oid);
         bv_val_dup( &control->ldctl_value, &ret->ldctl_value );
@@ -295,12 +292,12 @@ ULONG CDECL ldap_encode_sort_controlA( WLDAP32_LDAP *ld, LDAPSortKeyA **sortkeys
  *  This function is obsolete. Use its equivalent
  *  ldap_create_sort_control instead.
  */
-ULONG CDECL ldap_encode_sort_controlW( WLDAP32_LDAP *ld, LDAPSortKeyW **sortkeys, LDAPControlW *ret, BOOLEAN critical )
+ULONG CDECL ldap_encode_sort_controlW( LDAP *ld, LDAPSortKeyW **sortkeys, LDAPControlW *ret, BOOLEAN critical )
 {
     LDAPControlW *control;
     ULONG result;
 
-    if ((result = ldap_create_sort_controlW( ld, sortkeys, critical, &control )) == WLDAP32_LDAP_SUCCESS)
+    if ((result = ldap_create_sort_controlW( ld, sortkeys, critical, &control )) == LDAP_SUCCESS)
     {
         ret->ldctl_oid = strdupW(control->ldctl_oid);
         bv_val_dup( &control->ldctl_value, &ret->ldctl_value );
diff --git a/dlls/wldap32/delete.c b/dlls/wldap32/delete.c
index 2f3d078629fe..21fd8d08d4be 100644
--- a/dlls/wldap32/delete.c
+++ b/dlls/wldap32/delete.c
@@ -22,6 +22,7 @@
 #include "windef.h"
 #include "winbase.h"
 #include "winnls.h"
+#include "winldap.h"
 
 #include "wine/debug.h"
 #include "winldap_private.h"
@@ -33,7 +34,7 @@ WINE_DEFAULT_DEBUG_CHANNEL(wldap32);
  *
  * See ldap_deleteW.
  */
-ULONG CDECL ldap_deleteA( WLDAP32_LDAP *ld, char *dn )
+ULONG CDECL ldap_deleteA( LDAP *ld, char *dn )
 {
     ULONG ret;
     WCHAR *dnW = NULL;
@@ -41,7 +42,7 @@ ULONG CDECL ldap_deleteA( WLDAP32_LDAP *ld, char *dn )
     TRACE( "(%p, %s)\n", ld, debugstr_a(dn) );
 
     if (!ld) return ~0u;
-    if (dn && !(dnW = strAtoW( dn ))) return WLDAP32_LDAP_NO_MEMORY;
+    if (dn && !(dnW = strAtoW( dn ))) return LDAP_NO_MEMORY;
 
     ret = ldap_deleteW( ld, dnW );
     free( dnW );
@@ -66,14 +67,14 @@ ULONG CDECL ldap_deleteA( WLDAP32_LDAP *ld, char *dn )
  *  the operation. Cancel the operation by calling ldap_abandon
  *  with the message ID.
  */
-ULONG CDECL ldap_deleteW( WLDAP32_LDAP *ld, WCHAR *dn )
+ULONG CDECL ldap_deleteW( LDAP *ld, WCHAR *dn )
 {
     ULONG ret, msg;
 
     TRACE( "(%p, %s)\n", ld, debugstr_w(dn) );
 
     ret = ldap_delete_extW( ld, dn, NULL, NULL, &msg );
-    if (ret == WLDAP32_LDAP_SUCCESS) return msg;
+    if (ret == LDAP_SUCCESS) return msg;
     return ~0u;
 }
 
@@ -82,16 +83,16 @@ ULONG CDECL ldap_deleteW( WLDAP32_LDAP *ld, WCHAR *dn )
  *
  * See ldap_delete_extW.
  */
-ULONG CDECL ldap_delete_extA( WLDAP32_LDAP *ld, char *dn, LDAPControlA **serverctrls,
-    LDAPControlA **clientctrls, ULONG *message )
+ULONG CDECL ldap_delete_extA( LDAP *ld, char *dn, LDAPControlA **serverctrls, LDAPControlA **clientctrls,
+    ULONG *message )
 {
-    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
+    ULONG ret = LDAP_NO_MEMORY;
     WCHAR *dnW = NULL;
     LDAPControlW **serverctrlsW = NULL, **clientctrlsW = NULL;
 
     TRACE( "(%p, %s, %p, %p, %p)\n", ld, debugstr_a(dn), serverctrls, clientctrls, message );
 
-    if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
+    if (!ld) return LDAP_PARAM_ERROR;
 
     if (dn && !(dnW = strAtoW( dn ))) goto exit;
     if (serverctrls && !(serverctrlsW = controlarrayAtoW( serverctrls ))) goto exit;
@@ -127,22 +128,22 @@ ULONG CDECL ldap_delete_extA( WLDAP32_LDAP *ld, char *dn, LDAPControlA **serverc
  *  the operation. The serverctrls and clientctrls parameters are
  *  optional and should be set to NULL if not used.
  */
-ULONG CDECL ldap_delete_extW( WLDAP32_LDAP *ld, WCHAR *dn, LDAPControlW **serverctrls,
-    LDAPControlW **clientctrls, ULONG *message )
+ULONG CDECL ldap_delete_extW( LDAP *ld, WCHAR *dn, LDAPControlW **serverctrls, LDAPControlW **clientctrls,
+    ULONG *message )
 {
-    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
+    ULONG ret = LDAP_NO_MEMORY;
     char *dnU = NULL;
     LDAPControlU **serverctrlsU = NULL, **clientctrlsU = NULL;
 
     TRACE( "(%p, %s, %p, %p, %p)\n", ld, debugstr_w(dn), serverctrls, clientctrls, message );
 
-    if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
+    if (!ld) return LDAP_PARAM_ERROR;
 
     if (dn && !(dnU = strWtoU( dn ))) goto exit;
     if (serverctrls && !(serverctrlsU = controlarrayWtoU( serverctrls ))) goto exit;
     if (clientctrls && !(clientctrlsU = controlarrayWtoU( clientctrls ))) goto exit;
 
-    ret = map_error( ldap_funcs->ldap_delete_ext( ld->ld, dnU, serverctrlsU, clientctrlsU, message ) );
+    ret = map_error( ldap_funcs->fn_ldap_delete_ext( CTX(ld), dnU, serverctrlsU, clientctrlsU, message ) );
 
 exit:
     free( dnU );
@@ -156,16 +157,15 @@ ULONG CDECL ldap_delete_extW( WLDAP32_LDAP *ld, WCHAR *dn, LDAPControlW **server
  *
  * See ldap_delete_ext_sW.
  */
-ULONG CDECL ldap_delete_ext_sA( WLDAP32_LDAP *ld, char *dn, LDAPControlA **serverctrls,
-    LDAPControlA **clientctrls )
+ULONG CDECL ldap_delete_ext_sA( LDAP *ld, char *dn, LDAPControlA **serverctrls, LDAPControlA **clientctrls )
 {
-    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
+    ULONG ret = LDAP_NO_MEMORY;
     WCHAR *dnW = NULL;
     LDAPControlW **serverctrlsW = NULL, **clientctrlsW = NULL;
 
     TRACE( "(%p, %s, %p, %p)\n", ld, debugstr_a(dn), serverctrls, clientctrls );
 
-    if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
+    if (!ld) return LDAP_PARAM_ERROR;
 
     if (dn && !(dnW = strAtoW( dn ))) goto exit;
     if (serverctrls && !(serverctrlsW = controlarrayAtoW( serverctrls ))) goto exit;
@@ -199,22 +199,21 @@ ULONG CDECL ldap_delete_ext_sA( WLDAP32_LDAP *ld, char *dn, LDAPControlA **serve
  *  The serverctrls and clientctrls parameters are optional and
  *  should be set to NULL if not used.
  */
-ULONG CDECL ldap_delete_ext_sW( WLDAP32_LDAP *ld, WCHAR *dn, LDAPControlW **serverctrls,
-    LDAPControlW **clientctrls )
+ULONG CDECL ldap_delete_ext_sW( LDAP *ld, WCHAR *dn, LDAPControlW **serverctrls, LDAPControlW **clientctrls )
 {
-    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
+    ULONG ret = LDAP_NO_MEMORY;
     char *dnU = NULL;
     LDAPControlU **serverctrlsU = NULL, **clientctrlsU = NULL;
 
     TRACE( "(%p, %s, %p, %p)\n", ld, debugstr_w(dn), serverctrls, clientctrls );
 
-    if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
+    if (!ld) return LDAP_PARAM_ERROR;
 
     if (dn && !(dnU = strWtoU( dn ))) goto exit;
     if (serverctrls && !(serverctrlsU = controlarrayWtoU( serverctrls ))) goto exit;
     if (clientctrls && !(clientctrlsU = controlarrayWtoU( clientctrls ))) goto exit;
 
-    ret = map_error( ldap_funcs->ldap_delete_ext_s( ld->ld, dnU, serverctrlsU, clientctrlsU ) );
+    ret = map_error( ldap_funcs->fn_ldap_delete_ext_s( CTX(ld), dnU, serverctrlsU, clientctrlsU ) );
 
 exit:
     free( dnU );
@@ -228,15 +227,15 @@ ULONG CDECL ldap_delete_ext_sW( WLDAP32_LDAP *ld, WCHAR *dn, LDAPControlW **serv
  *
  * See ldap_delete_sW.
  */
-ULONG CDECL ldap_delete_sA( WLDAP32_LDAP *ld, char *dn )
+ULONG CDECL ldap_delete_sA( LDAP *ld, char *dn )
 {
     ULONG ret;
     WCHAR *dnW = NULL;
 
     TRACE( "(%p, %s)\n", ld, debugstr_a(dn) );
 
-    if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
-    if (dn && !(dnW = strAtoW( dn ))) return WLDAP32_LDAP_NO_MEMORY;
+    if (!ld) return LDAP_PARAM_ERROR;
+    if (dn && !(dnW = strAtoW( dn ))) return LDAP_NO_MEMORY;
 
     ret = ldap_delete_sW( ld, dnW );
     free( dnW );
@@ -256,7 +255,7 @@ ULONG CDECL ldap_delete_sA( WLDAP32_LDAP *ld, char *dn )
  *  Success: LDAP_SUCCESS
  *  Failure: An LDAP error code.
  */
-ULONG CDECL ldap_delete_sW( WLDAP32_LDAP *ld, WCHAR *dn )
+ULONG CDECL ldap_delete_sW( LDAP *ld, WCHAR *dn )
 {
     TRACE( "(%p, %s)\n", ld, debugstr_w(dn) );
     return ldap_delete_ext_sW( ld, dn, NULL, NULL );
diff --git a/dlls/wldap32/dn.c b/dlls/wldap32/dn.c
index e9a6be999a8e..1528d8aef1e3 100644
--- a/dlls/wldap32/dn.c
+++ b/dlls/wldap32/dn.c
@@ -22,6 +22,7 @@
 #include "windef.h"
 #include "winbase.h"
 #include "winnls.h"
+#include "winldap.h"
 
 #include "wine/debug.h"
 #include "winldap_private.h"
@@ -74,11 +75,11 @@ WCHAR * CDECL ldap_dn2ufnW( WCHAR *dn )
 
     if (!(dnU = strWtoU( dn ))) return NULL;
 
-    retU = ldap_funcs->ldap_dn2ufn( dnU );
+    retU = ldap_funcs->fn_ldap_dn2ufn( dnU );
     ret = strUtoW( retU );
 
     free( dnU );
-    ldap_funcs->ldap_memfree( retU );
+    ldap_funcs->fn_ldap_memfree( retU );
     return ret;
 }
 
@@ -130,11 +131,11 @@ WCHAR ** CDECL ldap_explode_dnW( WCHAR *dn, ULONG notypes )
 
     if (!(dnU = strWtoU( dn ))) return NULL;
 
-    retU = ldap_funcs->ldap_explode_dn( dnU, notypes );
+    retU = ldap_funcs->fn_ldap_explode_dn( dnU, notypes );
     ret = strarrayUtoW( retU );
 
     free( dnU );
-    ldap_funcs->ldap_memvfree( (void **)retU );
+    ldap_funcs->fn_ldap_memvfree( (void **)retU );
     return ret;
 }
 
@@ -143,7 +144,7 @@ WCHAR ** CDECL ldap_explode_dnW( WCHAR *dn, ULONG notypes )
  *
  * See ldap_get_dnW.
  */
-char * CDECL ldap_get_dnA( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *entry )
+char * CDECL ldap_get_dnA( LDAP *ld, LDAPMessage *entry )
 {
     char *ret;
     WCHAR *retW;
@@ -175,7 +176,7 @@ char * CDECL ldap_get_dnA( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *entry )
  * NOTES
  *  Free the string with ldap_memfree.
  */
-WCHAR * CDECL ldap_get_dnW( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *entry )
+WCHAR * CDECL ldap_get_dnW( LDAP *ld, LDAPMessage *entry )
 {
     WCHAR *ret;
     char *retU;
@@ -184,10 +185,10 @@ WCHAR * CDECL ldap_get_dnW( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *entry )
 
     if (!ld || !entry) return NULL;
 
-    retU = ldap_funcs->ldap_get_dn( ld->ld, entry->Request );
+    retU = ldap_funcs->fn_ldap_get_dn( CTX(ld), MSG(entry) );
 
     ret = strUtoW( retU );
-    ldap_funcs->ldap_memfree( retU );
+    ldap_funcs->fn_ldap_memfree( retU );
     return ret;
 }
 
@@ -203,16 +204,16 @@ ULONG CDECL ldap_ufn2dnA( char *ufn, char **dn )
 
     TRACE( "(%s, %p)\n", debugstr_a(ufn), dn );
 
-    if (!dn) return WLDAP32_LDAP_PARAM_ERROR;
+    if (!dn) return LDAP_PARAM_ERROR;
 
     *dn = NULL;
-    if (ufn && !(ufnW = strAtoW( ufn ))) return WLDAP32_LDAP_NO_MEMORY;
+    if (ufn && !(ufnW = strAtoW( ufn ))) return LDAP_NO_MEMORY;
 
     ret = ldap_ufn2dnW( ufnW, &dnW );
     if (dnW)
     {
         char *str;
-        if (!(str = strWtoA( dnW ))) ret = WLDAP32_LDAP_NO_MEMORY;
+        if (!(str = strWtoA( dnW ))) ret = LDAP_NO_MEMORY;
         else *dn = str;
     }
 
@@ -239,21 +240,21 @@ ULONG CDECL ldap_ufn2dnA( char *ufn, char **dn )
  */
 ULONG CDECL ldap_ufn2dnW( WCHAR *ufn, WCHAR **dn )
 {
-    ULONG ret = WLDAP32_LDAP_SUCCESS;
+    ULONG ret = LDAP_SUCCESS;
     char *ufnU = NULL;
 
     TRACE( "(%s, %p)\n", debugstr_w(ufn), dn );
 
-    if (!dn) return WLDAP32_LDAP_PARAM_ERROR;
+    if (!dn) return LDAP_PARAM_ERROR;
 
     *dn = NULL;
     if (ufn)
     {
         WCHAR *str;
-        if (!(ufnU = strWtoU( ufn ))) return WLDAP32_LDAP_NO_MEMORY;
+        if (!(ufnU = strWtoU( ufn ))) return LDAP_NO_MEMORY;
 
         /* FIXME: do more than just a copy */
-        if (!(str = strUtoW( ufnU ))) ret = WLDAP32_LDAP_NO_MEMORY;
+        if (!(str = strUtoW( ufnU ))) ret = LDAP_NO_MEMORY;
         else *dn = str;
     }
 
diff --git a/dlls/wldap32/error.c b/dlls/wldap32/error.c
index a56adc11c02a..e7a19144bf22 100644
--- a/dlls/wldap32/error.c
+++ b/dlls/wldap32/error.c
@@ -23,6 +23,7 @@
 #include "winbase.h"
 #include "winuser.h"
 #include "winnls.h"
+#include "winldap.h"
 
 #include "wine/debug.h"
 #include "winldap_private.h"
@@ -35,24 +36,24 @@ ULONG map_error( int error )
 {
     switch (error)
     {
-    case  0:    return WLDAP32_LDAP_SUCCESS;
-    case -1:    return WLDAP32_LDAP_SERVER_DOWN;
-    case -2:    return WLDAP32_LDAP_LOCAL_ERROR;
-    case -3:    return WLDAP32_LDAP_ENCODING_ERROR;
-    case -4:    return WLDAP32_LDAP_DECODING_ERROR;
-    case -5:    return WLDAP32_LDAP_TIMEOUT;
-    case -6:    return WLDAP32_LDAP_AUTH_UNKNOWN;
-    case -7:    return WLDAP32_LDAP_FILTER_ERROR;
-    case -8:    return WLDAP32_LDAP_USER_CANCELLED;
-    case -9:    return WLDAP32_LDAP_PARAM_ERROR;
-    case -10:   return WLDAP32_LDAP_NO_MEMORY;
-    case -11:   return WLDAP32_LDAP_CONNECT_ERROR;
-    case -12:   return WLDAP32_LDAP_NOT_SUPPORTED;
-    case -13:   return WLDAP32_LDAP_CONTROL_NOT_FOUND;
-    case -14:   return WLDAP32_LDAP_NO_RESULTS_RETURNED;
-    case -15:   return WLDAP32_LDAP_MORE_RESULTS_TO_RETURN;
-    case -16:   return WLDAP32_LDAP_CLIENT_LOOP;
-    case -17:   return WLDAP32_LDAP_REFERRAL_LIMIT_EXCEEDED;
+    case  0:    return LDAP_SUCCESS;
+    case -1:    return LDAP_SERVER_DOWN;
+    case -2:    return LDAP_LOCAL_ERROR;
+    case -3:    return LDAP_ENCODING_ERROR;
+    case -4:    return LDAP_DECODING_ERROR;
+    case -5:    return LDAP_TIMEOUT;
+    case -6:    return LDAP_AUTH_UNKNOWN;
+    case -7:    return LDAP_FILTER_ERROR;
+    case -8:    return LDAP_USER_CANCELLED;
+    case -9:    return LDAP_PARAM_ERROR;
+    case -10:   return LDAP_NO_MEMORY;
+    case -11:   return LDAP_CONNECT_ERROR;
+    case -12:   return LDAP_NOT_SUPPORTED;
+    case -13:   return LDAP_CONTROL_NOT_FOUND;
+    case -14:   return LDAP_NO_RESULTS_RETURNED;
+    case -15:   return LDAP_MORE_RESULTS_TO_RETURN;
+    case -16:   return LDAP_CLIENT_LOOP;
+    case -17:   return LDAP_REFERRAL_LIMIT_EXCEEDED;
     default: return error;
     }
 }
@@ -68,10 +69,10 @@ char * CDECL ldap_err2stringA( ULONG err )
 
     TRACE( "(0x%08x)\n", err );
 
-    if (err <= WLDAP32_LDAP_REFERRAL_LIMIT_EXCEEDED)
+    if (err <= LDAP_REFERRAL_LIMIT_EXCEEDED)
         LoadStringA( hwldap32, err, buf, 256 );
     else
-        LoadStringA( hwldap32, WLDAP32_LDAP_LOCAL_ERROR, buf, 256 );
+        LoadStringA( hwldap32, LDAP_LOCAL_ERROR, buf, 256 );
 
     return buf;
 }
@@ -98,10 +99,10 @@ WCHAR * CDECL ldap_err2stringW( ULONG err )
 
     TRACE( "(0x%08x)\n", err );
 
-    if (err <= WLDAP32_LDAP_REFERRAL_LIMIT_EXCEEDED)
+    if (err <= LDAP_REFERRAL_LIMIT_EXCEEDED)
         LoadStringW( hwldap32, err, buf, 256 );
     else
-        LoadStringW( hwldap32, WLDAP32_LDAP_LOCAL_ERROR, buf, 256 );
+        LoadStringW( hwldap32, LDAP_LOCAL_ERROR, buf, 256 );
 
     return buf;
 }
@@ -121,7 +122,7 @@ WCHAR * CDECL ldap_err2stringW( ULONG err )
  * NOTES
  *  Like native, this function does nothing.
  */
-void CDECL WLDAP32_ldap_perror( WLDAP32_LDAP *ld, const PCHAR msg )
+void CDECL ldap_perror( LDAP *ld, const PCHAR msg )
 {
     TRACE( "(%p, %s)\n", ld, debugstr_a(msg) );
 }
@@ -143,7 +144,7 @@ void CDECL WLDAP32_ldap_perror( WLDAP32_LDAP *ld, const PCHAR msg )
  * NOTES
  *  If not asked for, use ldap_msgfree to free the LDAPMessage.
  */
-ULONG CDECL WLDAP32_ldap_result2error( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *res, ULONG free )
+ULONG CDECL ldap_result2error( LDAP *ld, LDAPMessage *res, ULONG free )
 {
     ULONG ret;
     int error;
@@ -152,8 +153,8 @@ ULONG CDECL WLDAP32_ldap_result2error( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *re
 
     if (!ld || !res) return ~0u;
 
-    ret = map_error( ldap_funcs->ldap_parse_result( ld->ld, res->Request, &error, NULL, NULL, NULL, NULL, free ) );
-    if (ret == WLDAP32_LDAP_SUCCESS)
+    ret = map_error( ldap_funcs->fn_ldap_parse_result( CTX(ld), MSG(res), &error, NULL, NULL, NULL, NULL, free ) );
+    if (ret == LDAP_SUCCESS)
         ret = error;
     else
         ret = ~0u;
@@ -178,7 +179,7 @@ ULONG CDECL LdapGetLastError( void )
     return GetLastError();
 }
 
-static const ULONG WLDAP32_errormap[] = {
+static const ULONG errormap[] = {
     /* LDAP_SUCCESS */                      ERROR_SUCCESS,
     /* LDAP_OPERATIONS_ERROR */             ERROR_OPEN_FAILED,
     /* LDAP_PROTOCOL_ERROR */               ERROR_INVALID_LEVEL,
@@ -294,6 +295,6 @@ ULONG CDECL LdapMapErrorToWin32( ULONG err )
 {
     TRACE( "(0x%08x)\n", err );
 
-    if (err >= ARRAY_SIZE( WLDAP32_errormap )) return ERROR_DS_GENERIC_ERROR;
-    return WLDAP32_errormap[err];
+    if (err >= ARRAY_SIZE( errormap )) return ERROR_DS_GENERIC_ERROR;
+    return errormap[err];
 }
diff --git a/dlls/wldap32/extended.c b/dlls/wldap32/extended.c
index 2a71ce59acf4..3b33b0e588b8 100644
--- a/dlls/wldap32/extended.c
+++ b/dlls/wldap32/extended.c
@@ -22,6 +22,7 @@
 #include "windef.h"
 #include "winbase.h"
 #include "winnls.h"
+#include "winldap.h"
 
 #include "wine/debug.h"
 #include "winldap_private.h"
@@ -45,12 +46,12 @@ WINE_DEFAULT_DEBUG_CHANNEL(wldap32);
  *  Contrary to native, OpenLDAP does not require us to close
  *  extended operations, so this is a no-op.
  */
-ULONG CDECL ldap_close_extended_op( WLDAP32_LDAP *ld, ULONG msgid )
+ULONG CDECL ldap_close_extended_op( LDAP *ld, ULONG msgid )
 {
     TRACE( "(%p, 0x%08x)\n", ld, msgid );
 
-    if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
-    return WLDAP32_LDAP_SUCCESS;
+    if (!ld) return LDAP_PARAM_ERROR;
+    return LDAP_SUCCESS;
 }
 
 /***********************************************************************
@@ -58,16 +59,16 @@ ULONG CDECL ldap_close_extended_op( WLDAP32_LDAP *ld, ULONG msgid )
  *
  * See ldap_extended_operationW.
  */
-ULONG CDECL ldap_extended_operationA( WLDAP32_LDAP *ld, char *oid, struct WLDAP32_berval *data,
-    LDAPControlA **serverctrls, LDAPControlA **clientctrls, ULONG *message )
+ULONG CDECL ldap_extended_operationA( LDAP *ld, char *oid, struct berval *data, LDAPControlA **serverctrls,
+    LDAPControlA **clientctrls, ULONG *message )
 {
-    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
+    ULONG ret = LDAP_NO_MEMORY;
     WCHAR *oidW = NULL;
     LDAPControlW **serverctrlsW = NULL, **clientctrlsW = NULL;
 
     TRACE( "(%p, %s, %p, %p, %p, %p)\n", ld, debugstr_a(oid), data, serverctrls, clientctrls, message );
 
-    if (!ld || !message) return WLDAP32_LDAP_PARAM_ERROR;
+    if (!ld || !message) return LDAP_PARAM_ERROR;
 
     if (oid && !(oidW = strAtoW( oid ))) goto exit;
     if (serverctrls && !(serverctrlsW = controlarrayAtoW( serverctrls ))) goto exit;
@@ -107,24 +108,25 @@ ULONG CDECL ldap_extended_operationA( WLDAP32_LDAP *ld, char *oid, struct WLDAP3
  *  are optional and should be set to NULL if not used. Call
  *  ldap_close_extended_op to close the operation.
  */
-ULONG CDECL ldap_extended_operationW( WLDAP32_LDAP *ld, WCHAR *oid, struct WLDAP32_berval *data,
-    LDAPControlW **serverctrls, LDAPControlW **clientctrls, ULONG *message )
+ULONG CDECL ldap_extended_operationW( LDAP *ld, WCHAR *oid, struct berval *data, LDAPControlW **serverctrls,
+    LDAPControlW **clientctrls, ULONG *message )
 {
-    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
+    ULONG ret = LDAP_NO_MEMORY;
     char *oidU = NULL;
     LDAPControlU **serverctrlsU = NULL, **clientctrlsU = NULL;
     struct bervalU *dataU = NULL;
 
     TRACE( "(%p, %s, %p, %p, %p, %p)\n", ld, debugstr_w(oid), data, serverctrls, clientctrls, message );
 
-    if (!ld || !message) return WLDAP32_LDAP_PARAM_ERROR;
+    if (!ld || !message) return LDAP_PARAM_ERROR;
 
     if (oid && !(oidU = strWtoU( oid ))) goto exit;
     if (data && !(dataU = bervalWtoU( data ))) goto exit;
     if (serverctrls && !(serverctrlsU = controlarrayWtoU( serverctrls ))) goto exit;
     if (clientctrls && !(clientctrlsU = controlarrayWtoU( clientctrls ))) goto exit;
 
-    ret = map_error( ldap_funcs->ldap_extended_operation( ld->ld, oidU, dataU, serverctrlsU, clientctrlsU, message ) );
+    ret = map_error( ldap_funcs->fn_ldap_extended_operation( CTX(ld), oidU, dataU, serverctrlsU, clientctrlsU,
+                                                             message ) );
 
 exit:
     free( oidU );
@@ -139,16 +141,16 @@ ULONG CDECL ldap_extended_operationW( WLDAP32_LDAP *ld, WCHAR *oid, struct WLDAP
  *
  * See ldap_extended_operation_sW.
  */
-ULONG CDECL ldap_extended_operation_sA( WLDAP32_LDAP *ld, char *oid, struct WLDAP32_berval *data,
-    LDAPControlA **serverctrls, LDAPControlA **clientctrls, char **retoid, struct WLDAP32_berval **retdata )
+ULONG CDECL ldap_extended_operation_sA( LDAP *ld, char *oid, struct berval *data, LDAPControlA **serverctrls,
+    LDAPControlA **clientctrls, char **retoid, struct berval **retdata )
 {
-    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
+    ULONG ret = LDAP_NO_MEMORY;
     WCHAR *oidW = NULL, *retoidW = NULL;
     LDAPControlW **serverctrlsW = NULL, **clientctrlsW = NULL;
 
     TRACE( "(%p, %s, %p, %p, %p, %p, %p)\n", ld, debugstr_a(oid), data, serverctrls, clientctrls, retoid, retdata );
 
-    if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
+    if (!ld) return LDAP_PARAM_ERROR;
 
     if (oid && !(oidW = strAtoW( oid ))) goto exit;
     if (serverctrls && !(serverctrlsW = controlarrayAtoW( serverctrls ))) goto exit;
@@ -159,7 +161,7 @@ ULONG CDECL ldap_extended_operation_sA( WLDAP32_LDAP *ld, char *oid, struct WLDA
     {
         char *str = strWtoA( retoidW );
         if (str) *retoid = str;
-        else ret = WLDAP32_LDAP_NO_MEMORY;
+        else ret = LDAP_NO_MEMORY;
         ldap_memfreeW( retoidW );
     }
 
@@ -194,38 +196,38 @@ ULONG CDECL ldap_extended_operation_sA( WLDAP32_LDAP *ld, char *oid, struct WLDA
  *  and retdata parameters are also optional. Set to NULL if not
  *  used. Free retoid and retdata after use with ldap_memfree.
  */
-ULONG CDECL ldap_extended_operation_sW( WLDAP32_LDAP *ld, WCHAR *oid, struct WLDAP32_berval *data,
-    LDAPControlW **serverctrls, LDAPControlW **clientctrls, WCHAR **retoid, struct WLDAP32_berval **retdata )
+ULONG CDECL ldap_extended_operation_sW( LDAP *ld, WCHAR *oid, struct berval *data, LDAPControlW **serverctrls,
+    LDAPControlW **clientctrls, WCHAR **retoid, struct berval **retdata )
 {
-    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
+    ULONG ret = LDAP_NO_MEMORY;
     char *oidU = NULL, *retoidU = NULL;
     LDAPControlU **serverctrlsU = NULL, **clientctrlsU = NULL;
     struct bervalU *retdataU, *dataU = NULL;
 
     TRACE( "(%p, %s, %p, %p, %p, %p, %p)\n", ld, debugstr_w(oid), data, serverctrls, clientctrls, retoid, retdata );
 
-    if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
+    if (!ld) return LDAP_PARAM_ERROR;
 
     if (oid && !(oidU = strWtoU( oid ))) goto exit;
     if (data && !(dataU = bervalWtoU( data ))) goto exit;
     if (serverctrls && !(serverctrlsU = controlarrayWtoU( serverctrls ))) goto exit;
     if (clientctrls && !(clientctrlsU = controlarrayWtoU( clientctrls ))) goto exit;
 
-    ret = map_error( ldap_funcs->ldap_extended_operation_s( ld->ld, oidU, dataU, serverctrlsU, clientctrlsU,
-                                                            &retoidU, &retdataU ) );
+    ret = map_error( ldap_funcs->fn_ldap_extended_operation_s( CTX(ld), oidU, dataU, serverctrlsU, clientctrlsU,
+                                                               &retoidU, &retdataU ) );
     if (retoid && retoidU)
     {
         WCHAR *str = strUtoW( retoidU );
         if (str) *retoid = str;
-        else ret = WLDAP32_LDAP_NO_MEMORY;
-        ldap_funcs->ldap_memfree( retoidU );
+        else ret = LDAP_NO_MEMORY;
+        ldap_funcs->fn_ldap_memfree( retoidU );
     }
     if (retdata && retdataU)
     {
-        struct WLDAP32_berval *bv = bervalUtoW( retdataU );
+        struct berval *bv = bervalUtoW( retdataU );
         if (bv) *retdata = bv;
-        else ret = WLDAP32_LDAP_NO_MEMORY;
-        ldap_funcs->ber_bvfree( retdataU );
+        else ret = LDAP_NO_MEMORY;
+        ldap_funcs->fn_ber_bvfree( retdataU );
     }
 
 exit:
diff --git a/dlls/wldap32/init.c b/dlls/wldap32/init.c
index 8043164ad307..35f97754f64a 100644
--- a/dlls/wldap32/init.c
+++ b/dlls/wldap32/init.c
@@ -24,6 +24,7 @@
 #include "winbase.h"
 #include "winnls.h"
 #include "winternl.h"
+#include "winldap.h"
 
 #include "wine/debug.h"
 #include "winldap_private.h"
@@ -190,18 +191,18 @@ static char *urlify_hostnames( const char *scheme, char *hostnames, ULONG port )
 }
 
 
-static WLDAP32_LDAP *create_context( const char *url )
+static LDAP *create_context( const char *url )
 {
-    WLDAP32_LDAP *ld;
-    int version = WLDAP32_LDAP_VERSION3;
+    LDAP *ld;
+    int version = LDAP_VERSION3;
 
     if (!(ld = calloc( 1, sizeof( *ld )))) return NULL;
-    if (map_error( ldap_funcs->ldap_initialize( &ld->ld, url ) ) != WLDAP32_LDAP_SUCCESS)
+    if (map_error( ldap_funcs->fn_ldap_initialize( &CTX(ld), url ) ) != LDAP_SUCCESS)
     {
         free( ld );
         return NULL;
     }
-    ldap_funcs->ldap_set_option( ld->ld, WLDAP32_LDAP_OPT_PROTOCOL_VERSION, &version );
+    ldap_funcs->fn_ldap_set_option( CTX(ld), LDAP_OPT_PROTOCOL_VERSION, &version );
     return ld;
 }
 
@@ -210,9 +211,9 @@ static WLDAP32_LDAP *create_context( const char *url )
  *
  * See cldap_openW.
  */
-WLDAP32_LDAP * CDECL cldap_openA( char *hostname, ULONG portnumber )
+LDAP * CDECL cldap_openA( char *hostname, ULONG portnumber )
 {
-    WLDAP32_LDAP *ld;
+    LDAP *ld;
     WCHAR *hostnameW = NULL;
 
     TRACE( "(%s, %d)\n", debugstr_a(hostname), portnumber );
@@ -246,9 +247,9 @@ WLDAP32_LDAP * CDECL cldap_openA( char *hostname, ULONG portnumber )
  *  will take precedence over the port number supplied as a parameter
  *  to this function.
  */
-WLDAP32_LDAP * CDECL cldap_openW( WCHAR *hostname, ULONG portnumber )
+LDAP * CDECL cldap_openW( WCHAR *hostname, ULONG portnumber )
 {
-    WLDAP32_LDAP *ld = NULL;
+    LDAP *ld = NULL;
     char *hostnameU, *url = NULL;
 
     TRACE( "(%s, %d)\n", debugstr_w(hostname), portnumber );
@@ -282,12 +283,12 @@ WLDAP32_LDAP * CDECL cldap_openW( WCHAR *hostname, ULONG portnumber )
  *  The timeout parameter may be NULL in which case a default timeout
  *  value will be used.
  */
-ULONG CDECL ldap_connect( WLDAP32_LDAP *ld, struct l_timeval *timeout )
+ULONG CDECL ldap_connect( LDAP *ld, struct l_timeval *timeout )
 {
     TRACE( "(%p, %p)\n", ld, timeout );
 
-    if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
-    return WLDAP32_LDAP_SUCCESS; /* FIXME: do something, e.g. ping the host */
+    if (!ld) return LDAP_PARAM_ERROR;
+    return LDAP_SUCCESS; /* FIXME: do something, e.g. ping the host */
 }
 
 /***********************************************************************
@@ -295,9 +296,9 @@ ULONG CDECL ldap_connect( WLDAP32_LDAP *ld, struct l_timeval *timeout )
  *
  * See ldap_initW.
  */
-WLDAP32_LDAP *  CDECL ldap_initA( const PCHAR hostname, ULONG portnumber )
+LDAP *  CDECL ldap_initA( const PCHAR hostname, ULONG portnumber )
 {
-    WLDAP32_LDAP *ld;
+    LDAP *ld;
     WCHAR *hostnameW = NULL;
 
     TRACE( "(%s, %d)\n", debugstr_a(hostname), portnumber );
@@ -332,9 +333,9 @@ WLDAP32_LDAP *  CDECL ldap_initA( const PCHAR hostname, ULONG portnumber )
  *  to this function. The connection will not be made until the first
  *  LDAP function that needs it is called.
  */
-WLDAP32_LDAP * CDECL ldap_initW( const PWCHAR hostname, ULONG portnumber )
+LDAP * CDECL ldap_initW( const PWCHAR hostname, ULONG portnumber )
 {
-    WLDAP32_LDAP *ld = NULL;
+    LDAP *ld = NULL;
     char *hostnameU, *url = NULL;
 
     TRACE( "(%s, %d)\n", debugstr_w(hostname), portnumber );
@@ -355,9 +356,9 @@ WLDAP32_LDAP * CDECL ldap_initW( const PWCHAR hostname, ULONG portnumber )
  *
  * See ldap_openW.
  */
-WLDAP32_LDAP * CDECL ldap_openA( char *hostname, ULONG portnumber )
+LDAP * CDECL ldap_openA( char *hostname, ULONG portnumber )
 {
-    WLDAP32_LDAP *ld;
+    LDAP *ld;
     WCHAR *hostnameW = NULL;
 
     TRACE( "(%s, %d)\n", debugstr_a(hostname), portnumber );
@@ -391,9 +392,9 @@ WLDAP32_LDAP * CDECL ldap_openA( char *hostname, ULONG portnumber )
  *  will take precedence over the port number supplied as a parameter
  *  to this function.
  */
-WLDAP32_LDAP * CDECL ldap_openW( WCHAR *hostname, ULONG portnumber )
+LDAP * CDECL ldap_openW( WCHAR *hostname, ULONG portnumber )
 {
-    WLDAP32_LDAP *ld = NULL;
+    LDAP *ld = NULL;
     char *hostnameU, *url = NULL;
 
     TRACE( "(%s, %d)\n", debugstr_w(hostname), portnumber );
@@ -414,9 +415,9 @@ WLDAP32_LDAP * CDECL ldap_openW( WCHAR *hostname, ULONG portnumber )
  *
  * See ldap_sslinitW.
  */
-WLDAP32_LDAP * CDECL ldap_sslinitA( char *hostname, ULONG portnumber, int secure )
+LDAP * CDECL ldap_sslinitA( char *hostname, ULONG portnumber, int secure )
 {
-    WLDAP32_LDAP *ld;
+    LDAP *ld;
     WCHAR *hostnameW = NULL;
 
     TRACE( "(%s, %d, 0x%08x)\n", debugstr_a(hostname), portnumber, secure );
@@ -452,9 +453,9 @@ WLDAP32_LDAP * CDECL ldap_sslinitA( char *hostname, ULONG portnumber, int secure
  *  to this function. The connection will not be made until the first
  *  LDAP function that needs it is called.
  */
-WLDAP32_LDAP * CDECL ldap_sslinitW( WCHAR *hostname, ULONG portnumber, int secure )
+LDAP * CDECL ldap_sslinitW( WCHAR *hostname, ULONG portnumber, int secure )
 {
-    WLDAP32_LDAP *ld = NULL;
+    LDAP *ld = NULL;
     char *hostnameU, *url = NULL;
 
     TRACE( "(%s, %d, 0x%08x)\n", debugstr_w(hostname), portnumber, secure );
@@ -480,10 +481,10 @@ WLDAP32_LDAP * CDECL ldap_sslinitW( WCHAR *hostname, ULONG portnumber, int secur
  *
  * See ldap_start_tls_sW.
  */
-ULONG CDECL ldap_start_tls_sA( WLDAP32_LDAP *ld, ULONG *retval, WLDAP32_LDAPMessage **result,
-    LDAPControlA **serverctrls, LDAPControlA **clientctrls )
+ULONG CDECL ldap_start_tls_sA( LDAP *ld, ULONG *retval, LDAPMessage **result, LDAPControlA **serverctrls,
+    LDAPControlA **clientctrls )
 {
-    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
+    ULONG ret = LDAP_NO_MEMORY;
     LDAPControlW **serverctrlsW = NULL, **clientctrlsW = NULL;
 
     TRACE( "(%p, %p, %p, %p, %p)\n", ld, retval, result, serverctrls, clientctrls );
@@ -520,10 +521,10 @@ ULONG CDECL ldap_start_tls_sA( WLDAP32_LDAP *ld, ULONG *retval, WLDAP32_LDAPMess
  * NOTES
  *  LDAP function that needs it is called.
  */
-ULONG CDECL ldap_start_tls_sW( WLDAP32_LDAP *ld, ULONG *retval, WLDAP32_LDAPMessage **result,
-    LDAPControlW **serverctrls, LDAPControlW **clientctrls )
+ULONG CDECL ldap_start_tls_sW( LDAP *ld, ULONG *retval, LDAPMessage **result, LDAPControlW **serverctrls,
+    LDAPControlW **clientctrls )
 {
-    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
+    ULONG ret = LDAP_NO_MEMORY;
     LDAPControlU **serverctrlsU = NULL, **clientctrlsU = NULL;
 
     TRACE( "(%p, %p, %p, %p, %p)\n", ld, retval, result, serverctrls, clientctrls );
@@ -538,7 +539,7 @@ ULONG CDECL ldap_start_tls_sW( WLDAP32_LDAP *ld, ULONG *retval, WLDAP32_LDAPMess
     if (serverctrls && !(serverctrlsU = controlarrayWtoU( serverctrls ))) goto exit;
     if (clientctrls && !(clientctrlsU = controlarrayWtoU( clientctrls ))) goto exit;
 
-    ret = map_error( ldap_funcs->ldap_start_tls_s( ld->ld, serverctrlsU, clientctrlsU ) );
+    ret = map_error( ldap_funcs->fn_ldap_start_tls_s( CTX(ld), serverctrlsU, clientctrlsU ) );
 
 exit:
     controlarrayfreeU( serverctrlsU );
@@ -552,7 +553,7 @@ ULONG CDECL ldap_start_tls_sW( WLDAP32_LDAP *ld, ULONG *retval, WLDAP32_LDAPMess
 ULONG CDECL ldap_startup( LDAP_VERSION_INFO *version, HANDLE *instance )
 {
     TRACE( "(%p, %p)\n", version, instance );
-    return WLDAP32_LDAP_SUCCESS;
+    return LDAP_SUCCESS;
 }
 
 /***********************************************************************
@@ -567,7 +568,7 @@ ULONG CDECL ldap_startup( LDAP_VERSION_INFO *version, HANDLE *instance )
  *  Success: TRUE
  *  Failure: FALSE
  */
-BOOLEAN CDECL ldap_stop_tls_s( WLDAP32_LDAP *ld )
+BOOLEAN CDECL ldap_stop_tls_s( LDAP *ld )
 {
     TRACE( "(%p)\n", ld );
     return TRUE; /* FIXME: find a way to stop tls on a connection */
diff --git a/dlls/wldap32/libldap.c b/dlls/wldap32/libldap.c
index f71970e2a59e..5cea944729da 100644
--- a/dlls/wldap32/libldap.c
+++ b/dlls/wldap32/libldap.c
@@ -25,6 +25,7 @@
 #include "config.h"
 
 #ifdef HAVE_LDAP
+#include <assert.h>
 #include <stdarg.h>
 #include <sys/time.h>
 #ifdef HAVE_LDAP_H
@@ -41,7 +42,7 @@
 #include "winbase.h"
 
 #include "wine/debug.h"
-#include "winldap_private.h"
+#include "libldap.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(wldap32);
 
@@ -54,6 +55,8 @@ C_ASSERT( sizeof(LDAPAPIInfoU) == sizeof(LDAPAPIInfo) );
 C_ASSERT( sizeof(LDAPAPIFeatureInfoU) == sizeof(LDAPAPIFeatureInfo) );
 C_ASSERT( sizeof(struct timevalU) == sizeof(struct timeval) );
 
+#define WLDAP32_LBER_ERROR  (~0l)
+
 static LDAPMod *nullmods[] = { NULL };
 
 static const struct ldap_callbacks *callbacks;
diff --git a/dlls/wldap32/libldap.h b/dlls/wldap32/libldap.h
index cc247e8fd824..3d2719452c45 100644
--- a/dlls/wldap32/libldap.h
+++ b/dlls/wldap32/libldap.h
@@ -184,80 +184,81 @@ extern void CDECL wrap_ldap_value_free_len(struct bervalU **) DECLSPEC_HIDDEN;
 
 struct ldap_funcs
 {
-    void * (CDECL *ber_alloc_t)(int);
-    void (CDECL *ber_bvecfree)(struct bervalU **);
-    void (CDECL *ber_bvfree)(struct bervalU *);
-    unsigned int (CDECL *ber_first_element)(void *, unsigned int *, char **);
-    int (CDECL *ber_flatten)(void *, struct bervalU **);
-    void (CDECL *ber_free)(void *, int);
-    void * (CDECL *ber_init)(struct bervalU *);
-    unsigned int (CDECL *ber_next_element)(void *, unsigned int *, char *);
-    unsigned int (CDECL *ber_peek_tag)(void *, unsigned int *);
-    unsigned int (CDECL *ber_skip_tag)(void *, unsigned int *);
-    int (WINAPIV *ber_printf)(void *, char *, ...);
-    int (WINAPIV *ber_scanf)(void *, char *, ...);
+    void * (CDECL *fn_ber_alloc_t)(int);
+    void (CDECL *fn_ber_bvecfree)(struct bervalU **);
+    void (CDECL *fn_ber_bvfree)(struct bervalU *);
+    unsigned int (CDECL *fn_ber_first_element)(void *, unsigned int *, char **);
+    int (CDECL *fn_ber_flatten)(void *, struct bervalU **);
+    void (CDECL *fn_ber_free)(void *, int);
+    void * (CDECL *fn_ber_init)(struct bervalU *);
+    unsigned int (CDECL *fn_ber_next_element)(void *, unsigned int *, char *);
+    unsigned int (CDECL *fn_ber_peek_tag)(void *, unsigned int *);
+    unsigned int (CDECL *fn_ber_skip_tag)(void *, unsigned int *);
+    int (WINAPIV *fn_ber_printf)(void *, char *, ...);
+    int (WINAPIV *fn_ber_scanf)(void *, char *, ...);
 
-    int (CDECL *ldap_abandon_ext)(void *, int, LDAPControlU **, LDAPControlU **);
-    int (CDECL *ldap_add_ext)(void *, const char *, LDAPModU **, LDAPControlU **, LDAPControlU **, ULONG *);
-    int (CDECL *ldap_add_ext_s)(void *, const char *, LDAPModU **, LDAPControlU **, LDAPControlU **);
-    int (CDECL *ldap_compare_ext)(void *, const char *, const char *, struct bervalU *, LDAPControlU **,
-                                  LDAPControlU **, ULONG *);
-    int (CDECL *ldap_compare_ext_s)(void *, const char *, const char *, struct bervalU *, LDAPControlU **,
-                                    LDAPControlU **);
-    void (CDECL *ldap_control_free)(LDAPControlU *);
-    void (CDECL *ldap_controls_free)(LDAPControlU **);
-    int (CDECL *ldap_count_entries)(void *, void *);
-    int (CDECL *ldap_count_references)(void *, void *);
-    int (CDECL *ldap_count_values_len)(struct bervalU **);
-    int (CDECL *ldap_create_sort_control)(void *, LDAPSortKeyU **, int, LDAPControlU **);
-    int (CDECL *ldap_create_vlv_control)(void *, LDAPVLVInfoU *, LDAPControlU **);
-    int (CDECL *ldap_delete_ext)(void *, const char *, LDAPControlU **, LDAPControlU **, ULONG *);
-    int (CDECL *ldap_delete_ext_s)(void *, const char *, LDAPControlU **, LDAPControlU **);
-    char * (CDECL *ldap_dn2ufn)(const char *);
-    char ** (CDECL *ldap_explode_dn)(const char *, int);
-    int (CDECL *ldap_extended_operation)(void *, const char *, struct bervalU *, LDAPControlU **,
-                                         LDAPControlU **, ULONG *);
-    int (CDECL *ldap_extended_operation_s)(void *, const char *, struct bervalU *, LDAPControlU **,
-                                           LDAPControlU **, char **, struct bervalU **);
-    char * (CDECL *ldap_get_dn)(void *, void *);
-    int (CDECL *ldap_get_option)(void *, int, void *);
-    struct bervalU ** (CDECL *ldap_get_values_len)(void *, void *, const char *);
-    int (CDECL *ldap_initialize)(void **, const char *);
-    char * (CDECL *ldap_first_attribute)(void *, void *, void **);
-    void * (CDECL *ldap_first_entry)(void *, void *);
-    void * (CDECL *ldap_first_reference)(void *, void *);
-    void (CDECL *ldap_memfree)(void *);
-    void (CDECL *ldap_memvfree)(void **);
-    int (CDECL *ldap_modify_ext)(void *, const char *, LDAPModU **, LDAPControlU **, LDAPControlU **, ULONG *);
-    int (CDECL *ldap_modify_ext_s)(void *, const char *, LDAPModU **, LDAPControlU **, LDAPControlU **);
-    int (CDECL *ldap_msgfree)(void *);
-    char * (CDECL *ldap_next_attribute)(void *, void *, void *);
-    void * (CDECL *ldap_next_entry)(void *, void *);
-    void * (CDECL *ldap_next_reference)(void *, void *);
-    int (CDECL *ldap_parse_extended_result)(void *, void *, char **, struct bervalU **, int);
-    int (CDECL *ldap_parse_reference)(void *, void *, char ***, LDAPControlU ***, int);
-    int (CDECL *ldap_parse_result)(void *, void *, int *, char **, char **, char ***, LDAPControlU ***, int);
-    int (CDECL *ldap_parse_sortresponse_control)(void *, LDAPControlU *, int *, char **);
-    int (CDECL *ldap_parse_vlvresponse_control)(void *, LDAPControlU *, int *, int *, struct bervalU **, int *);
-    int (CDECL *ldap_rename)(void *, const char *, const char *, const char *, int, LDAPControlU **, LDAPControlU **,
-                             ULONG *);
-    int (CDECL *ldap_rename_s)(void *, const char *, const char *, const char *, int, LDAPControlU **, LDAPControlU **);
-    int (CDECL *ldap_result)(void *, int, int, struct timevalU *, void **);
-    int (CDECL *ldap_sasl_bind)(void *, const char *, const char *, struct bervalU *, LDAPControlU **, LDAPControlU **,
-                                int *);
-    int (CDECL *ldap_sasl_bind_s)(void *, const char *, const char *, struct bervalU *, LDAPControlU **,
-                                  LDAPControlU **, struct bervalU **);
-    int (CDECL *ldap_sasl_interactive_bind_s)(void *, const char *, const char *, LDAPControlU **, LDAPControlU **,
-                                              unsigned int, void *);
-    int (CDECL *ldap_search_ext)(void *, const char *, int, const char *, char **, int, LDAPControlU **,
-                                 LDAPControlU **, struct timevalU *, int, ULONG *);
-    int (CDECL *ldap_search_ext_s)(void *, const char *, int, const char *, char **, int, LDAPControlU **,
-                                   LDAPControlU **, struct timevalU *, int, void **);
-    int (CDECL *ldap_set_option)(void *, int, const void *);
-    int (CDECL *ldap_start_tls_s)(void *, LDAPControlU **, LDAPControlU **);
-    int (CDECL *ldap_unbind_ext)(void *, LDAPControlU **, LDAPControlU **);
-    int (CDECL *ldap_unbind_ext_s)(void *, LDAPControlU **, LDAPControlU **);
-    void (CDECL *ldap_value_free_len)(struct bervalU **);
+    int (CDECL *fn_ldap_abandon_ext)(void *, int, LDAPControlU **, LDAPControlU **);
+    int (CDECL *fn_ldap_add_ext)(void *, const char *, LDAPModU **, LDAPControlU **, LDAPControlU **, ULONG *);
+    int (CDECL *fn_ldap_add_ext_s)(void *, const char *, LDAPModU **, LDAPControlU **, LDAPControlU **);
+    int (CDECL *fn_ldap_compare_ext)(void *, const char *, const char *, struct bervalU *, LDAPControlU **,
+                                     LDAPControlU **, ULONG *);
+    int (CDECL *fn_ldap_compare_ext_s)(void *, const char *, const char *, struct bervalU *, LDAPControlU **,
+                                       LDAPControlU **);
+    void (CDECL *fn_ldap_control_free)(LDAPControlU *);
+    void (CDECL *fn_ldap_controls_free)(LDAPControlU **);
+    int (CDECL *fn_ldap_count_entries)(void *, void *);
+    int (CDECL *fn_ldap_count_references)(void *, void *);
+    int (CDECL *fn_ldap_count_values_len)(struct bervalU **);
+    int (CDECL *fn_ldap_create_sort_control)(void *, LDAPSortKeyU **, int, LDAPControlU **);
+    int (CDECL *fn_ldap_create_vlv_control)(void *, LDAPVLVInfoU *, LDAPControlU **);
+    int (CDECL *fn_ldap_delete_ext)(void *, const char *, LDAPControlU **, LDAPControlU **, ULONG *);
+    int (CDECL *fn_ldap_delete_ext_s)(void *, const char *, LDAPControlU **, LDAPControlU **);
+    char * (CDECL *fn_ldap_dn2ufn)(const char *);
+    char ** (CDECL *fn_ldap_explode_dn)(const char *, int);
+    int (CDECL *fn_ldap_extended_operation)(void *, const char *, struct bervalU *, LDAPControlU **,
+                                            LDAPControlU **, ULONG *);
+    int (CDECL *fn_ldap_extended_operation_s)(void *, const char *, struct bervalU *, LDAPControlU **,
+                                              LDAPControlU **, char **, struct bervalU **);
+    char * (CDECL *fn_ldap_get_dn)(void *, void *);
+    int (CDECL *fn_ldap_get_option)(void *, int, void *);
+    struct bervalU ** (CDECL *fn_ldap_get_values_len)(void *, void *, const char *);
+    int (CDECL *fn_ldap_initialize)(void **, const char *);
+    char * (CDECL *fn_ldap_first_attribute)(void *, void *, void **);
+    void * (CDECL *fn_ldap_first_entry)(void *, void *);
+    void * (CDECL *fn_ldap_first_reference)(void *, void *);
+    void (CDECL *fn_ldap_memfree)(void *);
+    void (CDECL *fn_ldap_memvfree)(void **);
+    int (CDECL *fn_ldap_modify_ext)(void *, const char *, LDAPModU **, LDAPControlU **, LDAPControlU **, ULONG *);
+    int (CDECL *fn_ldap_modify_ext_s)(void *, const char *, LDAPModU **, LDAPControlU **, LDAPControlU **);
+    int (CDECL *fn_ldap_msgfree)(void *);
+    char * (CDECL *fn_ldap_next_attribute)(void *, void *, void *);
+    void * (CDECL *fn_ldap_next_entry)(void *, void *);
+    void * (CDECL *fn_ldap_next_reference)(void *, void *);
+    int (CDECL *fn_ldap_parse_extended_result)(void *, void *, char **, struct bervalU **, int);
+    int (CDECL *fn_ldap_parse_reference)(void *, void *, char ***, LDAPControlU ***, int);
+    int (CDECL *fn_ldap_parse_result)(void *, void *, int *, char **, char **, char ***, LDAPControlU ***, int);
+    int (CDECL *fn_ldap_parse_sortresponse_control)(void *, LDAPControlU *, int *, char **);
+    int (CDECL *fn_ldap_parse_vlvresponse_control)(void *, LDAPControlU *, int *, int *, struct bervalU **, int *);
+    int (CDECL *fn_ldap_rename)(void *, const char *, const char *, const char *, int, LDAPControlU **,
+                                LDAPControlU **, ULONG *);
+    int (CDECL *fn_ldap_rename_s)(void *, const char *, const char *, const char *, int, LDAPControlU **,
+                                  LDAPControlU **);
+    int (CDECL *fn_ldap_result)(void *, int, int, struct timevalU *, void **);
+    int (CDECL *fn_ldap_sasl_bind)(void *, const char *, const char *, struct bervalU *, LDAPControlU **,
+                                   LDAPControlU **, int *);
+    int (CDECL *fn_ldap_sasl_bind_s)(void *, const char *, const char *, struct bervalU *, LDAPControlU **,
+                                     LDAPControlU **, struct bervalU **);
+    int (CDECL *fn_ldap_sasl_interactive_bind_s)(void *, const char *, const char *, LDAPControlU **,
+                                                 LDAPControlU **, unsigned int, void *);
+    int (CDECL *fn_ldap_search_ext)(void *, const char *, int, const char *, char **, int, LDAPControlU **,
+                                    LDAPControlU **, struct timevalU *, int, ULONG *);
+    int (CDECL *fn_ldap_search_ext_s)(void *, const char *, int, const char *, char **, int, LDAPControlU **,
+                                      LDAPControlU **, struct timevalU *, int, void **);
+    int (CDECL *fn_ldap_set_option)(void *, int, const void *);
+    int (CDECL *fn_ldap_start_tls_s)(void *, LDAPControlU **, LDAPControlU **);
+    int (CDECL *fn_ldap_unbind_ext)(void *, LDAPControlU **, LDAPControlU **);
+    int (CDECL *fn_ldap_unbind_ext_s)(void *, LDAPControlU **, LDAPControlU **);
+    void (CDECL *fn_ldap_value_free_len)(struct bervalU **);
 };
 
 extern int CDECL sasl_interact_cb(void *, unsigned int, void *, void *) DECLSPEC_HIDDEN;
diff --git a/dlls/wldap32/misc.c b/dlls/wldap32/misc.c
index 330355e573c2..dbda4609ff2f 100644
--- a/dlls/wldap32/misc.c
+++ b/dlls/wldap32/misc.c
@@ -23,6 +23,7 @@
 #include "windef.h"
 #include "winbase.h"
 #include "winnls.h"
+#include "winldap.h"
 
 #include "wine/debug.h"
 #include "winldap_private.h"
@@ -42,12 +43,12 @@ WINE_DEFAULT_DEBUG_CHANNEL(wldap32);
  *  Success: LDAP_SUCCESS
  *  Failure: An LDAP error code.
  */
-ULONG CDECL WLDAP32_ldap_abandon( WLDAP32_LDAP *ld, ULONG msgid )
+ULONG CDECL ldap_abandon( LDAP *ld, ULONG msgid )
 {
     TRACE( "(%p, 0x%08x)\n", ld, msgid );
 
     if (!ld) return ~0u;
-    return map_error( ldap_funcs->ldap_abandon_ext( ld->ld, msgid, NULL, NULL ) );
+    return map_error( ldap_funcs->fn_ldap_abandon_ext( CTX(ld), msgid, NULL, NULL ) );
 }
 
 /***********************************************************************
@@ -55,15 +56,15 @@ ULONG CDECL WLDAP32_ldap_abandon( WLDAP32_LDAP *ld, ULONG msgid )
  *
  * See ldap_check_filterW.
  */
-ULONG CDECL ldap_check_filterA( WLDAP32_LDAP *ld, char *filter )
+ULONG CDECL ldap_check_filterA( LDAP *ld, char *filter )
 {
     ULONG ret;
     WCHAR *filterW = NULL;
 
     TRACE( "(%p, %s)\n", ld, debugstr_a(filter) );
 
-    if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
-    if (filter && !(filterW = strAtoW( filter ))) return WLDAP32_LDAP_NO_MEMORY;
+    if (!ld) return LDAP_PARAM_ERROR;
+    if (filter && !(filterW = strAtoW( filter ))) return LDAP_NO_MEMORY;
 
     ret = ldap_check_filterW( ld, filterW );
 
@@ -84,12 +85,12 @@ ULONG CDECL ldap_check_filterA( WLDAP32_LDAP *ld, char *filter )
  *  Success: LDAP_SUCCESS
  *  Failure: An LDAP error code.
  */
-ULONG CDECL ldap_check_filterW( WLDAP32_LDAP *ld, WCHAR *filter )
+ULONG CDECL ldap_check_filterW( LDAP *ld, WCHAR *filter )
 {
     TRACE( "(%p, %s)\n", ld, debugstr_w(filter) );
 
-    if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
-    return WLDAP32_LDAP_SUCCESS; /* FIXME: do some checks */
+    if (!ld) return LDAP_PARAM_ERROR;
+    return LDAP_SUCCESS; /* FIXME: do some checks */
 }
 
 /***********************************************************************
@@ -98,7 +99,7 @@ ULONG CDECL ldap_check_filterW( WLDAP32_LDAP *ld, WCHAR *filter )
 ULONG CDECL ldap_cleanup( HANDLE instance )
 {
     TRACE( "(%p)\n", instance );
-    return WLDAP32_LDAP_SUCCESS;
+    return LDAP_SUCCESS;
 }
 
 /***********************************************************************
@@ -114,7 +115,7 @@ ULONG CDECL ldap_cleanup( HANDLE instance )
  *  Success: Pointer to an LDAP context.
  *  Failure: NULL
  */
-WLDAP32_LDAP * CDECL ldap_conn_from_msg( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *res )
+LDAP * CDECL ldap_conn_from_msg( LDAP *ld, LDAPMessage *res )
 {
     TRACE( "(%p, %p)\n", ld, res );
 
@@ -135,12 +136,12 @@ WLDAP32_LDAP * CDECL ldap_conn_from_msg( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *
  *  Success: The number of entries.
  *  Failure: ~0u
  */
-ULONG CDECL WLDAP32_ldap_count_entries( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *res )
+ULONG CDECL ldap_count_entries( LDAP *ld, LDAPMessage *res )
 {
     TRACE( "(%p, %p)\n", ld, res );
 
     if (!ld) return ~0u;
-    return ldap_funcs->ldap_count_entries( ld->ld, res->Request );
+    return ldap_funcs->fn_ldap_count_entries( CTX(ld), MSG(res) );
 }
 
 /***********************************************************************
@@ -156,12 +157,12 @@ ULONG CDECL WLDAP32_ldap_count_entries( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *r
  *  Success: The number of references.
  *  Failure: ~0u
  */
-ULONG CDECL WLDAP32_ldap_count_references( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *res )
+ULONG CDECL ldap_count_references( LDAP *ld, LDAPMessage *res )
 {
     TRACE( "(%p, %p)\n", ld, res );
 
     if (!ld) return 0;
-    return ldap_funcs->ldap_count_references( ld->ld, res->Request );
+    return ldap_funcs->fn_ldap_count_references( CTX(ld), MSG(res) );
 }
 
 static ULONG get_escape_size( PCHAR src, ULONG srclen )
@@ -213,10 +214,10 @@ ULONG CDECL ldap_escape_filter_elementA( char *src, ULONG srclen, char *dst, ULO
     TRACE( "(%p, 0x%08x, %p, 0x%08x)\n", src, srclen, dst, dstlen );
 
     if (!dst) return len;
-    if (!src || dstlen < len) return WLDAP32_LDAP_PARAM_ERROR;
+    if (!src || dstlen < len) return LDAP_PARAM_ERROR;
 
     escape_filter_element( src, srclen, dst );
-    return WLDAP32_LDAP_SUCCESS;
+    return LDAP_SUCCESS;
 }
 
 /***********************************************************************
@@ -243,7 +244,7 @@ ULONG CDECL ldap_escape_filter_elementW( char *src, ULONG srclen, WCHAR *dst, UL
     if (!dst) return len;
 
     /* no matter what you throw at it, this is what native returns */
-    return WLDAP32_LDAP_PARAM_ERROR;
+    return LDAP_PARAM_ERROR;
 }
 
 /***********************************************************************
@@ -251,7 +252,7 @@ ULONG CDECL ldap_escape_filter_elementW( char *src, ULONG srclen, WCHAR *dst, UL
  *
  * See ldap_first_attributeW.
  */
-char * CDECL ldap_first_attributeA( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *entry, WLDAP32_BerElement **ber )
+char * CDECL ldap_first_attributeA( LDAP *ld, LDAPMessage *entry, BerElement **ber )
 {
     char *ret = NULL;
     WCHAR *retW;
@@ -260,7 +261,7 @@ char * CDECL ldap_first_attributeA( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *entry
 
     if (!ld || !entry) return NULL;
 
-    retW = ldap_first_attributeW( ld, entry->Request, ber );
+    retW = ldap_first_attributeW( ld, entry, ber );
     if (retW)
     {
         ret = strWtoA( retW );
@@ -287,10 +288,10 @@ char * CDECL ldap_first_attributeA( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *entry
  * NOTES
  *  Use ldap_memfree to free the returned string.
  */
-WCHAR * CDECL ldap_first_attributeW( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *entry, WLDAP32_BerElement **ptr )
+WCHAR * CDECL ldap_first_attributeW( LDAP *ld, LDAPMessage *entry, BerElement **ptr )
 {
     WCHAR *ret = NULL;
-    WLDAP32_BerElement *ber;
+    BerElement *ber;
     char *retU;
     void *berU;
 
@@ -298,15 +299,15 @@ WCHAR * CDECL ldap_first_attributeW( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *entr
 
     if (!ld || !entry) return NULL;
 
-    retU = ldap_funcs->ldap_first_attribute( ld->ld, entry->Request, &berU );
+    retU = ldap_funcs->fn_ldap_first_attribute( CTX(ld), MSG(entry), &berU );
     if (retU && (ber = malloc( sizeof(*ber) )))
     {
-        ber->opaque = (char *)berU;
+        BER(ber) = (char *)berU;
         *ptr = ber;
         ret = strUtoW( retU );
     }
 
-    ldap_funcs->ldap_memfree( retU );
+    ldap_funcs->fn_ldap_memfree( retU );
     return ret;
 }
 
@@ -326,7 +327,7 @@ WCHAR * CDECL ldap_first_attributeW( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *entr
  * NOTES
  *  The returned entry will be freed when the message is freed.
  */
-WLDAP32_LDAPMessage * CDECL WLDAP32_ldap_first_entry( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *res )
+LDAPMessage * CDECL ldap_first_entry( LDAP *ld, LDAPMessage *res )
 {
     void *msgU;
 
@@ -334,10 +335,10 @@ WLDAP32_LDAPMessage * CDECL WLDAP32_ldap_first_entry( WLDAP32_LDAP *ld, WLDAP32_
 
     if (!ld || !res) return NULL;
 
-    msgU = ldap_funcs->ldap_first_entry( ld->ld, res->Request );
+    msgU = ldap_funcs->fn_ldap_first_entry( CTX(ld), MSG(res) );
     if (msgU)
     {
-        assert( msgU == res->Request );
+        assert( msgU == MSG(res) );
         return res;
     }
 
@@ -357,7 +358,7 @@ WLDAP32_LDAPMessage * CDECL WLDAP32_ldap_first_entry( WLDAP32_LDAP *ld, WLDAP32_
  *  Success: The first reference.
  *  Failure: NULL
  */
-WLDAP32_LDAPMessage * CDECL WLDAP32_ldap_first_reference( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *res )
+LDAPMessage * CDECL ldap_first_reference( LDAP *ld, LDAPMessage *res )
 {
     void *msgU;
 
@@ -365,10 +366,10 @@ WLDAP32_LDAPMessage * CDECL WLDAP32_ldap_first_reference( WLDAP32_LDAP *ld, WLDA
 
     if (!ld) return NULL;
 
-    msgU = ldap_funcs->ldap_first_reference( ld->ld, res->Request );
+    msgU = ldap_funcs->fn_ldap_first_reference( CTX(ld), MSG(res) );
     if (msgU)
     {
-        assert( msgU == res->Request );
+        assert( msgU == MSG(res) );
         return res;
     }
 
@@ -408,15 +409,15 @@ void CDECL ldap_memfreeW( WCHAR *block )
  * PARAMS
  *  res [I] Message to be freed.
  */
-ULONG CDECL WLDAP32_ldap_msgfree( WLDAP32_LDAPMessage *res )
+ULONG CDECL ldap_msgfree( LDAPMessage *res )
 {
-    WLDAP32_LDAPMessage *entry, *list = res;
+    LDAPMessage *entry, *list = res;
 
     TRACE( "(%p)\n", res );
 
-    if (!res) return WLDAP32_LDAP_SUCCESS;
+    if (!res) return LDAP_SUCCESS;
 
-    ldap_funcs->ldap_msgfree( res->Request );
+    ldap_funcs->fn_ldap_msgfree( MSG(res) );
     while (list)
     {
         entry = list;
@@ -424,7 +425,7 @@ ULONG CDECL WLDAP32_ldap_msgfree( WLDAP32_LDAPMessage *res )
         free( entry );
     }
 
-    return WLDAP32_LDAP_SUCCESS;
+    return LDAP_SUCCESS;
 }
 
 /***********************************************************************
@@ -432,7 +433,7 @@ ULONG CDECL WLDAP32_ldap_msgfree( WLDAP32_LDAPMessage *res )
  *
  * See ldap_next_attributeW.
  */
-char * CDECL ldap_next_attributeA( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *entry, WLDAP32_BerElement *ptr )
+char * CDECL ldap_next_attributeA( LDAP *ld, LDAPMessage *entry, BerElement *ptr )
 {
     char *ret = NULL;
     WCHAR *retW;
@@ -441,7 +442,7 @@ char * CDECL ldap_next_attributeA( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *entry,
 
     if (!ld || !entry || !ptr) return NULL;
 
-    retW = ldap_next_attributeW( ld, entry->Request, ptr );
+    retW = ldap_next_attributeW( ld, entry, ptr );
     if (retW)
     {
         ret = strWtoA( retW );
@@ -469,7 +470,7 @@ char * CDECL ldap_next_attributeA( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *entry,
  *  Free the returned string after each iteration with ldap_memfree.
  *  When done iterating and when ptr != NULL, call ber_free( ptr, 0 ).
  */
-WCHAR * CDECL ldap_next_attributeW( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *entry, WLDAP32_BerElement *ptr )
+WCHAR * CDECL ldap_next_attributeW( LDAP *ld, LDAPMessage *entry, BerElement *ptr )
 {
     WCHAR *ret = NULL;
     char *retU;
@@ -478,11 +479,11 @@ WCHAR * CDECL ldap_next_attributeW( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *entry
 
     if (!ld || !entry || !ptr) return NULL;
 
-    retU = ldap_funcs->ldap_next_attribute( ld->ld, entry->Request, ptr->opaque );
+    retU = ldap_funcs->fn_ldap_next_attribute( CTX(ld), MSG(entry), BER(ptr) );
     if (retU)
     {
         ret = strUtoW( retU );
-        ldap_funcs->ldap_memfree( retU );
+        ldap_funcs->fn_ldap_memfree( retU );
     }
 
     return ret;
@@ -504,9 +505,9 @@ WCHAR * CDECL ldap_next_attributeW( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *entry
  * NOTES
  *  The returned entry will be freed when the message is freed.
  */
-WLDAP32_LDAPMessage * CDECL WLDAP32_ldap_next_entry( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *entry )
+LDAPMessage * CDECL ldap_next_entry( LDAP *ld, LDAPMessage *entry )
 {
-    WLDAP32_LDAPMessage *msg = NULL;
+    LDAPMessage *msg = NULL;
     void *msgU;
 
     TRACE( "(%p, %p)\n", ld, entry );
@@ -515,10 +516,10 @@ WLDAP32_LDAPMessage * CDECL WLDAP32_ldap_next_entry( WLDAP32_LDAP *ld, WLDAP32_L
 
     if (entry->lm_next) return entry->lm_next;
 
-    msgU = ldap_funcs->ldap_next_entry( ld->ld, entry->Request );
+    msgU = ldap_funcs->fn_ldap_next_entry( CTX(ld), MSG(entry) );
     if (msgU && (msg = calloc( 1, sizeof(*msg) )))
     {
-        msg->Request = msgU;
+        MSG(msg) = msgU;
         entry->lm_next = msg;
     }
 
@@ -541,9 +542,9 @@ WLDAP32_LDAPMessage * CDECL WLDAP32_ldap_next_entry( WLDAP32_LDAP *ld, WLDAP32_L
  * NOTES
  *  The returned entry will be freed when the message is freed.
  */
-WLDAP32_LDAPMessage * CDECL WLDAP32_ldap_next_reference( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *entry )
+LDAPMessage * CDECL ldap_next_reference( LDAP *ld, LDAPMessage *entry )
 {
-    WLDAP32_LDAPMessage *msg = NULL;
+    LDAPMessage *msg = NULL;
     void *msgU;
 
     TRACE( "(%p, %p)\n", ld, entry );
@@ -552,10 +553,10 @@ WLDAP32_LDAPMessage * CDECL WLDAP32_ldap_next_reference( WLDAP32_LDAP *ld, WLDAP
 
     if (entry->lm_next) return entry->lm_next;
 
-    msgU = ldap_funcs->ldap_next_reference( ld->ld, entry->Request );
+    msgU = ldap_funcs->fn_ldap_next_reference( CTX(ld), MSG(entry) );
     if (msgU && (msg = calloc( 1, sizeof(*msg) )))
     {
-        msg->Request = msgU;
+        MSG(msg) = msgU;
         entry->lm_next = msg;
     }
 
@@ -598,10 +599,9 @@ WLDAP32_LDAPMessage * CDECL WLDAP32_ldap_next_reference( WLDAP32_LDAP *ld, WLDAP
  *  to immediately return any available results. Free returned results
  *  with ldap_msgfree.
  */
-ULONG CDECL WLDAP32_ldap_result( WLDAP32_LDAP *ld, ULONG msgid, ULONG all, struct l_timeval *timeout,
-    WLDAP32_LDAPMessage **res )
+ULONG CDECL ldap_result( LDAP *ld, ULONG msgid, ULONG all, struct l_timeval *timeout, LDAPMessage **res )
 {
-    WLDAP32_LDAPMessage *msg;
+    LDAPMessage *msg;
     struct timevalU timeval;
     void *msgU = NULL;
     ULONG ret;
@@ -616,10 +616,10 @@ ULONG CDECL WLDAP32_ldap_result( WLDAP32_LDAP *ld, ULONG msgid, ULONG all, struc
         timeval.tv_usec = timeout->tv_usec;
     }
 
-    ret = ldap_funcs->ldap_result( ld->ld, msgid, all, timeout ? &timeval : NULL, &msgU );
+    ret = ldap_funcs->fn_ldap_result( CTX(ld), msgid, all, timeout ? &timeval : NULL, &msgU );
     if (msgU && (msg = calloc( 1, sizeof(*msg) )))
     {
-        msg->Request = msgU;
+        MSG(msg) = msgU;
         *res = msg;
     }
 
diff --git a/dlls/wldap32/modify.c b/dlls/wldap32/modify.c
index 280989f88b4a..6f56f5a0e871 100644
--- a/dlls/wldap32/modify.c
+++ b/dlls/wldap32/modify.c
@@ -22,6 +22,7 @@
 #include "windef.h"
 #include "winbase.h"
 #include "winnls.h"
+#include "winldap.h"
 
 #include "wine/debug.h"
 #include "winldap_private.h"
@@ -33,9 +34,9 @@ WINE_DEFAULT_DEBUG_CHANNEL(wldap32);
  *
  * See ldap_modifyW.
  */
-ULONG CDECL ldap_modifyA( WLDAP32_LDAP *ld, char *dn, LDAPModA **mods )
+ULONG CDECL ldap_modifyA( LDAP *ld, char *dn, LDAPModA **mods )
 {
-    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
+    ULONG ret = LDAP_NO_MEMORY;
     WCHAR *dnW = NULL;
     LDAPModW **modsW = NULL;
 
@@ -74,14 +75,14 @@ ULONG CDECL ldap_modifyA( WLDAP32_LDAP *ld, char *dn, LDAPModA **mods )
  *  the operation. Cancel the operation by calling ldap_abandon
  *  with the message ID.
  */
-ULONG CDECL ldap_modifyW( WLDAP32_LDAP *ld, WCHAR *dn, LDAPModW **mods )
+ULONG CDECL ldap_modifyW( LDAP *ld, WCHAR *dn, LDAPModW **mods )
 {
     ULONG ret, msg;
 
     TRACE( "(%p, %s, %p)\n", ld, debugstr_w(dn), mods );
 
     ret = ldap_modify_extW( ld, dn, mods, NULL, NULL, &msg );
-    if (ret == WLDAP32_LDAP_SUCCESS) return msg;
+    if (ret == LDAP_SUCCESS) return msg;
     return ~0u;
 }
 
@@ -90,10 +91,10 @@ ULONG CDECL ldap_modifyW( WLDAP32_LDAP *ld, WCHAR *dn, LDAPModW **mods )
  *
  * See ldap_modify_extW.
  */
-ULONG CDECL ldap_modify_extA( WLDAP32_LDAP *ld, char *dn, LDAPModA **mods,
-    LDAPControlA **serverctrls, LDAPControlA **clientctrls, ULONG *message )
+ULONG CDECL ldap_modify_extA( LDAP *ld, char *dn, LDAPModA **mods, LDAPControlA **serverctrls,
+    LDAPControlA **clientctrls, ULONG *message )
 {
-    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
+    ULONG ret = LDAP_NO_MEMORY;
     WCHAR *dnW = NULL;
     LDAPModW **modsW = NULL;
     LDAPControlW **serverctrlsW = NULL, **clientctrlsW = NULL;
@@ -140,10 +141,10 @@ ULONG CDECL ldap_modify_extA( WLDAP32_LDAP *ld, char *dn, LDAPModA **mods,
  *  the operation. The serverctrls and clientctrls parameters are
  *  optional and should be set to NULL if not used.
  */
-ULONG CDECL ldap_modify_extW( WLDAP32_LDAP *ld, WCHAR *dn, LDAPModW **mods,
-    LDAPControlW **serverctrls, LDAPControlW **clientctrls, ULONG *message )
+ULONG CDECL ldap_modify_extW( LDAP *ld, WCHAR *dn, LDAPModW **mods, LDAPControlW **serverctrls,
+    LDAPControlW **clientctrls, ULONG *message )
 {
-    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
+    ULONG ret = LDAP_NO_MEMORY;
     char *dnU = NULL;
     LDAPModU **modsU = NULL;
     LDAPControlU **serverctrlsU = NULL, **clientctrlsU = NULL;
@@ -157,7 +158,7 @@ ULONG CDECL ldap_modify_extW( WLDAP32_LDAP *ld, WCHAR *dn, LDAPModW **mods,
     if (serverctrls && !(serverctrlsU = controlarrayWtoU( serverctrls ))) goto exit;
     if (clientctrls && !(clientctrlsU = controlarrayWtoU( clientctrls ))) goto exit;
 
-    ret = map_error( ldap_funcs->ldap_modify_ext( ld->ld, dnU, modsU, serverctrlsU, clientctrlsU, message ) );
+    ret = map_error( ldap_funcs->fn_ldap_modify_ext( CTX(ld), dnU, modsU, serverctrlsU, clientctrlsU, message ) );
 
 exit:
     free( dnU );
@@ -172,17 +173,17 @@ ULONG CDECL ldap_modify_extW( WLDAP32_LDAP *ld, WCHAR *dn, LDAPModW **mods,
  *
  * See ldap_modify_ext_sW.
  */
-ULONG CDECL ldap_modify_ext_sA( WLDAP32_LDAP *ld, char *dn, LDAPModA **mods,
-    LDAPControlA **serverctrls, LDAPControlA **clientctrls )
+ULONG CDECL ldap_modify_ext_sA( LDAP *ld, char *dn, LDAPModA **mods, LDAPControlA **serverctrls,
+    LDAPControlA **clientctrls )
 {
-    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
+    ULONG ret = LDAP_NO_MEMORY;
     WCHAR *dnW = NULL;
     LDAPModW **modsW = NULL;
     LDAPControlW **serverctrlsW = NULL, **clientctrlsW = NULL;
 
     TRACE( "(%p, %s, %p, %p, %p)\n", ld, debugstr_a(dn), mods, serverctrls, clientctrls );
 
-    if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
+    if (!ld) return LDAP_PARAM_ERROR;
 
     if (dn && !(dnW = strAtoW( dn ))) goto exit;
     if (mods && !(modsW = modarrayAtoW( mods ))) goto exit;
@@ -220,24 +221,24 @@ ULONG CDECL ldap_modify_ext_sA( WLDAP32_LDAP *ld, char *dn, LDAPModA **mods,
  *  The serverctrls and clientctrls parameters are optional and
  *  should be set to NULL if not used.
  */
-ULONG CDECL ldap_modify_ext_sW( WLDAP32_LDAP *ld, WCHAR *dn, LDAPModW **mods,
-    LDAPControlW **serverctrls, LDAPControlW **clientctrls )
+ULONG CDECL ldap_modify_ext_sW( LDAP *ld, WCHAR *dn, LDAPModW **mods, LDAPControlW **serverctrls,
+    LDAPControlW **clientctrls )
 {
-    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
+    ULONG ret = LDAP_NO_MEMORY;
     char *dnU = NULL;
     LDAPModU **modsU = NULL;
     LDAPControlU **serverctrlsU = NULL, **clientctrlsU = NULL;
 
     TRACE( "(%p, %s, %p, %p, %p)\n", ld, debugstr_w(dn), mods, serverctrls, clientctrls );
 
-    if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
+    if (!ld) return LDAP_PARAM_ERROR;
 
     if (dn && !(dnU = strWtoU( dn ))) goto exit;
     if (mods && !(modsU = modarrayWtoU( mods ))) goto exit;
     if (serverctrls && !(serverctrlsU = controlarrayWtoU( serverctrls ))) goto exit;
     if (clientctrls && !(clientctrlsU = controlarrayWtoU( clientctrls ))) goto exit;
 
-    ret = map_error( ldap_funcs->ldap_modify_ext_s( ld->ld, dnU, modsU, serverctrlsU, clientctrlsU ) );
+    ret = map_error( ldap_funcs->fn_ldap_modify_ext_s( CTX(ld), dnU, modsU, serverctrlsU, clientctrlsU ) );
 
 exit:
     free( dnU );
@@ -252,15 +253,15 @@ ULONG CDECL ldap_modify_ext_sW( WLDAP32_LDAP *ld, WCHAR *dn, LDAPModW **mods,
  *
  * See ldap_modify_sW.
  */
-ULONG CDECL ldap_modify_sA( WLDAP32_LDAP *ld, char *dn, LDAPModA **mods )
+ULONG CDECL ldap_modify_sA( LDAP *ld, char *dn, LDAPModA **mods )
 {
-    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
+    ULONG ret = LDAP_NO_MEMORY;
     WCHAR *dnW = NULL;
     LDAPModW **modsW = NULL;
 
     TRACE( "(%p, %s, %p)\n", ld, debugstr_a(dn), mods );
 
-    if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
+    if (!ld) return LDAP_PARAM_ERROR;
 
     if (dn && !(dnW = strAtoW( dn ))) goto exit;
     if (mods && !(modsW = modarrayAtoW( mods ))) goto exit;
@@ -288,7 +289,7 @@ ULONG CDECL ldap_modify_sA( WLDAP32_LDAP *ld, char *dn, LDAPModA **mods )
  *  Success: LDAP_SUCCESS
  *  Failure: An LDAP error code.
  */
-ULONG CDECL ldap_modify_sW( WLDAP32_LDAP *ld, WCHAR *dn, LDAPModW **mods )
+ULONG CDECL ldap_modify_sW( LDAP *ld, WCHAR *dn, LDAPModW **mods )
 {
     TRACE( "(%p, %s, %p)\n", ld, debugstr_w(dn), mods );
     return ldap_modify_ext_sW( ld, dn, mods, NULL, NULL );
diff --git a/dlls/wldap32/modrdn.c b/dlls/wldap32/modrdn.c
index 937bd651f5ee..3e1969163d73 100644
--- a/dlls/wldap32/modrdn.c
+++ b/dlls/wldap32/modrdn.c
@@ -22,6 +22,7 @@
 #include "windef.h"
 #include "winbase.h"
 #include "winnls.h"
+#include "winldap.h"
 
 #include "wine/debug.h"
 #include "winldap_private.h"
@@ -33,9 +34,9 @@ WINE_DEFAULT_DEBUG_CHANNEL(wldap32);
  *
  * See ldap_modrdnW.
  */
-ULONG CDECL ldap_modrdnA( WLDAP32_LDAP *ld, char *dn, char *newdn )
+ULONG CDECL ldap_modrdnA( LDAP *ld, char *dn, char *newdn )
 {
-    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
+    ULONG ret = LDAP_NO_MEMORY;
     WCHAR *dnW = NULL, *newdnW = NULL;
 
     TRACE( "(%p, %s, %s)\n", ld, debugstr_a(dn), debugstr_a(newdn) );
@@ -72,7 +73,7 @@ ULONG CDECL ldap_modrdnA( WLDAP32_LDAP *ld, char *dn, char *newdn )
  *  the operation. Cancel the operation by calling ldap_abandon
  *  with the message ID.
  */
-ULONG CDECL ldap_modrdnW( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *newdn )
+ULONG CDECL ldap_modrdnW( LDAP *ld, WCHAR *dn, WCHAR *newdn )
 {
     TRACE( "(%p, %s, %s)\n", ld, debugstr_w(dn), debugstr_w(newdn) );
     return ldap_modrdn2W( ld, dn, newdn, 1 );
@@ -83,9 +84,9 @@ ULONG CDECL ldap_modrdnW( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *newdn )
  *
  * See ldap_modrdn2W.
  */
-ULONG CDECL ldap_modrdn2A( WLDAP32_LDAP *ld, char *dn, char *newdn, int delete )
+ULONG CDECL ldap_modrdn2A( LDAP *ld, char *dn, char *newdn, int delete )
 {
-    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
+    ULONG ret = LDAP_NO_MEMORY;
     WCHAR *dnW = NULL, *newdnW = NULL;
 
     TRACE( "(%p, %s, %p, 0x%02x)\n", ld, debugstr_a(dn), newdn, delete );
@@ -123,9 +124,9 @@ ULONG CDECL ldap_modrdn2A( WLDAP32_LDAP *ld, char *dn, char *newdn, int delete )
  *  the operation. Cancel the operation by calling ldap_abandon
  *  with the message ID.
  */
-ULONG CDECL ldap_modrdn2W( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *newdn, int delete )
+ULONG CDECL ldap_modrdn2W( LDAP *ld, WCHAR *dn, WCHAR *newdn, int delete )
 {
-    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
+    ULONG ret = LDAP_NO_MEMORY;
     char *dnU = NULL, *newdnU = NULL;
     ULONG msg;
 
@@ -136,8 +137,8 @@ ULONG CDECL ldap_modrdn2W( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *newdn, int delete
     if (dn && !(dnU = strWtoU( dn ))) goto exit;
     if (!(newdnU = strWtoU( newdn ))) goto exit;
 
-    ret = ldap_funcs->ldap_rename( ld->ld, dnU, newdnU, NULL, delete, NULL, NULL, &msg );
-    if (ret == WLDAP32_LDAP_SUCCESS)
+    ret = ldap_funcs->fn_ldap_rename( CTX(ld), dnU, newdnU, NULL, delete, NULL, NULL, &msg );
+    if (ret == LDAP_SUCCESS)
         ret = msg;
     else
         ret = ~0u;
@@ -153,14 +154,14 @@ ULONG CDECL ldap_modrdn2W( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *newdn, int delete
  *
  * See ldap_modrdn2_sW.
  */
-ULONG CDECL ldap_modrdn2_sA( WLDAP32_LDAP *ld, char *dn, char *newdn, int delete )
+ULONG CDECL ldap_modrdn2_sA( LDAP *ld, char *dn, char *newdn, int delete )
 {
-    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
+    ULONG ret = LDAP_NO_MEMORY;
     WCHAR *dnW = NULL, *newdnW = NULL;
 
     TRACE( "(%p, %s, %p, 0x%02x)\n", ld, debugstr_a(dn), newdn, delete );
 
-    if (!ld || !newdn) return WLDAP32_LDAP_PARAM_ERROR;
+    if (!ld || !newdn) return LDAP_PARAM_ERROR;
 
     if (dn && !(dnW = strAtoW( dn ))) goto exit;
     if (!(newdnW = strAtoW( newdn ))) goto exit;
@@ -188,19 +189,19 @@ ULONG CDECL ldap_modrdn2_sA( WLDAP32_LDAP *ld, char *dn, char *newdn, int delete
  *  Success: LDAP_SUCCESS
  *  Failure: An LDAP error code.
  */
-ULONG CDECL ldap_modrdn2_sW( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *newdn, int delete )
+ULONG CDECL ldap_modrdn2_sW( LDAP *ld, WCHAR *dn, WCHAR *newdn, int delete )
 {
-    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
+    ULONG ret = LDAP_NO_MEMORY;
     char *dnU = NULL, *newdnU = NULL;
 
     TRACE( "(%p, %s, %p, 0x%02x)\n", ld, debugstr_w(dn), newdn, delete );
 
-    if (!ld || !newdn) return WLDAP32_LDAP_PARAM_ERROR;
+    if (!ld || !newdn) return LDAP_PARAM_ERROR;
 
     if (dn && !(dnU = strWtoU( dn ))) goto exit;
     if (!(newdnU = strWtoU( newdn ))) goto exit;
 
-    ret = map_error( ldap_funcs->ldap_rename_s( ld->ld, dnU, newdnU, NULL, delete, NULL, NULL ));
+    ret = map_error( ldap_funcs->fn_ldap_rename_s( CTX(ld), dnU, newdnU, NULL, delete, NULL, NULL ));
 
 exit:
     free( dnU );
@@ -213,14 +214,14 @@ ULONG CDECL ldap_modrdn2_sW( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *newdn, int dele
  *
  * See ldap_modrdn_sW.
  */
-ULONG CDECL ldap_modrdn_sA( WLDAP32_LDAP *ld, char *dn, char *newdn )
+ULONG CDECL ldap_modrdn_sA( LDAP *ld, char *dn, char *newdn )
 {
-    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
+    ULONG ret = LDAP_NO_MEMORY;
     WCHAR *dnW = NULL, *newdnW = NULL;
 
     TRACE( "(%p, %s, %p)\n", ld, debugstr_a(dn), newdn );
 
-    if (!ld || !newdn) return WLDAP32_LDAP_PARAM_ERROR;
+    if (!ld || !newdn) return LDAP_PARAM_ERROR;
 
     if (dn && !(dnW = strAtoW( dn ))) goto exit;
     if (!(newdnW = strAtoW( newdn ))) goto exit;
@@ -247,7 +248,7 @@ ULONG CDECL ldap_modrdn_sA( WLDAP32_LDAP *ld, char *dn, char *newdn )
  *  Success: LDAP_SUCCESS
  *  Failure: An LDAP error code.
  */
-ULONG CDECL ldap_modrdn_sW( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *newdn )
+ULONG CDECL ldap_modrdn_sW( LDAP *ld, WCHAR *dn, WCHAR *newdn )
 {
     TRACE( "(%p, %s, %p)\n", ld, debugstr_w(dn), newdn );
     return ldap_modrdn2_sW( ld, dn, newdn, 1 );
diff --git a/dlls/wldap32/option.c b/dlls/wldap32/option.c
index f307837d83a4..1037b73174bb 100644
--- a/dlls/wldap32/option.c
+++ b/dlls/wldap32/option.c
@@ -22,45 +22,50 @@
 #include "windef.h"
 #include "winbase.h"
 #include "winnls.h"
+#include "winldap.h"
 
 #include "wine/debug.h"
 #include "winldap_private.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(wldap32);
 
+#ifndef LDAP_OPT_SERVER_CONTROLS
+#define LDAP_OPT_SERVER_CONTROLS 0x0012
+#endif
+
 /***********************************************************************
  *      ldap_get_optionA     (WLDAP32.@)
  *
  * See ldap_get_optionW.
  */
-ULONG CDECL ldap_get_optionA( WLDAP32_LDAP *ld, int option, void *value )
+ULONG CDECL ldap_get_optionA( LDAP *ld, int option, void *value )
 {
     ULONG ret;
 
     TRACE( "(%p, 0x%08x, %p)\n", ld, option, value );
 
-    if (!ld || !value) return WLDAP32_LDAP_PARAM_ERROR;
+    if (!ld || !value) return LDAP_PARAM_ERROR;
 
     switch (option)
     {
-    case WLDAP32_LDAP_OPT_API_FEATURE_INFO:
+    case LDAP_OPT_API_FEATURE_INFO:
     {
         LDAPAPIFeatureInfoW featureW;
         LDAPAPIFeatureInfoA *featureA = value;
 
-        if (!featureA->ldapaif_name) return WLDAP32_LDAP_PARAM_ERROR;
+        if (!featureA->ldapaif_name) return LDAP_PARAM_ERROR;
 
         featureW.ldapaif_info_version = featureA->ldapaif_info_version;
-        if (!(featureW.ldapaif_name = strAtoW( featureA->ldapaif_name ))) return WLDAP32_LDAP_NO_MEMORY;
+        if (!(featureW.ldapaif_name = strAtoW( featureA->ldapaif_name ))) return LDAP_NO_MEMORY;
         featureW.ldapaif_version = 0;
 
         ret = ldap_get_optionW( ld, option, &featureW );
 
-        if (ret == WLDAP32_LDAP_SUCCESS) featureA->ldapaif_version = featureW.ldapaif_version;
+        if (ret == LDAP_SUCCESS) featureA->ldapaif_version = featureW.ldapaif_version;
         free( featureW.ldapaif_name );
         return ret;
     }
-    case WLDAP32_LDAP_OPT_API_INFO:
+    case LDAP_OPT_API_INFO:
     {
         LDAPAPIInfoW infoW;
         LDAPAPIInfoA *infoA = value;
@@ -69,17 +74,17 @@ ULONG CDECL ldap_get_optionA( WLDAP32_LDAP *ld, int option, void *value )
         infoW.ldapai_info_version = infoA->ldapai_info_version;
 
         ret = ldap_get_optionW( ld, option, &infoW );
-        if (ret == WLDAP32_LDAP_SUCCESS)
+        if (ret == LDAP_SUCCESS)
         {
             infoA->ldapai_api_version = infoW.ldapai_api_version;
             infoA->ldapai_protocol_version = infoW.ldapai_protocol_version;
 
             if (infoW.ldapai_extensions && !(infoA->ldapai_extensions = strarrayWtoA( infoW.ldapai_extensions )))
-                return WLDAP32_LDAP_NO_MEMORY;
+                return LDAP_NO_MEMORY;
             if (infoW.ldapai_vendor_name && !(infoA->ldapai_vendor_name = strWtoA( infoW.ldapai_vendor_name )))
             {
                 ldap_value_freeW( infoW.ldapai_extensions );
-                return WLDAP32_LDAP_NO_MEMORY;
+                return LDAP_NO_MEMORY;
             }
             infoA->ldapai_vendor_version = infoW.ldapai_vendor_version;
 
@@ -89,61 +94,61 @@ ULONG CDECL ldap_get_optionA( WLDAP32_LDAP *ld, int option, void *value )
         return ret;
     }
 
-    case WLDAP32_LDAP_OPT_DEREF:
-    case WLDAP32_LDAP_OPT_DESC:
-    case WLDAP32_LDAP_OPT_ERROR_NUMBER:
-    case WLDAP32_LDAP_OPT_PROTOCOL_VERSION:
-    case WLDAP32_LDAP_OPT_REFERRALS:
-    case WLDAP32_LDAP_OPT_SIZELIMIT:
-    case WLDAP32_LDAP_OPT_TIMELIMIT:
+    case LDAP_OPT_DEREF:
+    case LDAP_OPT_DESC:
+    case LDAP_OPT_ERROR_NUMBER:
+    case LDAP_OPT_PROTOCOL_VERSION:
+    case LDAP_OPT_REFERRALS:
+    case LDAP_OPT_SIZELIMIT:
+    case LDAP_OPT_TIMELIMIT:
         return ldap_get_optionW( ld, option, value );
 
-    case WLDAP32_LDAP_OPT_CACHE_ENABLE:
-    case WLDAP32_LDAP_OPT_CACHE_FN_PTRS:
-    case WLDAP32_LDAP_OPT_CACHE_STRATEGY:
-    case WLDAP32_LDAP_OPT_IO_FN_PTRS:
-    case WLDAP32_LDAP_OPT_REBIND_ARG:
-    case WLDAP32_LDAP_OPT_REBIND_FN:
-    case WLDAP32_LDAP_OPT_RESTART:
-    case WLDAP32_LDAP_OPT_THREAD_FN_PTRS:
-        return WLDAP32_LDAP_LOCAL_ERROR;
-
-    case WLDAP32_LDAP_OPT_AREC_EXCLUSIVE:
-    case WLDAP32_LDAP_OPT_AUTO_RECONNECT:
-    case WLDAP32_LDAP_OPT_CLIENT_CERTIFICATE:
-    case WLDAP32_LDAP_OPT_DNSDOMAIN_NAME:
-    case WLDAP32_LDAP_OPT_ENCRYPT:
-    case WLDAP32_LDAP_OPT_ERROR_STRING:
-    case WLDAP32_LDAP_OPT_FAST_CONCURRENT_BIND:
-    case WLDAP32_LDAP_OPT_GETDSNAME_FLAGS:
-    case WLDAP32_LDAP_OPT_HOST_NAME:
-    case WLDAP32_LDAP_OPT_HOST_REACHABLE:
-    case WLDAP32_LDAP_OPT_PING_KEEP_ALIVE:
-    case WLDAP32_LDAP_OPT_PING_LIMIT:
-    case WLDAP32_LDAP_OPT_PING_WAIT_TIME:
-    case WLDAP32_LDAP_OPT_PROMPT_CREDENTIALS:
-    case WLDAP32_LDAP_OPT_REF_DEREF_CONN_PER_MSG:
-    case WLDAP32_LDAP_OPT_REFERRAL_CALLBACK:
-    case WLDAP32_LDAP_OPT_REFERRAL_HOP_LIMIT:
-    case WLDAP32_LDAP_OPT_ROOTDSE_CACHE:
-    case WLDAP32_LDAP_OPT_SASL_METHOD:
-    case WLDAP32_LDAP_OPT_SECURITY_CONTEXT:
-    case WLDAP32_LDAP_OPT_SEND_TIMEOUT:
-    case WLDAP32_LDAP_OPT_SERVER_CERTIFICATE:
-    case WLDAP32_LDAP_OPT_SERVER_CONTROLS:
-    case WLDAP32_LDAP_OPT_SERVER_ERROR:
-    case WLDAP32_LDAP_OPT_SERVER_EXT_ERROR:
-    case WLDAP32_LDAP_OPT_SIGN:
-    case WLDAP32_LDAP_OPT_SSL:
-    case WLDAP32_LDAP_OPT_SSL_INFO:
-    case WLDAP32_LDAP_OPT_SSPI_FLAGS:
-    case WLDAP32_LDAP_OPT_TCP_KEEPALIVE:
+    case LDAP_OPT_CACHE_ENABLE:
+    case LDAP_OPT_CACHE_FN_PTRS:
+    case LDAP_OPT_CACHE_STRATEGY:
+    case LDAP_OPT_IO_FN_PTRS:
+    case LDAP_OPT_REBIND_ARG:
+    case LDAP_OPT_REBIND_FN:
+    case LDAP_OPT_RESTART:
+    case LDAP_OPT_THREAD_FN_PTRS:
+        return LDAP_LOCAL_ERROR;
+
+    case LDAP_OPT_AREC_EXCLUSIVE:
+    case LDAP_OPT_AUTO_RECONNECT:
+    case LDAP_OPT_CLIENT_CERTIFICATE:
+    case LDAP_OPT_DNSDOMAIN_NAME:
+    case LDAP_OPT_ENCRYPT:
+    case LDAP_OPT_ERROR_STRING:
+    case LDAP_OPT_FAST_CONCURRENT_BIND:
+    case LDAP_OPT_GETDSNAME_FLAGS:
+    case LDAP_OPT_HOST_NAME:
+    case LDAP_OPT_HOST_REACHABLE:
+    case LDAP_OPT_PING_KEEP_ALIVE:
+    case LDAP_OPT_PING_LIMIT:
+    case LDAP_OPT_PING_WAIT_TIME:
+    case LDAP_OPT_PROMPT_CREDENTIALS:
+    case LDAP_OPT_REF_DEREF_CONN_PER_MSG:
+    case LDAP_OPT_REFERRAL_CALLBACK:
+    case LDAP_OPT_REFERRAL_HOP_LIMIT:
+    case LDAP_OPT_ROOTDSE_CACHE:
+    case LDAP_OPT_SASL_METHOD:
+    case LDAP_OPT_SECURITY_CONTEXT:
+    case LDAP_OPT_SEND_TIMEOUT:
+    case LDAP_OPT_SERVER_CERTIFICATE:
+    case LDAP_OPT_SERVER_CONTROLS:
+    case LDAP_OPT_SERVER_ERROR:
+    case LDAP_OPT_SERVER_EXT_ERROR:
+    case LDAP_OPT_SIGN:
+    case LDAP_OPT_SSL:
+    case LDAP_OPT_SSL_INFO:
+    case LDAP_OPT_SSPI_FLAGS:
+    case LDAP_OPT_TCP_KEEPALIVE:
         FIXME( "Unsupported option: 0x%02x\n", option );
-        return WLDAP32_LDAP_NOT_SUPPORTED;
+        return LDAP_NOT_SUPPORTED;
 
     default:
         FIXME( "Unknown option: 0x%02x\n", option );
-        return WLDAP32_LDAP_LOCAL_ERROR;
+        return LDAP_LOCAL_ERROR;
     }
 }
 
@@ -161,34 +166,34 @@ ULONG CDECL ldap_get_optionA( WLDAP32_LDAP *ld, int option, void *value )
  *  Success: LDAP_SUCCESS
  *  Failure: An LDAP error code.
  */
-ULONG CDECL ldap_get_optionW( WLDAP32_LDAP *ld, int option, void *value )
+ULONG CDECL ldap_get_optionW( LDAP *ld, int option, void *value )
 {
     ULONG ret;
 
     TRACE( "(%p, 0x%08x, %p)\n", ld, option, value );
 
-    if (!ld || !value) return WLDAP32_LDAP_PARAM_ERROR;
+    if (!ld || !value) return LDAP_PARAM_ERROR;
 
     switch (option)
     {
-    case WLDAP32_LDAP_OPT_API_FEATURE_INFO:
+    case LDAP_OPT_API_FEATURE_INFO:
     {
         LDAPAPIFeatureInfoU featureU;
         LDAPAPIFeatureInfoW *featureW = value;
 
-        if (!featureW->ldapaif_name) return WLDAP32_LDAP_PARAM_ERROR;
+        if (!featureW->ldapaif_name) return LDAP_PARAM_ERROR;
 
         featureU.ldapaif_info_version = featureW->ldapaif_info_version;
-        if (!(featureU.ldapaif_name = strWtoU( featureW->ldapaif_name ))) return WLDAP32_LDAP_NO_MEMORY;
+        if (!(featureU.ldapaif_name = strWtoU( featureW->ldapaif_name ))) return LDAP_NO_MEMORY;
         featureU.ldapaif_version = 0;
 
-        ret = map_error( ldap_funcs->ldap_get_option( ld->ld, option, &featureU ) );
+        ret = map_error( ldap_funcs->fn_ldap_get_option( CTX(ld), option, &featureU ) );
 
-        if (ret == WLDAP32_LDAP_SUCCESS) featureW->ldapaif_version = featureU.ldapaif_version;
+        if (ret == LDAP_SUCCESS) featureW->ldapaif_version = featureU.ldapaif_version;
         free( featureU.ldapaif_name );
         return ret;
     }
-    case WLDAP32_LDAP_OPT_API_INFO:
+    case LDAP_OPT_API_INFO:
     {
         LDAPAPIInfoU infoU;
         LDAPAPIInfoW *infoW = value;
@@ -196,82 +201,82 @@ ULONG CDECL ldap_get_optionW( WLDAP32_LDAP *ld, int option, void *value )
         memset( &infoU, 0, sizeof(infoU) );
         infoU.ldapai_info_version = infoW->ldapai_info_version;
 
-        ret = map_error( ldap_funcs->ldap_get_option( ld->ld, option, &infoU ) );
-        if (ret == WLDAP32_LDAP_SUCCESS)
+        ret = map_error( ldap_funcs->fn_ldap_get_option( CTX(ld), option, &infoU ) );
+        if (ret == LDAP_SUCCESS)
         {
             infoW->ldapai_api_version = infoU.ldapai_api_version;
             infoW->ldapai_protocol_version = infoU.ldapai_protocol_version;
 
             if (infoU.ldapai_extensions && !(infoW->ldapai_extensions = strarrayUtoW( infoU.ldapai_extensions )))
-                return WLDAP32_LDAP_NO_MEMORY;
+                return LDAP_NO_MEMORY;
             if (infoU.ldapai_vendor_name && !(infoW->ldapai_vendor_name = strUtoW( infoU.ldapai_vendor_name )))
             {
-                ldap_funcs->ldap_memvfree( (void **)infoU.ldapai_extensions );
-                return WLDAP32_LDAP_NO_MEMORY;
+                ldap_funcs->fn_ldap_memvfree( (void **)infoU.ldapai_extensions );
+                return LDAP_NO_MEMORY;
             }
             infoW->ldapai_vendor_version = infoU.ldapai_vendor_version;
 
-            ldap_funcs->ldap_memvfree( (void **)infoU.ldapai_extensions );
-            ldap_funcs->ldap_memfree( infoU.ldapai_vendor_name );
+            ldap_funcs->fn_ldap_memvfree( (void **)infoU.ldapai_extensions );
+            ldap_funcs->fn_ldap_memfree( infoU.ldapai_vendor_name );
         }
         return ret;
     }
 
-    case WLDAP32_LDAP_OPT_DEREF:
-    case WLDAP32_LDAP_OPT_DESC:
-    case WLDAP32_LDAP_OPT_ERROR_NUMBER:
-    case WLDAP32_LDAP_OPT_PROTOCOL_VERSION:
-    case WLDAP32_LDAP_OPT_REFERRALS:
-    case WLDAP32_LDAP_OPT_SIZELIMIT:
-    case WLDAP32_LDAP_OPT_TIMELIMIT:
-        return map_error( ldap_funcs->ldap_get_option( ld->ld, option, value ));
-
-    case WLDAP32_LDAP_OPT_CACHE_ENABLE:
-    case WLDAP32_LDAP_OPT_CACHE_FN_PTRS:
-    case WLDAP32_LDAP_OPT_CACHE_STRATEGY:
-    case WLDAP32_LDAP_OPT_IO_FN_PTRS:
-    case WLDAP32_LDAP_OPT_REBIND_ARG:
-    case WLDAP32_LDAP_OPT_REBIND_FN:
-    case WLDAP32_LDAP_OPT_RESTART:
-    case WLDAP32_LDAP_OPT_THREAD_FN_PTRS:
-        return WLDAP32_LDAP_LOCAL_ERROR;
-
-    case WLDAP32_LDAP_OPT_AREC_EXCLUSIVE:
-    case WLDAP32_LDAP_OPT_AUTO_RECONNECT:
-    case WLDAP32_LDAP_OPT_CLIENT_CERTIFICATE:
-    case WLDAP32_LDAP_OPT_DNSDOMAIN_NAME:
-    case WLDAP32_LDAP_OPT_ENCRYPT:
-    case WLDAP32_LDAP_OPT_ERROR_STRING:
-    case WLDAP32_LDAP_OPT_FAST_CONCURRENT_BIND:
-    case WLDAP32_LDAP_OPT_GETDSNAME_FLAGS:
-    case WLDAP32_LDAP_OPT_HOST_NAME:
-    case WLDAP32_LDAP_OPT_HOST_REACHABLE:
-    case WLDAP32_LDAP_OPT_PING_KEEP_ALIVE:
-    case WLDAP32_LDAP_OPT_PING_LIMIT:
-    case WLDAP32_LDAP_OPT_PING_WAIT_TIME:
-    case WLDAP32_LDAP_OPT_PROMPT_CREDENTIALS:
-    case WLDAP32_LDAP_OPT_REF_DEREF_CONN_PER_MSG:
-    case WLDAP32_LDAP_OPT_REFERRAL_CALLBACK:
-    case WLDAP32_LDAP_OPT_REFERRAL_HOP_LIMIT:
-    case WLDAP32_LDAP_OPT_ROOTDSE_CACHE:
-    case WLDAP32_LDAP_OPT_SASL_METHOD:
-    case WLDAP32_LDAP_OPT_SECURITY_CONTEXT:
-    case WLDAP32_LDAP_OPT_SEND_TIMEOUT:
-    case WLDAP32_LDAP_OPT_SERVER_CERTIFICATE:
-    case WLDAP32_LDAP_OPT_SERVER_CONTROLS:
-    case WLDAP32_LDAP_OPT_SERVER_ERROR:
-    case WLDAP32_LDAP_OPT_SERVER_EXT_ERROR:
-    case WLDAP32_LDAP_OPT_SIGN:
-    case WLDAP32_LDAP_OPT_SSL:
-    case WLDAP32_LDAP_OPT_SSL_INFO:
-    case WLDAP32_LDAP_OPT_SSPI_FLAGS:
-    case WLDAP32_LDAP_OPT_TCP_KEEPALIVE:
+    case LDAP_OPT_DEREF:
+    case LDAP_OPT_DESC:
+    case LDAP_OPT_ERROR_NUMBER:
+    case LDAP_OPT_PROTOCOL_VERSION:
+    case LDAP_OPT_REFERRALS:
+    case LDAP_OPT_SIZELIMIT:
+    case LDAP_OPT_TIMELIMIT:
+        return map_error( ldap_funcs->fn_ldap_get_option( CTX(ld), option, value ));
+
+    case LDAP_OPT_CACHE_ENABLE:
+    case LDAP_OPT_CACHE_FN_PTRS:
+    case LDAP_OPT_CACHE_STRATEGY:
+    case LDAP_OPT_IO_FN_PTRS:
+    case LDAP_OPT_REBIND_ARG:
+    case LDAP_OPT_REBIND_FN:
+    case LDAP_OPT_RESTART:
+    case LDAP_OPT_THREAD_FN_PTRS:
+        return LDAP_LOCAL_ERROR;
+
+    case LDAP_OPT_AREC_EXCLUSIVE:
+    case LDAP_OPT_AUTO_RECONNECT:
+    case LDAP_OPT_CLIENT_CERTIFICATE:
+    case LDAP_OPT_DNSDOMAIN_NAME:
+    case LDAP_OPT_ENCRYPT:
+    case LDAP_OPT_ERROR_STRING:
+    case LDAP_OPT_FAST_CONCURRENT_BIND:
+    case LDAP_OPT_GETDSNAME_FLAGS:
+    case LDAP_OPT_HOST_NAME:
+    case LDAP_OPT_HOST_REACHABLE:
+    case LDAP_OPT_PING_KEEP_ALIVE:
+    case LDAP_OPT_PING_LIMIT:
+    case LDAP_OPT_PING_WAIT_TIME:
+    case LDAP_OPT_PROMPT_CREDENTIALS:
+    case LDAP_OPT_REF_DEREF_CONN_PER_MSG:
+    case LDAP_OPT_REFERRAL_CALLBACK:
+    case LDAP_OPT_REFERRAL_HOP_LIMIT:
+    case LDAP_OPT_ROOTDSE_CACHE:
+    case LDAP_OPT_SASL_METHOD:
+    case LDAP_OPT_SECURITY_CONTEXT:
+    case LDAP_OPT_SEND_TIMEOUT:
+    case LDAP_OPT_SERVER_CERTIFICATE:
+    case LDAP_OPT_SERVER_CONTROLS:
+    case LDAP_OPT_SERVER_ERROR:
+    case LDAP_OPT_SERVER_EXT_ERROR:
+    case LDAP_OPT_SIGN:
+    case LDAP_OPT_SSL:
+    case LDAP_OPT_SSL_INFO:
+    case LDAP_OPT_SSPI_FLAGS:
+    case LDAP_OPT_TCP_KEEPALIVE:
         FIXME( "Unsupported option: 0x%02x\n", option );
-        return WLDAP32_LDAP_NOT_SUPPORTED;
+        return LDAP_NOT_SUPPORTED;
 
     default:
         FIXME( "Unknown option: 0x%02x\n", option );
-        return WLDAP32_LDAP_LOCAL_ERROR;
+        return LDAP_LOCAL_ERROR;
     }
 }
 
@@ -280,114 +285,115 @@ ULONG CDECL ldap_get_optionW( WLDAP32_LDAP *ld, int option, void *value )
  *
  * See ldap_set_optionW.
  */
-ULONG CDECL ldap_set_optionA( WLDAP32_LDAP *ld, int option, void *value )
+ULONG CDECL ldap_set_optionA( LDAP *ld, int option, void *value )
 {
     ULONG ret;
 
     TRACE( "(%p, 0x%08x, %p)\n", ld, option, value );
 
-    if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
+    if (!ld) return LDAP_PARAM_ERROR;
 
     switch (option)
     {
-    case WLDAP32_LDAP_OPT_SERVER_CONTROLS:
+    case LDAP_OPT_SERVER_CONTROLS:
     {
         LDAPControlW **ctrlsW;
-        if (!(ctrlsW = controlarrayAtoW( value ))) return WLDAP32_LDAP_NO_MEMORY;
+        if (!(ctrlsW = controlarrayAtoW( value ))) return LDAP_NO_MEMORY;
         ret = ldap_set_optionW( ld, option, ctrlsW );
         controlarrayfreeW( ctrlsW );
         return ret;
     }
-    case WLDAP32_LDAP_OPT_DEREF:
-    case WLDAP32_LDAP_OPT_DESC:
-    case WLDAP32_LDAP_OPT_ERROR_NUMBER:
-    case WLDAP32_LDAP_OPT_PROTOCOL_VERSION:
-    case WLDAP32_LDAP_OPT_REFERRALS:
-    case WLDAP32_LDAP_OPT_SIZELIMIT:
-    case WLDAP32_LDAP_OPT_TIMELIMIT:
+    case LDAP_OPT_DEREF:
+    case LDAP_OPT_DESC:
+    case LDAP_OPT_ERROR_NUMBER:
+    case LDAP_OPT_PROTOCOL_VERSION:
+    case LDAP_OPT_REFERRALS:
+    case LDAP_OPT_SIZELIMIT:
+    case LDAP_OPT_TIMELIMIT:
         return ldap_set_optionW( ld, option, value );
 
-    case WLDAP32_LDAP_OPT_CACHE_ENABLE:
-    case WLDAP32_LDAP_OPT_CACHE_FN_PTRS:
-    case WLDAP32_LDAP_OPT_CACHE_STRATEGY:
-    case WLDAP32_LDAP_OPT_IO_FN_PTRS:
-    case WLDAP32_LDAP_OPT_REBIND_ARG:
-    case WLDAP32_LDAP_OPT_REBIND_FN:
-    case WLDAP32_LDAP_OPT_RESTART:
-    case WLDAP32_LDAP_OPT_THREAD_FN_PTRS:
-        return WLDAP32_LDAP_LOCAL_ERROR;
-
-    case WLDAP32_LDAP_OPT_API_FEATURE_INFO:
-    case WLDAP32_LDAP_OPT_API_INFO:
-        return WLDAP32_LDAP_UNWILLING_TO_PERFORM;
-
-    case WLDAP32_LDAP_OPT_AREC_EXCLUSIVE:
-    case WLDAP32_LDAP_OPT_AUTO_RECONNECT:
-    case WLDAP32_LDAP_OPT_CLIENT_CERTIFICATE:
-    case WLDAP32_LDAP_OPT_DNSDOMAIN_NAME:
-    case WLDAP32_LDAP_OPT_ENCRYPT:
-    case WLDAP32_LDAP_OPT_ERROR_STRING:
-    case WLDAP32_LDAP_OPT_FAST_CONCURRENT_BIND:
-    case WLDAP32_LDAP_OPT_GETDSNAME_FLAGS:
-    case WLDAP32_LDAP_OPT_HOST_NAME:
-    case WLDAP32_LDAP_OPT_HOST_REACHABLE:
-    case WLDAP32_LDAP_OPT_PING_KEEP_ALIVE:
-    case WLDAP32_LDAP_OPT_PING_LIMIT:
-    case WLDAP32_LDAP_OPT_PING_WAIT_TIME:
-    case WLDAP32_LDAP_OPT_PROMPT_CREDENTIALS:
-    case WLDAP32_LDAP_OPT_REF_DEREF_CONN_PER_MSG:
-    case WLDAP32_LDAP_OPT_REFERRAL_CALLBACK:
-    case WLDAP32_LDAP_OPT_REFERRAL_HOP_LIMIT:
-    case WLDAP32_LDAP_OPT_ROOTDSE_CACHE:
-    case WLDAP32_LDAP_OPT_SASL_METHOD:
-    case WLDAP32_LDAP_OPT_SECURITY_CONTEXT:
-    case WLDAP32_LDAP_OPT_SEND_TIMEOUT:
-    case WLDAP32_LDAP_OPT_SERVER_CERTIFICATE:
-    case WLDAP32_LDAP_OPT_SERVER_ERROR:
-    case WLDAP32_LDAP_OPT_SERVER_EXT_ERROR:
-    case WLDAP32_LDAP_OPT_SIGN:
-    case WLDAP32_LDAP_OPT_SSL:
-    case WLDAP32_LDAP_OPT_SSL_INFO:
-    case WLDAP32_LDAP_OPT_SSPI_FLAGS:
-    case WLDAP32_LDAP_OPT_TCP_KEEPALIVE:
+    case LDAP_OPT_CACHE_ENABLE:
+    case LDAP_OPT_CACHE_FN_PTRS:
+    case LDAP_OPT_CACHE_STRATEGY:
+    case LDAP_OPT_IO_FN_PTRS:
+    case LDAP_OPT_REBIND_ARG:
+    case LDAP_OPT_REBIND_FN:
+    case LDAP_OPT_RESTART:
+    case LDAP_OPT_THREAD_FN_PTRS:
+        return LDAP_LOCAL_ERROR;
+
+    case LDAP_OPT_API_FEATURE_INFO:
+    case LDAP_OPT_API_INFO:
+        return LDAP_UNWILLING_TO_PERFORM;
+
+    case LDAP_OPT_AREC_EXCLUSIVE:
+    case LDAP_OPT_AUTO_RECONNECT:
+    case LDAP_OPT_CLIENT_CERTIFICATE:
+    case LDAP_OPT_DNSDOMAIN_NAME:
+    case LDAP_OPT_ENCRYPT:
+    case LDAP_OPT_ERROR_STRING:
+    case LDAP_OPT_FAST_CONCURRENT_BIND:
+    case LDAP_OPT_GETDSNAME_FLAGS:
+    case LDAP_OPT_HOST_NAME:
+    case LDAP_OPT_HOST_REACHABLE:
+    case LDAP_OPT_PING_KEEP_ALIVE:
+    case LDAP_OPT_PING_LIMIT:
+    case LDAP_OPT_PING_WAIT_TIME:
+    case LDAP_OPT_PROMPT_CREDENTIALS:
+    case LDAP_OPT_REF_DEREF_CONN_PER_MSG:
+    case LDAP_OPT_REFERRAL_CALLBACK:
+    case LDAP_OPT_REFERRAL_HOP_LIMIT:
+    case LDAP_OPT_ROOTDSE_CACHE:
+    case LDAP_OPT_SASL_METHOD:
+    case LDAP_OPT_SECURITY_CONTEXT:
+    case LDAP_OPT_SEND_TIMEOUT:
+    case LDAP_OPT_SERVER_CERTIFICATE:
+    case LDAP_OPT_SERVER_ERROR:
+    case LDAP_OPT_SERVER_EXT_ERROR:
+    case LDAP_OPT_SIGN:
+    case LDAP_OPT_SSL:
+    case LDAP_OPT_SSL_INFO:
+    case LDAP_OPT_SSPI_FLAGS:
+    case LDAP_OPT_TCP_KEEPALIVE:
         FIXME( "Unsupported option: 0x%02x\n", option );
-        return WLDAP32_LDAP_NOT_SUPPORTED;
+        return LDAP_NOT_SUPPORTED;
 
     default:
         FIXME( "Unknown option: 0x%02x\n", option );
-        return WLDAP32_LDAP_LOCAL_ERROR;
+        return LDAP_LOCAL_ERROR;
     }
 }
 
-static BOOL query_supported_server_ctrls( WLDAP32_LDAP *ld )
+static BOOL query_supported_server_ctrls( LDAP *ld )
 {
     char *attrs[] = { (char *)"supportedControl", NULL };
     void *res, *entry;
     ULONG ret;
 
-    if (ld->ld_server_ctrls) return TRUE;
+    if (SERVER_CTRLS(ld)) return TRUE;
 
-    ret = map_error( ldap_funcs->ldap_search_ext_s( ld->ld, (char *)"", WLDAP32_LDAP_SCOPE_BASE,
-                                                    (char *)"(objectClass=*)", attrs, FALSE, NULL, NULL, NULL, 0, &res ) );
-    if (ret != WLDAP32_LDAP_SUCCESS) return FALSE;
+    ret = map_error( ldap_funcs->fn_ldap_search_ext_s( CTX(ld), (char *)"", LDAP_SCOPE_BASE, (char *)"(objectClass=*)",
+                                                       attrs, FALSE, NULL, NULL, NULL, 0, &res ) );
+    if (ret != LDAP_SUCCESS) return FALSE;
 
-    entry = ldap_funcs->ldap_first_entry( ld->ld, res );
+    entry = ldap_funcs->fn_ldap_first_entry( CTX(ld), res );
     if (entry)
     {
         ULONG count, i;
+        struct bervalU **ctrls = SERVER_CTRLS(ld);
 
-        ld->ld_server_ctrls = ldap_funcs->ldap_get_values_len( ld->ld, entry, attrs[0] );
-        count = ldap_funcs->ldap_count_values_len( ld->ld_server_ctrls );
+        *(struct bervalU ***)&SERVER_CTRLS(ld) = ldap_funcs->fn_ldap_get_values_len( CTX(ld), entry, attrs[0] );
+        count = ldap_funcs->fn_ldap_count_values_len( SERVER_CTRLS(ld) );
         for (i = 0; i < count; i++)
-            TRACE("%u: %s\n", i, debugstr_an( ld->ld_server_ctrls[i]->bv_val, ld->ld_server_ctrls[i]->bv_len ));
+            TRACE("%u: %s\n", i, debugstr_an( ctrls[i]->bv_val, ctrls[i]->bv_len ));
     }
 
-    ldap_funcs->ldap_msgfree( res );
+    ldap_funcs->fn_ldap_msgfree( res );
 
-    return ld->ld_server_ctrls != NULL;
+    return SERVER_CTRLS(ld) != NULL;
 }
 
-static BOOL is_supported_server_ctrls( WLDAP32_LDAP *ld, LDAPControlU **ctrls )
+static BOOL is_supported_server_ctrls( LDAP *ld, LDAPControlU **ctrls )
 {
     ULONG user_count, server_count, i, n, supported = 0;
 
@@ -395,7 +401,7 @@ static BOOL is_supported_server_ctrls( WLDAP32_LDAP *ld, LDAPControlU **ctrls )
         return TRUE; /* can't verify, let the server handle it on next query */
 
     user_count = controlarraylenU( ctrls );
-    server_count = ldap_funcs->ldap_count_values_len( ld->ld_server_ctrls );
+    server_count = ldap_funcs->fn_ldap_count_values_len( SERVER_CTRLS(ld) );
 
     for (n = 0; n < user_count; n++)
     {
@@ -403,7 +409,8 @@ static BOOL is_supported_server_ctrls( WLDAP32_LDAP *ld, LDAPControlU **ctrls )
 
         for (i = 0; i < server_count; i++)
         {
-            if (!strncmp( ctrls[n]->ldctl_oid, ld->ld_server_ctrls[i]->bv_val, ld->ld_server_ctrls[i]->bv_len))
+            struct bervalU **server_ctrls = SERVER_CTRLS(ld);
+            if (!strncmp( ctrls[n]->ldctl_oid, server_ctrls[i]->bv_val, server_ctrls[i]->bv_len))
             {
                 supported++;
                 break;
@@ -431,95 +438,95 @@ static BOOL is_supported_server_ctrls( WLDAP32_LDAP *ld, LDAPControlU **ctrls )
  * NOTES
  *  Set value to LDAP_OPT_ON or LDAP_OPT_OFF for on/off options.
  */
-ULONG CDECL ldap_set_optionW( WLDAP32_LDAP *ld, int option, void *value )
+ULONG CDECL ldap_set_optionW( LDAP *ld, int option, void *value )
 {
     ULONG ret;
 
     TRACE( "(%p, 0x%08x, %p)\n", ld, option, value );
 
-    if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
+    if (!ld) return LDAP_PARAM_ERROR;
 
     switch (option)
     {
-    case WLDAP32_LDAP_OPT_SERVER_CONTROLS:
+    case LDAP_OPT_SERVER_CONTROLS:
     {
         LDAPControlU **ctrlsU;
 
-        if (!(ctrlsU = controlarrayWtoU( value ))) return WLDAP32_LDAP_NO_MEMORY;
+        if (!(ctrlsU = controlarrayWtoU( value ))) return LDAP_NO_MEMORY;
 
         if (!is_supported_server_ctrls( ld, ctrlsU ))
-            ret = WLDAP32_LDAP_PARAM_ERROR;
+            ret = LDAP_PARAM_ERROR;
         else
-            ret = map_error( ldap_funcs->ldap_set_option( ld->ld, option, ctrlsU ) );
+            ret = map_error( ldap_funcs->fn_ldap_set_option( CTX(ld), option, ctrlsU ) );
         controlarrayfreeU( ctrlsU );
         return ret;
     }
-    case WLDAP32_LDAP_OPT_REFERRALS:
+    case LDAP_OPT_REFERRALS:
     {
-        void *openldap_referral = WLDAP32_LDAP_OPT_ON;
-        if (value == WLDAP32_LDAP_OPT_OFF)
-            openldap_referral = WLDAP32_LDAP_OPT_OFF;
+        void *openldap_referral = LDAP_OPT_ON;
+        if (value == LDAP_OPT_OFF)
+            openldap_referral = LDAP_OPT_OFF;
         else
             FIXME("upgrading referral value %p to LDAP_OPT_ON (OpenLDAP lacks sufficient granularity)\n", value);
-        return map_error( ldap_funcs->ldap_set_option( ld->ld, option, openldap_referral ) );
+        return map_error( ldap_funcs->fn_ldap_set_option( CTX(ld), option, openldap_referral ) );
         break;
     }
-    case WLDAP32_LDAP_OPT_DEREF:
-    case WLDAP32_LDAP_OPT_DESC:
-    case WLDAP32_LDAP_OPT_ERROR_NUMBER:
-    case WLDAP32_LDAP_OPT_PROTOCOL_VERSION:
-    case WLDAP32_LDAP_OPT_SIZELIMIT:
-    case WLDAP32_LDAP_OPT_TIMELIMIT:
-        return map_error( ldap_funcs->ldap_set_option( ld->ld, option, value ));
-
-    case WLDAP32_LDAP_OPT_CACHE_ENABLE:
-    case WLDAP32_LDAP_OPT_CACHE_FN_PTRS:
-    case WLDAP32_LDAP_OPT_CACHE_STRATEGY:
-    case WLDAP32_LDAP_OPT_IO_FN_PTRS:
-    case WLDAP32_LDAP_OPT_REBIND_ARG:
-    case WLDAP32_LDAP_OPT_REBIND_FN:
-    case WLDAP32_LDAP_OPT_RESTART:
-    case WLDAP32_LDAP_OPT_THREAD_FN_PTRS:
-        return WLDAP32_LDAP_LOCAL_ERROR;
-
-    case WLDAP32_LDAP_OPT_API_FEATURE_INFO:
-    case WLDAP32_LDAP_OPT_API_INFO:
-        return WLDAP32_LDAP_UNWILLING_TO_PERFORM;
-
-    case WLDAP32_LDAP_OPT_AREC_EXCLUSIVE:
-    case WLDAP32_LDAP_OPT_AUTO_RECONNECT:
-    case WLDAP32_LDAP_OPT_CLIENT_CERTIFICATE:
-    case WLDAP32_LDAP_OPT_DNSDOMAIN_NAME:
-    case WLDAP32_LDAP_OPT_ENCRYPT:
-    case WLDAP32_LDAP_OPT_ERROR_STRING:
-    case WLDAP32_LDAP_OPT_FAST_CONCURRENT_BIND:
-    case WLDAP32_LDAP_OPT_GETDSNAME_FLAGS:
-    case WLDAP32_LDAP_OPT_HOST_NAME:
-    case WLDAP32_LDAP_OPT_HOST_REACHABLE:
-    case WLDAP32_LDAP_OPT_PING_KEEP_ALIVE:
-    case WLDAP32_LDAP_OPT_PING_LIMIT:
-    case WLDAP32_LDAP_OPT_PING_WAIT_TIME:
-    case WLDAP32_LDAP_OPT_PROMPT_CREDENTIALS:
-    case WLDAP32_LDAP_OPT_REF_DEREF_CONN_PER_MSG:
-    case WLDAP32_LDAP_OPT_REFERRAL_CALLBACK:
-    case WLDAP32_LDAP_OPT_REFERRAL_HOP_LIMIT:
-    case WLDAP32_LDAP_OPT_ROOTDSE_CACHE:
-    case WLDAP32_LDAP_OPT_SASL_METHOD:
-    case WLDAP32_LDAP_OPT_SECURITY_CONTEXT:
-    case WLDAP32_LDAP_OPT_SEND_TIMEOUT:
-    case WLDAP32_LDAP_OPT_SERVER_CERTIFICATE:
-    case WLDAP32_LDAP_OPT_SERVER_ERROR:
-    case WLDAP32_LDAP_OPT_SERVER_EXT_ERROR:
-    case WLDAP32_LDAP_OPT_SIGN:
-    case WLDAP32_LDAP_OPT_SSL:
-    case WLDAP32_LDAP_OPT_SSL_INFO:
-    case WLDAP32_LDAP_OPT_SSPI_FLAGS:
-    case WLDAP32_LDAP_OPT_TCP_KEEPALIVE:
+    case LDAP_OPT_DEREF:
+    case LDAP_OPT_DESC:
+    case LDAP_OPT_ERROR_NUMBER:
+    case LDAP_OPT_PROTOCOL_VERSION:
+    case LDAP_OPT_SIZELIMIT:
+    case LDAP_OPT_TIMELIMIT:
+        return map_error( ldap_funcs->fn_ldap_set_option( CTX(ld), option, value ));
+
+    case LDAP_OPT_CACHE_ENABLE:
+    case LDAP_OPT_CACHE_FN_PTRS:
+    case LDAP_OPT_CACHE_STRATEGY:
+    case LDAP_OPT_IO_FN_PTRS:
+    case LDAP_OPT_REBIND_ARG:
+    case LDAP_OPT_REBIND_FN:
+    case LDAP_OPT_RESTART:
+    case LDAP_OPT_THREAD_FN_PTRS:
+        return LDAP_LOCAL_ERROR;
+
+    case LDAP_OPT_API_FEATURE_INFO:
+    case LDAP_OPT_API_INFO:
+        return LDAP_UNWILLING_TO_PERFORM;
+
+    case LDAP_OPT_AREC_EXCLUSIVE:
+    case LDAP_OPT_AUTO_RECONNECT:
+    case LDAP_OPT_CLIENT_CERTIFICATE:
+    case LDAP_OPT_DNSDOMAIN_NAME:
+    case LDAP_OPT_ENCRYPT:
+    case LDAP_OPT_ERROR_STRING:
+    case LDAP_OPT_FAST_CONCURRENT_BIND:
+    case LDAP_OPT_GETDSNAME_FLAGS:
+    case LDAP_OPT_HOST_NAME:
+    case LDAP_OPT_HOST_REACHABLE:
+    case LDAP_OPT_PING_KEEP_ALIVE:
+    case LDAP_OPT_PING_LIMIT:
+    case LDAP_OPT_PING_WAIT_TIME:
+    case LDAP_OPT_PROMPT_CREDENTIALS:
+    case LDAP_OPT_REF_DEREF_CONN_PER_MSG:
+    case LDAP_OPT_REFERRAL_CALLBACK:
+    case LDAP_OPT_REFERRAL_HOP_LIMIT:
+    case LDAP_OPT_ROOTDSE_CACHE:
+    case LDAP_OPT_SASL_METHOD:
+    case LDAP_OPT_SECURITY_CONTEXT:
+    case LDAP_OPT_SEND_TIMEOUT:
+    case LDAP_OPT_SERVER_CERTIFICATE:
+    case LDAP_OPT_SERVER_ERROR:
+    case LDAP_OPT_SERVER_EXT_ERROR:
+    case LDAP_OPT_SIGN:
+    case LDAP_OPT_SSL:
+    case LDAP_OPT_SSL_INFO:
+    case LDAP_OPT_SSPI_FLAGS:
+    case LDAP_OPT_TCP_KEEPALIVE:
         FIXME( "Unsupported option: 0x%02x\n", option );
-        return WLDAP32_LDAP_NOT_SUPPORTED;
+        return LDAP_NOT_SUPPORTED;
 
     default:
         FIXME( "Unknown option: 0x%02x\n", option );
-        return WLDAP32_LDAP_LOCAL_ERROR;
+        return LDAP_LOCAL_ERROR;
     }
 }
diff --git a/dlls/wldap32/page.c b/dlls/wldap32/page.c
index 19110aa10ce9..471108c636e2 100644
--- a/dlls/wldap32/page.c
+++ b/dlls/wldap32/page.c
@@ -23,6 +23,8 @@
 #include "windef.h"
 #include "winbase.h"
 #include "winnls.h"
+#include "winldap.h"
+#include "winber.h"
 
 #include "wine/debug.h"
 #include "winldap_private.h"
@@ -31,25 +33,25 @@ WINE_DEFAULT_DEBUG_CHANNEL(wldap32);
 
 #define LDAP_MAXINT (2^31)
 
-static struct WLDAP32_berval null_cookieW = { 0, NULL };
+static struct berval null_cookieW = { 0, NULL };
 
 /***********************************************************************
  *      ldap_create_page_controlA     (WLDAP32.@)
  *
  * See ldap_create_page_controlW.
  */
-ULONG CDECL ldap_create_page_controlA( WLDAP32_LDAP *ld, ULONG pagesize,
-    struct WLDAP32_berval *cookie, UCHAR critical, LDAPControlA **control )
+ULONG CDECL ldap_create_page_controlA( LDAP *ld, ULONG pagesize, struct berval *cookie, UCHAR critical,
+    LDAPControlA **control )
 {
     ULONG ret;
     LDAPControlW *controlW = NULL;
 
     TRACE( "(%p, 0x%08x, %p, 0x%02x, %p)\n", ld, pagesize, cookie, critical, control );
 
-    if (!ld || !control || pagesize > LDAP_MAXINT) return WLDAP32_LDAP_PARAM_ERROR;
+    if (!ld || !control || pagesize > LDAP_MAXINT) return LDAP_PARAM_ERROR;
 
     ret = ldap_create_page_controlW( ld, pagesize, cookie, critical, &controlW );
-    if (ret == WLDAP32_LDAP_SUCCESS)
+    if (ret == LDAP_SUCCESS)
     {
         *control = controlWtoA( controlW );
         ldap_control_freeW( controlW );
@@ -58,52 +60,52 @@ ULONG CDECL ldap_create_page_controlA( WLDAP32_LDAP *ld, ULONG pagesize,
 }
 
 /* create a page control by hand */
-static ULONG create_page_control( ULONG pagesize, struct WLDAP32_berval *cookie, UCHAR critical, LDAPControlW **control )
+static ULONG create_page_control( ULONG pagesize, struct berval *cookie, UCHAR critical, LDAPControlW **control )
 {
     LDAPControlW *ctrl;
-    WLDAP32_BerElement *ber;
-    struct WLDAP32_berval *berval, *vec[2];
+    BerElement *ber;
+    struct berval *berval, *vec[2];
     int ret, len;
     char *val;
 
-    if (!(ber = WLDAP32_ber_alloc_t( WLDAP32_LBER_USE_DER ))) return WLDAP32_LDAP_NO_MEMORY;
+    if (!(ber = ber_alloc_t( LBER_USE_DER ))) return LDAP_NO_MEMORY;
 
     vec[1] = NULL;
     if (cookie)
         vec[0] = cookie;
     else
         vec[0] = &null_cookieW;
-    len = WLDAP32_ber_printf( ber, (char *)"{iV}", pagesize, vec );
+    len = ber_printf( ber, (char *)"{iV}", pagesize, vec );
 
-    ret = WLDAP32_ber_flatten( ber, &berval );
-    WLDAP32_ber_free( ber, 1 );
+    ret = ber_flatten( ber, &berval );
+    ber_free( ber, 1 );
 
-    if (len == WLDAP32_LBER_ERROR) return WLDAP32_LDAP_ENCODING_ERROR;
-    if (ret == -1) return WLDAP32_LDAP_NO_MEMORY;
+    if (len == LBER_ERROR) return LDAP_ENCODING_ERROR;
+    if (ret == -1) return LDAP_NO_MEMORY;
 
     /* copy the berval so it can be properly freed by the caller */
-    if (!(val = malloc( berval->bv_len ))) return WLDAP32_LDAP_NO_MEMORY;
+    if (!(val = malloc( berval->bv_len ))) return LDAP_NO_MEMORY;
 
     len = berval->bv_len;
     memcpy( val, berval->bv_val, len );
-    WLDAP32_ber_bvfree( berval );
+    ber_bvfree( berval );
 
     if (!(ctrl = malloc( sizeof(*ctrl) )))
     {
         free( val );
-        return WLDAP32_LDAP_NO_MEMORY;
+        return LDAP_NO_MEMORY;
     }
     if (!(ctrl->ldctl_oid = strAtoW( LDAP_PAGED_RESULT_OID_STRING )))
     {
         free( ctrl );
-        return WLDAP32_LDAP_NO_MEMORY;
+        return LDAP_NO_MEMORY;
     }
     ctrl->ldctl_value.bv_len = len;
     ctrl->ldctl_value.bv_val = val;
     ctrl->ldctl_iscritical   = critical;
 
     *control = ctrl;
-    return WLDAP32_LDAP_SUCCESS;
+    return LDAP_SUCCESS;
 }
 
 /***********************************************************************
@@ -124,25 +126,25 @@ static ULONG create_page_control( ULONG pagesize, struct WLDAP32_berval *cookie,
  *  Success: LDAP_SUCCESS
  *  Failure: An LDAP error code.
  */
-ULONG CDECL ldap_create_page_controlW( WLDAP32_LDAP *ld, ULONG pagesize, struct WLDAP32_berval *cookie,
-    UCHAR critical, LDAPControlW **control )
+ULONG CDECL ldap_create_page_controlW( LDAP *ld, ULONG pagesize, struct berval *cookie, UCHAR critical,
+    LDAPControlW **control )
 {
     TRACE( "(%p, 0x%08x, %p, 0x%02x, %p)\n", ld, pagesize, cookie, critical, control );
 
-    if (!ld || !control || pagesize > LDAP_MAXINT) return WLDAP32_LDAP_PARAM_ERROR;
+    if (!ld || !control || pagesize > LDAP_MAXINT) return LDAP_PARAM_ERROR;
     return create_page_control( pagesize, cookie, critical, control );
 }
 
-ULONG CDECL ldap_get_next_page( WLDAP32_LDAP *ld, LDAPSearch *search, ULONG pagesize, ULONG *message )
+ULONG CDECL ldap_get_next_page( LDAP *ld, LDAPSearch *search, ULONG pagesize, ULONG *message )
 {
     FIXME( "(%p, %p, 0x%08x, %p)\n", ld, search, pagesize, message );
 
     if (!ld) return ~0u;
-    return WLDAP32_LDAP_NOT_SUPPORTED;
+    return LDAP_NOT_SUPPORTED;
 }
 
-ULONG CDECL ldap_get_next_page_s( WLDAP32_LDAP *ld, LDAPSearch *search, struct l_timeval *timeout, ULONG pagesize,
-    ULONG *count, WLDAP32_LDAPMessage **results )
+ULONG CDECL ldap_get_next_page_s( LDAP *ld, LDAPSearch *search, struct l_timeval *timeout, ULONG pagesize,
+    ULONG *count, LDAPMessage **results )
 {
     ULONG ret;
 
@@ -155,7 +157,7 @@ ULONG CDECL ldap_get_next_page_s( WLDAP32_LDAP *ld, LDAPSearch *search, struct l
         /* end of paged results */
         *count = 0;
         *results = NULL;
-        return WLDAP32_LDAP_NO_RESULTS_RETURNED;
+        return LDAP_NO_RESULTS_RETURNED;
     }
 
     if (search->serverctrls[0])
@@ -166,41 +168,41 @@ ULONG CDECL ldap_get_next_page_s( WLDAP32_LDAP *ld, LDAPSearch *search, struct l
 
     TRACE("search->cookie: %s\n", search->cookie ? debugstr_an(search->cookie->bv_val, search->cookie->bv_len) : "NULL");
     ret = ldap_create_page_controlW( ld, pagesize, search->cookie, 1, &search->serverctrls[0] );
-    if (ret != WLDAP32_LDAP_SUCCESS) return ret;
+    if (ret != LDAP_SUCCESS) return ret;
 
     ret = ldap_search_ext_sW( ld, search->dn, search->scope, search->filter, search->attrs, search->attrsonly,
                               search->serverctrls, search->clientctrls,
                               search->timeout.tv_sec ? &search->timeout : NULL, search->sizelimit, results );
-    if (ret != WLDAP32_LDAP_SUCCESS) return ret;
+    if (ret != LDAP_SUCCESS) return ret;
 
     return ldap_get_paged_count( ld, search, count, *results );
 }
 
-ULONG CDECL ldap_get_paged_count( WLDAP32_LDAP *ld, LDAPSearch *search, ULONG *count, WLDAP32_LDAPMessage *results )
+ULONG CDECL ldap_get_paged_count( LDAP *ld, LDAPSearch *search, ULONG *count, LDAPMessage *results )
 {
     ULONG ret;
     LDAPControlW **server_ctrls = NULL;
 
     TRACE( "(%p, %p, %p, %p)\n", ld, search, count, results );
 
-    if (!ld || !count || !results) return WLDAP32_LDAP_PARAM_ERROR;
+    if (!ld || !count || !results) return LDAP_PARAM_ERROR;
 
     *count = 0;
 
     ret = ldap_parse_resultW( ld, results, NULL, NULL, NULL, NULL, &server_ctrls, 0 );
-    if (ret != WLDAP32_LDAP_SUCCESS) return ret;
+    if (ret != LDAP_SUCCESS) return ret;
 
     if (!server_ctrls) /* assume end of paged results */
     {
         search->cookie = &null_cookieW;
-        return WLDAP32_LDAP_SUCCESS;
+        return LDAP_SUCCESS;
     }
 
     free( search->cookie );
     search->cookie = NULL;
 
     ret = ldap_parse_page_controlW( ld, server_ctrls, count, &search->cookie );
-    if (ret == WLDAP32_LDAP_SUCCESS)
+    if (ret == LDAP_SUCCESS)
         TRACE("new search->cookie: %s, count %u\n", debugstr_an(search->cookie->bv_val, search->cookie->bv_len), *count);
 
     ldap_controls_freeW( server_ctrls );
@@ -210,17 +212,16 @@ ULONG CDECL ldap_get_paged_count( WLDAP32_LDAP *ld, LDAPSearch *search, ULONG *c
 /***********************************************************************
  *      ldap_parse_page_controlA      (WLDAP32.@)
  */
-ULONG CDECL ldap_parse_page_controlA( WLDAP32_LDAP *ld, LDAPControlA **ctrls, ULONG *count,
-    struct WLDAP32_berval **cookie )
+ULONG CDECL ldap_parse_page_controlA( LDAP *ld, LDAPControlA **ctrls, ULONG *count, struct berval **cookie )
 {
     ULONG ret;
     LDAPControlW **ctrlsW = NULL;
 
     TRACE( "(%p, %p, %p, %p)\n", ld, ctrls, count, cookie );
 
-    if (!ld || !ctrls || !count || !cookie) return WLDAP32_LDAP_PARAM_ERROR;
+    if (!ld || !ctrls || !count || !cookie) return LDAP_PARAM_ERROR;
 
-    if (!(ctrlsW = controlarrayAtoW( ctrls ))) return WLDAP32_LDAP_NO_MEMORY;
+    if (!(ctrlsW = controlarrayAtoW( ctrls ))) return LDAP_NO_MEMORY;
     ret = ldap_parse_page_controlW( ld, ctrlsW, count, cookie );
     controlarrayfreeW( ctrlsW );
     return ret;
@@ -229,42 +230,41 @@ ULONG CDECL ldap_parse_page_controlA( WLDAP32_LDAP *ld, LDAPControlA **ctrls, UL
 /***********************************************************************
  *      ldap_parse_page_controlW      (WLDAP32.@)
  */
-ULONG CDECL ldap_parse_page_controlW( WLDAP32_LDAP *ld, LDAPControlW **ctrls, ULONG *count,
-    struct WLDAP32_berval **cookie )
+ULONG CDECL ldap_parse_page_controlW( LDAP *ld, LDAPControlW **ctrls, ULONG *count, struct berval **cookie )
 {
     ULONG ret;
     LDAPControlW *control = NULL;
-    WLDAP32_BerElement *ber;
-    struct WLDAP32_berval *vec[2];
+    BerElement *ber;
+    struct berval *vec[2];
     int tag;
     ULONG i;
 
     TRACE( "(%p, %p, %p, %p)\n", ld, ctrls, count, cookie );
 
-    if (!ld || !ctrls || !count || !cookie) return WLDAP32_LDAP_PARAM_ERROR;
+    if (!ld || !ctrls || !count || !cookie) return LDAP_PARAM_ERROR;
 
     for (i = 0; ctrls[i]; i++)
     {
         if (!wcscmp( LDAP_PAGED_RESULT_OID_STRING_W, ctrls[i]->ldctl_oid ))
             control = ctrls[i];
     }
-    if (!control) return WLDAP32_LDAP_CONTROL_NOT_FOUND;
+    if (!control) return LDAP_CONTROL_NOT_FOUND;
 
-    if (!(ber = WLDAP32_ber_init( &control->ldctl_value ))) return WLDAP32_LDAP_NO_MEMORY;
+    if (!(ber = ber_init( &control->ldctl_value ))) return LDAP_NO_MEMORY;
 
     vec[0] = *cookie;
     vec[1] = 0;
-    tag = WLDAP32_ber_scanf( ber, (char *)"{iV}", count, vec );
-    if (tag == WLDAP32_LBER_ERROR)
-        ret = WLDAP32_LDAP_DECODING_ERROR;
+    tag = ber_scanf( ber, (char *)"{iV}", count, vec );
+    if (tag == LBER_ERROR)
+        ret = LDAP_DECODING_ERROR;
     else
-        ret = WLDAP32_LDAP_SUCCESS;
+        ret = LDAP_SUCCESS;
 
-    WLDAP32_ber_free( ber, 1 );
+    ber_free( ber, 1 );
     return ret;
 }
 
-ULONG CDECL ldap_search_abandon_page( WLDAP32_LDAP *ld, LDAPSearch *search )
+ULONG CDECL ldap_search_abandon_page( LDAP *ld, LDAPSearch *search )
 {
     LDAPControlW **ctrls;
 
@@ -284,10 +284,10 @@ ULONG CDECL ldap_search_abandon_page( WLDAP32_LDAP *ld, LDAPSearch *search )
     if (search->cookie && search->cookie != &null_cookieW) free( search->cookie );
     free( search );
 
-    return WLDAP32_LDAP_SUCCESS;
+    return LDAP_SUCCESS;
 }
 
-LDAPSearch * CDECL ldap_search_init_pageA( WLDAP32_LDAP *ld, char *dn, ULONG scope, char *filter, char **attrs,
+LDAPSearch * CDECL ldap_search_init_pageA( LDAP *ld, char *dn, ULONG scope, char *filter, char **attrs,
     ULONG attrsonly, LDAPControlA **serverctrls, LDAPControlA **clientctrls, ULONG timelimit, ULONG sizelimit,
     LDAPSortKeyA **sortkeys )
 {
@@ -296,7 +296,7 @@ LDAPSearch * CDECL ldap_search_init_pageA( WLDAP32_LDAP *ld, char *dn, ULONG sco
     return NULL;
 }
 
-LDAPSearch * CDECL ldap_search_init_pageW( WLDAP32_LDAP *ld, WCHAR *dn, ULONG scope, WCHAR *filter, WCHAR **attrs,
+LDAPSearch * CDECL ldap_search_init_pageW( LDAP *ld, WCHAR *dn, ULONG scope, WCHAR *filter, WCHAR **attrs,
     ULONG attrsonly, LDAPControlW **serverctrls, LDAPControlW **clientctrls, ULONG timelimit, ULONG sizelimit,
     LDAPSortKeyW **sortkeys )
 {
@@ -308,7 +308,7 @@ LDAPSearch * CDECL ldap_search_init_pageW( WLDAP32_LDAP *ld, WCHAR *dn, ULONG sc
 
     if (!(search = calloc( 1, sizeof(*search) )))
     {
-        ld->ld_errno = WLDAP32_LDAP_NO_MEMORY;
+        ld->ld_errno = LDAP_NO_MEMORY;
         return NULL;
     }
 
@@ -345,6 +345,6 @@ LDAPSearch * CDECL ldap_search_init_pageW( WLDAP32_LDAP *ld, WCHAR *dn, ULONG sc
 
 fail:
     ldap_search_abandon_page( ld, search );
-    ld->ld_errno = WLDAP32_LDAP_NO_MEMORY;
+    ld->ld_errno = LDAP_NO_MEMORY;
     return NULL;
 }
diff --git a/dlls/wldap32/parse.c b/dlls/wldap32/parse.c
index 1b6994352237..b4745546110d 100644
--- a/dlls/wldap32/parse.c
+++ b/dlls/wldap32/parse.c
@@ -22,6 +22,7 @@
 #include "windef.h"
 #include "winbase.h"
 #include "winnls.h"
+#include "winldap.h"
 
 #include "wine/debug.h"
 #include "winldap_private.h"
@@ -33,23 +34,23 @@ WINE_DEFAULT_DEBUG_CHANNEL(wldap32);
  *
  * See ldap_parse_extended_resultW.
  */
-ULONG CDECL ldap_parse_extended_resultA( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *result, char **oid,
-    struct WLDAP32_berval **data, BOOLEAN free )
+ULONG CDECL ldap_parse_extended_resultA( LDAP *ld, LDAPMessage *result, char **oid, struct berval **data,
+    BOOLEAN free )
 {
     ULONG ret;
     WCHAR *oidW = NULL;
 
     TRACE( "(%p, %p, %p, %p, 0x%02x)\n", ld, result, oid, data, free );
 
-    if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
-    if (!result) return WLDAP32_LDAP_NO_RESULTS_RETURNED;
+    if (!ld) return LDAP_PARAM_ERROR;
+    if (!result) return LDAP_NO_RESULTS_RETURNED;
 
     ret = ldap_parse_extended_resultW( ld, result, &oidW, data, free );
     if (oid && oidW)
     {
         char *str;
         if ((str = strWtoA( oidW ))) *oid = str;
-        else ret = WLDAP32_LDAP_NO_MEMORY;
+        else ret = LDAP_NO_MEMORY;
         ldap_memfreeW( oidW );
     }
     return ret;
@@ -75,8 +76,8 @@ ULONG CDECL ldap_parse_extended_resultA( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *
  *  Free the OID and result data with ldap_memfree. Pass a nonzero
  *  value for 'free' or call ldap_msgfree to free the result message.
  */
-ULONG CDECL ldap_parse_extended_resultW( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *result,
-    WCHAR **oid, struct WLDAP32_berval **data, BOOLEAN free )
+ULONG CDECL ldap_parse_extended_resultW( LDAP *ld, LDAPMessage *result, WCHAR **oid, struct berval **data,
+    BOOLEAN free )
 {
     ULONG ret;
     char *oidU = NULL;
@@ -84,23 +85,23 @@ ULONG CDECL ldap_parse_extended_resultW( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *
 
     TRACE( "(%p, %p, %p, %p, 0x%02x)\n", ld, result, oid, data, free );
 
-    if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
-    if (!result) return WLDAP32_LDAP_NO_RESULTS_RETURNED;
+    if (!ld) return LDAP_PARAM_ERROR;
+    if (!result) return LDAP_NO_RESULTS_RETURNED;
 
-    ret = map_error( ldap_funcs->ldap_parse_extended_result( ld->ld, result, &oidU, &dataU, free ) );
+    ret = map_error( ldap_funcs->fn_ldap_parse_extended_result( CTX(ld), result, &oidU, &dataU, free ) );
     if (oid && oidU)
     {
         WCHAR *str;
         if ((str = strUtoW( oidU ))) *oid = str;
-        else ret = WLDAP32_LDAP_NO_MEMORY;
-        ldap_funcs->ldap_memfree( oidU );
+        else ret = LDAP_NO_MEMORY;
+        ldap_funcs->fn_ldap_memfree( oidU );
     }
     if (data && dataU)
     {
-        struct WLDAP32_berval *bv;
+        struct berval *bv;
         if ((bv = bervalUtoW( dataU ))) *data = bv;
-        else ret = WLDAP32_LDAP_NO_MEMORY;
-        ldap_funcs->ber_bvfree( dataU );
+        else ret = LDAP_NO_MEMORY;
+        ldap_funcs->fn_ber_bvfree( dataU );
     }
 
     return ret;
@@ -111,7 +112,7 @@ ULONG CDECL ldap_parse_extended_resultW( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *
  *
  * See ldap_parse_referenceW.
  */
-ULONG CDECL ldap_parse_referenceA( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *message, char ***referrals )
+ULONG CDECL ldap_parse_referenceA( LDAP *ld, LDAPMessage *message, char ***referrals )
 {
     ULONG ret;
     WCHAR **referralsW = NULL;
@@ -125,7 +126,7 @@ ULONG CDECL ldap_parse_referenceA( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *messag
     {
         char **ref;
         if ((ref = strarrayWtoA( referralsW ))) *referrals = ref;
-        else ret = WLDAP32_LDAP_NO_MEMORY;
+        else ret = LDAP_NO_MEMORY;
         ldap_value_freeW( referralsW );
     }
     return ret;
@@ -148,7 +149,7 @@ ULONG CDECL ldap_parse_referenceA( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *messag
  * NOTES
  *  Free the referrals with ldap_value_free.
  */
-ULONG CDECL ldap_parse_referenceW( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *message, WCHAR ***referrals )
+ULONG CDECL ldap_parse_referenceW( LDAP *ld, LDAPMessage *message, WCHAR ***referrals )
 {
     ULONG ret;
     char **referralsU = NULL;
@@ -157,13 +158,13 @@ ULONG CDECL ldap_parse_referenceW( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *messag
 
     if (!ld) return ~0u;
 
-    ret = map_error( ldap_funcs->ldap_parse_reference( ld->ld, message, &referralsU, NULL, 0 ) );
+    ret = map_error( ldap_funcs->fn_ldap_parse_reference( CTX(ld), message, &referralsU, NULL, 0 ) );
     if (referralsU)
     {
         WCHAR **ref;
         if ((ref = strarrayUtoW( referralsU ))) *referrals = ref;
-        else ret = WLDAP32_LDAP_NO_MEMORY;
-        ldap_funcs->ldap_memfree( referralsU );
+        else ret = LDAP_NO_MEMORY;
+        ldap_funcs->fn_ldap_memfree( referralsU );
     }
     return ret;
 }
@@ -173,8 +174,8 @@ ULONG CDECL ldap_parse_referenceW( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *messag
  *
  * See ldap_parse_resultW.
  */
-ULONG CDECL ldap_parse_resultA( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *result, ULONG *retcode, char **matched,
-    char **error, char ***referrals, LDAPControlA ***serverctrls, BOOLEAN free )
+ULONG CDECL ldap_parse_resultA( LDAP *ld, LDAPMessage *result, ULONG *retcode, char **matched, char **error,
+    char ***referrals, LDAPControlA ***serverctrls, BOOLEAN free )
 {
     ULONG ret;
     WCHAR *matchedW = NULL, *errorW = NULL, **referralsW = NULL;
@@ -183,7 +184,7 @@ ULONG CDECL ldap_parse_resultA( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *result, U
     TRACE( "(%p, %p, %p, %p, %p, %p, %p, 0x%02x)\n", ld, result, retcode, matched, error, referrals, serverctrls,
            free );
 
-    if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
+    if (!ld) return LDAP_PARAM_ERROR;
 
     ret = ldap_parse_resultW( ld, result, retcode, &matchedW, &errorW, &referralsW, &serverctrlsW, free );
 
@@ -224,8 +225,8 @@ ULONG CDECL ldap_parse_resultA( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *result, U
  *  ldap_controls_free. Pass a nonzero value for 'free' or call
  *  ldap_msgfree to free the result message.
  */
-ULONG CDECL ldap_parse_resultW( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *result, ULONG *retcode, WCHAR **matched,
-    WCHAR **error, WCHAR ***referrals, LDAPControlW ***serverctrls, BOOLEAN free )
+ULONG CDECL ldap_parse_resultW( LDAP *ld, LDAPMessage *result, ULONG *retcode, WCHAR **matched, WCHAR **error,
+    WCHAR ***referrals, LDAPControlW ***serverctrls, BOOLEAN free )
 {
     ULONG ret;
     char *matchedU = NULL, *errorU = NULL, **referralsU = NULL;
@@ -234,20 +235,20 @@ ULONG CDECL ldap_parse_resultW( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *result, U
     TRACE( "(%p, %p, %p, %p, %p, %p, %p, 0x%02x)\n", ld, result, retcode, matched, error, referrals, serverctrls,
            free );
 
-    if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
+    if (!ld) return LDAP_PARAM_ERROR;
 
-    ret = map_error( ldap_funcs->ldap_parse_result( ld->ld, result->Request, (int *)retcode, &matchedU, &errorU,
-                                                    &referralsU, &serverctrlsU, free ) );
+    ret = map_error( ldap_funcs->fn_ldap_parse_result( CTX(ld), MSG(result), (int *)retcode, &matchedU, &errorU,
+                                                       &referralsU, &serverctrlsU, free ) );
 
     if (matched) *matched = strUtoW( matchedU );
     if (error) *error = strUtoW( errorU );
     if (referrals) *referrals = strarrayUtoW( referralsU );
     if (serverctrls) *serverctrls = controlarrayUtoW( serverctrlsU );
 
-    ldap_funcs->ldap_memfree( matchedU );
-    ldap_funcs->ldap_memfree( errorU );
-    ldap_funcs->ldap_memvfree( (void **)referralsU );
-    ldap_funcs->ldap_controls_free( serverctrlsU );
+    ldap_funcs->fn_ldap_memfree( matchedU );
+    ldap_funcs->fn_ldap_memfree( errorU );
+    ldap_funcs->fn_ldap_memvfree( (void **)referralsU );
+    ldap_funcs->fn_ldap_controls_free( serverctrlsU );
     return ret;
 }
 
@@ -256,7 +257,7 @@ ULONG CDECL ldap_parse_resultW( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *result, U
  *
  * See ldap_parse_sort_controlW.
  */
-ULONG CDECL ldap_parse_sort_controlA( WLDAP32_LDAP *ld, LDAPControlA **control, ULONG *result, char **attr )
+ULONG CDECL ldap_parse_sort_controlA( LDAP *ld, LDAPControlA **control, ULONG *result, char **attr )
 {
     ULONG ret;
     WCHAR *attrW = NULL;
@@ -264,9 +265,9 @@ ULONG CDECL ldap_parse_sort_controlA( WLDAP32_LDAP *ld, LDAPControlA **control,
 
     TRACE( "(%p, %p, %p, %p)\n", ld, control, result, attr );
 
-    if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
-    if (!control) return WLDAP32_LDAP_CONTROL_NOT_FOUND;
-    if (!(controlW = controlarrayAtoW( control ))) return WLDAP32_LDAP_NO_MEMORY;
+    if (!ld) return LDAP_PARAM_ERROR;
+    if (!control) return LDAP_CONTROL_NOT_FOUND;
+    if (!(controlW = controlarrayAtoW( control ))) return LDAP_NO_MEMORY;
 
     ret = ldap_parse_sort_controlW( ld, controlW, result, &attrW );
 
@@ -293,7 +294,7 @@ ULONG CDECL ldap_parse_sort_controlA( WLDAP32_LDAP *ld, LDAPControlA **control,
  * NOTES
  *  If the function fails, free the failing attribute with ldap_memfree.
  */
-ULONG CDECL ldap_parse_sort_controlW( WLDAP32_LDAP *ld, LDAPControlW **control, ULONG *result, WCHAR **attr )
+ULONG CDECL ldap_parse_sort_controlW( LDAP *ld, LDAPControlW **control, ULONG *result, WCHAR **attr )
 {
     ULONG ret;
     char *attrU = NULL;
@@ -303,9 +304,9 @@ ULONG CDECL ldap_parse_sort_controlW( WLDAP32_LDAP *ld, LDAPControlW **control,
 
     TRACE( "(%p, %p, %p, %p)\n", ld, control, result, attr );
 
-    if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
-    if (!control) return WLDAP32_LDAP_CONTROL_NOT_FOUND;
-    if (!(controlU = controlarrayWtoU( control ))) return WLDAP32_LDAP_NO_MEMORY;
+    if (!ld) return LDAP_PARAM_ERROR;
+    if (!control) return LDAP_CONTROL_NOT_FOUND;
+    if (!(controlU = controlarrayWtoU( control ))) return LDAP_NO_MEMORY;
 
     for (i = 0; controlU[i]; i++)
     {
@@ -315,11 +316,11 @@ ULONG CDECL ldap_parse_sort_controlW( WLDAP32_LDAP *ld, LDAPControlW **control,
     if (!sortcontrol)
     {
         controlarrayfreeU( controlU );
-        return WLDAP32_LDAP_CONTROL_NOT_FOUND;
+        return LDAP_CONTROL_NOT_FOUND;
     }
 
-    ret = map_error( ldap_funcs->ldap_parse_sortresponse_control( ld->ld, sortcontrol, &res, &attrU ) );
-    if (ret == WLDAP32_LDAP_SUCCESS)
+    ret = map_error( ldap_funcs->fn_ldap_parse_sortresponse_control( CTX(ld), sortcontrol, &res, &attrU ) );
+    if (ret == LDAP_SUCCESS)
     {
         WCHAR *str;
         if ((str = strUtoW( attrU )))
@@ -327,8 +328,8 @@ ULONG CDECL ldap_parse_sort_controlW( WLDAP32_LDAP *ld, LDAPControlW **control,
             *attr = str;
             *result = res;
         }
-        else ret = WLDAP32_LDAP_NO_MEMORY;
-        ldap_funcs->ldap_memfree( attrU );
+        else ret = LDAP_NO_MEMORY;
+        ldap_funcs->fn_ldap_memfree( attrU );
     }
 
     controlarrayfreeU( controlU );
@@ -340,8 +341,8 @@ ULONG CDECL ldap_parse_sort_controlW( WLDAP32_LDAP *ld, LDAPControlW **control,
  *
  * See ldap_parse_vlv_controlW.
  */
-int CDECL ldap_parse_vlv_controlA( WLDAP32_LDAP *ld, LDAPControlA **control, ULONG *targetpos, ULONG *listcount,
-    struct WLDAP32_berval **context, int *errcode )
+int CDECL ldap_parse_vlv_controlA( LDAP *ld, LDAPControlA **control, ULONG *targetpos, ULONG *listcount,
+    struct berval **context, int *errcode )
 {
     int ret;
     LDAPControlW **controlW = NULL;
@@ -350,7 +351,7 @@ int CDECL ldap_parse_vlv_controlA( WLDAP32_LDAP *ld, LDAPControlA **control, ULO
 
     if (!ld) return ~0u;
 
-    if (control && !(controlW = controlarrayAtoW( control ))) return WLDAP32_LDAP_NO_MEMORY;
+    if (control && !(controlW = controlarrayAtoW( control ))) return LDAP_NO_MEMORY;
     ret = ldap_parse_vlv_controlW( ld, controlW, targetpos, listcount, context, errcode );
     controlarrayfreeW( controlW );
     return ret;
@@ -376,8 +377,8 @@ int CDECL ldap_parse_vlv_controlA( WLDAP32_LDAP *ld, LDAPControlA **control, ULO
  * NOTES
  *  Free the server context with ber_bvfree.
  */
-int CDECL ldap_parse_vlv_controlW( WLDAP32_LDAP *ld, LDAPControlW **control, ULONG *targetpos, ULONG *listcount,
-    struct WLDAP32_berval **context, int *errcode )
+int CDECL ldap_parse_vlv_controlW( LDAP *ld, LDAPControlW **control, ULONG *targetpos, ULONG *listcount,
+    struct berval **context, int *errcode )
 {
     int ret, pos, count;
     LDAPControlU **controlU, *vlvcontrolU = NULL;
@@ -388,7 +389,7 @@ int CDECL ldap_parse_vlv_controlW( WLDAP32_LDAP *ld, LDAPControlW **control, ULO
 
     if (!ld || !control) return ~0u;
 
-    if (!(controlU = controlarrayWtoU( control ))) return WLDAP32_LDAP_NO_MEMORY;
+    if (!(controlU = controlarrayWtoU( control ))) return LDAP_NO_MEMORY;
 
     for (i = 0; controlU[i]; i++)
     {
@@ -398,21 +399,22 @@ int CDECL ldap_parse_vlv_controlW( WLDAP32_LDAP *ld, LDAPControlW **control, ULO
     if (!vlvcontrolU)
     {
         controlarrayfreeU( controlU );
-        return WLDAP32_LDAP_CONTROL_NOT_FOUND;
+        return LDAP_CONTROL_NOT_FOUND;
     }
 
-    ret = map_error( ldap_funcs->ldap_parse_vlvresponse_control( ld->ld, vlvcontrolU, &pos, &count, &ctxU, errcode ) );
-    if (ret == WLDAP32_LDAP_SUCCESS)
+    ret = map_error( ldap_funcs->fn_ldap_parse_vlvresponse_control( CTX(ld), vlvcontrolU, &pos, &count, &ctxU,
+                                                                    errcode ) );
+    if (ret == LDAP_SUCCESS)
     {
-        struct WLDAP32_berval *bv;
+        struct berval *bv;
         if ((bv = bervalUtoW( ctxU )))
         {
             *context = bv;
             *targetpos = pos;
             *listcount = count;
         }
-        else ret = WLDAP32_LDAP_NO_MEMORY;
-        ldap_funcs->ber_bvfree( ctxU );
+        else ret = LDAP_NO_MEMORY;
+        ldap_funcs->fn_ber_bvfree( ctxU );
     }
 
     controlarrayfreeU( controlU );
diff --git a/dlls/wldap32/rename.c b/dlls/wldap32/rename.c
index b5e06f3f7dd6..8d8951f214b1 100644
--- a/dlls/wldap32/rename.c
+++ b/dlls/wldap32/rename.c
@@ -22,6 +22,7 @@
 #include "windef.h"
 #include "winbase.h"
 #include "winnls.h"
+#include "winldap.h"
 
 #include "wine/debug.h"
 #include "winldap_private.h"
@@ -33,17 +34,17 @@ WINE_DEFAULT_DEBUG_CHANNEL(wldap32);
  *
  *  See ldap_rename_extW.
  */
-ULONG CDECL ldap_rename_extA( WLDAP32_LDAP *ld, char *dn, char *newrdn, char *newparent, int delete,
+ULONG CDECL ldap_rename_extA( LDAP *ld, char *dn, char *newrdn, char *newparent, int delete,
     LDAPControlA **serverctrls, LDAPControlA **clientctrls, ULONG *message )
 {
-    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
+    ULONG ret = LDAP_NO_MEMORY;
     WCHAR *dnW = NULL, *newrdnW = NULL, *newparentW = NULL;
     LDAPControlW **serverctrlsW = NULL, **clientctrlsW = NULL;
 
     TRACE( "(%p, %s, %s, %s, 0x%02x, %p, %p, %p)\n", ld, debugstr_a(dn), debugstr_a(newrdn), debugstr_a(newparent),
            delete, serverctrls, clientctrls, message );
 
-    if (!ld || !message) return WLDAP32_LDAP_PARAM_ERROR;
+    if (!ld || !message) return LDAP_PARAM_ERROR;
 
     if (dn && !(dnW = strAtoW( dn ))) goto exit;
     if (newrdn && !(newrdnW = strAtoW( newrdn ))) goto exit;
@@ -86,17 +87,17 @@ ULONG CDECL ldap_rename_extA( WLDAP32_LDAP *ld, char *dn, char *newrdn, char *ne
  *  the operation. Cancel the operation by calling ldap_abandon
  *  with the message ID.
  */
-ULONG CDECL ldap_rename_extW( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *newrdn, WCHAR *newparent, int delete,
+ULONG CDECL ldap_rename_extW( LDAP *ld, WCHAR *dn, WCHAR *newrdn, WCHAR *newparent, int delete,
     LDAPControlW **serverctrls, LDAPControlW **clientctrls, ULONG *message )
 {
-    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
+    ULONG ret = LDAP_NO_MEMORY;
     char *dnU = NULL, *newrdnU = NULL, *newparentU = NULL;
     LDAPControlU **serverctrlsU = NULL, **clientctrlsU = NULL;
 
     TRACE( "(%p, %s, %s, %s, 0x%02x, %p, %p, %p)\n", ld, debugstr_w(dn), debugstr_w(newrdn), debugstr_w(newparent),
            delete, serverctrls, clientctrls, message );
 
-    if (!ld || !message) return WLDAP32_LDAP_PARAM_ERROR;
+    if (!ld || !message) return LDAP_PARAM_ERROR;
 
     if (dn && !(dnU = strWtoU( dn ))) goto exit;
     if (newrdn && !(newrdnU = strWtoU( newrdn ))) goto exit;
@@ -104,8 +105,8 @@ ULONG CDECL ldap_rename_extW( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *newrdn, WCHAR
     if (serverctrls && !(serverctrlsU = controlarrayWtoU( serverctrls ))) goto exit;
     if (clientctrls && !(clientctrlsU = controlarrayWtoU( clientctrls ))) goto exit;
 
-    ret = map_error( ldap_funcs->ldap_rename( ld->ld, dnU, newrdnU, newparentU, delete, serverctrlsU, clientctrlsU,
-                                              message ) );
+    ret = map_error( ldap_funcs->fn_ldap_rename( CTX(ld), dnU, newrdnU, newparentU, delete, serverctrlsU, clientctrlsU,
+                                                 message ) );
 exit:
     free( dnU );
     free( newrdnU );
@@ -120,17 +121,17 @@ ULONG CDECL ldap_rename_extW( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *newrdn, WCHAR
  *
  *  See ldap_rename_ext_sW.
  */
-ULONG CDECL ldap_rename_ext_sA( WLDAP32_LDAP *ld, char *dn, char *newrdn, char *newparent, int delete,
+ULONG CDECL ldap_rename_ext_sA( LDAP *ld, char *dn, char *newrdn, char *newparent, int delete,
     LDAPControlA **serverctrls, LDAPControlA **clientctrls )
 {
-    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
+    ULONG ret = LDAP_NO_MEMORY;
     WCHAR *dnW = NULL, *newrdnW = NULL, *newparentW = NULL;
     LDAPControlW **serverctrlsW = NULL, **clientctrlsW = NULL;
 
     TRACE( "(%p, %s, %s, %s, 0x%02x, %p, %p)\n", ld, debugstr_a(dn), debugstr_a(newrdn), debugstr_a(newparent),
            delete, serverctrls, clientctrls );
 
-    if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
+    if (!ld) return LDAP_PARAM_ERROR;
 
     if (dn && !(dnW = strAtoW( dn ))) goto exit;
     if (newrdn && !(newrdnW = strAtoW( newrdn ))) goto exit;
@@ -166,17 +167,17 @@ ULONG CDECL ldap_rename_ext_sA( WLDAP32_LDAP *ld, char *dn, char *newrdn, char *
  *  Success: LDAP_SUCCESS
  *  Failure: An LDAP error code.
  */
-ULONG CDECL ldap_rename_ext_sW( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *newrdn, WCHAR *newparent, int delete,
+ULONG CDECL ldap_rename_ext_sW( LDAP *ld, WCHAR *dn, WCHAR *newrdn, WCHAR *newparent, int delete,
     LDAPControlW **serverctrls, LDAPControlW **clientctrls )
 {
-    ULONG ret = WLDAP32_LDAP_PARAM_ERROR;
+    ULONG ret = LDAP_PARAM_ERROR;
     char *dnU = NULL, *newrdnU = NULL, *newparentU = NULL;
     LDAPControlU **serverctrlsU = NULL, **clientctrlsU = NULL;
 
     TRACE( "(%p, %s, %s, %s, 0x%02x, %p, %p)\n", ld, debugstr_w(dn), debugstr_w(newrdn), debugstr_w(newparent),
            delete, serverctrls, clientctrls );
 
-    if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
+    if (!ld) return LDAP_PARAM_ERROR;
 
     if (dn && !(dnU = strWtoU( dn ))) goto exit;
     if (newrdn && !(newrdnU = strWtoU( newrdn ))) goto exit;
@@ -184,8 +185,8 @@ ULONG CDECL ldap_rename_ext_sW( WLDAP32_LDAP *ld, WCHAR *dn, WCHAR *newrdn, WCHA
     if (serverctrls && !(serverctrlsU = controlarrayWtoU( serverctrls ))) goto exit;
     if (clientctrls && !(clientctrlsU = controlarrayWtoU( clientctrls ))) goto exit;
 
-    ret = map_error( ldap_funcs->ldap_rename_s( ld->ld, dnU, newrdnU, newparentU, delete, serverctrlsU,
-                                                clientctrlsU ) );
+    ret = map_error( ldap_funcs->fn_ldap_rename_s( CTX(ld), dnU, newrdnU, newparentU, delete, serverctrlsU,
+                                                   clientctrlsU ) );
 exit:
     free( dnU );
     free( newrdnU );
diff --git a/dlls/wldap32/search.c b/dlls/wldap32/search.c
index 7a496e02af38..af5b4ab63d33 100644
--- a/dlls/wldap32/search.c
+++ b/dlls/wldap32/search.c
@@ -23,6 +23,7 @@
 #include "windef.h"
 #include "winbase.h"
 #include "winnls.h"
+#include "winldap.h"
 
 #include "wine/debug.h"
 #include "winldap_private.h"
@@ -34,9 +35,9 @@ WINE_DEFAULT_DEBUG_CHANNEL(wldap32);
  *
  * See ldap_searchW.
  */
-ULONG CDECL ldap_searchA( WLDAP32_LDAP *ld, char *base, ULONG scope, char *filter, char **attrs, ULONG attrsonly )
+ULONG CDECL ldap_searchA( LDAP *ld, char *base, ULONG scope, char *filter, char **attrs, ULONG attrsonly )
 {
-    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
+    ULONG ret = LDAP_NO_MEMORY;
     WCHAR *baseW = NULL, *filterW = NULL, **attrsW = NULL;
 
     TRACE( "(%p, %s, 0x%08x, %s, %p, 0x%08x)\n", ld, debugstr_a(base), scope, debugstr_a(filter), attrs, attrsonly );
@@ -79,13 +80,13 @@ ULONG CDECL ldap_searchA( WLDAP32_LDAP *ld, char *base, ULONG scope, char *filte
  *  the operation. Cancel the operation by calling ldap_abandon
  *  with the message ID.
  */
-ULONG CDECL ldap_searchW( WLDAP32_LDAP *ld, WCHAR *base, ULONG scope, WCHAR *filter, WCHAR **attrs, ULONG attrsonly )
+ULONG CDECL ldap_searchW( LDAP *ld, WCHAR *base, ULONG scope, WCHAR *filter, WCHAR **attrs, ULONG attrsonly )
 {
     ULONG ret, msg;
     TRACE( "(%p, %s, 0x%08x, %s, %p, 0x%08x)\n", ld, debugstr_w(base), scope, debugstr_w(filter), attrs, attrsonly );
 
     ret = ldap_search_extW( ld, base, scope, filter, attrs, attrsonly, NULL, NULL, 0, 0, &msg );
-    if (ret == WLDAP32_LDAP_SUCCESS) return msg;
+    if (ret == LDAP_SUCCESS) return msg;
     return ~0u;
 }
 
@@ -94,17 +95,17 @@ ULONG CDECL ldap_searchW( WLDAP32_LDAP *ld, WCHAR *base, ULONG scope, WCHAR *fil
  *
  * See ldap_search_extW.
  */
-ULONG CDECL ldap_search_extA( WLDAP32_LDAP *ld, char *base, ULONG scope, char *filter, char **attrs, ULONG attrsonly,
+ULONG CDECL ldap_search_extA( LDAP *ld, char *base, ULONG scope, char *filter, char **attrs, ULONG attrsonly,
     LDAPControlA **serverctrls, LDAPControlA **clientctrls, ULONG timelimit, ULONG sizelimit, ULONG *message )
 {
-    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
+    ULONG ret = LDAP_NO_MEMORY;
     WCHAR *baseW = NULL, *filterW = NULL, **attrsW = NULL;
     LDAPControlW **serverctrlsW = NULL, **clientctrlsW = NULL;
 
     TRACE( "(%p, %s, 0x%08x, %s, %p, 0x%08x, %p, %p, 0x%08x, 0x%08x, %p)\n", ld, debugstr_a(base), scope,
            debugstr_a(filter), attrs, attrsonly, serverctrls, clientctrls, timelimit, sizelimit, message );
 
-    if (!ld) return WLDAP32_LDAP_PARAM_ERROR;
+    if (!ld) return LDAP_PARAM_ERROR;
 
     if (base && !(baseW = strAtoW( base ))) goto exit;
     if (filter && !(filterW = strAtoW( filter ))) goto exit;
@@ -152,11 +153,11 @@ ULONG CDECL ldap_search_extA( WLDAP32_LDAP *ld, char *base, ULONG scope, char *f
  *  the operation. Cancel the operation by calling ldap_abandon
  *  with the message ID.
  */
-ULONG CDECL ldap_search_extW( WLDAP32_LDAP *ld, WCHAR *base, ULONG scope, WCHAR *filter, WCHAR **attrs,
+ULONG CDECL ldap_search_extW( LDAP *ld, WCHAR *base, ULONG scope, WCHAR *filter, WCHAR **attrs,
     ULONG attrsonly, LDAPControlW **serverctrls, LDAPControlW **clientctrls, ULONG timelimit, ULONG sizelimit,
     ULONG *message )
 {
-    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
+    ULONG ret = LDAP_NO_MEMORY;
     char *baseU = NULL, *filterU = NULL, **attrsU = NULL;
     LDAPControlU **serverctrlsU = NULL, **clientctrlsU = NULL;
     struct timevalU timevalU;
@@ -175,9 +176,8 @@ ULONG CDECL ldap_search_extW( WLDAP32_LDAP *ld, WCHAR *base, ULONG scope, WCHAR
     timevalU.tv_sec = timelimit;
     timevalU.tv_usec = 0;
 
-    ret = map_error( ldap_funcs->ldap_search_ext( ld->ld, baseU, scope, filterU, attrsU, attrsonly,
-                                                  serverctrlsU, clientctrlsU, timelimit ? &timevalU : NULL, sizelimit,
-                                                  message ) );
+    ret = map_error( ldap_funcs->fn_ldap_search_ext( CTX(ld), baseU, scope, filterU, attrsU, attrsonly, serverctrlsU,
+                                                     clientctrlsU, timelimit ? &timevalU : NULL, sizelimit, message ) );
 exit:
     free( baseU );
     free( filterU );
@@ -192,18 +192,18 @@ ULONG CDECL ldap_search_extW( WLDAP32_LDAP *ld, WCHAR *base, ULONG scope, WCHAR
  *
  * See ldap_search_ext_sW.
  */
-ULONG CDECL ldap_search_ext_sA( WLDAP32_LDAP *ld, char *base, ULONG scope, char *filter, char **attrs,
+ULONG CDECL ldap_search_ext_sA( LDAP *ld, char *base, ULONG scope, char *filter, char **attrs,
     ULONG attrsonly, LDAPControlA **serverctrls, LDAPControlA **clientctrls, struct l_timeval *timeout,
-    ULONG sizelimit, WLDAP32_LDAPMessage **res )
+    ULONG sizelimit, LDAPMessage **res )
 {
-    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
+    ULONG ret = LDAP_NO_MEMORY;
     WCHAR *baseW = NULL, *filterW = NULL, **attrsW = NULL;
     LDAPControlW **serverctrlsW = NULL, **clientctrlsW = NULL;
 
     TRACE( "(%p, %s, 0x%08x, %s, %p, 0x%08x, %p, %p, %p, 0x%08x, %p)\n", ld, debugstr_a(base), scope,
            debugstr_a(filter), attrs, attrsonly, serverctrls, clientctrls, timeout, sizelimit, res );
 
-    if (!ld || !res) return WLDAP32_LDAP_PARAM_ERROR;
+    if (!ld || !res) return LDAP_PARAM_ERROR;
 
     if (base && !(baseW = strAtoW( base ))) goto exit;
     if (filter && !(filterW = strAtoW( filter ))) goto exit;
@@ -249,11 +249,11 @@ ULONG CDECL ldap_search_ext_sA( WLDAP32_LDAP *ld, char *base, ULONG scope, char
  * NOTES
  *  Call ldap_msgfree to free the results.
  */
-ULONG CDECL ldap_search_ext_sW( WLDAP32_LDAP *ld, WCHAR *base, ULONG scope, WCHAR *filter, WCHAR **attrs,
+ULONG CDECL ldap_search_ext_sW( LDAP *ld, WCHAR *base, ULONG scope, WCHAR *filter, WCHAR **attrs,
     ULONG attrsonly, LDAPControlW **serverctrls, LDAPControlW **clientctrls, struct l_timeval *timeout,
-    ULONG sizelimit, WLDAP32_LDAPMessage **res )
+    ULONG sizelimit, LDAPMessage **res )
 {
-    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
+    ULONG ret = LDAP_NO_MEMORY;
     char *baseU = NULL, *filterU = NULL, **attrsU = NULL;
     LDAPControlU **serverctrlsU = NULL, **clientctrlsU = NULL;
     struct timevalU timevalU;
@@ -262,7 +262,7 @@ ULONG CDECL ldap_search_ext_sW( WLDAP32_LDAP *ld, WCHAR *base, ULONG scope, WCHA
     TRACE( "(%p, %s, 0x%08x, %s, %p, 0x%08x, %p, %p, %p, 0x%08x, %p)\n", ld, debugstr_w(base), scope,
            debugstr_w(filter), attrs, attrsonly, serverctrls, clientctrls, timeout, sizelimit, res );
 
-    if (!ld || !res) return WLDAP32_LDAP_PARAM_ERROR;
+    if (!ld || !res) return LDAP_PARAM_ERROR;
 
     if (base && !(baseU = strWtoU( base ))) goto exit;
     if (filter && !(filterU = strWtoU( filter ))) goto exit;
@@ -276,20 +276,20 @@ ULONG CDECL ldap_search_ext_sW( WLDAP32_LDAP *ld, WCHAR *base, ULONG scope, WCHA
         timevalU.tv_usec = timeout->tv_usec;
     }
 
-    ret = map_error( ldap_funcs->ldap_search_ext_s( ld->ld, baseU, scope, filterU, attrsU, attrsonly, serverctrlsU,
-                                                    clientctrlsU, timeout ? &timevalU : NULL, sizelimit, &msgU ) );
+    ret = map_error( ldap_funcs->fn_ldap_search_ext_s( CTX(ld), baseU, scope, filterU, attrsU, attrsonly, serverctrlsU,
+                                                       clientctrlsU, timeout ? &timevalU : NULL, sizelimit, &msgU ) );
     if (msgU)
     {
-        WLDAP32_LDAPMessage *msg = calloc( 1, sizeof(*msg) );
+        LDAPMessage *msg = calloc( 1, sizeof(*msg) );
         if (msg)
         {
-            msg->Request = msgU;
+            MSG(msg) = msgU;
             *res = msg;
         }
         else
         {
-            ldap_funcs->ldap_msgfree( msgU );
-            ret = WLDAP32_LDAP_NO_MEMORY;
+            ldap_funcs->fn_ldap_msgfree( msgU );
+            ret = LDAP_NO_MEMORY;
         }
     }
 
@@ -307,16 +307,16 @@ ULONG CDECL ldap_search_ext_sW( WLDAP32_LDAP *ld, WCHAR *base, ULONG scope, WCHA
  *
  * See ldap_search_sW.
  */
-ULONG CDECL ldap_search_sA( WLDAP32_LDAP *ld, char *base, ULONG scope, char *filter, char **attrs, ULONG attrsonly,
-    WLDAP32_LDAPMessage **res )
+ULONG CDECL ldap_search_sA( LDAP *ld, char *base, ULONG scope, char *filter, char **attrs, ULONG attrsonly,
+    LDAPMessage **res )
 {
-    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
+    ULONG ret = LDAP_NO_MEMORY;
     WCHAR *baseW = NULL, *filterW = NULL, **attrsW = NULL;
 
     TRACE( "(%p, %s, 0x%08x, %s, %p, 0x%08x, %p)\n", ld, debugstr_a(base), scope, debugstr_a(filter), attrs,
            attrsonly, res );
 
-    if (!ld || !res) return WLDAP32_LDAP_PARAM_ERROR;
+    if (!ld || !res) return LDAP_PARAM_ERROR;
 
     if (base && !(baseW = strAtoW( base ))) goto exit;
     if (filter && !(filterW = strAtoW( filter ))) goto exit;
@@ -353,8 +353,8 @@ ULONG CDECL ldap_search_sA( WLDAP32_LDAP *ld, char *base, ULONG scope, char *fil
  * NOTES
  *  Call ldap_msgfree to free the results.
  */
-ULONG CDECL ldap_search_sW( WLDAP32_LDAP *ld, WCHAR *base, ULONG scope, WCHAR *filter, WCHAR **attrs, ULONG attrsonly,
-    WLDAP32_LDAPMessage **res )
+ULONG CDECL ldap_search_sW( LDAP *ld, WCHAR *base, ULONG scope, WCHAR *filter, WCHAR **attrs, ULONG attrsonly,
+    LDAPMessage **res )
 {
     TRACE( "(%p, %s, 0x%08x, %s, %p, 0x%08x, %p)\n", ld, debugstr_w(base), scope, debugstr_w(filter), attrs,
            attrsonly, res );
@@ -366,16 +366,16 @@ ULONG CDECL ldap_search_sW( WLDAP32_LDAP *ld, WCHAR *base, ULONG scope, WCHAR *f
  *
  * See ldap_search_stW.
  */
-ULONG CDECL ldap_search_stA( WLDAP32_LDAP *ld, const PCHAR base, ULONG scope, const PCHAR filter, char **attrs,
-    ULONG attrsonly, struct l_timeval *timeout, WLDAP32_LDAPMessage **res )
+ULONG CDECL ldap_search_stA( LDAP *ld, const PCHAR base, ULONG scope, const PCHAR filter, char **attrs,
+    ULONG attrsonly, struct l_timeval *timeout, LDAPMessage **res )
 {
-    ULONG ret = WLDAP32_LDAP_NO_MEMORY;
+    ULONG ret = LDAP_NO_MEMORY;
     WCHAR *baseW = NULL, *filterW = NULL, **attrsW = NULL;
 
     TRACE( "(%p, %s, 0x%08x, %s, %p, 0x%08x, %p, %p)\n", ld, debugstr_a(base), scope, debugstr_a(filter), attrs,
            attrsonly, timeout, res );
 
-    if (!ld || !res) return WLDAP32_LDAP_PARAM_ERROR;
+    if (!ld || !res) return LDAP_PARAM_ERROR;
 
     if (base && !(baseW = strAtoW( base ))) goto exit;
     if (filter && !(filterW = strAtoW( filter ))) goto exit;
@@ -413,8 +413,8 @@ ULONG CDECL ldap_search_stA( WLDAP32_LDAP *ld, const PCHAR base, ULONG scope, co
  * NOTES
  *  Call ldap_msgfree to free the results.
  */
-ULONG CDECL ldap_search_stW( WLDAP32_LDAP *ld, const PWCHAR base, ULONG scope, const PWCHAR filter, WCHAR **attrs,
-    ULONG attrsonly, struct l_timeval *timeout, WLDAP32_LDAPMessage **res )
+ULONG CDECL ldap_search_stW( LDAP *ld, const PWCHAR base, ULONG scope, const PWCHAR filter, WCHAR **attrs,
+    ULONG attrsonly, struct l_timeval *timeout, LDAPMessage **res )
 {
     TRACE( "(%p, %s, 0x%08x, %s, %p, 0x%08x, %p, %p)\n", ld, debugstr_w(base), scope, debugstr_w(filter), attrs,
            attrsonly, timeout, res );
diff --git a/dlls/wldap32/value.c b/dlls/wldap32/value.c
index b2111557afb9..d7fc1902bdea 100644
--- a/dlls/wldap32/value.c
+++ b/dlls/wldap32/value.c
@@ -23,6 +23,7 @@
 #include "windef.h"
 #include "winbase.h"
 #include "winnls.h"
+#include "winldap.h"
 
 #include "wine/debug.h"
 #include "winldap_private.h"
@@ -45,10 +46,10 @@ WINE_DEFAULT_DEBUG_CHANNEL(wldap32);
  *  Call ldap_count_values_len with the result of a call to
  *  ldap_get_values_len.
  */
-ULONG CDECL WLDAP32_ldap_count_values_len( struct WLDAP32_berval **values )
+ULONG CDECL ldap_count_values_len( struct berval **values )
 {
     ULONG ret = 0;
-    struct WLDAP32_berval **ptr = values;
+    struct berval **ptr = values;
 
     TRACE( "(%p)\n", values );
 
@@ -107,7 +108,7 @@ ULONG CDECL ldap_count_valuesW( WCHAR **values )
  *
  * See ldap_get_valuesW.
  */
-char ** CDECL ldap_get_valuesA( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *entry, char *attr )
+char ** CDECL ldap_get_valuesA( LDAP *ld, LDAPMessage *entry, char *attr )
 {
     char **ret;
     WCHAR *attrW = NULL, **retW;
@@ -186,7 +187,7 @@ static char **bv2str_array( struct bervalU **bv )
  *  ldap_first_entry or ldap_next_entry. Free the returned
  *  array with a call to ldap_value_freeW.
  */
-WCHAR ** CDECL ldap_get_valuesW( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *entry, WCHAR *attr )
+WCHAR ** CDECL ldap_get_valuesW( LDAP *ld, LDAPMessage *entry, WCHAR *attr )
 {
     WCHAR **ret = NULL;
     char *attrU, **retU;
@@ -196,12 +197,12 @@ WCHAR ** CDECL ldap_get_valuesW( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *entry, W
 
     if (!ld || !entry || !attr || !(attrU = strWtoU( attr ))) return NULL;
 
-    if ((bv = ldap_funcs->ldap_get_values_len( ld->ld, entry->Request, attrU )))
+    if ((bv = ldap_funcs->fn_ldap_get_values_len( CTX(ld), MSG(entry), attrU )))
     {
         retU = bv2str_array( bv );
         ret = strarrayUtoW( retU );
 
-        ldap_funcs->ldap_value_free_len( bv );
+        ldap_funcs->fn_ldap_value_free_len( bv );
         strarrayfreeU( retU );
     }
 
@@ -214,10 +215,10 @@ WCHAR ** CDECL ldap_get_valuesW( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *entry, W
  *
  * See ldap_get_values_lenW.
  */
-struct WLDAP32_berval ** CDECL ldap_get_values_lenA( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *message, char *attr )
+struct berval ** CDECL ldap_get_values_lenA( LDAP *ld, LDAPMessage *message, char *attr )
 {
     WCHAR *attrW;
-    struct WLDAP32_berval **ret;
+    struct berval **ret;
 
     TRACE( "(%p, %p, %s)\n", ld, message, debugstr_a(attr) );
 
@@ -248,17 +249,17 @@ struct WLDAP32_berval ** CDECL ldap_get_values_lenA( WLDAP32_LDAP *ld, WLDAP32_L
  *  ldap_first_entry or ldap_next_entry. Free the returned
  *  array with a call to ldap_value_free_len.
  */
-struct WLDAP32_berval ** CDECL ldap_get_values_lenW( WLDAP32_LDAP *ld, WLDAP32_LDAPMessage *message, WCHAR *attr )
+struct berval ** CDECL ldap_get_values_lenW( LDAP *ld, LDAPMessage *message, WCHAR *attr )
 {
     char *attrU = NULL;
     struct bervalU **retU;
-    struct WLDAP32_berval **ret = NULL;
+    struct berval **ret = NULL;
 
     TRACE( "(%p, %p, %s)\n", ld, message, debugstr_w(attr) );
 
     if (!ld || !message || !attr || !(attrU = strWtoU( attr ))) return NULL;
 
-    if ((retU = ldap_funcs->ldap_get_values_len( ld->ld, message->Request, attrU )))
+    if ((retU = ldap_funcs->fn_ldap_get_values_len( CTX(ld), MSG(message), attrU )))
     {
         ret = bvarrayUtoW( retU );
         bvarrayfreeU( retU );
@@ -280,12 +281,12 @@ struct WLDAP32_berval ** CDECL ldap_get_values_lenW( WLDAP32_LDAP *ld, WLDAP32_L
  *  Success: LDAP_SUCCESS
  *  Failure: An LDAP error code.
  */
-ULONG CDECL WLDAP32_ldap_value_free_len( struct WLDAP32_berval **values )
+ULONG CDECL ldap_value_free_len( struct berval **values )
 {
     TRACE( "(%p)\n", values );
 
     bvarrayfreeW( values );
-    return WLDAP32_LDAP_SUCCESS;
+    return LDAP_SUCCESS;
 }
 
 /***********************************************************************
@@ -298,7 +299,7 @@ ULONG CDECL ldap_value_freeA( char **values )
     TRACE( "(%p)\n", values );
 
     strarrayfreeA( values );
-    return WLDAP32_LDAP_SUCCESS;
+    return LDAP_SUCCESS;
 }
 
 /***********************************************************************
@@ -318,5 +319,5 @@ ULONG CDECL ldap_value_freeW( WCHAR **values )
     TRACE( "(%p)\n", values );
 
     strarrayfreeW( values );
-    return WLDAP32_LDAP_SUCCESS;
+    return LDAP_SUCCESS;
 }
diff --git a/dlls/wldap32/winldap_private.h b/dlls/wldap32/winldap_private.h
index 0d528471b0cd..b8b6daf5a507 100644
--- a/dlls/wldap32/winldap_private.h
+++ b/dlls/wldap32/winldap_private.h
@@ -16,10 +16,6 @@
  * You should have received a copy of the GNU Lesser General Public
  * License along with this library; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- *
- * This is an internal version of winldap.h where constants, types and
- * functions are prefixed with WLDAP32_ whenever they conflict with
- * native headers.
  */
 
 #include <assert.h>
@@ -28,475 +24,24 @@
 #include "winnls.h"
 #include "libldap.h"
 
-#define WLDAP32_LBER_ERROR (~0L)
-
-#define WLDAP32_LDAP_VERSION1   1
-#define WLDAP32_LDAP_VERSION2   2
-#define WLDAP32_LDAP_VERSION3   3
-
-#define WLDAP32_LDAP_OPT_ON  ((void *)1)
-#define WLDAP32_LDAP_OPT_OFF ((void *)0)
-
-#define WLDAP32_LDAP_SCOPE_BASE     0x00
-#define WLDAP32_LDAP_SCOPE_ONELEVEL 0x01
-#define WLDAP32_LDAP_SCOPE_SUBTREE  0x02
-
-#define WLDAP32_LBER_USE_DER 0x01
-
-typedef enum {
-    WLDAP32_LDAP_SUCCESS                 =   0x00,
-    WLDAP32_LDAP_UNWILLING_TO_PERFORM    =   0x35,
-    WLDAP32_LDAP_SERVER_DOWN             =   0x51,
-    WLDAP32_LDAP_LOCAL_ERROR             =   0x52,
-    WLDAP32_LDAP_ENCODING_ERROR          =   0x53,
-    WLDAP32_LDAP_DECODING_ERROR          =   0x54,
-    WLDAP32_LDAP_TIMEOUT                 =   0x55,
-    WLDAP32_LDAP_AUTH_UNKNOWN            =   0x56,
-    WLDAP32_LDAP_FILTER_ERROR            =   0x57,
-    WLDAP32_LDAP_USER_CANCELLED          =   0x58,
-    WLDAP32_LDAP_PARAM_ERROR             =   0x59,
-    WLDAP32_LDAP_NO_MEMORY               =   0x5a,
-    WLDAP32_LDAP_CONNECT_ERROR           =   0x5b,
-    WLDAP32_LDAP_NOT_SUPPORTED           =   0x5c,
-    WLDAP32_LDAP_NO_RESULTS_RETURNED     =   0x5e,
-    WLDAP32_LDAP_CONTROL_NOT_FOUND       =   0x5d,
-    WLDAP32_LDAP_MORE_RESULTS_TO_RETURN  =   0x5f,
-
-    WLDAP32_LDAP_CLIENT_LOOP             =   0x60,
-    WLDAP32_LDAP_REFERRAL_LIMIT_EXCEEDED =   0x61
-} LDAP_RETCODE;
-
-typedef struct berelement
-{
-    PCHAR opaque;
-} WLDAP32_BerElement;
-
-#define WLDAP32_LDAP_OPT_API_INFO               0x00
-#define WLDAP32_LDAP_OPT_DESC                   0x01
-#define WLDAP32_LDAP_OPT_DEREF                  0x02
-#define WLDAP32_LDAP_OPT_SIZELIMIT              0x03
-#define WLDAP32_LDAP_OPT_TIMELIMIT              0x04
-#define WLDAP32_LDAP_OPT_THREAD_FN_PTRS         0x05
-#define WLDAP32_LDAP_OPT_REBIND_FN              0x06
-#define WLDAP32_LDAP_OPT_REBIND_ARG             0x07
-#define WLDAP32_LDAP_OPT_REFERRALS              0x08
-#define WLDAP32_LDAP_OPT_RESTART                0x09
-#define WLDAP32_LDAP_OPT_SSL                    0x0a
-#define WLDAP32_LDAP_OPT_IO_FN_PTRS             0x0b
-#define WLDAP32_LDAP_OPT_CACHE_FN_PTRS          0x0d
-#define WLDAP32_LDAP_OPT_CACHE_STRATEGY         0x0e
-#define WLDAP32_LDAP_OPT_CACHE_ENABLE           0x0f
-#define WLDAP32_LDAP_OPT_REFERRAL_HOP_LIMIT     0x10
-#define WLDAP32_LDAP_OPT_VERSION                0x11
-#define WLDAP32_LDAP_OPT_PROTOCOL_VERSION       WLDAP32_LDAP_OPT_VERSION
-#define WLDAP32_LDAP_OPT_SERVER_CONTROLS        0x12
-#define WLDAP32_LDAP_OPT_API_FEATURE_INFO       0x15
-#define WLDAP32_LDAP_OPT_HOST_NAME              0x30
-#define WLDAP32_LDAP_OPT_ERROR_NUMBER           0x31
-#define WLDAP32_LDAP_OPT_ERROR_STRING           0x32
-#define WLDAP32_LDAP_OPT_SERVER_ERROR           0x33
-#define WLDAP32_LDAP_OPT_SERVER_EXT_ERROR       0x34
-#define WLDAP32_LDAP_OPT_PING_KEEP_ALIVE        0x36
-#define WLDAP32_LDAP_OPT_PING_WAIT_TIME         0x37
-#define WLDAP32_LDAP_OPT_PING_LIMIT             0x38
-#define WLDAP32_LDAP_OPT_DNSDOMAIN_NAME         0x3b
-#define WLDAP32_LDAP_OPT_GETDSNAME_FLAGS        0x3d
-#define WLDAP32_LDAP_OPT_HOST_REACHABLE         0x3e
-#define WLDAP32_LDAP_OPT_PROMPT_CREDENTIALS     0x3f
-#define WLDAP32_LDAP_OPT_TCP_KEEPALIVE          0x40
-#define WLDAP32_LDAP_OPT_FAST_CONCURRENT_BIND   0x41
-#define WLDAP32_LDAP_OPT_SEND_TIMEOUT           0x42
-#define WLDAP32_LDAP_OPT_REFERRAL_CALLBACK      0x70
-#define WLDAP32_LDAP_OPT_CLIENT_CERTIFICATE     0x80
-#define WLDAP32_LDAP_OPT_SERVER_CERTIFICATE     0x81
-#define WLDAP32_LDAP_OPT_AUTO_RECONNECT         0x91
-#define WLDAP32_LDAP_OPT_SSPI_FLAGS             0x92
-#define WLDAP32_LDAP_OPT_SSL_INFO               0x93
-#define WLDAP32_LDAP_OPT_REF_DEREF_CONN_PER_MSG 0x94
-#define WLDAP32_LDAP_OPT_TLS                    WLDAP32_LDAP_OPT_SSL
-#define WLDAP32_LDAP_OPT_TLS_INFO               WLDAP32_LDAP_OPT_SSL_INFO
-#define WLDAP32_LDAP_OPT_SIGN                   0x95
-#define WLDAP32_LDAP_OPT_ENCRYPT                0x96
-#define WLDAP32_LDAP_OPT_SASL_METHOD            0x97
-#define WLDAP32_LDAP_OPT_AREC_EXCLUSIVE         0x98
-#define WLDAP32_LDAP_OPT_SECURITY_CONTEXT       0x99
-#define WLDAP32_LDAP_OPT_ROOTDSE_CACHE          0x9a
-
-#define WLDAP32_LDAP_AUTH_SIMPLE         0x80
-#define WLDAP32_LDAP_AUTH_SASL           0x83
-#define WLDAP32_LDAP_AUTH_NEGOTIATE     0x486
-
-typedef struct WLDAP32_berval
-{
-    ULONG bv_len;
-    PCHAR bv_val;
-} LDAP_BERVAL, *PLDAP_BERVAL, BERVAL, *PBERVAL, WLDAP32_BerValue;
-
-typedef struct wldap32
-{
-    struct
-    {
-        UINT_PTR sb_sd;
-        UCHAR Reserved1[41];
-        ULONG_PTR sb_naddr;
-        UCHAR Reserved2[24];
-    } ld_sb;
-
-    PCHAR ld_host;
-    ULONG ld_version;
-    UCHAR ld_lberoptions;
-    ULONG ld_deref;
-    ULONG ld_timelimit;
-    ULONG ld_sizelimit;
-    ULONG ld_errno;
-    PCHAR ld_matched;
-    PCHAR ld_error;
-    ULONG ld_msgid;
-    UCHAR Reserved3[25];
-    ULONG ld_cldaptries;
-    ULONG ld_cldaptimeout;
-    ULONG ld_refhoplimit;
-    ULONG ld_options;
-    /* internal LDAP context */
-    struct bervalU **ld_server_ctrls;
-    void *ld;
-} WLDAP32_LDAP, *WLDAP32_PLDAP;
-
-typedef struct ldapmodA {
-    ULONG mod_op;
-    PCHAR mod_type;
-    union {
-        PCHAR *modv_strvals;
-        struct WLDAP32_berval **modv_bvals;
-    } mod_vals;
-} LDAPModA, *PLDAPModA;
-
-typedef struct ldapmodW {
-    ULONG mod_op;
-    PWCHAR mod_type;
-    union {
-        PWCHAR *modv_strvals;
-        struct WLDAP32_berval **modv_bvals;
-    } mod_vals;
-} LDAPModW, *PLDAPModW;
-
-typedef struct l_timeval
-{
-    LONG tv_sec;
-    LONG tv_usec;
-} LDAP_TIMEVAL, *PLDAP_TIMEVAL;
-
-typedef struct ldapmsg
-{
-    ULONG lm_msgid;
-    ULONG lm_msgtype;
-
-    PVOID lm_ber;
-
-    struct ldapmsg *lm_chain;
-    struct ldapmsg *lm_next;
-    ULONG lm_time;
-
-    WLDAP32_PLDAP Connection;
-    PVOID Request;
-    ULONG lm_returncode;
-    USHORT lm_referral;
-    BOOLEAN lm_chased;
-    BOOLEAN lm_eom;
-    BOOLEAN ConnectionReferenced;
-} WLDAP32_LDAPMessage, *WLDAP32_PLDAPMessage;
-
-#define LAPI_MAJOR_VER1     1
-#define LAPI_MINOR_VER1     1
-
-typedef struct ldap_version_info
-{
-    ULONG lv_size;
-    ULONG lv_major;
-    ULONG lv_minor;
-} LDAP_VERSION_INFO, *PLDAP_VERSION_INFO;
-
-#define LDAP_PAGED_RESULT_OID_STRING "1.2.840.113556.1.4.319"
-#define LDAP_SERVER_RESP_SORT_OID "1.2.840.113556.1.4.474"
-#define LDAP_CONTROL_VLVRESPONSE "2.16.840.1.113730.3.4.10"
-
-#define LDAP_PAGED_RESULT_OID_STRING_W L"1.2.840.113556.1.4.319"
-#define LDAP_SERVER_RESP_SORT_OID_W L"1.2.840.113556.1.4.474"
-#define LDAP_CONTROL_VLVRESPONSE_W L"2.16.840.1.113730.3.4.10"
-
-typedef struct ldapcontrolA
-{
-    PCHAR ldctl_oid;
-    struct WLDAP32_berval ldctl_value;
-    BOOLEAN ldctl_iscritical;
-} LDAPControlA, *PLDAPControlA;
-
-typedef struct ldapcontrolW
-{
-    PWCHAR ldctl_oid;
-    struct WLDAP32_berval ldctl_value;
-    BOOLEAN ldctl_iscritical;
-} LDAPControlW, *PLDAPControlW;
-
-typedef struct WLDAP32_ldapvlvinfo
-{
-    int ldvlv_version;
-    ULONG ldvlv_before_count;
-    ULONG ldvlv_after_count;
-    ULONG ldvlv_offset;
-    ULONG ldvlv_count;
-    PBERVAL ldvlv_attrvalue;
-    PBERVAL ldvlv_context;
-    VOID *ldvlv_extradata;
-} WLDAP32_LDAPVLVInfo, *WLDAP32_PLDAPVLVInfo;
-
 typedef struct ldapsearch
 {
-    WCHAR *dn, *filter, **attrs;
-    ULONG scope, attrsonly;
+    WCHAR *dn;
+    WCHAR *filter;
+    WCHAR **attrs;
+    ULONG scope;
+    ULONG attrsonly;
     LDAPControlW **serverctrls;
     LDAPControlW **clientctrls;
     struct l_timeval timeout;
     ULONG sizelimit;
-    struct WLDAP32_berval *cookie;
-} LDAPSearch, *PLDAPSearch;
-
-typedef struct ldapsortkeyA
-{
-    PCHAR sk_attrtype;
-    PCHAR sk_matchruleoid;
-    BOOLEAN sk_reverseorder;
-} LDAPSortKeyA, *PLDAPSortKeyA;
-
-typedef struct ldapsortkeyW
-{
-    PWCHAR sk_attrtype;
-    PWCHAR sk_matchruleoid;
-    BOOLEAN sk_reverseorder;
-} LDAPSortKeyW, *PLDAPSortKeyW;
-
-typedef struct ldapapiinfoA
-{
-    int ldapai_info_version;
-    int ldapai_api_version;
-    int ldapai_protocol_version;
-    char **ldapai_extensions;
-    char *ldapai_vendor_name;
-    int ldapai_vendor_version;
-} LDAPAPIInfoA;
-
-typedef struct ldapapiinfoW
-{
-    int ldapai_info_version;
-    int ldapai_api_version;
-    int ldapai_protocol_version;
-    PWCHAR *ldapai_extensions;
-    PWCHAR ldapai_vendor_name;
-    int ldapai_vendor_version;
-} LDAPAPIInfoW;
-
-typedef struct ldap_apifeature_infoA
-{
-    int ldapaif_info_version;
-    char *ldapaif_name;
-    int ldapaif_version;
-} LDAPAPIFeatureInfoA;
-
-typedef struct ldap_apifeature_infoW
-{
-    int ldapaif_info_version;
-    PWCHAR ldapaif_name;
-    int ldapaif_version;
-} LDAPAPIFeatureInfoW;
-
-WLDAP32_BerElement * CDECL WLDAP32_ber_alloc_t(int);
-void CDECL WLDAP32_ber_bvfree(BERVAL *);
-int CDECL WLDAP32_ber_flatten(WLDAP32_BerElement *, BERVAL **);
-void CDECL WLDAP32_ber_free(WLDAP32_BerElement *, int);
-WLDAP32_BerElement * CDECL WLDAP32_ber_init(BERVAL *);
-int WINAPIV WLDAP32_ber_printf(WLDAP32_BerElement *, char *, ...);
-ULONG WINAPIV WLDAP32_ber_scanf(WLDAP32_BerElement *, char *, ...);
-
-WLDAP32_LDAP * CDECL cldap_openA(PCHAR,ULONG);
-WLDAP32_LDAP * CDECL cldap_openW(PWCHAR,ULONG);
-ULONG CDECL WLDAP32_ldap_abandon(WLDAP32_LDAP*,ULONG);
-ULONG CDECL ldap_addA(WLDAP32_LDAP*,PCHAR,LDAPModA*[]);
-ULONG CDECL ldap_addW(WLDAP32_LDAP*,PWCHAR,LDAPModW*[]);
-ULONG CDECL ldap_add_extA(WLDAP32_LDAP*,PCHAR,LDAPModA*[],PLDAPControlA*,PLDAPControlA*,ULONG*);
-ULONG CDECL ldap_add_extW(WLDAP32_LDAP*,PWCHAR,LDAPModW*[],PLDAPControlW*,PLDAPControlW*,ULONG*);
-ULONG CDECL ldap_add_ext_sA(WLDAP32_LDAP*,PCHAR,LDAPModA*[],PLDAPControlA*,PLDAPControlA*);
-ULONG CDECL ldap_add_ext_sW(WLDAP32_LDAP*,PWCHAR,LDAPModW*[],PLDAPControlW*,PLDAPControlW*);
-ULONG CDECL ldap_add_sA(WLDAP32_LDAP*,PCHAR,LDAPModA*[]);
-ULONG CDECL ldap_add_sW(WLDAP32_LDAP*,PWCHAR,LDAPModW*[]);
-ULONG CDECL ldap_bindA(WLDAP32_LDAP*,PCHAR,PCHAR,ULONG);
-ULONG CDECL ldap_bindW(WLDAP32_LDAP*,PWCHAR,PWCHAR,ULONG);
-ULONG CDECL ldap_bind_sA(WLDAP32_LDAP*,PCHAR,PCHAR,ULONG);
-ULONG CDECL ldap_bind_sW(WLDAP32_LDAP*,PWCHAR,PWCHAR,ULONG);
-ULONG CDECL ldap_check_filterA(WLDAP32_LDAP*,PCHAR);
-ULONG CDECL ldap_check_filterW(WLDAP32_LDAP*,PWCHAR);
-ULONG CDECL ldap_cleanup(HANDLE);
-ULONG CDECL ldap_close_extended_op(WLDAP32_LDAP*,ULONG);
-ULONG CDECL ldap_compareA(WLDAP32_LDAP*,PCHAR,PCHAR,PCHAR);
-ULONG CDECL ldap_compareW(WLDAP32_LDAP*,PWCHAR,PWCHAR,PWCHAR);
-ULONG CDECL ldap_compare_extA(WLDAP32_LDAP*,PCHAR,PCHAR,PCHAR,struct WLDAP32_berval*,PLDAPControlA*,PLDAPControlA*,ULONG*);
-ULONG CDECL ldap_compare_extW(WLDAP32_LDAP*,PWCHAR,PWCHAR,PWCHAR,struct WLDAP32_berval*,PLDAPControlW*,PLDAPControlW*,ULONG*);
-ULONG CDECL ldap_compare_ext_sA(WLDAP32_LDAP*,PCHAR,PCHAR,PCHAR,struct WLDAP32_berval*,PLDAPControlA*,PLDAPControlA*);
-ULONG CDECL ldap_compare_ext_sW(WLDAP32_LDAP*,PWCHAR,PWCHAR,PWCHAR,struct WLDAP32_berval*,PLDAPControlW*,PLDAPControlW*);
-ULONG CDECL ldap_compare_sA(WLDAP32_LDAP*,PCHAR,PCHAR,PCHAR);
-ULONG CDECL ldap_compare_sW(WLDAP32_LDAP*,PWCHAR,PWCHAR,PWCHAR);
-ULONG CDECL ldap_connect(WLDAP32_LDAP*,LDAP_TIMEVAL*);
-WLDAP32_LDAP * CDECL ldap_conn_from_msg(WLDAP32_LDAP*,WLDAP32_LDAPMessage*);
-ULONG CDECL ldap_control_freeA(LDAPControlA*);
-ULONG CDECL ldap_control_freeW(LDAPControlW*);
-ULONG CDECL ldap_controls_freeA(LDAPControlA**);
-ULONG CDECL ldap_controls_freeW(LDAPControlW**);
-ULONG CDECL WLDAP32_ldap_count_entries(WLDAP32_LDAP*,WLDAP32_LDAPMessage*);
-ULONG CDECL WLDAP32_ldap_count_references(WLDAP32_LDAP*,WLDAP32_LDAPMessage*);
-ULONG CDECL ldap_count_valuesA(PCHAR*);
-ULONG CDECL ldap_count_valuesW(PWCHAR*);
-ULONG CDECL WLDAP32_ldap_count_values_len(PBERVAL*);
-ULONG CDECL ldap_create_page_controlA(WLDAP32_PLDAP,ULONG,struct WLDAP32_berval*,UCHAR,PLDAPControlA*);
-ULONG CDECL ldap_create_page_controlW(WLDAP32_PLDAP,ULONG,struct WLDAP32_berval*,UCHAR,PLDAPControlW*);
-ULONG CDECL ldap_create_sort_controlA(WLDAP32_PLDAP,PLDAPSortKeyA*,UCHAR,PLDAPControlA*);
-ULONG CDECL ldap_create_sort_controlW(WLDAP32_PLDAP,PLDAPSortKeyW*,UCHAR,PLDAPControlW*);
-INT CDECL ldap_create_vlv_controlA(WLDAP32_LDAP*,WLDAP32_LDAPVLVInfo*,UCHAR,LDAPControlA**);
-INT CDECL ldap_create_vlv_controlW(WLDAP32_LDAP*,WLDAP32_LDAPVLVInfo*,UCHAR,LDAPControlW**);
-ULONG CDECL ldap_deleteA(WLDAP32_LDAP*,PCHAR);
-ULONG CDECL ldap_deleteW(WLDAP32_LDAP*,PWCHAR);
-ULONG CDECL ldap_delete_extA(WLDAP32_LDAP*,PCHAR,PLDAPControlA*,PLDAPControlA*,ULONG*);
-ULONG CDECL ldap_delete_extW(WLDAP32_LDAP*,PWCHAR,PLDAPControlW*,PLDAPControlW*,ULONG*);
-ULONG CDECL ldap_delete_ext_sA(WLDAP32_LDAP*,PCHAR,PLDAPControlA*,PLDAPControlA*);
-ULONG CDECL ldap_delete_ext_sW(WLDAP32_LDAP*,PWCHAR,PLDAPControlW*,PLDAPControlW*);
-ULONG CDECL ldap_delete_sA(WLDAP32_LDAP*,PCHAR);
-ULONG CDECL ldap_delete_sW(WLDAP32_LDAP*,PWCHAR);
-PCHAR CDECL ldap_dn2ufnA(PCHAR);
-PWCHAR CDECL ldap_dn2ufnW(PWCHAR);
-ULONG CDECL ldap_encode_sort_controlA(WLDAP32_PLDAP,PLDAPSortKeyA*,PLDAPControlA,BOOLEAN);
-ULONG CDECL ldap_encode_sort_controlW(WLDAP32_PLDAP,PLDAPSortKeyW*,PLDAPControlW,BOOLEAN);
-PCHAR CDECL ldap_err2stringA(ULONG);
-PWCHAR CDECL ldap_err2stringW(ULONG);
-ULONG CDECL ldap_escape_filter_elementA(PCHAR,ULONG,PCHAR,ULONG);
-ULONG CDECL ldap_escape_filter_elementW(PCHAR,ULONG,PWCHAR,ULONG);
-PCHAR * CDECL ldap_explode_dnA(PCHAR,ULONG);
-PWCHAR * CDECL ldap_explode_dnW(PWCHAR,ULONG);
-ULONG CDECL ldap_extended_operationA(WLDAP32_LDAP*,PCHAR,struct WLDAP32_berval*,PLDAPControlA*,PLDAPControlA*,ULONG*);
-ULONG CDECL ldap_extended_operationW(WLDAP32_LDAP*,PWCHAR,struct WLDAP32_berval*,PLDAPControlW*,PLDAPControlW*,ULONG*);
-ULONG CDECL ldap_extended_operation_sA(WLDAP32_LDAP*,PCHAR,struct WLDAP32_berval*,PLDAPControlA*, PLDAPControlA*,
-    PCHAR*,struct WLDAP32_berval**);
-ULONG CDECL ldap_extended_operation_sW(WLDAP32_LDAP*,PWCHAR,struct WLDAP32_berval*,PLDAPControlW*, PLDAPControlW*,
-    PWCHAR*,struct WLDAP32_berval**);
-PCHAR CDECL ldap_first_attributeA(WLDAP32_LDAP*,WLDAP32_LDAPMessage*,WLDAP32_BerElement**);
-PWCHAR CDECL ldap_first_attributeW(WLDAP32_LDAP*,WLDAP32_LDAPMessage*,WLDAP32_BerElement**);
-WLDAP32_LDAPMessage * CDECL WLDAP32_ldap_first_entry(WLDAP32_LDAP*,WLDAP32_LDAPMessage*);
-WLDAP32_LDAPMessage * CDECL WLDAP32_ldap_first_reference(WLDAP32_LDAP*,WLDAP32_LDAPMessage*);
-ULONG CDECL ldap_free_controlsA(LDAPControlA**);
-ULONG CDECL ldap_free_controlsW(LDAPControlW**);
-PCHAR CDECL ldap_get_dnA(WLDAP32_LDAP*,WLDAP32_LDAPMessage*);
-PWCHAR CDECL ldap_get_dnW(WLDAP32_LDAP*,WLDAP32_LDAPMessage*);
-ULONG CDECL ldap_get_next_page(WLDAP32_LDAP*,PLDAPSearch,ULONG,ULONG*);
-ULONG CDECL ldap_get_next_page_s(WLDAP32_LDAP*,PLDAPSearch,struct l_timeval*,ULONG,ULONG*,WLDAP32_LDAPMessage**);
-ULONG CDECL ldap_get_optionA(WLDAP32_LDAP*,int,void*);
-ULONG CDECL ldap_get_optionW(WLDAP32_LDAP*,int,void*);
-ULONG CDECL ldap_get_paged_count(WLDAP32_LDAP*,PLDAPSearch,ULONG*,WLDAP32_LDAPMessage*);
-PCHAR * CDECL ldap_get_valuesA(WLDAP32_LDAP*,WLDAP32_LDAPMessage*,PCHAR);
-PWCHAR * CDECL ldap_get_valuesW(WLDAP32_LDAP*,WLDAP32_LDAPMessage*,PWCHAR);
-PBERVAL * CDECL ldap_get_values_lenA(WLDAP32_LDAP*,WLDAP32_LDAPMessage*,PCHAR);
-PBERVAL * CDECL ldap_get_values_lenW(WLDAP32_LDAP*,WLDAP32_LDAPMessage*,PWCHAR);
-WLDAP32_LDAP * CDECL ldap_initA(const PCHAR,ULONG);
-WLDAP32_LDAP * CDECL ldap_initW(const PWCHAR,ULONG);
-void CDECL ldap_memfreeA(PCHAR);
-void CDECL ldap_memfreeW(PWCHAR);
-ULONG CDECL ldap_modifyA(WLDAP32_LDAP*,PCHAR,LDAPModA*[]);
-ULONG CDECL ldap_modifyW(WLDAP32_LDAP*,PWCHAR,LDAPModW*[]);
-ULONG CDECL ldap_modify_extA(WLDAP32_LDAP*,PCHAR,LDAPModA*[],PLDAPControlA*,PLDAPControlA*,ULONG*);
-ULONG CDECL ldap_modify_extW(WLDAP32_LDAP*,PWCHAR,LDAPModW*[],PLDAPControlW*,PLDAPControlW*,ULONG*);
-ULONG CDECL ldap_modify_ext_sA(WLDAP32_LDAP*,PCHAR,LDAPModA*[],PLDAPControlA*,PLDAPControlA*);
-ULONG CDECL ldap_modify_ext_sW(WLDAP32_LDAP*,PWCHAR,LDAPModW*[],PLDAPControlW*,PLDAPControlW*);
-ULONG CDECL ldap_modify_sA(WLDAP32_LDAP*,PCHAR,LDAPModA*[]);
-ULONG CDECL ldap_modify_sW(WLDAP32_LDAP*,PWCHAR,LDAPModW*[]);
-ULONG CDECL ldap_modrdnA(WLDAP32_LDAP*,PCHAR,PCHAR);
-ULONG CDECL ldap_modrdnW(WLDAP32_LDAP*,PWCHAR,PWCHAR);
-ULONG CDECL ldap_modrdn2A(WLDAP32_LDAP*,PCHAR,PCHAR,INT);
-ULONG CDECL ldap_modrdn2W(WLDAP32_LDAP*,PWCHAR,PWCHAR,INT);
-ULONG CDECL ldap_modrdn2_sA(WLDAP32_LDAP*,PCHAR,PCHAR,INT);
-ULONG CDECL ldap_modrdn2_sW(WLDAP32_LDAP*,PWCHAR,PWCHAR,INT);
-ULONG CDECL ldap_modrdn_sA(WLDAP32_LDAP*,PCHAR,PCHAR);
-ULONG CDECL ldap_modrdn_sW(WLDAP32_LDAP*,PWCHAR,PWCHAR);
-ULONG CDECL WLDAP32_ldap_msgfree(WLDAP32_LDAPMessage*);
-PCHAR CDECL ldap_next_attributeA(WLDAP32_LDAP*,WLDAP32_LDAPMessage*,WLDAP32_BerElement*);
-PWCHAR CDECL ldap_next_attributeW(WLDAP32_LDAP*,WLDAP32_LDAPMessage*,WLDAP32_BerElement*);
-WLDAP32_LDAPMessage * CDECL WLDAP32_ldap_next_entry(WLDAP32_LDAP*,WLDAP32_LDAPMessage*);
-WLDAP32_LDAPMessage * CDECL WLDAP32_ldap_next_reference(WLDAP32_LDAP*,WLDAP32_LDAPMessage*);
-WLDAP32_LDAP * CDECL ldap_openA(PCHAR,ULONG);
-WLDAP32_LDAP * CDECL ldap_openW(PWCHAR,ULONG);
-ULONG CDECL ldap_parse_extended_resultA(WLDAP32_LDAP*,WLDAP32_LDAPMessage*,PCHAR*,struct WLDAP32_berval**,BOOLEAN);
-ULONG CDECL ldap_parse_extended_resultW(WLDAP32_LDAP*,WLDAP32_LDAPMessage*,PWCHAR*,struct WLDAP32_berval**,BOOLEAN);
-ULONG CDECL ldap_parse_page_controlA(WLDAP32_LDAP*,PLDAPControlA*,ULONG*,struct WLDAP32_berval**);
-ULONG CDECL ldap_parse_page_controlW(WLDAP32_LDAP*,PLDAPControlW*,ULONG*,struct WLDAP32_berval**);
-ULONG CDECL ldap_parse_referenceA(WLDAP32_LDAP*,WLDAP32_LDAPMessage*,PCHAR**);
-ULONG CDECL ldap_parse_referenceW(WLDAP32_LDAP*,WLDAP32_LDAPMessage*,PWCHAR**);
-ULONG CDECL ldap_parse_resultA(WLDAP32_LDAP*,WLDAP32_LDAPMessage*,ULONG*,PCHAR*,PCHAR*,PCHAR**,PLDAPControlA**,BOOLEAN);
-ULONG CDECL ldap_parse_resultW(WLDAP32_LDAP*,WLDAP32_LDAPMessage*,ULONG*,PWCHAR*,PWCHAR*,PWCHAR**,PLDAPControlW**,BOOLEAN);
-ULONG CDECL ldap_parse_sort_controlA(WLDAP32_LDAP*,PLDAPControlA*,ULONG*,PCHAR*);
-ULONG CDECL ldap_parse_sort_controlW(WLDAP32_LDAP*,PLDAPControlW*,ULONG*,PWCHAR*);
-int CDECL ldap_parse_vlv_controlA(WLDAP32_LDAP*,LDAPControlA**,ULONG*,ULONG*,struct WLDAP32_berval**,INT*);
-int CDECL ldap_parse_vlv_controlW(WLDAP32_LDAP*,LDAPControlW**,ULONG*,ULONG*,struct WLDAP32_berval**,INT*);
-void CDECL WLDAP32_ldap_perror(WLDAP32_LDAP*,const PCHAR);
-ULONG CDECL ldap_rename_extA(WLDAP32_LDAP*,PCHAR,PCHAR,PCHAR,INT,PLDAPControlA*,PLDAPControlA*,ULONG*);
-ULONG CDECL ldap_rename_extW(WLDAP32_LDAP*,PWCHAR,PWCHAR,PWCHAR,INT,PLDAPControlW*,PLDAPControlW*,ULONG*);
-ULONG CDECL ldap_rename_ext_sA(WLDAP32_LDAP*,PCHAR,PCHAR,PCHAR,INT,PLDAPControlA*,PLDAPControlA*);
-ULONG CDECL ldap_rename_ext_sW(WLDAP32_LDAP*,PWCHAR,PWCHAR,PWCHAR,INT,PLDAPControlW*,PLDAPControlW*);
-ULONG CDECL WLDAP32_ldap_result(WLDAP32_LDAP*,ULONG,ULONG,struct l_timeval*,WLDAP32_LDAPMessage**);
-ULONG CDECL WLDAP32_ldap_result2error(WLDAP32_LDAP*,WLDAP32_LDAPMessage*,ULONG);
-ULONG CDECL ldap_sasl_bindA(WLDAP32_LDAP*,const PSTR,const PSTR,const BERVAL*,PLDAPControlA*,PLDAPControlA*,int*);
-ULONG CDECL ldap_sasl_bindW(WLDAP32_LDAP*,const PWSTR,const PWSTR,const BERVAL*,PLDAPControlW*,PLDAPControlW*,int*);
-ULONG CDECL ldap_sasl_bind_sA(WLDAP32_LDAP*,const PSTR,const PSTR,const BERVAL*,PLDAPControlA*,PLDAPControlA*,PBERVAL*);
-ULONG CDECL ldap_sasl_bind_sW(WLDAP32_LDAP*,const PWSTR,const PWSTR,const BERVAL*,PLDAPControlW*,PLDAPControlW*,PBERVAL*);
-ULONG CDECL ldap_search_abandon_page(WLDAP32_PLDAP,PLDAPSearch);
-ULONG CDECL ldap_searchA(WLDAP32_LDAP*,PCHAR,ULONG,PCHAR,PCHAR[],ULONG);
-ULONG CDECL ldap_searchW(WLDAP32_LDAP*,PWCHAR,ULONG,PWCHAR,PWCHAR[],ULONG);
-ULONG CDECL ldap_search_extA(WLDAP32_LDAP*,PCHAR,ULONG,PCHAR,PCHAR[],ULONG,PLDAPControlA*,
-    PLDAPControlA*,ULONG,ULONG,ULONG*);
-ULONG CDECL ldap_search_extW(WLDAP32_LDAP*,PWCHAR,ULONG,PWCHAR,PWCHAR[],ULONG,PLDAPControlW*,
-    PLDAPControlW*,ULONG,ULONG,ULONG*);
-ULONG CDECL ldap_search_ext_sA(WLDAP32_LDAP*,PCHAR,ULONG,PCHAR,PCHAR[],ULONG,PLDAPControlA*,
-    PLDAPControlA*,struct l_timeval*,ULONG,WLDAP32_LDAPMessage**);
-ULONG CDECL ldap_search_ext_sW(WLDAP32_LDAP*,PWCHAR,ULONG,PWCHAR,PWCHAR[],ULONG,PLDAPControlW*,
-    PLDAPControlW*,struct l_timeval*,ULONG,WLDAP32_LDAPMessage**);
-PLDAPSearch CDECL ldap_search_init_pageA(WLDAP32_PLDAP,PCHAR,ULONG,PCHAR,PCHAR[],ULONG,PLDAPControlA*,
-    PLDAPControlA*,ULONG,ULONG,PLDAPSortKeyA*);
-PLDAPSearch CDECL ldap_search_init_pageW(WLDAP32_PLDAP,PWCHAR,ULONG,PWCHAR,PWCHAR[],ULONG,PLDAPControlW*,
-    PLDAPControlW*,ULONG,ULONG, PLDAPSortKeyW*);
-ULONG CDECL ldap_search_sA(WLDAP32_LDAP*,PCHAR,ULONG,PCHAR,PCHAR[],ULONG,WLDAP32_LDAPMessage**);
-ULONG CDECL ldap_search_sW(WLDAP32_LDAP*,PWCHAR,ULONG,PWCHAR,PWCHAR[],ULONG,WLDAP32_LDAPMessage**);
-ULONG CDECL ldap_search_stA(WLDAP32_LDAP*,const PCHAR,ULONG,const PCHAR,PCHAR[],ULONG,
-    struct l_timeval*,WLDAP32_LDAPMessage**);
-ULONG CDECL ldap_search_stW(WLDAP32_LDAP*,const PWCHAR,ULONG,const PWCHAR,PWCHAR[],ULONG,
-    struct l_timeval*,WLDAP32_LDAPMessage**);
-ULONG CDECL ldap_set_optionA(WLDAP32_LDAP*,int,void*);
-ULONG CDECL ldap_set_optionW(WLDAP32_LDAP*,int,void*);
-ULONG CDECL ldap_simple_bindA(WLDAP32_LDAP*,PCHAR,PCHAR);
-ULONG CDECL ldap_simple_bindW(WLDAP32_LDAP*,PWCHAR,PWCHAR);
-ULONG CDECL ldap_simple_bind_sA(WLDAP32_LDAP*,PCHAR,PCHAR);
-ULONG CDECL ldap_simple_bind_sW(WLDAP32_LDAP*,PWCHAR,PWCHAR);
-WLDAP32_LDAP * CDECL ldap_sslinitA(PCHAR,ULONG,int);
-WLDAP32_LDAP * CDECL ldap_sslinitW(PWCHAR,ULONG,int);
-ULONG CDECL ldap_start_tls_sA(WLDAP32_PLDAP,PULONG,WLDAP32_LDAPMessage**,PLDAPControlA*,PLDAPControlA*);
-ULONG CDECL ldap_start_tls_sW(WLDAP32_PLDAP,PULONG,WLDAP32_LDAPMessage**,PLDAPControlW*,PLDAPControlW*);
-ULONG CDECL ldap_startup(PLDAP_VERSION_INFO,HANDLE*);
-BOOLEAN CDECL ldap_stop_tls_s(WLDAP32_PLDAP);
-ULONG CDECL ldap_ufn2dnA(PCHAR,PCHAR*);
-ULONG CDECL ldap_ufn2dnW(PWCHAR,PWCHAR*);
-ULONG CDECL WLDAP32_ldap_unbind(WLDAP32_LDAP*);
-ULONG CDECL WLDAP32_ldap_unbind_s(WLDAP32_LDAP*);
-ULONG CDECL ldap_value_freeA(PCHAR*);
-ULONG CDECL ldap_value_freeW(PWCHAR*);
-ULONG CDECL WLDAP32_ldap_value_free_len(struct WLDAP32_berval**);
-
-ULONG CDECL LdapGetLastError(void);
-ULONG CDECL LdapMapErrorToWin32(ULONG);
-int CDECL LdapUnicodeToUTF8(LPCWSTR,int,LPSTR,int);
-int CDECL LdapUTF8ToUnicode(LPCSTR,int,LPWSTR,int);
+    struct berval *cookie;
+} LDAPSearch;
+
+#define CTX(ld) (*(void **)ld->Reserved3)
+#define SERVER_CTRLS(ld) (*(void **)(ld->Reserved3 + sizeof(void *)))
+#define MSG(entry) (entry->Request)
+#define BER(ber) (ber->opaque)
 
 ULONG map_error( int ) DECLSPEC_HIDDEN;
 
@@ -572,9 +117,9 @@ static inline WCHAR *strnAtoW( const char *str, DWORD in_len, DWORD *out_len )
     return ret;
 }
 
-static inline DWORD bvarraylenW( struct WLDAP32_berval **bv )
+static inline DWORD bvarraylenW( struct berval **bv )
 {
-    struct WLDAP32_berval **p = bv;
+    struct berval **p = bv;
     while (*p) p++;
     return p - bv;
 }
@@ -657,8 +202,6 @@ static inline char **strarrayWtoA( WCHAR **strarray )
     return strarrayA;
 }
 
-#define WLDAP32_LDAP_MOD_BVALUES    0x80
-
 static inline DWORD modarraylenW( LDAPModW **modarray )
 {
     LDAPModW **p = modarray;
@@ -666,7 +209,7 @@ static inline DWORD modarraylenW( LDAPModW **modarray )
     return p - modarray;
 }
 
-static inline struct bervalU *bervalWtoU( const struct WLDAP32_berval *bv )
+static inline struct bervalU *bervalWtoU( const struct berval *bv )
 {
     struct bervalU *berval;
     DWORD size = sizeof(*berval) + bv->bv_len;
@@ -689,9 +232,9 @@ static inline DWORD bvarraylenU( struct bervalU **bv )
     return p - bv;
 }
 
-static inline struct WLDAP32_berval *bervalUtoW( const struct bervalU *bv )
+static inline struct berval *bervalUtoW( const struct bervalU *bv )
 {
-    struct WLDAP32_berval *berval;
+    struct berval *berval;
     DWORD size = sizeof(*berval) + bv->bv_len;
 
     assert( bv->bv_len <= ~0u );
@@ -707,9 +250,9 @@ static inline struct WLDAP32_berval *bervalUtoW( const struct bervalU *bv )
     return berval;
 }
 
-static inline struct WLDAP32_berval **bvarrayUtoW( struct bervalU **bv )
+static inline struct berval **bvarrayUtoW( struct bervalU **bv )
 {
-    struct WLDAP32_berval **berval = NULL;
+    struct berval **berval = NULL;
     DWORD size;
 
     if (bv)
@@ -718,7 +261,7 @@ static inline struct WLDAP32_berval **bvarrayUtoW( struct bervalU **bv )
         if ((berval = malloc( size )))
         {
             struct bervalU **p = bv;
-            struct WLDAP32_berval **q = berval;
+            struct berval **q = berval;
 
             while (*p) *q++ = bervalUtoW( *p++ );
             *q = NULL;
@@ -732,7 +275,7 @@ static inline void bvfreeU( struct bervalU *berval )
     free( berval );
 }
 
-static inline struct bervalU **bvarrayWtoU( struct WLDAP32_berval **bv )
+static inline struct bervalU **bvarrayWtoU( struct berval **bv )
 {
     struct bervalU **berval = NULL;
     DWORD size;
@@ -742,7 +285,7 @@ static inline struct bervalU **bvarrayWtoU( struct WLDAP32_berval **bv )
         size = sizeof(*berval) * (bvarraylenW( bv ) + 1);
         if ((berval = malloc( size )))
         {
-            struct WLDAP32_berval **p = bv;
+            struct berval **p = bv;
             struct bervalU **q = berval;
 
             while (*p) *q++ = bervalWtoU( *p++ );
@@ -761,7 +304,7 @@ static inline LDAPModU *modWtoU( const LDAPModW *mod )
         modU->mod_op = mod->mod_op;
         modU->mod_type = strWtoU( mod->mod_type );
 
-        if (mod->mod_op & WLDAP32_LDAP_MOD_BVALUES)
+        if (mod->mod_op & LDAP_MOD_BVALUES)
             modU->mod_vals.modv_bvals = bvarrayWtoU( mod->mod_vals.modv_bvals );
         else
             modU->mod_vals.modv_strvals = strarrayWtoU( mod->mod_vals.modv_strvals );
@@ -808,7 +351,7 @@ static inline void strarrayfreeU( char **strarray )
 
 static inline void modfreeU( LDAPModU *mod )
 {
-    if (mod->mod_op & WLDAP32_LDAP_MOD_BVALUES)
+    if (mod->mod_op & LDAP_MOD_BVALUES)
         bvarrayfreeU( mod->mod_vals.modv_bvals );
     else
         strarrayfreeU( mod->mod_vals.modv_strvals );
@@ -832,9 +375,9 @@ static inline DWORD modarraylenA( LDAPModA **modarray )
     return p - modarray;
 }
 
-static inline struct WLDAP32_berval *bervalWtoW( const struct WLDAP32_berval *bv )
+static inline struct berval *bervalWtoW( const struct berval *bv )
 {
-    struct WLDAP32_berval *berval;
+    struct berval *berval;
     DWORD size = sizeof(*berval) + bv->bv_len;
 
     if ((berval = malloc( size )))
@@ -848,9 +391,9 @@ static inline struct WLDAP32_berval *bervalWtoW( const struct WLDAP32_berval *bv
     return berval;
 }
 
-static inline struct WLDAP32_berval **bvarrayWtoW( struct WLDAP32_berval **bv )
+static inline struct berval **bvarrayWtoW( struct berval **bv )
 {
-    struct WLDAP32_berval **berval = NULL;
+    struct berval **berval = NULL;
     DWORD size;
 
     if (bv)
@@ -858,8 +401,8 @@ static inline struct WLDAP32_berval **bvarrayWtoW( struct WLDAP32_berval **bv )
         size = sizeof(*berval) * (bvarraylenW( bv ) + 1);
         if ((berval = malloc( size )))
         {
-            struct WLDAP32_berval **p = bv;
-            struct WLDAP32_berval **q = berval;
+            struct berval **p = bv;
+            struct berval **q = berval;
 
             while (*p) *q++ = bervalWtoW( *p++ );
             *q = NULL;
@@ -904,7 +447,7 @@ static inline LDAPModW *modAtoW( const LDAPModA *mod )
         modW->mod_op = mod->mod_op;
         modW->mod_type = strAtoW( mod->mod_type );
 
-        if (mod->mod_op & WLDAP32_LDAP_MOD_BVALUES)
+        if (mod->mod_op & LDAP_MOD_BVALUES)
             modW->mod_vals.modv_bvals = bvarrayWtoW( mod->mod_vals.modv_bvals );
         else
             modW->mod_vals.modv_strvals = strarrayAtoW( mod->mod_vals.modv_strvals );
@@ -932,9 +475,9 @@ static inline LDAPModW **modarrayAtoW( LDAPModA **modarray )
     return modarrayW;
 }
 
-static inline void bvarrayfreeW( struct WLDAP32_berval **bv )
+static inline void bvarrayfreeW( struct berval **bv )
 {
-    struct WLDAP32_berval **p = bv;
+    struct berval **p = bv;
     while (*p) free( *p++ );
     free( bv );
 }
@@ -951,7 +494,7 @@ static inline void strarrayfreeW( WCHAR **strarray )
 
 static inline void modfreeW( LDAPModW *mod )
 {
-    if (mod->mod_op & WLDAP32_LDAP_MOD_BVALUES)
+    if (mod->mod_op & LDAP_MOD_BVALUES)
         bvarrayfreeW( mod->mod_vals.modv_bvals );
     else
         strarrayfreeW( mod->mod_vals.modv_strvals );
@@ -1467,7 +1010,7 @@ static inline void sortkeyarrayfreeU( LDAPSortKeyU **sortkeyarray )
     }
 }
 
-static inline LDAPVLVInfoU *vlvinfoWtoU( const WLDAP32_LDAPVLVInfo *info )
+static inline LDAPVLVInfoU *vlvinfoWtoU( const LDAPVLVInfo *info )
 {
     LDAPVLVInfoU *infoU;
 
diff --git a/dlls/wldap32/wldap32.spec b/dlls/wldap32/wldap32.spec
index 8a8e29fc198f..63271615eb86 100644
--- a/dlls/wldap32/wldap32.spec
+++ b/dlls/wldap32/wldap32.spec
@@ -1,20 +1,20 @@
- 10 cdecl ldap_abandon(ptr long) WLDAP32_ldap_abandon
+ 10 cdecl ldap_abandon(ptr long)
  11 cdecl ldap_add(ptr str ptr) ldap_addA
  12 cdecl ldap_get_optionW(ptr long ptr)
- 13 cdecl ldap_unbind(ptr) WLDAP32_ldap_unbind
+ 13 cdecl ldap_unbind(ptr)
  14 cdecl ldap_set_optionW(ptr long ptr)
  16 cdecl LdapGetLastError()
  17 cdecl cldap_open(str long) cldap_openA
  18 cdecl LdapMapErrorToWin32(long)
  19 cdecl ldap_compare(ptr str str str) ldap_compareA
  20 cdecl ldap_delete(ptr str) ldap_deleteA
- 21 cdecl ldap_result2error(ptr ptr long) WLDAP32_ldap_result2error
+ 21 cdecl ldap_result2error(ptr ptr long)
  22 cdecl ldap_err2string(long) ldap_err2stringA
  23 cdecl ldap_modify(ptr str ptr) ldap_modifyA
  24 cdecl ldap_modrdn(ptr str ptr) ldap_modrdnA
  25 cdecl ldap_open(str long) ldap_openA
- 26 cdecl ldap_first_entry(ptr ptr) WLDAP32_ldap_first_entry
- 27 cdecl ldap_next_entry(ptr ptr) WLDAP32_ldap_next_entry
+ 26 cdecl ldap_first_entry(ptr ptr)
+ 27 cdecl ldap_next_entry(ptr ptr)
  28 cdecl cldap_openW(wstr long)
  29 cdecl LdapUTF8ToUnicode(str long ptr long)
  30 cdecl ldap_get_dn(ptr ptr) ldap_get_dnA
@@ -23,17 +23,17 @@
  33 cdecl ldap_next_attribute(ptr ptr ptr) ldap_next_attributeA
  34 cdecl ldap_get_values(ptr ptr str) ldap_get_valuesA
  35 cdecl ldap_get_values_len(ptr ptr str) ldap_get_values_lenA
- 36 cdecl ldap_count_entries(ptr ptr) WLDAP32_ldap_count_entries
+ 36 cdecl ldap_count_entries(ptr ptr)
  37 cdecl ldap_count_values(ptr) ldap_count_valuesA
  38 cdecl ldap_value_free(ptr) ldap_value_freeA
  39 cdecl ldap_explode_dn(str long) ldap_explode_dnA
- 40 cdecl ldap_result(ptr long long ptr ptr) WLDAP32_ldap_result
- 41 cdecl ldap_msgfree(ptr) WLDAP32_ldap_msgfree
+ 40 cdecl ldap_result(ptr long long ptr ptr)
+ 41 cdecl ldap_msgfree(ptr)
  42 cdecl ldap_addW(ptr wstr ptr)
  43 cdecl ldap_search(ptr str long str ptr long) ldap_searchA
  44 cdecl ldap_add_s(ptr str ptr) ldap_add_sA
  45 cdecl ldap_bind_s(ptr str str long) ldap_bind_sA
- 46 cdecl ldap_unbind_s(ptr) WLDAP32_ldap_unbind_s
+ 46 cdecl ldap_unbind_s(ptr)
  47 cdecl ldap_delete_s(ptr str) ldap_delete_sA
  48 cdecl ldap_modify_s(ptr str ptr) ldap_modify_sA
  49 cdecl ldap_modrdn_s(ptr str ptr) ldap_modrdn_sA
@@ -41,7 +41,7 @@
  51 cdecl ldap_search_st(ptr str long str ptr long ptr ptr) ldap_search_stA
  52 cdecl ldap_compare_s(ptr str str str) ldap_compare_sA
  53 cdecl LdapUnicodeToUTF8(wstr long ptr long)
- 54 cdecl ber_bvfree(ptr) WLDAP32_ber_bvfree
+ 54 cdecl ber_bvfree(ptr)
  55 cdecl cldap_openA(str long)
  56 cdecl ldap_addA(ptr str ptr)
  57 cdecl ldap_add_ext(ptr str ptr ptr ptr ptr) ldap_add_extA
@@ -64,12 +64,12 @@
  74 cdecl ldap_close_extended_op(ptr long)
  75 cdecl ldap_compareA(ptr str str str)
  76 cdecl ldap_compareW(ptr wstr wstr wstr)
- 77 cdecl ldap_count_values_len(ptr) WLDAP32_ldap_count_values_len
+ 77 cdecl ldap_count_values_len(ptr)
  78 cdecl ldap_compare_ext(ptr str str str ptr ptr ptr ptr) ldap_compare_extA
- 79 cdecl ldap_value_free_len(ptr) WLDAP32_ldap_value_free_len
+ 79 cdecl ldap_value_free_len(ptr)
  80 cdecl ldap_compare_extA(ptr str str str ptr ptr ptr ptr)
  81 cdecl ldap_compare_extW(ptr wstr wstr wstr ptr ptr ptr ptr)
- 82 cdecl ldap_perror(ptr ptr) WLDAP32_ldap_perror
+ 82 cdecl ldap_perror(ptr ptr)
  83 cdecl ldap_compare_ext_s(ptr str str str ptr ptr ptr) ldap_compare_ext_sA
  84 cdecl ldap_compare_ext_sA(ptr str str str ptr ptr ptr)
  85 cdecl ldap_compare_ext_sW(ptr wstr wstr wstr ptr ptr ptr)
@@ -82,7 +82,7 @@
  92 cdecl ldap_controls_free(ptr) ldap_controls_freeA
  93 cdecl ldap_controls_freeA(ptr)
  94 cdecl ldap_controls_freeW(ptr)
- 95 cdecl ldap_count_references(ptr ptr) WLDAP32_ldap_count_references
+ 95 cdecl ldap_count_references(ptr ptr)
  96 cdecl ldap_count_valuesA(ptr)
  97 cdecl ldap_count_valuesW(ptr)
  98 cdecl ldap_create_page_control(ptr long ptr long ptr) ldap_create_page_controlA
@@ -115,7 +115,7 @@
 125 cdecl ldap_extended_operationW(ptr wstr ptr ptr ptr ptr)
 126 cdecl ldap_first_attributeA(ptr ptr ptr)
 127 cdecl ldap_first_attributeW(ptr ptr ptr)
-128 cdecl ldap_first_reference(ptr ptr) WLDAP32_ldap_first_reference
+128 cdecl ldap_first_reference(ptr ptr)
 129 cdecl ldap_free_controls(ptr) ldap_free_controlsA
 130 cdecl ldap_free_controlsA(ptr)
 131 cdecl ldap_free_controlsW(ptr)
@@ -155,7 +155,7 @@
 165 cdecl ldap_modrdn_sW(ptr wstr ptr)
 166 cdecl ldap_next_attributeA(ptr ptr ptr)
 167 cdecl ldap_next_attributeW(ptr ptr ptr)
-168 cdecl ldap_next_reference(ptr ptr) WLDAP32_ldap_next_reference
+168 cdecl ldap_next_reference(ptr ptr)
 169 cdecl ldap_openA(str long)
 170 cdecl ldap_openW(wstr long)
 171 cdecl ldap_parse_page_control(ptr ptr ptr ptr) ldap_parse_page_controlA
@@ -215,18 +215,18 @@
 230 cdecl ldap_check_filterA(ptr str)
 231 cdecl ldap_check_filterW(ptr wstr)
 232 cdecl ldap_dn2ufnA(str)
-300 cdecl ber_init(ptr) WLDAP32_ber_init
-301 cdecl ber_free(ptr long) WLDAP32_ber_free
-302 cdecl ber_bvecfree(ptr) WLDAP32_ber_bvecfree
-303 cdecl ber_bvdup(ptr) WLDAP32_ber_bvdup
-304 cdecl ber_alloc_t(long) WLDAP32_ber_alloc_t
-305 cdecl ber_skip_tag(ptr ptr) WLDAP32_ber_skip_tag
-306 cdecl ber_peek_tag(ptr ptr) WLDAP32_ber_peek_tag
-307 cdecl ber_first_element(ptr ptr ptr) WLDAP32_ber_first_element
-308 cdecl ber_next_element(ptr ptr ptr) WLDAP32_ber_next_element
-309 cdecl ber_flatten(ptr ptr) WLDAP32_ber_flatten
-310 varargs ber_printf(ptr str) WLDAP32_ber_printf
-311 varargs ber_scanf(ptr str) WLDAP32_ber_scanf
+300 cdecl ber_init(ptr)
+301 cdecl ber_free(ptr long)
+302 cdecl ber_bvecfree(ptr)
+303 cdecl ber_bvdup(ptr)
+304 cdecl ber_alloc_t(long)
+305 cdecl ber_skip_tag(ptr ptr)
+306 cdecl ber_peek_tag(ptr ptr)
+307 cdecl ber_first_element(ptr ptr ptr)
+308 cdecl ber_next_element(ptr ptr ptr)
+309 cdecl ber_flatten(ptr ptr)
+310 varargs ber_printf(ptr str)
+311 varargs ber_scanf(ptr str)
 312 cdecl ldap_conn_from_msg(ptr ptr)
 313 cdecl ldap_sasl_bindW(ptr wstr wstr ptr ptr ptr ptr)
 314 cdecl ldap_sasl_bind_sW(ptr wstr wstr ptr ptr ptr ptr)
diff --git a/include/winber.h b/include/winber.h
index 372cc3212699..65d9d50c789b 100644
--- a/include/winber.h
+++ b/include/winber.h
@@ -34,7 +34,7 @@ ULONG CDECL ber_first_element( BerElement *, ULONG *, char ** );
 int CDECL ber_flatten( BerElement *, BERVAL ** );
 void CDECL ber_free( BerElement *, int );
 BerElement * CDECL ber_init( BERVAL * );
-ULONG CDECL ber_next_element( BerElement *, ULONG *, char ** );
+ULONG CDECL ber_next_element( BerElement *, ULONG *, char * );
 ULONG CDECL ber_peek_tag( BerElement *, ULONG * );
 int WINAPIV ber_printf( BerElement *, char *, ... );
 ULONG WINAPIV ber_scanf( BerElement *, char *, ... );
diff --git a/include/winldap.h b/include/winldap.h
index 2cc29ef693c5..5e744b25bafc 100644
--- a/include/winldap.h
+++ b/include/winldap.h
@@ -293,6 +293,14 @@ typedef struct berval
     PCHAR bv_val;
 } LDAP_BERVAL, *PLDAP_BERVAL, BERVAL, *PBERVAL, BerValue;
 
+#define LDAP_PAGED_RESULT_OID_STRING "1.2.840.113556.1.4.319"
+#define LDAP_SERVER_RESP_SORT_OID "1.2.840.113556.1.4.474"
+#define LDAP_CONTROL_VLVRESPONSE "2.16.840.1.113730.3.4.10"
+
+#define LDAP_PAGED_RESULT_OID_STRING_W L"1.2.840.113556.1.4.319"
+#define LDAP_SERVER_RESP_SORT_OID_W L"1.2.840.113556.1.4.474"
+#define LDAP_CONTROL_VLVRESPONSE_W L"2.16.840.1.113730.3.4.10"
+
 typedef struct ldapcontrolA
 {
     PCHAR ldctl_oid;
@@ -586,7 +594,7 @@ ULONG CDECL ldap_simple_bind_sW(LDAP*,PWCHAR,PWCHAR);
 #define    ldap_simple_bind_s WINELIB_NAME_AW(ldap_simple_bind_s)
 ULONG CDECL ldap_search_abandon_page(PLDAP,PLDAPSearch);
 ULONG CDECL ldap_searchA(LDAP*,PCHAR,ULONG,PCHAR,PCHAR[],ULONG);
-ULONG CDECL ldap_searchW(LDAP*,PWCHAR,ULONG,PWCHAR,PCHAR[],ULONG);
+ULONG CDECL ldap_searchW(LDAP*,PWCHAR,ULONG,PWCHAR,PWCHAR[],ULONG);
 #define    ldap_search WINELIB_NAME_AW(ldap_search)
 ULONG CDECL ldap_search_extA(LDAP*,PCHAR,ULONG,PCHAR,PCHAR[],ULONG,PLDAPControlA*,
     PLDAPControlA*,ULONG,ULONG,ULONG*);
From fb4426780390d2a6bd1fced47f867ba46afa3ead Mon Sep 17 00:00:00 2001
From: Hans Leidekker <hans@codeweavers.com>
Date: Tue, 20 Apr 2021 11:42:19 +0200
Subject: [PATCH] wldap32: Fix parsing page controls.

Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/wldap32/page.c | 28 ++++++++++++++--------------
 1 file changed, 14 insertions(+), 14 deletions(-)

diff --git a/dlls/wldap32/page.c b/dlls/wldap32/page.c
index 471108c636e2..8b0ded40e350 100644
--- a/dlls/wldap32/page.c
+++ b/dlls/wldap32/page.c
@@ -20,6 +20,7 @@
 
 #include <stdarg.h>
 #include <stdlib.h>
+#include <limits.h>
 #include "windef.h"
 #include "winbase.h"
 #include "winnls.h"
@@ -31,8 +32,6 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(wldap32);
 
-#define LDAP_MAXINT (2^31)
-
 static struct berval null_cookieW = { 0, NULL };
 
 /***********************************************************************
@@ -48,7 +47,7 @@ ULONG CDECL ldap_create_page_controlA( LDAP *ld, ULONG pagesize, struct berval *
 
     TRACE( "(%p, 0x%08x, %p, 0x%02x, %p)\n", ld, pagesize, cookie, critical, control );
 
-    if (!ld || !control || pagesize > LDAP_MAXINT) return LDAP_PARAM_ERROR;
+    if (!ld || !control || pagesize > INT_MAX) return LDAP_PARAM_ERROR;
 
     ret = ldap_create_page_controlW( ld, pagesize, cookie, critical, &controlW );
     if (ret == LDAP_SUCCESS)
@@ -131,7 +130,7 @@ ULONG CDECL ldap_create_page_controlW( LDAP *ld, ULONG pagesize, struct berval *
 {
     TRACE( "(%p, 0x%08x, %p, 0x%02x, %p)\n", ld, pagesize, cookie, critical, control );
 
-    if (!ld || !control || pagesize > LDAP_MAXINT) return LDAP_PARAM_ERROR;
+    if (!ld || !control || pagesize > INT_MAX) return LDAP_PARAM_ERROR;
     return create_page_control( pagesize, cookie, critical, control );
 }
 
@@ -230,18 +229,18 @@ ULONG CDECL ldap_parse_page_controlA( LDAP *ld, LDAPControlA **ctrls, ULONG *cou
 /***********************************************************************
  *      ldap_parse_page_controlW      (WLDAP32.@)
  */
-ULONG CDECL ldap_parse_page_controlW( LDAP *ld, LDAPControlW **ctrls, ULONG *count, struct berval **cookie )
+ULONG CDECL ldap_parse_page_controlW( LDAP *ld, LDAPControlW **ctrls, ULONG *ret_count, struct berval **ret_cookie )
 {
-    ULONG ret;
+    ULONG ret, count;
     LDAPControlW *control = NULL;
     BerElement *ber;
-    struct berval *vec[2];
+    struct berval *cookie = NULL;
     int tag;
     ULONG i;
 
-    TRACE( "(%p, %p, %p, %p)\n", ld, ctrls, count, cookie );
+    TRACE( "(%p, %p, %p, %p)\n", ld, ctrls, ret_count, ret_cookie );
 
-    if (!ld || !ctrls || !count || !cookie) return LDAP_PARAM_ERROR;
+    if (!ld || !ctrls || !ret_count || !ret_cookie) return LDAP_PARAM_ERROR;
 
     for (i = 0; ctrls[i]; i++)
     {
@@ -252,13 +251,14 @@ ULONG CDECL ldap_parse_page_controlW( LDAP *ld, LDAPControlW **ctrls, ULONG *cou
 
     if (!(ber = ber_init( &control->ldctl_value ))) return LDAP_NO_MEMORY;
 
-    vec[0] = *cookie;
-    vec[1] = 0;
-    tag = ber_scanf( ber, (char *)"{iV}", count, vec );
-    if (tag == LBER_ERROR)
-        ret = LDAP_DECODING_ERROR;
+    tag = ber_scanf( ber, (char *)"{iO}", &count, &cookie );
+    if (tag == LBER_ERROR) ret = LDAP_DECODING_ERROR;
     else
+    {
+        *ret_count = count;
+        *ret_cookie = cookie;
         ret = LDAP_SUCCESS;
+    }
 
     ber_free( ber, 1 );
     return ret;
From 885c480d2e63895693b51a858f0745d2fd2468b4 Mon Sep 17 00:00:00 2001
From: Hans Leidekker <hans@codeweavers.com>
Date: Tue, 20 Apr 2021 11:42:20 +0200
Subject: [PATCH] wldap32: Avoid a crash with tracing on.

Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/wldap32/option.c | 16 +++++++---------
 1 file changed, 7 insertions(+), 9 deletions(-)

diff --git a/dlls/wldap32/option.c b/dlls/wldap32/option.c
index 1037b73174bb..0f3d10e12045 100644
--- a/dlls/wldap32/option.c
+++ b/dlls/wldap32/option.c
@@ -368,9 +368,10 @@ static BOOL query_supported_server_ctrls( LDAP *ld )
 {
     char *attrs[] = { (char *)"supportedControl", NULL };
     void *res, *entry;
+    struct bervalU **ctrls = SERVER_CTRLS(ld);
     ULONG ret;
 
-    if (SERVER_CTRLS(ld)) return TRUE;
+    if (ctrls) return TRUE;
 
     ret = map_error( ldap_funcs->fn_ldap_search_ext_s( CTX(ld), (char *)"", LDAP_SCOPE_BASE, (char *)"(objectClass=*)",
                                                        attrs, FALSE, NULL, NULL, NULL, 0, &res ) );
@@ -380,17 +381,14 @@ static BOOL query_supported_server_ctrls( LDAP *ld )
     if (entry)
     {
         ULONG count, i;
-        struct bervalU **ctrls = SERVER_CTRLS(ld);
-
-        *(struct bervalU ***)&SERVER_CTRLS(ld) = ldap_funcs->fn_ldap_get_values_len( CTX(ld), entry, attrs[0] );
-        count = ldap_funcs->fn_ldap_count_values_len( SERVER_CTRLS(ld) );
-        for (i = 0; i < count; i++)
-            TRACE("%u: %s\n", i, debugstr_an( ctrls[i]->bv_val, ctrls[i]->bv_len ));
+        ctrls = ldap_funcs->fn_ldap_get_values_len( CTX(ld), entry, attrs[0] );
+        count = ldap_funcs->fn_ldap_count_values_len( ctrls );
+        for (i = 0; i < count; i++) TRACE("%u: %s\n", i, debugstr_an( ctrls[i]->bv_val, ctrls[i]->bv_len ));
+        *(struct bervalU ***)&SERVER_CTRLS(ld) = ctrls;
     }
 
     ldap_funcs->fn_ldap_msgfree( res );
-
-    return SERVER_CTRLS(ld) != NULL;
+    return ctrls != NULL;
 }
 
 static BOOL is_supported_server_ctrls( LDAP *ld, LDAPControlU **ctrls )
From 78866a7b87d8569c18e11b934178a2751ad9496f Mon Sep 17 00:00:00 2001
From: Andrey Gusev <andrey.goosev@gmail.com>
Date: Tue, 20 Apr 2021 17:10:28 +0300
Subject: [PATCH] wldap32: Remove redundant 'break' statement.

Signed-off-by: Andrey Gusev <andrey.goosev@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/wldap32/option.c | 1 -
 1 file changed, 1 deletion(-)

diff --git a/dlls/wldap32/option.c b/dlls/wldap32/option.c
index 0f3d10e12045..ec3830d4ab3f 100644
--- a/dlls/wldap32/option.c
+++ b/dlls/wldap32/option.c
@@ -467,7 +467,6 @@ ULONG CDECL ldap_set_optionW( LDAP *ld, int option, void *value )
         else
             FIXME("upgrading referral value %p to LDAP_OPT_ON (OpenLDAP lacks sufficient granularity)\n", value);
         return map_error( ldap_funcs->fn_ldap_set_option( CTX(ld), option, openldap_referral ) );
-        break;
     }
     case LDAP_OPT_DEREF:
     case LDAP_OPT_DESC:
From efdd07ae3df873450dc3786ac3ff164a8a86b421 Mon Sep 17 00:00:00 2001
From: Francois Gouget <fgouget@free.fr>
Date: Thu, 26 Aug 2021 14:51:18 +0200
Subject: [PATCH] wldap32: Make the wrap_*() functions static.

Signed-off-by: Francois Gouget <fgouget@free.fr>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/wldap32/libldap.c | 126 ++++++++++++++++++++---------------------
 dlls/wldap32/libldap.h |  82 ---------------------------
 2 files changed, 63 insertions(+), 145 deletions(-)

diff --git a/dlls/wldap32/libldap.c b/dlls/wldap32/libldap.c
index 5cea944729da..495ea6090590 100644
--- a/dlls/wldap32/libldap.c
+++ b/dlls/wldap32/libldap.c
@@ -61,22 +61,22 @@ static LDAPMod *nullmods[] = { NULL };
 
 static const struct ldap_callbacks *callbacks;
 
-void * CDECL wrap_ber_alloc_t( int options )
+static void * CDECL wrap_ber_alloc_t( int options )
 {
     return ber_alloc_t( options );
 }
 
-void CDECL wrap_ber_bvecfree( struct bervalU **berval )
+static void CDECL wrap_ber_bvecfree( struct bervalU **berval )
 {
     ber_bvecfree( (struct berval **)berval );
 }
 
-void CDECL wrap_ber_bvfree( struct bervalU *berval )
+static void CDECL wrap_ber_bvfree( struct bervalU *berval )
 {
     ber_bvfree( (struct berval *)berval );
 }
 
-unsigned int CDECL wrap_ber_first_element( void *ber, ULONG *ret_len, char **last )
+static unsigned int CDECL wrap_ber_first_element( void *ber, ULONG *ret_len, char **last )
 {
     ber_len_t len;
     ber_tag_t ret;
@@ -97,22 +97,22 @@ unsigned int CDECL wrap_ber_first_element( void *ber, ULONG *ret_len, char **las
     return ret;
 }
 
-int CDECL wrap_ber_flatten( void *ber, struct bervalU **berval )
+static int CDECL wrap_ber_flatten( void *ber, struct bervalU **berval )
 {
     return ber_flatten( ber, (struct berval **)berval );
 }
 
-void CDECL wrap_ber_free( void *ber, int freebuf )
+static void CDECL wrap_ber_free( void *ber, int freebuf )
 {
     ber_free( ber, freebuf );
 }
 
-void * CDECL wrap_ber_init( struct bervalU *berval )
+static void * CDECL wrap_ber_init( struct bervalU *berval )
 {
     return ber_init( (struct berval *)berval );
 }
 
-unsigned int CDECL wrap_ber_next_element( void *ber, unsigned int *ret_len, char *last )
+static unsigned int CDECL wrap_ber_next_element( void *ber, unsigned int *ret_len, char *last )
 {
     ber_len_t len;
     ber_tag_t ret;
@@ -133,7 +133,7 @@ unsigned int CDECL wrap_ber_next_element( void *ber, unsigned int *ret_len, char
     return ret;
 }
 
-unsigned int CDECL wrap_ber_peek_tag( void *ber, unsigned int *ret_len )
+static unsigned int CDECL wrap_ber_peek_tag( void *ber, unsigned int *ret_len )
 {
     ber_len_t len;
     ber_tag_t ret;
@@ -149,7 +149,7 @@ unsigned int CDECL wrap_ber_peek_tag( void *ber, unsigned int *ret_len )
     return ret;
 }
 
-unsigned int CDECL wrap_ber_skip_tag( void *ber, unsigned int *ret_len )
+static unsigned int CDECL wrap_ber_skip_tag( void *ber, unsigned int *ret_len )
 {
     ber_len_t len;
     ber_tag_t ret;
@@ -165,7 +165,7 @@ unsigned int CDECL wrap_ber_skip_tag( void *ber, unsigned int *ret_len )
     return ret;
 }
 
-int WINAPIV wrap_ber_printf( void *ber, char *fmt, ... )
+static int WINAPIV wrap_ber_printf( void *ber, char *fmt, ... )
 {
     int ret;
     __ms_va_list args;
@@ -230,7 +230,7 @@ int WINAPIV wrap_ber_printf( void *ber, char *fmt, ... )
     return ret;
 }
 
-int WINAPIV wrap_ber_scanf( void *ber, char *fmt, ... )
+static int WINAPIV wrap_ber_scanf( void *ber, char *fmt, ... )
 {
     int ret;
     __ms_va_list args;
@@ -301,12 +301,12 @@ int WINAPIV wrap_ber_scanf( void *ber, char *fmt, ... )
     return ret;
 }
 
-int CDECL wrap_ldap_abandon_ext( void *ld, int msgid, LDAPControlU **serverctrls, LDAPControlU **clientctrls )
+static int CDECL wrap_ldap_abandon_ext( void *ld, int msgid, LDAPControlU **serverctrls, LDAPControlU **clientctrls )
 {
     return ldap_abandon_ext( ld, msgid, (LDAPControl **)serverctrls, (LDAPControl **)clientctrls );
 }
 
-int CDECL wrap_ldap_add_ext( void *ld, const char *dn, LDAPModU **attrs, LDAPControlU **serverctrls,
+static int CDECL wrap_ldap_add_ext( void *ld, const char *dn, LDAPModU **attrs, LDAPControlU **serverctrls,
                              LDAPControlU **clientctrls, ULONG *msg )
 {
     int dummy;
@@ -314,14 +314,14 @@ int CDECL wrap_ldap_add_ext( void *ld, const char *dn, LDAPModU **attrs, LDAPCon
                          (LDAPControl **)clientctrls, msg ? (int *)msg : &dummy );
 }
 
-int CDECL wrap_ldap_add_ext_s( void *ld, const char *dn, LDAPModU **attrs, LDAPControlU **serverctrls,
+static int CDECL wrap_ldap_add_ext_s( void *ld, const char *dn, LDAPModU **attrs, LDAPControlU **serverctrls,
                                LDAPControlU **clientctrls )
 {
     return ldap_add_ext_s( ld, dn ? dn : "", attrs ? (LDAPMod **)attrs : nullmods, (LDAPControl **)serverctrls,
                            (LDAPControl **)clientctrls );
 }
 
-int CDECL wrap_ldap_compare_ext( void *ld, const char *dn, const char *attrs, struct bervalU *value,
+static int CDECL wrap_ldap_compare_ext( void *ld, const char *dn, const char *attrs, struct bervalU *value,
                                  LDAPControlU **serverctrls, LDAPControlU **clientctrls, ULONG *msg )
 {
     int dummy;
@@ -329,49 +329,49 @@ int CDECL wrap_ldap_compare_ext( void *ld, const char *dn, const char *attrs, st
                              (LDAPControl **)serverctrls, (LDAPControl **)clientctrls, msg ? (int *)msg : &dummy );
 }
 
-int CDECL wrap_ldap_compare_ext_s( void *ld, const char *dn, const char *attrs, struct bervalU *value,
+static int CDECL wrap_ldap_compare_ext_s( void *ld, const char *dn, const char *attrs, struct bervalU *value,
                                    LDAPControlU **serverctrls, LDAPControlU **clientctrls )
 {
     return ldap_compare_ext_s( ld, dn ? dn : "", attrs ? attrs : "", (struct berval *)value,
                                (LDAPControl **)serverctrls, (LDAPControl **)clientctrls );
 }
 
-void CDECL wrap_ldap_control_free( LDAPControlU *control )
+static void CDECL wrap_ldap_control_free( LDAPControlU *control )
 {
     ldap_control_free( (LDAPControl *)control );
 }
 
-void CDECL wrap_ldap_controls_free( LDAPControlU **control )
+static void CDECL wrap_ldap_controls_free( LDAPControlU **control )
 {
     ldap_controls_free( (LDAPControl **)control );
 }
 
-int CDECL wrap_ldap_count_entries( void *ld, void *chain )
+static int CDECL wrap_ldap_count_entries( void *ld, void *chain )
 {
     return ldap_count_entries( ld, chain );
 }
 
-int CDECL wrap_ldap_count_references( void *ld, void *chain )
+static int CDECL wrap_ldap_count_references( void *ld, void *chain )
 {
     return ldap_count_references( ld, chain );
 }
 
-int CDECL wrap_ldap_count_values_len( struct bervalU **values )
+static int CDECL wrap_ldap_count_values_len( struct bervalU **values )
 {
     return ldap_count_values_len( (struct berval **)values );
 }
 
-int CDECL wrap_ldap_create_sort_control( void *ld, LDAPSortKeyU **keylist, int critical, LDAPControlU **control )
+static int CDECL wrap_ldap_create_sort_control( void *ld, LDAPSortKeyU **keylist, int critical, LDAPControlU **control )
 {
     return ldap_create_sort_control( ld, (LDAPSortKey **)keylist, critical, (LDAPControl **)control );
 }
 
-int CDECL wrap_ldap_create_vlv_control( void *ld, LDAPVLVInfoU *info, LDAPControlU **control )
+static int CDECL wrap_ldap_create_vlv_control( void *ld, LDAPVLVInfoU *info, LDAPControlU **control )
 {
     return ldap_create_vlv_control( ld, (LDAPVLVInfo *)info, (LDAPControl **)control );
 }
 
-int CDECL wrap_ldap_delete_ext( void *ld, const char *dn, LDAPControlU **serverctrls, LDAPControlU **clientctrls,
+static int CDECL wrap_ldap_delete_ext( void *ld, const char *dn, LDAPControlU **serverctrls, LDAPControlU **clientctrls,
                                 ULONG *msg )
 {
     int dummy;
@@ -379,22 +379,22 @@ int CDECL wrap_ldap_delete_ext( void *ld, const char *dn, LDAPControlU **serverc
                             msg ? (int *)msg : &dummy );
 }
 
-int CDECL wrap_ldap_delete_ext_s( void *ld, const char *dn, LDAPControlU **serverctrls, LDAPControlU **clientctrls )
+static int CDECL wrap_ldap_delete_ext_s( void *ld, const char *dn, LDAPControlU **serverctrls, LDAPControlU **clientctrls )
 {
     return ldap_delete_ext_s( ld, dn ? dn : "", (LDAPControl **)serverctrls, (LDAPControl **)clientctrls );
 }
 
-char * CDECL wrap_ldap_dn2ufn( const char *dn )
+static char * CDECL wrap_ldap_dn2ufn( const char *dn )
 {
     return ldap_dn2ufn( dn );
 }
 
-char ** CDECL wrap_ldap_explode_dn( const char *dn, int notypes )
+static char ** CDECL wrap_ldap_explode_dn( const char *dn, int notypes )
 {
     return ldap_explode_dn( dn, notypes );
 }
 
-int CDECL wrap_ldap_extended_operation( void *ld, const char *oid, struct bervalU *data, LDAPControlU **serverctrls,
+static int CDECL wrap_ldap_extended_operation( void *ld, const char *oid, struct bervalU *data, LDAPControlU **serverctrls,
                                         LDAPControlU **clientctrls, ULONG *msg )
 {
     int dummy;
@@ -402,59 +402,59 @@ int CDECL wrap_ldap_extended_operation( void *ld, const char *oid, struct berval
                                     (LDAPControl **)clientctrls, msg ? (int *)msg : &dummy );
 }
 
-int CDECL wrap_ldap_extended_operation_s( void *ld, const char *oid, struct bervalU *data, LDAPControlU **serverctrls,
+static int CDECL wrap_ldap_extended_operation_s( void *ld, const char *oid, struct bervalU *data, LDAPControlU **serverctrls,
                                           LDAPControlU **clientctrls, char **retoid, struct bervalU **retdata )
 {
     return ldap_extended_operation_s( ld, oid ? oid : "", (struct berval *)data, (LDAPControl **)serverctrls,
                                       (LDAPControl **)clientctrls, retoid, (struct berval **)retdata );
 }
 
-char * CDECL wrap_ldap_get_dn( void *ld, void *entry )
+static char * CDECL wrap_ldap_get_dn( void *ld, void *entry )
 {
     return ldap_get_dn( ld, entry );
 }
 
-char * CDECL wrap_ldap_first_attribute( void *ld, void *entry, void **ber )
+static char * CDECL wrap_ldap_first_attribute( void *ld, void *entry, void **ber )
 {
     return ldap_first_attribute( ld, entry, (BerElement **)ber );
 }
 
-void * CDECL wrap_ldap_first_entry( void *ld, void *chain )
+static void * CDECL wrap_ldap_first_entry( void *ld, void *chain )
 {
     return ldap_first_entry( ld, chain );
 }
 
-void * CDECL wrap_ldap_first_reference( void *ld, void *chain )
+static void * CDECL wrap_ldap_first_reference( void *ld, void *chain )
 {
     return ldap_first_reference( ld, chain );
 }
 
-int CDECL wrap_ldap_get_option( void *ld, int option, void *value )
+static int CDECL wrap_ldap_get_option( void *ld, int option, void *value )
 {
     return ldap_get_option( ld, option, value );
 }
 
-struct bervalU ** CDECL wrap_ldap_get_values_len( void *ld, void *entry, const char *attr )
+static struct bervalU ** CDECL wrap_ldap_get_values_len( void *ld, void *entry, const char *attr )
 {
     return (struct bervalU **)ldap_get_values_len( ld, entry, attr );
 }
 
-int CDECL wrap_ldap_initialize( void **ld, const char *url )
+static int CDECL wrap_ldap_initialize( void **ld, const char *url )
 {
     return ldap_initialize( (LDAP **)ld, url );
 }
 
-void CDECL wrap_ldap_memfree( void *ptr )
+static void CDECL wrap_ldap_memfree( void *ptr )
 {
     return ldap_memfree( ptr );
 }
 
-void CDECL wrap_ldap_memvfree( void **ptr )
+static void CDECL wrap_ldap_memvfree( void **ptr )
 {
     ldap_memvfree( ptr );
 }
 
-int CDECL wrap_ldap_modify_ext( void *ld, const char *dn, LDAPModU **mods, LDAPControlU **serverctrls,
+static int CDECL wrap_ldap_modify_ext( void *ld, const char *dn, LDAPModU **mods, LDAPControlU **serverctrls,
                                 LDAPControlU **clientctrls, ULONG *msg )
 {
     int dummy;
@@ -462,88 +462,88 @@ int CDECL wrap_ldap_modify_ext( void *ld, const char *dn, LDAPModU **mods, LDAPC
                             (LDAPControl **)clientctrls, msg ? (int *)msg : &dummy );
 }
 
-int CDECL wrap_ldap_modify_ext_s( void *ld, const char *dn, LDAPModU **mods, LDAPControlU **serverctrls,
+static int CDECL wrap_ldap_modify_ext_s( void *ld, const char *dn, LDAPModU **mods, LDAPControlU **serverctrls,
                                   LDAPControlU **clientctrls )
 {
     return ldap_modify_ext_s( ld, dn ? dn : "", mods ? (LDAPMod **)mods : nullmods, (LDAPControl **)serverctrls,
                               (LDAPControl **)clientctrls );
 }
 
-int CDECL wrap_ldap_msgfree( void *msg )
+static int CDECL wrap_ldap_msgfree( void *msg )
 {
     return ldap_msgfree( msg );
 }
 
-char * CDECL wrap_ldap_next_attribute( void *ld, void *entry, void *ber )
+static char * CDECL wrap_ldap_next_attribute( void *ld, void *entry, void *ber )
 {
     return ldap_next_attribute( ld, entry, ber );
 }
 
-void * CDECL wrap_ldap_next_entry( void *ld, void *entry )
+static void * CDECL wrap_ldap_next_entry( void *ld, void *entry )
 {
     return ldap_next_entry( ld, entry );
 }
 
-void * CDECL wrap_ldap_next_reference( void *ld, void *entry )
+static void * CDECL wrap_ldap_next_reference( void *ld, void *entry )
 {
     return ldap_next_reference( ld, entry );
 }
 
-int CDECL wrap_ldap_parse_extended_result( void *ld, void *result, char **retoid, struct bervalU **retdata, int free )
+static int CDECL wrap_ldap_parse_extended_result( void *ld, void *result, char **retoid, struct bervalU **retdata, int free )
 {
     return ldap_parse_extended_result( ld, result, retoid, (struct berval **)retdata, free );
 }
 
-int CDECL wrap_ldap_parse_reference( void *ld, void *ref, char ***referrals, LDAPControlU ***serverctrls, int free )
+static int CDECL wrap_ldap_parse_reference( void *ld, void *ref, char ***referrals, LDAPControlU ***serverctrls, int free )
 {
     return ldap_parse_reference( ld, ref, referrals, (LDAPControl ***)serverctrls, free );
 }
 
-int CDECL wrap_ldap_parse_result( void *ld, void *res, int *errcode, char **matcheddn, char **errmsg,
+static int CDECL wrap_ldap_parse_result( void *ld, void *res, int *errcode, char **matcheddn, char **errmsg,
                                   char ***referrals, LDAPControlU ***serverctrls, int free )
 {
     return ldap_parse_result( ld, res, errcode, matcheddn, errmsg, referrals, (LDAPControl ***)serverctrls, free );
 }
 
-int CDECL wrap_ldap_parse_sortresponse_control( void *ld, LDAPControlU *ctrl, int *result, char **attr )
+static int CDECL wrap_ldap_parse_sortresponse_control( void *ld, LDAPControlU *ctrl, int *result, char **attr )
 {
     return ldap_parse_sortresponse_control( ld, (LDAPControl *)ctrl, result, attr );
 }
 
-int CDECL wrap_ldap_parse_vlvresponse_control( void *ld, LDAPControlU *ctrls, int *target_pos, int *list_count,
+static int CDECL wrap_ldap_parse_vlvresponse_control( void *ld, LDAPControlU *ctrls, int *target_pos, int *list_count,
                                                struct bervalU **ctx, int *errcode )
 {
     return ldap_parse_vlvresponse_control( ld, (LDAPControl *)ctrls, target_pos, list_count, (struct berval **)ctx,
                                            errcode );
 }
 
-int CDECL wrap_ldap_rename( void *ld, const char *dn, const char *newrdn, const char *newparent, int delete,
+static int CDECL wrap_ldap_rename( void *ld, const char *dn, const char *newrdn, const char *newparent, int delete,
                             LDAPControlU **clientctrls, LDAPControlU **serverctrls, ULONG *msg )
 {
     return ldap_rename( ld, dn ? dn : "", newrdn, newparent, delete, (LDAPControl **)clientctrls,
                         (LDAPControl **)serverctrls, (int *)msg );
 }
 
-int CDECL wrap_ldap_rename_s( void *ld, const char *dn, const char *newrdn, const char *newparent, int delete,
+static int CDECL wrap_ldap_rename_s( void *ld, const char *dn, const char *newrdn, const char *newparent, int delete,
                               LDAPControlU **clientctrls, LDAPControlU **serverctrls )
 {
     return ldap_rename_s( ld, dn ? dn : "", newrdn, newparent, delete, (LDAPControl **)clientctrls,
                           (LDAPControl **)serverctrls );
 }
 
-int CDECL wrap_ldap_result( void *ld, int msgid, int all, struct timevalU *timeout, void **result )
+static int CDECL wrap_ldap_result( void *ld, int msgid, int all, struct timevalU *timeout, void **result )
 {
     return ldap_result( ld, msgid, all, (struct timeval *)timeout, (LDAPMessage **)result );
 }
 
-int CDECL wrap_ldap_sasl_bind( void *ld, const char *dn, const char *mech, struct bervalU *cred,
+static int CDECL wrap_ldap_sasl_bind( void *ld, const char *dn, const char *mech, struct bervalU *cred,
                                LDAPControlU **serverctrls, LDAPControlU **clientctrls, int *msgid )
 {
     return ldap_sasl_bind( ld, dn, mech, (struct berval *)cred, (LDAPControl **)serverctrls,
                            (LDAPControl **)clientctrls, msgid );
 }
 
-int CDECL wrap_ldap_sasl_bind_s( void *ld, const char *dn, const char *mech, struct bervalU *cred,
+static int CDECL wrap_ldap_sasl_bind_s( void *ld, const char *dn, const char *mech, struct bervalU *cred,
                                  LDAPControlU **serverctrls, LDAPControlU **clientctrls, struct bervalU **servercred )
 {
     return ldap_sasl_bind_s( ld, dn, mech, (struct berval *)cred, (LDAPControl **)serverctrls,
@@ -559,14 +559,14 @@ static int wrap_sasl_interact( LDAP *ld, unsigned int flags, void *defaults, voi
     return -1;
 }
 
-int CDECL wrap_ldap_sasl_interactive_bind_s( void *ld, const char *dn, const char *mech, LDAPControlU **serverctrls,
+static int CDECL wrap_ldap_sasl_interactive_bind_s( void *ld, const char *dn, const char *mech, LDAPControlU **serverctrls,
                                              LDAPControlU **clientctrls, unsigned int flags, void *defaults )
 {
     return ldap_sasl_interactive_bind_s( ld, dn, mech, (LDAPControl **)serverctrls, (LDAPControl **)clientctrls, flags,
                                          wrap_sasl_interact, defaults );
 }
 
-int CDECL wrap_ldap_search_ext( void *ld, const char *base, int scope, const char *filter, char **attrs, int attrsonly,
+static int CDECL wrap_ldap_search_ext( void *ld, const char *base, int scope, const char *filter, char **attrs, int attrsonly,
                                 LDAPControlU **serverctrls, LDAPControlU **clientctrls, struct timevalU *timeout,
                                 int sizelimit, ULONG *msg )
 {
@@ -574,7 +574,7 @@ int CDECL wrap_ldap_search_ext( void *ld, const char *base, int scope, const cha
                             (LDAPControl **)clientctrls, (struct timeval *)timeout, sizelimit, (int *)msg );
 }
 
-int CDECL wrap_ldap_search_ext_s( void *ld, const char *base, int scope, const char *filter, char **attrs,
+static int CDECL wrap_ldap_search_ext_s( void *ld, const char *base, int scope, const char *filter, char **attrs,
                                   int attrsonly, LDAPControlU **serverctrls, LDAPControlU **clientctrls,
                                   struct timevalU *timeout, int sizelimit, void **result )
 {
@@ -583,27 +583,27 @@ int CDECL wrap_ldap_search_ext_s( void *ld, const char *base, int scope, const c
                               (LDAPMessage **)result );
 }
 
-int CDECL wrap_ldap_set_option( void *ld, int option, const void *value )
+static int CDECL wrap_ldap_set_option( void *ld, int option, const void *value )
 {
     return ldap_set_option( ld, option, value );
 }
 
-int CDECL wrap_ldap_start_tls_s( void *ld, LDAPControlU **serverctrls, LDAPControlU **clientctrls )
+static int CDECL wrap_ldap_start_tls_s( void *ld, LDAPControlU **serverctrls, LDAPControlU **clientctrls )
 {
     return ldap_start_tls_s( ld, (LDAPControl **)serverctrls, (LDAPControl **)clientctrls );
 }
 
-int CDECL wrap_ldap_unbind_ext( void *ld, LDAPControlU **serverctrls, LDAPControlU **clientctrls )
+static int CDECL wrap_ldap_unbind_ext( void *ld, LDAPControlU **serverctrls, LDAPControlU **clientctrls )
 {
     return ldap_unbind_ext( ld, (LDAPControl **)serverctrls, (LDAPControl **)clientctrls );
 }
 
-int CDECL wrap_ldap_unbind_ext_s( void *ld, LDAPControlU **serverctrls, LDAPControlU **clientctrls )
+static int CDECL wrap_ldap_unbind_ext_s( void *ld, LDAPControlU **serverctrls, LDAPControlU **clientctrls )
 {
     return ldap_unbind_ext_s( ld, (LDAPControl **)serverctrls, (LDAPControl **)clientctrls );
 }
 
-void CDECL wrap_ldap_value_free_len( struct bervalU **values )
+static void CDECL wrap_ldap_value_free_len( struct bervalU **values )
 {
     ldap_value_free_len( (struct berval **)values );
 }
diff --git a/dlls/wldap32/libldap.h b/dlls/wldap32/libldap.h
index 3d2719452c45..d0c37ab498de 100644
--- a/dlls/wldap32/libldap.h
+++ b/dlls/wldap32/libldap.h
@@ -100,88 +100,6 @@ typedef struct sasl_interactU
     unsigned int  len;
 } sasl_interact_tU;
 
-extern void * CDECL wrap_ber_alloc_t(int) DECLSPEC_HIDDEN;
-extern void CDECL wrap_ber_bvecfree(struct bervalU **) DECLSPEC_HIDDEN;
-extern void CDECL wrap_ber_bvfree(struct bervalU *) DECLSPEC_HIDDEN;
-extern unsigned int CDECL wrap_ber_first_element(void *, unsigned int *, char **) DECLSPEC_HIDDEN;
-extern int CDECL wrap_ber_flatten(void *, struct bervalU **) DECLSPEC_HIDDEN;
-extern void CDECL wrap_ber_free(void *, int) DECLSPEC_HIDDEN;
-extern void * CDECL wrap_ber_init(struct bervalU *) DECLSPEC_HIDDEN;
-extern unsigned int CDECL wrap_ber_next_element(void *, unsigned int *, char *) DECLSPEC_HIDDEN;
-extern unsigned int CDECL wrap_ber_peek_tag(void *, unsigned int *) DECLSPEC_HIDDEN;
-extern unsigned int CDECL wrap_ber_skip_tag(void *, unsigned int *) DECLSPEC_HIDDEN;
-extern int WINAPIV wrap_ber_printf(void *, char *, ...) DECLSPEC_HIDDEN;
-extern int WINAPIV wrap_ber_scanf(void *, char *, ...) DECLSPEC_HIDDEN;
-
-extern int CDECL wrap_ldap_abandon_ext(void *, int, LDAPControlU **, LDAPControlU **) DECLSPEC_HIDDEN;
-extern int CDECL wrap_ldap_add_ext(void *, const char *, LDAPModU **, LDAPControlU **, LDAPControlU **,
-                                   ULONG *) DECLSPEC_HIDDEN;
-extern int CDECL wrap_ldap_add_ext_s(void *, const char *, LDAPModU **, LDAPControlU **,
-                                     LDAPControlU **) DECLSPEC_HIDDEN;
-extern int CDECL wrap_ldap_compare_ext(void *, const char *, const char *, struct bervalU *, LDAPControlU **,
-                                       LDAPControlU **, ULONG *) DECLSPEC_HIDDEN;
-extern int CDECL wrap_ldap_compare_ext_s(void *, const char *, const char *, struct bervalU *, LDAPControlU **,
-                                         LDAPControlU **) DECLSPEC_HIDDEN;
-extern void CDECL wrap_ldap_control_free(LDAPControlU *) DECLSPEC_HIDDEN;
-extern void CDECL wrap_ldap_controls_free(LDAPControlU **) DECLSPEC_HIDDEN;
-extern int CDECL wrap_ldap_count_entries(void *, void *) DECLSPEC_HIDDEN;
-extern int CDECL wrap_ldap_count_references(void *, void *) DECLSPEC_HIDDEN;
-extern int CDECL wrap_ldap_count_values_len(struct bervalU **) DECLSPEC_HIDDEN;
-extern int CDECL wrap_ldap_create_sort_control(void *, LDAPSortKeyU **, int, LDAPControlU **) DECLSPEC_HIDDEN;
-extern int CDECL wrap_ldap_create_vlv_control(void *, LDAPVLVInfoU *, LDAPControlU **) DECLSPEC_HIDDEN;
-extern int CDECL wrap_ldap_delete_ext(void *, const char *, LDAPControlU **, LDAPControlU **, ULONG *) DECLSPEC_HIDDEN;
-extern int CDECL wrap_ldap_delete_ext_s(void *, const char *, LDAPControlU **, LDAPControlU **) DECLSPEC_HIDDEN;
-extern char * CDECL wrap_ldap_dn2ufn(const char *) DECLSPEC_HIDDEN;
-extern char ** CDECL wrap_ldap_explode_dn(const char *, int) DECLSPEC_HIDDEN;
-extern int CDECL wrap_ldap_extended_operation(void *, const char *, struct bervalU *, LDAPControlU **,
-                                              LDAPControlU **, ULONG *) DECLSPEC_HIDDEN;
-extern int CDECL wrap_ldap_extended_operation_s(void *, const char *, struct bervalU *, LDAPControlU **,
-                                                LDAPControlU **, char **, struct bervalU **) DECLSPEC_HIDDEN;
-extern char * CDECL wrap_ldap_get_dn(void *, void *) DECLSPEC_HIDDEN;
-extern int CDECL wrap_ldap_get_option(void *, int, void *) DECLSPEC_HIDDEN;
-extern struct bervalU ** CDECL wrap_ldap_get_values_len(void *, void *, const char *) DECLSPEC_HIDDEN;
-extern int CDECL wrap_ldap_initialize(void **, const char *) DECLSPEC_HIDDEN;
-extern char * CDECL wrap_ldap_first_attribute(void *, void *, void **) DECLSPEC_HIDDEN;
-extern void * CDECL wrap_ldap_first_entry(void *, void *) DECLSPEC_HIDDEN;
-extern void * CDECL wrap_ldap_first_reference(void *, void *) DECLSPEC_HIDDEN;
-extern void CDECL wrap_ldap_memfree(void *) DECLSPEC_HIDDEN;
-extern void CDECL wrap_ldap_memvfree(void **) DECLSPEC_HIDDEN;
-extern int CDECL wrap_ldap_modify_ext(void *, const char *, LDAPModU **, LDAPControlU **, LDAPControlU **,
-                                      ULONG *) DECLSPEC_HIDDEN;
-extern int CDECL wrap_ldap_modify_ext_s(void *, const char *, LDAPModU **, LDAPControlU **,
-                                        LDAPControlU **) DECLSPEC_HIDDEN;
-extern int CDECL wrap_ldap_msgfree(void *) DECLSPEC_HIDDEN;
-extern char * CDECL wrap_ldap_next_attribute(void *, void *, void *) DECLSPEC_HIDDEN;
-extern void * CDECL wrap_ldap_next_entry(void *, void *) DECLSPEC_HIDDEN;
-extern void * CDECL wrap_ldap_next_reference(void *, void *) DECLSPEC_HIDDEN;
-extern int CDECL wrap_ldap_parse_extended_result(void *, void *, char **, struct bervalU **, int) DECLSPEC_HIDDEN;
-extern int CDECL wrap_ldap_parse_reference(void *, void *, char ***, LDAPControlU ***, int) DECLSPEC_HIDDEN;
-extern int CDECL wrap_ldap_parse_result(void *, void *, int *, char **, char **, char ***, LDAPControlU ***,
-                                        int) DECLSPEC_HIDDEN;
-extern int CDECL wrap_ldap_parse_sortresponse_control(void *, LDAPControlU *, int *, char **) DECLSPEC_HIDDEN;
-extern int CDECL wrap_ldap_parse_vlvresponse_control(void *, LDAPControlU *, int *, int *, struct bervalU **,
-                                                     int *) DECLSPEC_HIDDEN;
-extern int CDECL wrap_ldap_rename(void *, const char *, const char *, const char *, int, LDAPControlU **,
-                                  LDAPControlU **, ULONG *) DECLSPEC_HIDDEN;
-extern int CDECL wrap_ldap_rename_s(void *, const char *, const char *, const char *, int, LDAPControlU **,
-                                    LDAPControlU **) DECLSPEC_HIDDEN;
-extern int CDECL wrap_ldap_result(void *, int, int, struct timevalU *, void **) DECLSPEC_HIDDEN;
-extern int CDECL wrap_ldap_sasl_bind(void *, const char *, const char *, struct bervalU *, LDAPControlU **,
-                                     LDAPControlU **, int *) DECLSPEC_HIDDEN;
-extern int CDECL wrap_ldap_sasl_bind_s(void *, const char *, const char *, struct bervalU *, LDAPControlU **,
-                                       LDAPControlU **, struct bervalU **) DECLSPEC_HIDDEN;
-extern int CDECL wrap_ldap_sasl_interactive_bind_s(void *, const char *, const char *, LDAPControlU **,
-                                                   LDAPControlU **, unsigned int, void *) DECLSPEC_HIDDEN;
-extern int CDECL wrap_ldap_search_ext(void *, const char *, int, const char *, char **, int, LDAPControlU **,
-                                      LDAPControlU **, struct timevalU *, int, ULONG *) DECLSPEC_HIDDEN;
-extern int CDECL wrap_ldap_search_ext_s(void *, const char *, int, const char *, char **, int, LDAPControlU **,
-                                        LDAPControlU **, struct timevalU *, int, void **) DECLSPEC_HIDDEN;
-extern int CDECL wrap_ldap_set_option(void *, int, const void *) DECLSPEC_HIDDEN;
-extern int CDECL wrap_ldap_start_tls_s(void *, LDAPControlU **, LDAPControlU **) DECLSPEC_HIDDEN;
-extern int CDECL wrap_ldap_unbind_ext(void *, LDAPControlU **, LDAPControlU **) DECLSPEC_HIDDEN;
-extern int CDECL wrap_ldap_unbind_ext_s(void *, LDAPControlU **, LDAPControlU **) DECLSPEC_HIDDEN;
-extern void CDECL wrap_ldap_value_free_len(struct bervalU **) DECLSPEC_HIDDEN;
-
 struct ldap_funcs
 {
     void * (CDECL *fn_ber_alloc_t)(int);
From 5d78033a90b8c92e7f0b558bc0786c7f735be84d Mon Sep 17 00:00:00 2001
From: Alexandre Julliard <julliard@winehq.org>
Date: Fri, 22 Oct 2021 11:13:06 +0200
Subject: [PATCH] wldap32: Use the standard va_list instead of __ms_va_list.

Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/wldap32/ber.c | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)

diff --git a/dlls/wldap32/ber.c b/dlls/wldap32/ber.c
index ca5bbc305c50..7d37471c5c4e 100644
--- a/dlls/wldap32/ber.c
+++ b/dlls/wldap32/ber.c
@@ -318,12 +318,12 @@ ULONG CDECL ber_skip_tag( BerElement *ber, ULONG *len )
  */
 int WINAPIV ber_printf( BerElement *ber, char *fmt, ... )
 {
-    __ms_va_list list;
+    va_list list;
     int ret = 0;
     char new_fmt[2];
 
     new_fmt[1] = 0;
-    __ms_va_start( list, fmt );
+    va_start( list, fmt );
     while (*fmt)
     {
         new_fmt[0] = *fmt++;
@@ -392,7 +392,7 @@ int WINAPIV ber_printf( BerElement *ber, char *fmt, ... )
         }
         if (ret == -1) break;
     }
-    __ms_va_end( list );
+    va_end( list );
     return ret;
 }
 
@@ -417,12 +417,12 @@ int WINAPIV ber_printf( BerElement *ber, char *fmt, ... )
  */
 ULONG WINAPIV ber_scanf( BerElement *ber, char *fmt, ... )
 {
-    __ms_va_list list;
+    va_list list;
     int ret = 0;
     char new_fmt[2];
 
     new_fmt[1] = 0;
-    __ms_va_start( list, fmt );
+    va_start( list, fmt );
     while (*fmt)
     {
         new_fmt[0] = *fmt++;
@@ -508,6 +508,6 @@ ULONG WINAPIV ber_scanf( BerElement *ber, char *fmt, ... )
         }
         if (ret == -1) break;
     }
-    __ms_va_end( list );
+    va_end( list );
     return ret;
 }
From 449fae545c915f04c20cd3b6830e077ada8df3f2 Mon Sep 17 00:00:00 2001
From: Alexandre Julliard <julliard@winehq.org>
Date: Wed, 3 Nov 2021 12:10:00 +0100
Subject: [PATCH] wldap32: Move the SASL callback to the Unix side.

Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/wldap32/bind.c    | 32 --------------------------------
 dlls/wldap32/libldap.c | 33 ++++++++++++++++++++++++++++-----
 dlls/wldap32/libldap.h | 30 ++++++++----------------------
 dlls/wldap32/main.c    |  6 +-----
 4 files changed, 37 insertions(+), 64 deletions(-)

diff --git a/dlls/wldap32/bind.c b/dlls/wldap32/bind.c
index d45ed5d60e04..837612bf75f7 100644
--- a/dlls/wldap32/bind.c
+++ b/dlls/wldap32/bind.c
@@ -138,38 +138,6 @@ ULONG CDECL ldap_bind_sA( LDAP *ld, char *dn, char *cred, ULONG method )
     return ret;
 }
 
-int CDECL sasl_interact_cb( void *ld, unsigned flags, void *defaults, void *interact )
-{
-    SEC_WINNT_AUTH_IDENTITY_A *id = defaults;
-    struct sasl_interactU *sasl = interact;
-
-    TRACE( "(%p, 0x%08x, %p, %p)\n", ld, flags, defaults, interact );
-
-    while (sasl->id != SASL_CB_LIST_END)
-    {
-        TRACE( "sasl->id = %04lx\n", sasl->id );
-
-        if (sasl->id == SASL_CB_GETREALM)
-        {
-            sasl->result = id->Domain;
-            sasl->len = id->DomainLength;
-        }
-        else if (sasl->id == SASL_CB_USER)
-        {
-            sasl->result = id->User;
-            sasl->len = id->UserLength;
-        }
-        else if (sasl->id == SASL_CB_PASS)
-        {
-            sasl->result = id->Password;
-            sasl->len = id->PasswordLength;
-        }
-        sasl++;
-    }
-
-    return LDAP_SUCCESS;
-}
-
 /***********************************************************************
  *      ldap_bind_sW     (WLDAP32.@)
  *
diff --git a/dlls/wldap32/libldap.c b/dlls/wldap32/libldap.c
index 495ea6090590..d568c2daaae7 100644
--- a/dlls/wldap32/libldap.c
+++ b/dlls/wldap32/libldap.c
@@ -59,8 +59,6 @@ C_ASSERT( sizeof(struct timevalU) == sizeof(struct timeval) );
 
 static LDAPMod *nullmods[] = { NULL };
 
-static const struct ldap_callbacks *callbacks;
-
 static void * CDECL wrap_ber_alloc_t( int options )
 {
     return ber_alloc_t( options );
@@ -553,8 +551,34 @@ static int CDECL wrap_ldap_sasl_bind_s( void *ld, const char *dn, const char *me
 static int wrap_sasl_interact( LDAP *ld, unsigned int flags, void *defaults, void *interact )
 {
 #ifdef HAVE_SASL_SASL_H
-    C_ASSERT( sizeof(struct sasl_interactU) == sizeof(struct sasl_interact) );
-    return callbacks->sasl_interact( ld, flags, defaults, interact );
+    struct sasl_interactive_bind_id *id = defaults;
+    struct sasl_interact *sasl = interact;
+
+    TRACE( "(%p, 0x%08x, %p, %p)\n", ld, flags, defaults, interact );
+
+    while (sasl->id != SASL_CB_LIST_END)
+    {
+        TRACE( "sasl->id = %04lx\n", sasl->id );
+
+        if (sasl->id == SASL_CB_GETREALM)
+        {
+            sasl->result = id->domain;
+            sasl->len = id->domain_len;
+        }
+        else if (sasl->id == SASL_CB_USER)
+        {
+            sasl->result = id->user;
+            sasl->len = id->user_len;
+        }
+        else if (sasl->id == SASL_CB_PASS)
+        {
+            sasl->result = id->password;
+            sasl->len = id->password_len;
+        }
+        sasl++;
+    }
+
+    return LDAP_SUCCESS;
 #endif
     return -1;
 }
@@ -678,7 +702,6 @@ static const struct ldap_funcs funcs =
 NTSTATUS CDECL __wine_init_unix_lib( HMODULE module, DWORD reason, const void *ptr_in, void *ptr_out )
 {
     if (reason != DLL_PROCESS_ATTACH) return STATUS_SUCCESS;
-    callbacks = ptr_in;
     *(const struct ldap_funcs **)ptr_out = &funcs;
     return STATUS_SUCCESS;
 }
diff --git a/dlls/wldap32/libldap.h b/dlls/wldap32/libldap.h
index d0c37ab498de..e9736fc757f1 100644
--- a/dlls/wldap32/libldap.h
+++ b/dlls/wldap32/libldap.h
@@ -83,22 +83,15 @@ typedef struct timevalU
     LONG_PTR tv_usec;
 } LDAP_TIMEVALU;
 
-#ifndef SASL_CB_LIST_END
-#define SASL_CB_LIST_END    0
-#define SASL_CB_USER        0x4001
-#define SASL_CB_PASS        0x4004
-#define SASL_CB_GETREALM    0x4008
-#endif
-
-typedef struct sasl_interactU
+struct sasl_interactive_bind_id
 {
-    ULONG_PTR     id;
-    const char   *challenge;
-    const char   *prompt;
-    const char   *defresult;
-    const void   *result;
-    unsigned int  len;
-} sasl_interact_tU;
+    unsigned char* user;
+    ULONG          user_len;
+    unsigned char* domain;
+    ULONG          domain_len;
+    unsigned char* password;
+    ULONG          password_len;
+};
 
 struct ldap_funcs
 {
@@ -179,11 +172,4 @@ struct ldap_funcs
     void (CDECL *fn_ldap_value_free_len)(struct bervalU **);
 };
 
-extern int CDECL sasl_interact_cb(void *, unsigned int, void *, void *) DECLSPEC_HIDDEN;
-
-struct ldap_callbacks
-{
-    int (CDECL *sasl_interact)(void *, unsigned int, void *, void *);
-};
-
 extern const struct ldap_funcs *ldap_funcs;
diff --git a/dlls/wldap32/main.c b/dlls/wldap32/main.c
index c2fdf30f8205..55a08c9bad5e 100644
--- a/dlls/wldap32/main.c
+++ b/dlls/wldap32/main.c
@@ -31,10 +31,6 @@ HINSTANCE hwldap32;
 WINE_DEFAULT_DEBUG_CHANNEL(wldap32);
 
 const struct ldap_funcs *ldap_funcs = NULL;
-const struct ldap_callbacks ldap_callbacks =
-{
-    sasl_interact_cb
-};
 
 BOOL WINAPI DllMain( HINSTANCE hinst, DWORD reason, LPVOID reserved )
 {
@@ -45,7 +41,7 @@ BOOL WINAPI DllMain( HINSTANCE hinst, DWORD reason, LPVOID reserved )
     case DLL_PROCESS_ATTACH:
         hwldap32 = hinst;
         DisableThreadLibraryCalls( hinst );
-        if (__wine_init_unix_lib( hinst, reason, &ldap_callbacks, &ldap_funcs ))
+        if (__wine_init_unix_lib( hinst, reason, NULL, &ldap_funcs ))
             ERR( "No libldap support, expect problems\n" );
         break;
     }
From cefd34fbdae8774227118cd3749479cc211df1fe Mon Sep 17 00:00:00 2001
From: Alexandre Julliard <julliard@winehq.org>
Date: Wed, 3 Nov 2021 14:47:38 +0100
Subject: [PATCH] wldap32: Don't use varargs functions in the Unix library
 interface.

Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/wldap32/ber.c     |  28 ++++-----
 dlls/wldap32/libldap.c | 130 ++---------------------------------------
 dlls/wldap32/libldap.h |   4 +-
 3 files changed, 20 insertions(+), 142 deletions(-)

diff --git a/dlls/wldap32/ber.c b/dlls/wldap32/ber.c
index 7d37471c5c4e..482de4642343 100644
--- a/dlls/wldap32/ber.c
+++ b/dlls/wldap32/ber.c
@@ -334,26 +334,26 @@ int WINAPIV ber_printf( BerElement *ber, char *fmt, ... )
         case 'i':
         {
             int i = va_arg( list, int );
-            ret = ldap_funcs->fn_ber_printf( BER(ber), new_fmt, i );
+            ret = ldap_funcs->fn_ber_printf( BER(ber), new_fmt, i, 0 );
             break;
         }
         case 'o':
         case 's':
         {
             char *str = va_arg( list, char * );
-            ret = ldap_funcs->fn_ber_printf( BER(ber), new_fmt, str );
+            ret = ldap_funcs->fn_ber_printf( BER(ber), new_fmt, (ULONG_PTR)str, 0 );
             break;
         }
         case 't':
         {
             unsigned int tag = va_arg( list, unsigned int );
-            ret = ldap_funcs->fn_ber_printf( BER(ber), new_fmt, tag );
+            ret = ldap_funcs->fn_ber_printf( BER(ber), new_fmt, tag, 0 );
             break;
         }
         case 'v':
         {
             char **array = va_arg( list, char ** );
-            ret = ldap_funcs->fn_ber_printf( BER(ber), new_fmt, array );
+            ret = ldap_funcs->fn_ber_printf( BER(ber), new_fmt, (ULONG_PTR)array, 0 );
             break;
         }
         case 'V':
@@ -365,7 +365,7 @@ int WINAPIV ber_printf( BerElement *ber, char *fmt, ... )
                 ret = -1;
                 break;
             }
-            ret = ldap_funcs->fn_ber_printf( BER(ber), new_fmt, arrayU );
+            ret = ldap_funcs->fn_ber_printf( BER(ber), new_fmt, (ULONG_PTR)arrayU, 0 );
             bvarrayfreeU( arrayU );
             break;
         }
@@ -374,7 +374,7 @@ int WINAPIV ber_printf( BerElement *ber, char *fmt, ... )
             char *str = va_arg( list, char * );
             int len = va_arg( list, int );
             new_fmt[0] = 'B';  /* 'X' is deprecated */
-            ret = ldap_funcs->fn_ber_printf( BER(ber), new_fmt, str, len );
+            ret = ldap_funcs->fn_ber_printf( BER(ber), new_fmt, (ULONG_PTR)str, len );
             break;
         }
         case 'n':
@@ -382,7 +382,7 @@ int WINAPIV ber_printf( BerElement *ber, char *fmt, ... )
         case '}':
         case '[':
         case ']':
-            ret = ldap_funcs->fn_ber_printf( BER(ber), new_fmt );
+            ret = ldap_funcs->fn_ber_printf( BER(ber), new_fmt, 0, 0 );
             break;
 
         default:
@@ -431,7 +431,7 @@ ULONG WINAPIV ber_scanf( BerElement *ber, char *fmt, ... )
         case 'a':
         {
             char *str, **ptr = va_arg( list, char ** );
-            if ((ret = ldap_funcs->fn_ber_scanf( BER(ber), new_fmt, &str )) == -1) break;
+            if ((ret = ldap_funcs->fn_ber_scanf( BER(ber), new_fmt, &str, NULL )) == -1) break;
             *ptr = strdupU( str );
             ldap_funcs->fn_ldap_memfree( str );
             break;
@@ -441,19 +441,19 @@ ULONG WINAPIV ber_scanf( BerElement *ber, char *fmt, ... )
         case 'i':
         {
             int *i = va_arg( list, int * );
-            ret = ldap_funcs->fn_ber_scanf( BER(ber), new_fmt, i );
+            ret = ldap_funcs->fn_ber_scanf( BER(ber), new_fmt, i, NULL );
             break;
         }
         case 't':
         {
             unsigned int *tag = va_arg( list, unsigned int * );
-            ret = ldap_funcs->fn_ber_scanf( BER(ber), new_fmt, tag );
+            ret = ldap_funcs->fn_ber_scanf( BER(ber), new_fmt, tag, NULL );
             break;
         }
         case 'v':
         {
             char *str, **arrayU, **ptr, ***array = va_arg( list, char *** );
-            if ((ret = ldap_funcs->fn_ber_scanf( BER(ber), new_fmt, &arrayU )) == -1) break;
+            if ((ret = ldap_funcs->fn_ber_scanf( BER(ber), new_fmt, &arrayU, NULL )) == -1) break;
             *array = strarrayUtoU( arrayU );
             ptr = arrayU;
             while ((str = *ptr))
@@ -478,7 +478,7 @@ ULONG WINAPIV ber_scanf( BerElement *ber, char *fmt, ... )
         {
             struct berval **berval = va_arg( list, struct berval ** );
             struct bervalU *bervalU;
-            if ((ret = ldap_funcs->fn_ber_scanf( BER(ber), new_fmt, &bervalU )) == -1) break;
+            if ((ret = ldap_funcs->fn_ber_scanf( BER(ber), new_fmt, &bervalU, NULL )) == -1) break;
             *berval = bervalUtoW( bervalU );
             ldap_funcs->fn_ber_bvfree( bervalU );
             break;
@@ -487,7 +487,7 @@ ULONG WINAPIV ber_scanf( BerElement *ber, char *fmt, ... )
         {
             struct berval ***array = va_arg( list, struct berval *** );
             struct bervalU **arrayU;
-            if ((ret = ldap_funcs->fn_ber_scanf( BER(ber), new_fmt, &arrayU )) == -1) break;
+            if ((ret = ldap_funcs->fn_ber_scanf( BER(ber), new_fmt, &arrayU, NULL )) == -1) break;
             *array = bvarrayUtoW( arrayU );
             ldap_funcs->fn_ber_bvecfree( arrayU );
             break;
@@ -498,7 +498,7 @@ ULONG WINAPIV ber_scanf( BerElement *ber, char *fmt, ... )
         case '}':
         case '[':
         case ']':
-            ret = ldap_funcs->fn_ber_scanf( BER(ber), new_fmt );
+            ret = ldap_funcs->fn_ber_scanf( BER(ber), new_fmt, NULL, NULL );
             break;
 
         default:
diff --git a/dlls/wldap32/libldap.c b/dlls/wldap32/libldap.c
index d568c2daaae7..02ba0e01675e 100644
--- a/dlls/wldap32/libldap.c
+++ b/dlls/wldap32/libldap.c
@@ -163,140 +163,18 @@ static unsigned int CDECL wrap_ber_skip_tag( void *ber, unsigned int *ret_len )
     return ret;
 }
 
-static int WINAPIV wrap_ber_printf( void *ber, char *fmt, ... )
+static int CDECL wrap_ber_printf( void *ber, char *fmt, ULONG_PTR arg1, ULONG_PTR arg2 )
 {
-    int ret;
-    __ms_va_list args;
-
     assert( strlen(fmt) == 1 );
 
-    __ms_va_start( args, fmt );
-    switch (fmt[0])
-    {
-    case 'b':
-    case 'e':
-    case 'i':
-    {
-        int i = va_arg( args, int );
-        ret = ber_printf( ber, fmt, i );
-        break;
-    }
-    case 'o':
-    case 's':
-    {
-        char *str = va_arg( args, char * );
-        ret = ber_printf( ber, fmt, str );
-        break;
-    }
-    case 't':
-    {
-        unsigned int tag = va_arg( args, unsigned int );
-        ret = ber_printf( ber, fmt, tag );
-        break;
-    }
-    case 'v':
-    {
-        char **array = va_arg( args, char ** );
-        ret = ber_printf( ber, fmt, array );
-        break;
-    }
-    case 'V':
-    {
-        struct berval **array = va_arg( args, struct berval ** );
-        ret = ber_printf( ber, fmt, array );
-        break;
-    }
-    case 'B':
-    {
-        char *str = va_arg( args, char * );
-        int len = va_arg( args, int );
-        ret = ber_printf( ber, fmt, str, len );
-        break;
-    }
-    case 'n':
-    case '{':
-    case '}':
-    case '[':
-    case ']':
-        ret = ber_printf( ber, fmt );
-        break;
-
-    default:
-        assert( 0 );
-    }
-    __ms_va_end( args );
-    return ret;
+    return ber_printf( ber, fmt, arg1, arg2 );
 }
 
-static int WINAPIV wrap_ber_scanf( void *ber, char *fmt, ... )
+static int CDECL wrap_ber_scanf( void *ber, char *fmt, void *arg1, void *arg2 )
 {
-    int ret;
-    __ms_va_list args;
-
     assert( strlen(fmt) == 1 );
 
-    __ms_va_start( args, fmt );
-    switch (fmt[0])
-    {
-    case 'a':
-    {
-        char **str = va_arg( args, char ** );
-        ret = ber_scanf( ber, fmt, str );
-        break;
-    }
-    case 'b':
-    case 'e':
-    case 'i':
-    {
-        int *i = va_arg( args, int * );
-        ret = ber_scanf( ber, fmt, i );
-        break;
-    }
-    case 't':
-    {
-        unsigned int *tag = va_arg( args, unsigned int * );
-        ret = ber_scanf( ber, fmt, tag );
-        break;
-    }
-    case 'v':
-    {
-        char ***array = va_arg( args, char *** );
-        ret = ber_scanf( ber, fmt, array );
-        break;
-    }
-    case 'B':
-    {
-        char **str = va_arg( args, char ** );
-        int *len = va_arg( args, int * );
-        ret = ber_scanf( ber, fmt, str, len );
-        break;
-    }
-    case 'O':
-    {
-        struct berval **berval = va_arg( args, struct berval ** );
-        ret = ber_scanf( ber, fmt, berval );
-        break;
-    }
-    case 'V':
-    {
-        struct berval ***array = va_arg( args, struct berval *** );
-        ret = ber_scanf( ber, fmt, array );
-        break;
-    }
-    case 'n':
-    case 'x':
-    case '{':
-    case '}':
-    case '[':
-    case ']':
-        ret = ber_scanf( ber, fmt );
-        break;
-
-    default:
-        assert( 0 );
-    }
-    __ms_va_end( args );
-    return ret;
+    return ber_scanf( ber, fmt, arg1, arg2 );
 }
 
 static int CDECL wrap_ldap_abandon_ext( void *ld, int msgid, LDAPControlU **serverctrls, LDAPControlU **clientctrls )
diff --git a/dlls/wldap32/libldap.h b/dlls/wldap32/libldap.h
index e9736fc757f1..aec1f13a754f 100644
--- a/dlls/wldap32/libldap.h
+++ b/dlls/wldap32/libldap.h
@@ -105,8 +105,8 @@ struct ldap_funcs
     unsigned int (CDECL *fn_ber_next_element)(void *, unsigned int *, char *);
     unsigned int (CDECL *fn_ber_peek_tag)(void *, unsigned int *);
     unsigned int (CDECL *fn_ber_skip_tag)(void *, unsigned int *);
-    int (WINAPIV *fn_ber_printf)(void *, char *, ...);
-    int (WINAPIV *fn_ber_scanf)(void *, char *, ...);
+    int (CDECL *fn_ber_printf)(void *, char *, ULONG_PTR arg1, ULONG_PTR arg2 );
+    int (CDECL *fn_ber_scanf)(void *, char *, void *arg1, void *arg2 );
 
     int (CDECL *fn_ldap_abandon_ext)(void *, int, LDAPControlU **, LDAPControlU **);
     int (CDECL *fn_ldap_add_ext)(void *, const char *, LDAPModU **, LDAPControlU **, LDAPControlU **, ULONG *);
From 3cc3dd78e1fab3bd500a0510b3e78f21330406dc Mon Sep 17 00:00:00 2001
From: Alexandre Julliard <julliard@winehq.org>
Date: Wed, 3 Nov 2021 18:04:14 +0100
Subject: [PATCH] wldap32: Avoid returning pointers from the Unix interface
 functions.

Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/wldap32/ber.c     |  4 +--
 dlls/wldap32/dn.c      |  6 ++---
 dlls/wldap32/libldap.c | 60 +++++++++++++++++++++++++-----------------
 dlls/wldap32/libldap.h | 24 ++++++++---------
 dlls/wldap32/misc.c    | 15 +++++------
 dlls/wldap32/option.c  |  5 ++--
 dlls/wldap32/value.c   |  4 +--
 7 files changed, 63 insertions(+), 55 deletions(-)

diff --git a/dlls/wldap32/ber.c b/dlls/wldap32/ber.c
index 482de4642343..f7865f94e035 100644
--- a/dlls/wldap32/ber.c
+++ b/dlls/wldap32/ber.c
@@ -51,7 +51,7 @@ BerElement * CDECL ber_alloc_t( int options )
     BerElement *ret;
 
     if (!(ret = malloc( sizeof(*ret) ))) return NULL;
-    if (!(BER(ret) = ldap_funcs->fn_ber_alloc_t( options )))
+    if (ldap_funcs->fn_ber_alloc_t( options, (void **)&BER(ret) ))
     {
         free( ret );
         return NULL;
@@ -226,7 +226,7 @@ BerElement * CDECL ber_init( BERVAL *berval )
         free( ret );
         return NULL;
     }
-    if (!(BER(ret) = ldap_funcs->fn_ber_init( bervalU )))
+    if (ldap_funcs->fn_ber_init( bervalU, (void **)&BER(ret) ))
     {
         free( ret );
         ret = NULL;
diff --git a/dlls/wldap32/dn.c b/dlls/wldap32/dn.c
index 1528d8aef1e3..3c9edcdd07ef 100644
--- a/dlls/wldap32/dn.c
+++ b/dlls/wldap32/dn.c
@@ -75,7 +75,7 @@ WCHAR * CDECL ldap_dn2ufnW( WCHAR *dn )
 
     if (!(dnU = strWtoU( dn ))) return NULL;
 
-    retU = ldap_funcs->fn_ldap_dn2ufn( dnU );
+    ldap_funcs->fn_ldap_dn2ufn( dnU, &retU );
     ret = strUtoW( retU );
 
     free( dnU );
@@ -131,7 +131,7 @@ WCHAR ** CDECL ldap_explode_dnW( WCHAR *dn, ULONG notypes )
 
     if (!(dnU = strWtoU( dn ))) return NULL;
 
-    retU = ldap_funcs->fn_ldap_explode_dn( dnU, notypes );
+    ldap_funcs->fn_ldap_explode_dn( dnU, notypes, &retU );
     ret = strarrayUtoW( retU );
 
     free( dnU );
@@ -185,7 +185,7 @@ WCHAR * CDECL ldap_get_dnW( LDAP *ld, LDAPMessage *entry )
 
     if (!ld || !entry) return NULL;
 
-    retU = ldap_funcs->fn_ldap_get_dn( CTX(ld), MSG(entry) );
+    ldap_funcs->fn_ldap_get_dn( CTX(ld), MSG(entry), &retU );
 
     ret = strUtoW( retU );
     ldap_funcs->fn_ldap_memfree( retU );
diff --git a/dlls/wldap32/libldap.c b/dlls/wldap32/libldap.c
index 02ba0e01675e..8ace7632fadd 100644
--- a/dlls/wldap32/libldap.c
+++ b/dlls/wldap32/libldap.c
@@ -59,9 +59,10 @@ C_ASSERT( sizeof(struct timevalU) == sizeof(struct timeval) );
 
 static LDAPMod *nullmods[] = { NULL };
 
-static void * CDECL wrap_ber_alloc_t( int options )
+static int CDECL wrap_ber_alloc_t( int options, void **ret )
 {
-    return ber_alloc_t( options );
+    *ret = ber_alloc_t( options );
+    return *ret ? LDAP_SUCCESS : WLDAP32_LBER_ERROR;
 }
 
 static void CDECL wrap_ber_bvecfree( struct bervalU **berval )
@@ -105,9 +106,10 @@ static void CDECL wrap_ber_free( void *ber, int freebuf )
     ber_free( ber, freebuf );
 }
 
-static void * CDECL wrap_ber_init( struct bervalU *berval )
+static int CDECL wrap_ber_init( struct bervalU *berval, void **ret )
 {
-    return ber_init( (struct berval *)berval );
+    *ret = ber_init( (struct berval *)berval );
+    return *ret ? LDAP_SUCCESS : WLDAP32_LBER_ERROR;
 }
 
 static unsigned int CDECL wrap_ber_next_element( void *ber, unsigned int *ret_len, char *last )
@@ -260,14 +262,16 @@ static int CDECL wrap_ldap_delete_ext_s( void *ld, const char *dn, LDAPControlU
     return ldap_delete_ext_s( ld, dn ? dn : "", (LDAPControl **)serverctrls, (LDAPControl **)clientctrls );
 }
 
-static char * CDECL wrap_ldap_dn2ufn( const char *dn )
+static int CDECL wrap_ldap_dn2ufn( const char *dn, char **ret )
 {
-    return ldap_dn2ufn( dn );
+    *ret = ldap_dn2ufn( dn );
+    return *ret ? 0 : -1;
 }
 
-static char ** CDECL wrap_ldap_explode_dn( const char *dn, int notypes )
+static int CDECL wrap_ldap_explode_dn( const char *dn, int notypes, char ***ret )
 {
-    return ldap_explode_dn( dn, notypes );
+    *ret = ldap_explode_dn( dn, notypes );
+    return *ret ? 0 : -1;
 }
 
 static int CDECL wrap_ldap_extended_operation( void *ld, const char *oid, struct bervalU *data, LDAPControlU **serverctrls,
@@ -285,24 +289,28 @@ static int CDECL wrap_ldap_extended_operation_s( void *ld, const char *oid, stru
                                       (LDAPControl **)clientctrls, retoid, (struct berval **)retdata );
 }
 
-static char * CDECL wrap_ldap_get_dn( void *ld, void *entry )
+static int CDECL wrap_ldap_get_dn( void *ld, void *entry, char **ret )
 {
-    return ldap_get_dn( ld, entry );
+    *ret = ldap_get_dn( ld, entry );
+    return *ret ? 0 : -1;
 }
 
-static char * CDECL wrap_ldap_first_attribute( void *ld, void *entry, void **ber )
+static int CDECL wrap_ldap_first_attribute( void *ld, void *entry, void **ber, char **ret )
 {
-    return ldap_first_attribute( ld, entry, (BerElement **)ber );
+    *ret = ldap_first_attribute( ld, entry, (BerElement **)ber );
+    return *ret ? 0 : -1;
 }
 
-static void * CDECL wrap_ldap_first_entry( void *ld, void *chain )
+static int CDECL wrap_ldap_first_entry( void *ld, void *chain, void **ret )
 {
-    return ldap_first_entry( ld, chain );
+    *ret = ldap_first_entry( ld, chain );
+    return *ret ? 0 : -1;
 }
 
-static void * CDECL wrap_ldap_first_reference( void *ld, void *chain )
+static int CDECL wrap_ldap_first_reference( void *ld, void *chain, void **ret )
 {
-    return ldap_first_reference( ld, chain );
+    *ret = ldap_first_reference( ld, chain );
+    return *ret ? 0 : -1;
 }
 
 static int CDECL wrap_ldap_get_option( void *ld, int option, void *value )
@@ -310,9 +318,10 @@ static int CDECL wrap_ldap_get_option( void *ld, int option, void *value )
     return ldap_get_option( ld, option, value );
 }
 
-static struct bervalU ** CDECL wrap_ldap_get_values_len( void *ld, void *entry, const char *attr )
+static int CDECL wrap_ldap_get_values_len( void *ld, void *entry, const char *attr, struct bervalU ***ret )
 {
-    return (struct bervalU **)ldap_get_values_len( ld, entry, attr );
+    *ret = (struct bervalU **)ldap_get_values_len( ld, entry, attr );
+    return *ret ? 0 : -1;
 }
 
 static int CDECL wrap_ldap_initialize( void **ld, const char *url )
@@ -350,19 +359,22 @@ static int CDECL wrap_ldap_msgfree( void *msg )
     return ldap_msgfree( msg );
 }
 
-static char * CDECL wrap_ldap_next_attribute( void *ld, void *entry, void *ber )
+static int CDECL wrap_ldap_next_attribute( void *ld, void *entry, void *ber, char **ret )
 {
-    return ldap_next_attribute( ld, entry, ber );
+    *ret = ldap_next_attribute( ld, entry, ber );
+    return *ret ? 0 : -1;
 }
 
-static void * CDECL wrap_ldap_next_entry( void *ld, void *entry )
+static int CDECL wrap_ldap_next_entry( void *ld, void *entry, void **ret )
 {
-    return ldap_next_entry( ld, entry );
+    *ret = ldap_next_entry( ld, entry );
+    return *ret ? 0 : -1;
 }
 
-static void * CDECL wrap_ldap_next_reference( void *ld, void *entry )
+static int CDECL wrap_ldap_next_reference( void *ld, void *entry, void **ret )
 {
-    return ldap_next_reference( ld, entry );
+    *ret = ldap_next_reference( ld, entry );
+    return *ret ? 0 : -1;
 }
 
 static int CDECL wrap_ldap_parse_extended_result( void *ld, void *result, char **retoid, struct bervalU **retdata, int free )
diff --git a/dlls/wldap32/libldap.h b/dlls/wldap32/libldap.h
index aec1f13a754f..788a6dff5cdf 100644
--- a/dlls/wldap32/libldap.h
+++ b/dlls/wldap32/libldap.h
@@ -95,13 +95,13 @@ struct sasl_interactive_bind_id
 
 struct ldap_funcs
 {
-    void * (CDECL *fn_ber_alloc_t)(int);
+    int (CDECL *fn_ber_alloc_t)(int, void **);
     void (CDECL *fn_ber_bvecfree)(struct bervalU **);
     void (CDECL *fn_ber_bvfree)(struct bervalU *);
     unsigned int (CDECL *fn_ber_first_element)(void *, unsigned int *, char **);
     int (CDECL *fn_ber_flatten)(void *, struct bervalU **);
     void (CDECL *fn_ber_free)(void *, int);
-    void * (CDECL *fn_ber_init)(struct bervalU *);
+    int (CDECL *fn_ber_init)(struct bervalU *, void **);
     unsigned int (CDECL *fn_ber_next_element)(void *, unsigned int *, char *);
     unsigned int (CDECL *fn_ber_peek_tag)(void *, unsigned int *);
     unsigned int (CDECL *fn_ber_skip_tag)(void *, unsigned int *);
@@ -124,27 +124,27 @@ struct ldap_funcs
     int (CDECL *fn_ldap_create_vlv_control)(void *, LDAPVLVInfoU *, LDAPControlU **);
     int (CDECL *fn_ldap_delete_ext)(void *, const char *, LDAPControlU **, LDAPControlU **, ULONG *);
     int (CDECL *fn_ldap_delete_ext_s)(void *, const char *, LDAPControlU **, LDAPControlU **);
-    char * (CDECL *fn_ldap_dn2ufn)(const char *);
-    char ** (CDECL *fn_ldap_explode_dn)(const char *, int);
+    int (CDECL *fn_ldap_dn2ufn)(const char *, char **);
+    int (CDECL *fn_ldap_explode_dn)(const char *, int, char ***);
     int (CDECL *fn_ldap_extended_operation)(void *, const char *, struct bervalU *, LDAPControlU **,
                                             LDAPControlU **, ULONG *);
     int (CDECL *fn_ldap_extended_operation_s)(void *, const char *, struct bervalU *, LDAPControlU **,
                                               LDAPControlU **, char **, struct bervalU **);
-    char * (CDECL *fn_ldap_get_dn)(void *, void *);
+    int (CDECL *fn_ldap_get_dn)(void *, void *, char **);
     int (CDECL *fn_ldap_get_option)(void *, int, void *);
-    struct bervalU ** (CDECL *fn_ldap_get_values_len)(void *, void *, const char *);
+    int (CDECL *fn_ldap_get_values_len)(void *, void *, const char *, struct bervalU ***);
     int (CDECL *fn_ldap_initialize)(void **, const char *);
-    char * (CDECL *fn_ldap_first_attribute)(void *, void *, void **);
-    void * (CDECL *fn_ldap_first_entry)(void *, void *);
-    void * (CDECL *fn_ldap_first_reference)(void *, void *);
+    int (CDECL *fn_ldap_first_attribute)(void *, void *, void **, char **);
+    int (CDECL *fn_ldap_first_entry)(void *, void *, void **);
+    int (CDECL *fn_ldap_first_reference)(void *, void *, void **);
     void (CDECL *fn_ldap_memfree)(void *);
     void (CDECL *fn_ldap_memvfree)(void **);
     int (CDECL *fn_ldap_modify_ext)(void *, const char *, LDAPModU **, LDAPControlU **, LDAPControlU **, ULONG *);
     int (CDECL *fn_ldap_modify_ext_s)(void *, const char *, LDAPModU **, LDAPControlU **, LDAPControlU **);
     int (CDECL *fn_ldap_msgfree)(void *);
-    char * (CDECL *fn_ldap_next_attribute)(void *, void *, void *);
-    void * (CDECL *fn_ldap_next_entry)(void *, void *);
-    void * (CDECL *fn_ldap_next_reference)(void *, void *);
+    int (CDECL *fn_ldap_next_attribute)(void *, void *, void *, char **);
+    int (CDECL *fn_ldap_next_entry)(void *, void *, void **);
+    int (CDECL *fn_ldap_next_reference)(void *, void *, void **);
     int (CDECL *fn_ldap_parse_extended_result)(void *, void *, char **, struct bervalU **, int);
     int (CDECL *fn_ldap_parse_reference)(void *, void *, char ***, LDAPControlU ***, int);
     int (CDECL *fn_ldap_parse_result)(void *, void *, int *, char **, char **, char ***, LDAPControlU ***, int);
diff --git a/dlls/wldap32/misc.c b/dlls/wldap32/misc.c
index dbda4609ff2f..4810f2884f96 100644
--- a/dlls/wldap32/misc.c
+++ b/dlls/wldap32/misc.c
@@ -299,7 +299,7 @@ WCHAR * CDECL ldap_first_attributeW( LDAP *ld, LDAPMessage *entry, BerElement **
 
     if (!ld || !entry) return NULL;
 
-    retU = ldap_funcs->fn_ldap_first_attribute( CTX(ld), MSG(entry), &berU );
+    ldap_funcs->fn_ldap_first_attribute( CTX(ld), MSG(entry), &berU, &retU );
     if (retU && (ber = malloc( sizeof(*ber) )))
     {
         BER(ber) = (char *)berU;
@@ -335,8 +335,7 @@ LDAPMessage * CDECL ldap_first_entry( LDAP *ld, LDAPMessage *res )
 
     if (!ld || !res) return NULL;
 
-    msgU = ldap_funcs->fn_ldap_first_entry( CTX(ld), MSG(res) );
-    if (msgU)
+    if (!ldap_funcs->fn_ldap_first_entry( CTX(ld), MSG(res), &msgU ))
     {
         assert( msgU == MSG(res) );
         return res;
@@ -366,8 +365,7 @@ LDAPMessage * CDECL ldap_first_reference( LDAP *ld, LDAPMessage *res )
 
     if (!ld) return NULL;
 
-    msgU = ldap_funcs->fn_ldap_first_reference( CTX(ld), MSG(res) );
-    if (msgU)
+    if (!ldap_funcs->fn_ldap_first_reference( CTX(ld), MSG(res), &msgU ))
     {
         assert( msgU == MSG(res) );
         return res;
@@ -479,8 +477,7 @@ WCHAR * CDECL ldap_next_attributeW( LDAP *ld, LDAPMessage *entry, BerElement *pt
 
     if (!ld || !entry || !ptr) return NULL;
 
-    retU = ldap_funcs->fn_ldap_next_attribute( CTX(ld), MSG(entry), BER(ptr) );
-    if (retU)
+    if (!ldap_funcs->fn_ldap_next_attribute( CTX(ld), MSG(entry), BER(ptr), &retU ))
     {
         ret = strUtoW( retU );
         ldap_funcs->fn_ldap_memfree( retU );
@@ -516,7 +513,7 @@ LDAPMessage * CDECL ldap_next_entry( LDAP *ld, LDAPMessage *entry )
 
     if (entry->lm_next) return entry->lm_next;
 
-    msgU = ldap_funcs->fn_ldap_next_entry( CTX(ld), MSG(entry) );
+    ldap_funcs->fn_ldap_next_entry( CTX(ld), MSG(entry), &msgU );
     if (msgU && (msg = calloc( 1, sizeof(*msg) )))
     {
         MSG(msg) = msgU;
@@ -553,7 +550,7 @@ LDAPMessage * CDECL ldap_next_reference( LDAP *ld, LDAPMessage *entry )
 
     if (entry->lm_next) return entry->lm_next;
 
-    msgU = ldap_funcs->fn_ldap_next_reference( CTX(ld), MSG(entry) );
+    ldap_funcs->fn_ldap_next_reference( CTX(ld), MSG(entry), &msgU );
     if (msgU && (msg = calloc( 1, sizeof(*msg) )))
     {
         MSG(msg) = msgU;
diff --git a/dlls/wldap32/option.c b/dlls/wldap32/option.c
index ec3830d4ab3f..b3bc4e4d4eb9 100644
--- a/dlls/wldap32/option.c
+++ b/dlls/wldap32/option.c
@@ -377,11 +377,10 @@ static BOOL query_supported_server_ctrls( LDAP *ld )
                                                        attrs, FALSE, NULL, NULL, NULL, 0, &res ) );
     if (ret != LDAP_SUCCESS) return FALSE;
 
-    entry = ldap_funcs->fn_ldap_first_entry( CTX(ld), res );
-    if (entry)
+    if (!ldap_funcs->fn_ldap_first_entry( CTX(ld), res, &entry ))
     {
         ULONG count, i;
-        ctrls = ldap_funcs->fn_ldap_get_values_len( CTX(ld), entry, attrs[0] );
+        ldap_funcs->fn_ldap_get_values_len( CTX(ld), entry, attrs[0], &ctrls );
         count = ldap_funcs->fn_ldap_count_values_len( ctrls );
         for (i = 0; i < count; i++) TRACE("%u: %s\n", i, debugstr_an( ctrls[i]->bv_val, ctrls[i]->bv_len ));
         *(struct bervalU ***)&SERVER_CTRLS(ld) = ctrls;
diff --git a/dlls/wldap32/value.c b/dlls/wldap32/value.c
index d7fc1902bdea..814bfda00fba 100644
--- a/dlls/wldap32/value.c
+++ b/dlls/wldap32/value.c
@@ -197,7 +197,7 @@ WCHAR ** CDECL ldap_get_valuesW( LDAP *ld, LDAPMessage *entry, WCHAR *attr )
 
     if (!ld || !entry || !attr || !(attrU = strWtoU( attr ))) return NULL;
 
-    if ((bv = ldap_funcs->fn_ldap_get_values_len( CTX(ld), MSG(entry), attrU )))
+    if (!ldap_funcs->fn_ldap_get_values_len( CTX(ld), MSG(entry), attrU, &bv ))
     {
         retU = bv2str_array( bv );
         ret = strarrayUtoW( retU );
@@ -259,7 +259,7 @@ struct berval ** CDECL ldap_get_values_lenW( LDAP *ld, LDAPMessage *message, WCH
 
     if (!ld || !message || !attr || !(attrU = strWtoU( attr ))) return NULL;
 
-    if ((retU = ldap_funcs->fn_ldap_get_values_len( CTX(ld), MSG(message), attrU )))
+    if (!ldap_funcs->fn_ldap_get_values_len( CTX(ld), MSG(message), attrU, &retU ))
     {
         ret = bvarrayUtoW( retU );
         bvarrayfreeU( retU );
From 3f2458996c55b1e0ea8278015aa80450d459eada Mon Sep 17 00:00:00 2001
From: Alex Henrie <alexhenrie24@gmail.com>
Date: Mon, 20 Dec 2021 22:06:08 -0700
Subject: [PATCH] wldap32: Fix memory leak on error path in create_page_control
 (cppcheck).

Signed-off-by: Alex Henrie <alexhenrie24@gmail.com>
Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/wldap32/page.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/dlls/wldap32/page.c b/dlls/wldap32/page.c
index 8b0ded40e350..9f4acbdaa163 100644
--- a/dlls/wldap32/page.c
+++ b/dlls/wldap32/page.c
@@ -96,6 +96,7 @@ static ULONG create_page_control( ULONG pagesize, struct berval *cookie, UCHAR c
     }
     if (!(ctrl->ldctl_oid = strAtoW( LDAP_PAGED_RESULT_OID_STRING )))
     {
+        free( val );
         free( ctrl );
         return LDAP_NO_MEMORY;
     }
