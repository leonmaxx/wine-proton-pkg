diff -purN a/configure.ac b/configure.ac
--- a/configure.ac	2019-08-23 17:57:24.000000000 +0300
+++ b/configure.ac	2019-09-12 21:01:47.923318961 +0300
@@ -70,6 +70,14 @@ AC_ARG_WITH(openal,    AS_HELP_STRING([-
 AC_ARG_WITH(opencl,    AS_HELP_STRING([--without-opencl],[do not use OpenCL]),
             [if test "x$withval" = "xno"; then ac_cv_header_CL_cl_h=no; ac_cv_header_OpenCL_opencl_h=no; fi])
 AC_ARG_WITH(opengl,    AS_HELP_STRING([--without-opengl],[do not use OpenGL]))
+AC_ARG_WITH(d3d9-nine, AS_HELP_STRING([--without-d3d9-nine],[do not build d3d9-nine.dll (Gallium Nine support)]),
+            [], [with_d3d9_nine=auto])
+AC_ARG_WITH(d3d9-nine-module, AS_HELP_STRING([--with-d3d9-nine-module],
+            [Gallium Nine module location. Can be 'manual' (path to be filled in a register), 'auto' (default. use pkgconfig to detect the location) or a path]),
+            [], [with_d3d9_nine_module=auto])
+AC_ARG_WITH(d3d9-nine-headers-path, AS_HELP_STRING([--with-d3d9-nine-headers-path],
+            [Gallium Nine headers location. Can be 'auto' (default. use pkgconfig to detect the location) or a path]),
+            [], [with_d3d9_nine_headers_path=auto])
 AC_ARG_WITH(osmesa,     AS_HELP_STRING([--without-osmesa],[do not use the OSMesa library]))
 AC_ARG_WITH(oss,       AS_HELP_STRING([--without-oss],[do not use the OSS sound support]))
 AC_ARG_WITH(pcap,      AS_HELP_STRING([--without-pcap],[do not use the Packet Capture library]),
@@ -412,6 +420,8 @@ AC_CHECK_LIB(ossaudio,_oss_ioctl)
 
 AC_SUBST(OPENGL_LIBS,"")
 
+AC_SUBST(D3D9NINE_LIBS,"")
+
 dnl **** Check for header files ****
 
 AC_SYS_LARGEFILE()
@@ -1287,6 +1297,183 @@ This probably prevents linking to OpenGL
     WINE_WARNING_WITH(opengl,[test -n "$opengl_msg"],[$opengl_msg
 OpenGL and Direct3D won't be supported.])
 
+    dnl Check for d3d9-nine support
+    if test "x$with_d3d9_nine" = "xauto" && (test "x$with_d3d9_nine_module" = "xauto" || test "x$with_d3d9_nine_headers_path" = "xauto")
+    then
+        AC_MSG_CHECKING([whether d3dadapter9 package (Gallium Nine) is present])
+        D3DADAPTER9_MODULEDIR=`$PKG_CONFIG --variable=moduledir d3dadapter9 2>/dev/null`
+        D3DADAPTER9_LEGACY_MODULEDIR=`$PKG_CONFIG --variable=moduledir d3d 2>/dev/null`
+        if test "x$D3DADAPTER9_MODULEDIR" = "x" -a "x$D3DADAPTER9_LEGACY_MODULEDIR" = "x"
+        then
+            AC_MSG_RESULT([no, disabling support])
+            with_d3d9_nine=no
+        else
+            AC_MSG_RESULT([yes])
+        fi
+    fi
+
+    if test "x$with_d3d9_nine" != "xno"
+    then
+        AC_MSG_NOTICE([Checking for d3dadapter9 library dependencies])
+        D3D9NINE_LIBS=""
+        D3D9NINE_MISSING_LIBS=""
+        AC_CHECK_LIB(xcb,xcb_request_check,[AC_SUBST(D3D9NINE_LIBS,["$D3D9NINE_LIBS -lxcb"])])
+        test "x$ac_cv_lib_xcb_xcb_request_check" != xyes && D3D9NINE_MISSING_LIBS="libxcb "
+        AC_CHECK_LIB(xcb-dri3,xcb_dri3_open,[AC_SUBST(D3D9NINE_LIBS,["$D3D9NINE_LIBS -lxcb-dri3"])])
+        test "x$ac_cv_lib_xcb_dri3_xcb_dri3_open" != xyes && D3D9NINE_MISSING_LIBS="${D3D9NINE_MISSING_LIBS}libxcb-dri3 "
+        AC_CHECK_LIB(xcb-present,xcb_present_notify_msc,[AC_SUBST(D3D9NINE_LIBS,["$D3D9NINE_LIBS -lxcb-present"])])
+        test "x$ac_cv_lib_xcb_present_xcb_present_notify_msc" != xyes && D3D9NINE_MISSING_LIBS="${D3D9NINE_MISSING_LIBS}libxcb-present "
+        AC_CHECK_LIB(xcb-xfixes,xcb_xfixes_create_region,[AC_SUBST(D3D9NINE_LIBS,["$D3D9NINE_LIBS -lxcb-xfixes"])])
+        test "x$ac_cv_lib_xcb_xfixes_xcb_xfixes_create_region" != xyes && D3D9NINE_MISSING_LIBS="${D3D9NINE_MISSING_LIBS}libxcb-xfixes "
+        AC_CHECK_LIB(X11-xcb,XGetXCBConnection,[AC_SUBST(D3D9NINE_LIBS,["$D3D9NINE_LIBS -lX11-xcb"])])
+        test "x$ac_cv_lib_X11_xcb_XGetXCBConnection" != xyes && D3D9NINE_MISSING_LIBS="${D3D9NINE_MISSING_LIBS}libX11-xcb "
+        AC_CHECK_LIB(X11,XOpenDisplay,[AC_SUBST(D3D9NINE_LIBS,["$D3D9NINE_LIBS -lX11"])])
+        test "x$ac_cv_lib_X11_XOpenDisplay" != xyes && D3D9NINE_MISSING_LIBS="${D3D9NINE_MISSING_LIBS}libX11 "
+        AC_CHECK_LIB(Xext,XextRemoveDisplay,[AC_SUBST(D3D9NINE_LIBS,["$D3D9NINE_LIBS -lXext"])])
+        test "x$ac_cv_lib_Xext_XextRemoveDisplay" != xyes && D3D9NINE_MISSING_LIBS="${D3D9NINE_MISSING_LIBS}libXext "
+        # libs for the dri2 fallback
+        AC_CHECK_LIB(GL,glGenFramebuffers,[AC_SUBST(D3D9NINE_LIBS,["$D3D9NINE_LIBS -lGL"])])
+        test "x$ac_cv_lib_GL_glGenFramebuffers" != xyes && D3D9NINE_MISSING_LIBS="libGL "
+        AC_CHECK_LIB(EGL,eglCreateContext,[AC_SUBST(D3D9NINE_LIBS,["$D3D9NINE_LIBS -lEGL"])])
+        test "x$ac_cv_lib_EGL_eglCreateContext" != xyes && D3D9NINE_MISSING_LIBS="${D3D9NINE_MISSING_LIBS}libEGL"
+
+        if test "x$D3D9NINE_MISSING_LIBS" != x
+        then
+            if test "x$with_d3d9_nine" = "xyes"
+            then
+                AC_MSG_ERROR([Missing libraries to build d3d9-nine.dll: $D3D9NINE_MISSING_LIBS])
+            else
+                AC_MSG_NOTICE([Missing libraries to build d3d9-nine.dll: $D3D9NINE_MISSING_LIBS . disabling support])
+                with_d3d9_nine=no
+            fi
+        fi
+    fi
+
+    if test "x$with_d3d9_nine" != "xno"
+    then
+        AC_MSG_NOTICE([Checking d3dadapter9 header dependencies])
+        D3D9NINE_MISSING_HEADERS=""
+        AC_CHECK_HEADERS([X11/Xlib-xcb.h xcb/dri3.h xcb/present.h X11/Xutil.h X11/Xlib.h pthread.h])
+        test "x$ac_cv_header_X11_Xlib_xcb_h" != xyes && D3D9NINE_MISSING_HEADERS="${D3D9NINE_MISSING_HEADERS}X11/Xlib-xcb.h "
+        test "x$ac_cv_header_xcb_dri3_h" != xyes && D3D9NINE_MISSING_HEADERS="${D3D9NINE_MISSING_HEADERS}xcb/dri3.h "
+        test "x$ac_cv_header_xcb_present_h" != xyes && D3D9NINE_MISSING_HEADERS="${D3D9NINE_MISSING_HEADERS}xcb/present.h "
+        test "x$ac_cv_header_X11_Xutil_h" != xyes && D3D9NINE_MISSING_HEADERS="${D3D9NINE_MISSING_HEADERS}X11/Xutil.h "
+        test "x$ac_cv_header_X11_Xlib_h" != xyes && D3D9NINE_MISSING_HEADERS="${D3D9NINE_MISSING_HEADERS}X11/Xlib.h "
+        test "x$ac_cv_header_pthread_h" != xyes && D3D9NINE_MISSING_HEADERS="${D3D9NINE_MISSING_HEADERS}pthread.h "
+        # headers for the dri2 fallback
+        AC_CHECK_HEADERS([X11/Xmd.h X11/Xlibint.h X11/extensions/dri2tokens.h X11/extensions/dri2proto.h X11/extensions/extutil.h GL/gl.h GL/glext.h EGL/egl.h EGL/eglext.h libdrm/drm_fourcc.h libdrm/drm.h],
+                         [],[],[[
+#include <X11/Xlibint.h>
+#include <X11/extensions/dri2tokens.h>
+#include <GL/gl.h>
+#include <EGL/egl.h>
+]])
+        test "x$ac_cv_header_X11_Xmd_h" != xyes && D3D9NINE_MISSING_HEADERS="${D3D9NINE_MISSING_HEADERS}X11/Xmd.h "
+        test "x$ac_cv_header_X11_Xlibint_h" != xyes && D3D9NINE_MISSING_HEADERS="${D3D9NINE_MISSING_HEADERS}X11/Xlibint.h "
+        test "x$ac_cv_header_X11_extensions_dri2tokens_h" != xyes && D3D9NINE_MISSING_HEADERS="${D3D9NINE_MISSING_HEADERS}X11/extensions/dri2tokens.h "
+        test "x$ac_cv_header_X11_extensions_dri2proto_h" != xyes && D3D9NINE_MISSING_HEADERS="${D3D9NINE_MISSING_HEADERS}X11/extensions/dri2proto.h "
+        test "x$ac_cv_header_X11_extensions_extutil_h" != xyes && D3D9NINE_MISSING_HEADERS="${D3D9NINE_MISSING_HEADERS}X11/extensions/extutil.h "
+        test "x$ac_cv_header_GL_gl_h" != xyes && D3D9NINE_MISSING_HEADERS="${D3D9NINE_MISSING_HEADERS}GL/gl.h "
+        test "x$ac_cv_header_GL_glext_h" != xyes && D3D9NINE_MISSING_HEADERS="${D3D9NINE_MISSING_HEADERS}GL/glext.h "
+        test "x$ac_cv_header_EGL_egl_h" != xyes && D3D9NINE_MISSING_HEADERS="${D3D9NINE_MISSING_HEADERS}EGL/egl.h "
+        test "x$ac_cv_header_EGL_eglext_h" != xyes && D3D9NINE_MISSING_HEADERS="${D3D9NINE_MISSING_HEADERS}EGL/eglext.h "
+        test "x$ac_cv_header_libdrm_drm_fourcc_h" != xyes && D3D9NINE_MISSING_HEADERS="${D3D9NINE_MISSING_HEADERS}libdrm/drm_fourcc.h "
+        test "x$ac_cv_header_libdrm_drm_h" != xyes && D3D9NINE_MISSING_HEADERS="${D3D9NINE_MISSING_HEADERS}libdrm/drm.h "
+        if test "x$D3D9NINE_MISSING_HEADERS" != x
+        then
+            if test "x$with_d3d9_nine" = "xyes"
+            then
+                AC_MSG_ERROR([Missing headers to build d3d9-nine.dll: $D3D9NINE_MISSING_HEADERS])
+            else
+                AC_MSG_NOTICE([Missing headers to build d3d9-nine.dll: $D3D9NINE_MISSING_HEADERS . disabling support])
+                with_d3d9_nine=no
+            fi
+        fi
+    fi
+
+    if test "x$with_d3d9_nine" != "xno"
+    then
+        # d3d9-nine.dll will be built and an option to use it
+        # added. The module path can always be overriden by
+        # a wine registry setting. If the module isn't found
+        # at execution time, the dll will refuse to load and
+        # print an error message to the user.
+        AC_DEFINE(HAVE_D3D9NINE, 1, [Whether d3d9-nine.dll is built])
+        # default: use pkgconfig to find the gallium nine module.
+        # Check the module is there.
+        if test "x$with_d3d9_nine_module" = "xauto"
+        then
+            D3DADAPTER9_MODULEDIR=`$PKG_CONFIG --variable=moduledir d3dadapter9 2>/dev/null`
+            if test "x$D3DADAPTER9_MODULEDIR" = x
+            then
+                # legacy path
+                D3DADAPTER9_MODULEDIR=`$PKG_CONFIG --variable=moduledir d3d 2>/dev/null`
+                if test "x$D3DADAPTER9_MODULEDIR" = x
+                then
+                    AC_MSG_ERROR([pkg-config couldn't find Gallium Nine module])
+                fi
+            fi
+            AC_DEFINE_UNQUOTED(D3D9NINE_MODULEPATH, ["`echo ${D3DADAPTER9_MODULEDIR}/d3dadapter9.so.1`"], [Gallium Nine module path])
+            # Check module
+            CPPFLAGSBAK=$CPPFLAGS
+            # link against libdl
+            CPPFLAGS="$CPPFLAGS -Wl,--no-as-needed -ldl"
+
+            AC_RUN_IFELSE([AC_LANG_PROGRAM([[#include <dlfcn.h>
+#include <stdlib.h>]],[[void *handle = dlopen("${D3DADAPTER9_MODULEDIR}/d3dadapter9.so.1", RTLD_GLOBAL | RTLD_NOW);
+exit((handle && dlsym(handle, "D3DAdapter9GetProc")) ? 0 : 1)]])],
+                          [echo "d3dadapter9.so.1 found at '${D3DADAPTER9_MODULEDIR}/d3dadapter9.so.1'"],
+                          [AC_MSG_ERROR([Couldn't load Gallium nine module at '${D3DADAPTER9_MODULEDIR}/d3dadapter9.so.1' (found by pkg-config)])])
+            CPPFLAGS=$CPPFLAGSBAK
+        else
+            # Manual : do not feed any path, the wine registry will have
+            # to be used to pass a path. Useful for wine builds
+            # that are distributed and will run on different
+            # distros.
+            # Else feed a path directly. Useful for distro maintainers who
+            # know where the package would be installed, but don't have
+            # it installed on their build.
+            # Don't check if the module is there.
+            if test "x$with_d3d9_nine_module" != "xmanual"
+            then
+                AC_DEFINE_UNQUOTED(D3D9NINE_MODULEPATH, ["`echo ${with_d3d9_nine_module}`"], [Gallium Nine module path])
+            fi
+        fi
+
+        # by default the headers are found with pkgconfig,
+        # but it is possible to pass a path to a specific directory.
+        # that directory must contain a d3dadapter directory
+        # with d3dadapter9.h, drm.h and present.h
+        if test "x$with_d3d9_nine_headers_path" = "xauto"
+        then
+            AC_PROG_SED
+            D3DADAPTER9_INCLUDEDIR=`$PKG_CONFIG --variable=includedir d3dadapter9 2>/dev/null`
+            D3DADAPTER9_MAJOR=`$PKG_CONFIG --modversion d3dadapter9 2>/dev/null | $SED -n 's/\([[^\.]]*\)\..*$/\1/p'`
+            if test "x$D3DADAPTER9_INCLUDEDIR" = x
+            then
+                # legacy path
+                D3DADAPTER9_INCLUDEDIR=`$PKG_CONFIG --variable=includedir d3d 2>/dev/null`
+                D3DADAPTER9_MAJOR=`$PKG_CONFIG --modversion d3d 2>/dev/null | $SED -n 's/\([[^\.]]*\)\..*$/\1/p'`
+                if test "x$D3DADAPTER9_INCLUDEDIR" = x
+                then
+                    AC_MSG_ERROR([pkg-config couldn't find Gallium Nine headers])
+                fi
+            fi
+            # check major version of package. The major version number guarantees header compatibility.
+            if test "x$D3DADAPTER9_MAJOR" != x1
+            then
+                AC_MSG_ERROR([pkg-config found Gallium Nine Module and Headers, but version is incompatible])
+            fi
+        else
+            D3DADAPTER9_INCLUDEDIR=`echo ${with_d3d9_nine_headers_path}`
+        fi
+        AC_DEFINE_UNQUOTED(D3D9NINE_HEADERS_CFLAGS, ["`echo -I${D3DADAPTER9_INCLUDEDIR}`"], [Gallium Nine headers cflags])
+
+        AC_DEFINE(D3D9NINE_DRI2, 1, [Whether d3d9-nine DRI2 fallback is compiled])
+    else
+        enable_d3d9_nine=${enable_d3d9_nine:-no}
+    fi
+
     CPPFLAGS="$ac_save_CPPFLAGS"
 else
     X_CFLAGS=""
@@ -3102,6 +3289,7 @@ WINE_CONFIG_MAKEFILE(dlls/d3d8)
 WINE_CONFIG_MAKEFILE(dlls/d3d8/tests)
 WINE_CONFIG_MAKEFILE(dlls/d3d9)
 WINE_CONFIG_MAKEFILE(dlls/d3d9/tests)
+WINE_CONFIG_MAKEFILE(dlls/d3d9-nine)
 WINE_CONFIG_MAKEFILE(dlls/d3dcompiler_33)
 WINE_CONFIG_MAKEFILE(dlls/d3dcompiler_34)
 WINE_CONFIG_MAKEFILE(dlls/d3dcompiler_35)
diff -purN a/configure.ac.orig b/configure.ac.orig
--- a/configure.ac.orig	1970-01-01 03:00:00.000000000 +0300
+++ b/configure.ac.orig	2019-08-23 17:57:24.000000000 +0300
@@ -0,0 +1,4115 @@
+dnl Process this file with autoconf to produce a configure script.
+dnl Original author: Michael Patra
+dnl For detailed change history, see the git commit logs.
+
+m4_define(WINE_VERSION,regexp(m4_include(VERSION),[version \([-.0-9A-Za-z]+\)],[\1]))
+
+dnl autoconf versions before 2.62 don't handle source dir symlinks correctly
+AC_PREREQ(2.62)
+AC_INIT([Wine],[WINE_VERSION],[wine-devel@winehq.org],[wine],[https://www.winehq.org])
+AC_CONFIG_SRCDIR(server/atom.c)
+AC_CONFIG_HEADERS(include/config.h)
+AC_CONFIG_AUX_DIR(tools)
+
+libwine_version="1.0"
+
+dnl autoconf versions before 2.63b don't have AS_VAR_APPEND or AS_VAR_IF
+m4_ifdef([AS_VAR_APPEND],,[as_fn_append () { eval $[1]=\$$[1]\$[2]; }
+AC_DEFUN([AS_VAR_APPEND],[as_fn_append $1 $2])])dnl
+m4_ifdef([AS_VAR_IF],,[AC_DEFUN([AS_VAR_IF],
+[AS_LITERAL_IF([$1],
+  [AS_IF([test "x$$1" = x""$2], [$3], [$4])],
+  [eval as_val=\$$1
+   AS_IF([test "x$as_val" = x""$2], [$3], [$4])])])])dnl
+dnl autoconf versions before 2.64 don't have AC_PACKAGE_URL
+m4_ifdef([AC_PACKAGE_URL],,
+  [AC_DEFINE([PACKAGE_URL], ["https://www.winehq.org"], [Define to the home page for this package.])
+   AC_SUBST([PACKAGE_URL], ["https://www.winehq.org"])])dnl
+
+dnl **** Command-line arguments ****
+
+AC_ARG_ENABLE(win16, AS_HELP_STRING([--disable-win16],[do not include Win16 support]))
+AC_ARG_ENABLE(win64, AS_HELP_STRING([--enable-win64],[build a Win64 emulator on AMD64 (won't run Win32 binaries)]))
+AC_ARG_ENABLE(tests, AS_HELP_STRING([--disable-tests],[do not build the regression tests]))
+AC_ARG_ENABLE(maintainer-mode, AS_HELP_STRING([--enable-maintainer-mode],[enable maintainer-specific build rules]))
+
+AC_ARG_WITH(alsa,      AS_HELP_STRING([--without-alsa],[do not use the Alsa sound support]))
+AC_ARG_WITH(capi,      AS_HELP_STRING([--without-capi],[do not use CAPI (ISDN support)]))
+AC_ARG_WITH(cms,       AS_HELP_STRING([--without-cms],[do not use CMS (color management support)]))
+AC_ARG_WITH(coreaudio, AS_HELP_STRING([--without-coreaudio],[do not use the CoreAudio sound support]),
+            [if test "x$withval" = "xno"; then ac_cv_header_CoreAudio_CoreAudio_h=no; fi])
+AC_ARG_WITH(cups,      AS_HELP_STRING([--without-cups],[do not use CUPS]))
+AC_ARG_WITH(curses,    AS_HELP_STRING([--without-curses],[do not use (n)curses]),
+            [if test "x$withval" = "xno"; then ac_cv_header_ncurses_h=no; ac_cv_header_curses_h=no; fi])
+AC_ARG_WITH(dbus,      AS_HELP_STRING([--without-dbus],[do not use DBus (dynamic device support)]))
+AC_ARG_WITH(faudio,    AS_HELP_STRING([--without-faudio],[do not use FAudio (XAudio2 support)]))
+AC_ARG_WITH(float-abi, AS_HELP_STRING([--with-float-abi=abi],[specify the ABI (soft|softfp|hard) for ARM platforms]))
+AC_ARG_WITH(fontconfig,AS_HELP_STRING([--without-fontconfig],[do not use fontconfig]))
+AC_ARG_WITH(freetype,  AS_HELP_STRING([--without-freetype],[do not use the FreeType library]))
+AC_ARG_WITH(gettext,   AS_HELP_STRING([--without-gettext],[do not use gettext]))
+AC_ARG_WITH(gettextpo, AS_HELP_STRING([--with-gettextpo],[use the GetTextPO library to rebuild po files]),
+            [if test "x$withval" = "xno"; then ac_cv_header_gettext_po_h=no; fi])
+AC_ARG_WITH(gphoto,    AS_HELP_STRING([--without-gphoto],[do not use gphoto (Digital Camera support)]))
+AC_ARG_WITH(glu,       AS_HELP_STRING([--without-glu],[do not use the GLU library]))
+AC_ARG_WITH(gnutls,    AS_HELP_STRING([--without-gnutls],[do not use GnuTLS (schannel support)]))
+AC_ARG_WITH(gsm,       AS_HELP_STRING([--without-gsm],[do not use libgsm (GSM 06.10 codec support)]),
+            [if test "x$withval" = "xno"; then ac_cv_header_gsm_h=no; ac_cv_header_gsm_gsm_h=no; fi])
+AC_ARG_WITH(gssapi,    AS_HELP_STRING([--without-gssapi],[do not use GSSAPI (Kerberos SSP support)]))
+AC_ARG_WITH(gstreamer, AS_HELP_STRING([--without-gstreamer],[do not use GStreamer (codecs support)]))
+AC_ARG_WITH(hal,       AS_HELP_STRING([--without-hal],[do not use HAL (dynamic device support)]))
+AC_ARG_WITH(inotify,   AS_HELP_STRING([--without-inotify],[do not use inotify (filesystem change notifications)]))
+AC_ARG_WITH(jpeg,      AS_HELP_STRING([--without-jpeg],[do not use JPEG]))
+AC_ARG_WITH(krb5,      AS_HELP_STRING([--without-krb5],[do not use krb5 (Kerberos)]))
+AC_ARG_WITH(ldap,      AS_HELP_STRING([--without-ldap],[do not use LDAP]),
+            [if test "x$withval" = "xno"; then ac_cv_header_ldap_h=no; ac_cv_header_lber_h=no; fi])
+AC_ARG_WITH(mingw,     AS_HELP_STRING([--without-mingw],[do not use the MinGW cross-compiler]))
+AC_ARG_WITH(mpg123,    AS_HELP_STRING([--without-mpg123],[do not use the mpg123 library]))
+AC_ARG_WITH(netapi,    AS_HELP_STRING([--without-netapi],[do not use the Samba NetAPI library]))
+AC_ARG_WITH(openal,    AS_HELP_STRING([--without-openal],[do not use OpenAL]),
+            [if test "x$withval" = "xno"; then ac_cv_header_AL_al_h=no; ac_cv_header_OpenAL_al_h=no; fi])
+AC_ARG_WITH(opencl,    AS_HELP_STRING([--without-opencl],[do not use OpenCL]),
+            [if test "x$withval" = "xno"; then ac_cv_header_CL_cl_h=no; ac_cv_header_OpenCL_opencl_h=no; fi])
+AC_ARG_WITH(opengl,    AS_HELP_STRING([--without-opengl],[do not use OpenGL]))
+AC_ARG_WITH(osmesa,     AS_HELP_STRING([--without-osmesa],[do not use the OSMesa library]))
+AC_ARG_WITH(oss,       AS_HELP_STRING([--without-oss],[do not use the OSS sound support]))
+AC_ARG_WITH(pcap,      AS_HELP_STRING([--without-pcap],[do not use the Packet Capture library]),
+            [if test "x$withval" = "xno"; then ac_cv_header_pcap_pcap_h=no; fi])
+AC_ARG_WITH(png,       AS_HELP_STRING([--without-png],[do not use PNG]))
+AC_ARG_WITH(pthread,   AS_HELP_STRING([--without-pthread],[do not use the pthread library]),
+            [if test "x$withval" = "xno"; then ac_cv_header_pthread_h=no; fi])
+AC_ARG_WITH(pulse,     AS_HELP_STRING([--without-pulse],[do not use PulseAudio sound support]))
+AC_ARG_WITH(sane,      AS_HELP_STRING([--without-sane],[do not use SANE (scanner support)]))
+AC_ARG_WITH(sdl,       AS_HELP_STRING([--without-sdl],[do not use SDL]))
+AC_ARG_WITH(tiff,      AS_HELP_STRING([--without-tiff],[do not use TIFF]))
+AC_ARG_WITH(udev,      AS_HELP_STRING([--without-udev],[do not use udev (plug and play support)]))
+AC_ARG_WITH(v4l2,      AS_HELP_STRING([--without-v4l2],[do not use v4l2 (video capture)]))
+AC_ARG_WITH(vkd3d,     AS_HELP_STRING([--without-vkd3d],[do not use vkd3d (Direct3D 12 support)]))
+AC_ARG_WITH(vulkan,    AS_HELP_STRING([--without-vulkan],[do not use Vulkan]))
+AC_ARG_WITH(xcomposite,AS_HELP_STRING([--without-xcomposite],[do not use the Xcomposite extension]),
+            [if test "x$withval" = "xno"; then ac_cv_header_X11_extensions_Xcomposite_h=no; fi])
+AC_ARG_WITH(xcursor,   AS_HELP_STRING([--without-xcursor],[do not use the Xcursor extension]),
+            [if test "x$withval" = "xno"; then ac_cv_header_X11_Xcursor_Xcursor_h=no; fi])
+AC_ARG_WITH(xfixes,  AS_HELP_STRING([--without-xfixes],[do not use Xfixes for clipboard change notifications]),
+            [if test "x$withval" = "xno"; then ac_cv_header_X11_extensions_Xfixes_h=no; fi])
+AC_ARG_WITH(xinerama,  AS_HELP_STRING([--without-xinerama],[do not use Xinerama (multi-monitor support)]),
+            [if test "x$withval" = "xno"; then ac_cv_header_X11_extensions_Xinerama_h=no; fi])
+AC_ARG_WITH(xinput,    AS_HELP_STRING([--without-xinput],[do not use the Xinput extension]),
+            [if test "x$withval" = "xno"; then ac_cv_header_X11_extensions_XInput_h=no; fi])
+AC_ARG_WITH(xinput2,   AS_HELP_STRING([--without-xinput2],[do not use the Xinput 2 extension]),
+            [if test "x$withval" = "xno"; then ac_cv_header_X11_extensions_XInput2_h=no; fi])
+AC_ARG_WITH(xml,       AS_HELP_STRING([--without-xml],[do not use XML]))
+AC_ARG_WITH(xrandr,    AS_HELP_STRING([--without-xrandr],[do not use Xrandr (resolution changes)]),
+            [if test "x$withval" = "xno"; then ac_cv_header_X11_extensions_Xrandr_h=no; fi])
+AC_ARG_WITH(xrender,   AS_HELP_STRING([--without-xrender],[do not use the Xrender extension]),
+            [if test "x$withval" = "xno"; then ac_cv_header_X11_extensions_Xrender_h=no; fi])
+AC_ARG_WITH(xshape,    AS_HELP_STRING([--without-xshape],[do not use the Xshape extension]),
+            [if test "x$withval" = "xno"; then ac_cv_header_X11_extensions_shape_h=no; fi])
+AC_ARG_WITH(xshm,      AS_HELP_STRING([--without-xshm],[do not use XShm (shared memory extension)]),
+            [if test "x$withval" = "xno"; then ac_cv_header_X11_extensions_XShm_h=no; fi])
+AC_ARG_WITH(xslt,      AS_HELP_STRING([--without-xslt],[do not use XSLT]))
+AC_ARG_WITH(xxf86vm,   AS_HELP_STRING([--without-xxf86vm],[do not use XFree video mode extension]),
+            [if test "x$withval" = "xno"; then ac_cv_header_X11_extensions_xf86vmode_h=no; ac_cv_header_X11_extensions_xf86vmproto_h=no; fi])
+AC_ARG_WITH(zlib,      AS_HELP_STRING([--without-zlib],[do not use Zlib (data compression)]))
+
+AC_ARG_WITH(wine-tools,AS_HELP_STRING([--with-wine-tools=DIR],[use Wine tools from directory DIR]))
+AC_ARG_WITH(wine64,    AS_HELP_STRING([--with-wine64=DIR],[use the 64-bit Wine in DIR for a Wow64 build]))
+
+AC_CANONICAL_HOST
+
+dnl check for out of tree build with unclean source tree
+case "$srcdir" in
+ .) ;;
+ *) if test -f "$srcdir/Makefile" -o -f "$srcdir/include/config.h"; then
+      AC_MSG_ERROR([you are building out of the source tree, but the source tree contains object files.
+You need to run 'make distclean' in the source tree first.])
+    fi ;;
+esac
+
+dnl **** Check for some programs ****
+
+AC_PROG_MAKE_SET
+AC_PROG_CC
+AC_PROG_CXX
+dnl We can't use AC_PROG_CPP for winegcc, it uses by default $(CC) -E
+AC_CHECK_TOOL(CPPBIN,cpp,cpp)
+AC_DEFINE_UNQUOTED(EXEEXT,["$ac_exeext"],[Define to the file extension for executables.])
+AC_CHECK_TOOL(LD,ld)
+
+case $host in
+  *-darwin*)
+    with_fontconfig=${with_fontconfig:-no}
+    ;;
+  *-mingw32*|*-cygwin*)
+    enable_win16=${enable_win16:-no}
+    with_mingw=${with_mingw:-no}
+    CFLAGS="$CFLAGS -D_WIN32"
+    ;;
+esac
+
+case $host in
+  x86_64*|amd64*)
+    if test "x$enable_win64" != "xyes" -a "$cross_compiling" != "yes"
+    then
+      CC="$CC -m32"
+      CXX="$CXX -m32"
+      AC_CACHE_CHECK([whether $CC works], wine_cv_cc_m32,
+          [AC_LINK_IFELSE([AC_LANG_PROGRAM()],[wine_cv_cc_m32=yes],[wine_cv_cc_m32=no])])
+      test $wine_cv_cc_m32 != no || AC_MSG_ERROR([Cannot build a 32-bit program, you need to install 32-bit development libraries.])
+      host_cpu="i386"
+      notice_platform="32-bit "
+      AC_SUBST(TARGETFLAGS,"-m32")
+      PKG_CONFIG_PATH=${PKG_CONFIG_PATH:-/usr/lib/i386-linux-gnu/pkgconfig:/usr/lib/pkgconfig}
+      export PKG_CONFIG_PATH
+      enable_win16=${enable_win16:-yes}
+    else
+      if test "x${GCC}" = "xyes"
+      then
+        AC_CACHE_CHECK([whether $CC supports __builtin_ms_va_list],wine_cv_builtin_ms_va_list,
+            [AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <stdarg.h>]], [[void func(__builtin_ms_va_list *args);]])],
+                          [wine_cv_builtin_ms_va_list=yes],[wine_cv_builtin_ms_va_list=no])])
+        test $wine_cv_builtin_ms_va_list != no || AC_MSG_ERROR([You need gcc >= 4.4 or clang >= 3.8 to build Wine as 64-bit.])
+      fi
+      CC="$CC -m64"
+      CXX="$CXX -m64"
+      host_cpu="x86_64"
+      notice_platform="64-bit "
+      AC_SUBST(TARGETFLAGS,"-m64")
+    fi
+    ;;
+  arm*)
+    AC_CACHE_CHECK([whether $CC supports Thumb],wine_cv_thumb,
+        [WINE_TRY_ASM_LINK([".thumb\nblx ac_test\n.arm"],[int ac_test(int i) { return i; }], [if (ac_test(1)) return 1],
+                           [wine_cv_thumb=yes],[wine_cv_thumb=no])])
+    test $wine_cv_thumb != no || AC_MSG_ERROR([You need a target with Thumb support to build Wine for ARM.])
+    case $with_float_abi in
+      soft|softfp|hard)
+        float_abi=$with_float_abi ;;
+      *)
+        case $host_os in
+          *eabihf)
+            float_abi=hard ;;
+          *)
+            float_abi=softfp
+            saved_CFLAGS=$CFLAGS
+            CFLAGS="$CFLAGS -marm -mfloat-abi=$float_abi"
+            AC_CACHE_CHECK([whether $CC supports -mfloat-abi=$float_abi],wine_cv_float_abi,
+                [WINE_TRY_ASM_LINK(["vmrs r2,fpscr"],,,[wine_cv_float_abi=yes],[wine_cv_float_abi=no])])
+            if test $wine_cv_float_abi = no
+            then
+                float_abi=soft
+                WINE_WARNING([Floating point is not supported for this target. The resulting build won't be compatible with Windows ARM binaries.])
+            fi
+            CFLAGS=$saved_CFLAGS
+        esac
+        ;;
+    esac
+    CFLAGS="$CFLAGS -marm -mfloat-abi=$float_abi"
+    AC_SUBST(TARGETFLAGS,"-marm -mfloat-abi=$float_abi")
+    ;;
+  aarch64*)
+    AC_CACHE_CHECK([whether $CC supports __builtin_ms_va_list],wine_cv_builtin_ms_va_list,
+        [AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <stdarg.h>]], [[void func(__builtin_ms_va_list *args);]])],
+                      [wine_cv_builtin_ms_va_list=yes],[wine_cv_builtin_ms_va_list=no])])
+    test $wine_cv_builtin_ms_va_list != no || AC_MSG_ERROR([You need clang >= 5.0 to build Wine for arm64.])
+    ;;
+  i[[3456789]]86*)
+    enable_win16=${enable_win16:-yes}
+    ;;
+esac
+
+dnl enable_win16 defaults to yes on x86, to no on other CPUs
+enable_win16=${enable_win16:-no}
+enable_win64=${enable_win64:-no}
+
+dnl Disable winetest too if tests are disabled
+enable_winetest=${enable_winetest:-$enable_tests}
+
+dnl Some special cases for the 64-bit build
+if test "x$enable_win64" = "xyes"
+then
+    test -z "$with_wine64" || AC_MSG_ERROR([--enable-win64 and --with-wine64 are mutually exclusive.
+--enable-win64 should be used in the 64-bit build tree, --with-wine64 in the 32-bit Wow64 build tree.])
+    test "x$libdir" != "x\${exec_prefix}/lib" || libdir="\${exec_prefix}/lib64"
+fi
+
+AC_CACHE_CHECK([for the directory containing the Wine tools], wine_cv_toolsdir,
+  [wine_cv_toolsdir="$with_wine_tools"
+   if test -z "$with_wine_tools"; then
+     if test "$cross_compiling" = "yes"; then
+       AC_MSG_ERROR([you must use the --with-wine-tools option when cross-compiling.])
+     elif test -n "$with_wine64"; then
+       wine_cv_toolsdir="$with_wine64"
+     fi
+   fi])
+if test -z "$wine_cv_toolsdir"; then
+    wine_makedep=tools/makedep
+    AC_SUBST(TOOLSDIR,"\$(top_builddir)")
+elif test -d "$wine_cv_toolsdir/tools/winebuild"; then
+    wine_makedep=$wine_cv_toolsdir/tools/makedep
+    case "$wine_cv_toolsdir" in
+       /*) AC_SUBST(TOOLSDIR,$wine_cv_toolsdir) ;;
+       *)  AC_SUBST(TOOLSDIR,"\$(top_builddir)/$wine_cv_toolsdir") ;;
+    esac
+    enable_tools=${enable_tools:-no}
+    test -f "$wine_makedep" || AC_MSG_ERROR([the Wine tools have not yet been built in $wine_cv_toolsdir])
+else
+    AC_MSG_ERROR([could not find Wine tools in $wine_cv_toolsdir])
+fi
+if test -n "$host_alias" -a "$host_alias" != "$build_alias"
+then
+    AC_SUBST(TARGETFLAGS,"-b $host_alias $TARGETFLAGS")
+fi
+
+dnl Check for flex
+AC_CHECK_PROGS(FLEX,flex,none)
+if test "$FLEX" = "none"
+then
+  AC_MSG_ERROR([no suitable flex found. Please install the 'flex' package.])
+fi
+AC_CACHE_CHECK([whether flex is recent enough],wine_cv_recent_flex,
+    [cat >conftest.l <<EOF
+%top{
+#include "prediluvian.h"
+}
+%%
+EOF
+    if $FLEX -t conftest.l >/dev/null 2>&AS_MESSAGE_LOG_FD
+    then
+      wine_cv_recent_flex=yes
+    else
+      wine_cv_recent_flex=no
+    fi])
+test $wine_cv_recent_flex != no || AC_MSG_ERROR([Your flex version is too old. Please install flex version 2.5.33 or newer.])
+
+dnl Check for bison
+AC_CHECK_PROGS(BISON,bison,none)
+if test "$BISON" = "none"
+then
+  AC_MSG_ERROR([no suitable bison found. Please install the 'bison' package.])
+fi
+AC_CACHE_CHECK([whether bison is recent enough],wine_cv_recent_bison,
+    [cat >conftest.y <<EOF
+%define parse.error verbose
+%%
+empty: ;
+EOF
+    if $BISON conftest.y >/dev/null 2>&AS_MESSAGE_LOG_FD
+    then
+      wine_cv_recent_bison=yes
+    else
+      wine_cv_recent_bison=no
+    fi])
+test $wine_cv_recent_bison != no || AC_MSG_ERROR([Your bison version is too old. Please install bison version 3.0 or newer.])
+
+AC_CHECK_TOOLS(AR,[ar gar],ar)
+AC_CHECK_TOOL(STRIP,strip,strip)
+AC_PROG_RANLIB
+AC_PROG_LN_S
+AC_PROG_EGREP
+AC_PATH_PROG(LDCONFIG, ldconfig, true, [/sbin /usr/sbin $PATH])
+AC_CHECK_PROGS(MSGFMT, msgfmt, false)
+WINE_PATH_PKG_CONFIG
+
+if test "x$enable_maintainer_mode" != "xyes"
+then
+  FONTFORGE=""
+  RSVG=""
+  CONVERT=""
+  ICOTOOL=""
+else
+  test "$srcdir" = . || AC_MSG_ERROR([Maintainer mode cannot work out of tree.])
+  AC_CHECK_PROGS(FONTFORGE, fontforge, false)
+  AC_CHECK_PROGS(RSVG, rsvg-convert rsvg, false)
+  AC_CHECK_PROGS(CONVERT, convert, false)
+  AC_CHECK_PROGS(ICOTOOL, icotool, false)
+  test "$FONTFORGE" != "false" || AC_MSG_ERROR([You need fontforge to rebuild fonts in maintainer mode.])
+  test "$RSVG" != "false" || AC_MSG_ERROR([You need rsvg to rebuild icons in maintainer mode.])
+
+  dnl Check the imagemagick version
+  if test "$CONVERT" = false
+  then
+    AC_MSG_ERROR([You need imagemagick to rebuild icons in maintainer mode.])
+  else
+    AC_MSG_CHECKING([for recent enough imagemagick])
+    convert_version=`convert --version | head -n1`
+    if test "x$convert_version" != "x"
+    then
+      convert_version_major=`expr "$convert_version" : '.* \([[0-9]]*\)\.[[0-9]]*'`
+      convert_version_minor=`expr "$convert_version" : '.* [[0-9]]*\.\([[0-9]]*\)'`
+      if test "$convert_version_major" -eq 6 -a "$convert_version_minor" -lt 6
+      then
+        CONVERT=false
+      fi
+    fi
+    if test "$CONVERT" = false
+    then
+      AC_MSG_RESULT([no ($convert_version_major.$convert_version_minor)])
+      AC_MSG_ERROR([You need imagemagick version 6.6 or newer to rebuild icons in maintainer mode.])
+    else
+      AC_MSG_RESULT([yes ($convert_version_major.$convert_version_minor)])
+    fi
+  fi
+
+  dnl Check the icotool version
+  if test "$ICOTOOL" = false
+  then
+    AC_MSG_ERROR([You need icotool to rebuild icons in maintainer mode.])
+  else
+    AC_MSG_CHECKING([for recent enough icotool])
+    icotool_version=`icotool --version | head -n1`
+    if test "x$icotool_version" != "x"
+    then
+      icotool_version_major=`expr "$icotool_version" : '.* \([[0-9]]*\)\.[[0-9]]*'`
+      icotool_version_minor=`expr "$icotool_version" : '.* [[0-9]]*\.\([[0-9]]*\)'`
+      if test "$icotool_version_major" -eq 0 -a "$icotool_version_minor" -lt 29
+      then
+        ICOTOOL=false
+        WINE_WARNING([icotool version 0.29.0 or newer is needed to rebuild icons.])
+      fi
+    fi
+    if test "$ICOTOOL" = false
+    then
+      AC_MSG_RESULT([no ($icotool_version_major.$icotool_version_minor)])
+      AC_MSG_ERROR([You need icotool version 0.29.0 or newer to rebuild icons in maintainer mode.])
+    else
+      AC_MSG_RESULT([yes ($icotool_version_major.$icotool_version_minor)])
+    fi
+  fi
+
+  dnl Maintainer mode requires gettext
+  with_gettext=yes
+  with_gettextpo=yes
+fi
+
+test "x$with_gettext" != xno || MSGFMT=false
+if test "$MSGFMT" != "false"
+then
+  AC_CACHE_CHECK([whether msgfmt supports contexts],wine_cv_msgfmt_contexts,
+  [cat >conftest.po <<EOF
+# comment
+msgctxt "ctxt"
+msgid "id"
+msgstr "str"
+EOF
+  if $MSGFMT -o /dev/null conftest.po 2>&AS_MESSAGE_LOG_FD
+  then
+    wine_cv_msgfmt_contexts=yes
+  else
+    wine_cv_msgfmt_contexts=no
+  fi])
+  test $wine_cv_msgfmt_contexts != no || MSGFMT=false
+fi
+WINE_WARNING_WITH(gettext,[test "$MSGFMT" = false],
+                  [gettext tools not found (or too old), translations won't be built.],
+                  [enable_po])
+
+dnl **** Check for some libraries ****
+
+dnl Check for -li386 for NetBSD and OpenBSD
+AC_CHECK_LIB(i386,i386_set_ldt)
+dnl Check for -lossaudio for NetBSD
+AC_CHECK_LIB(ossaudio,_oss_ioctl)
+
+AC_SUBST(OPENGL_LIBS,"")
+
+dnl **** Check for header files ****
+
+AC_SYS_LARGEFILE()
+
+AC_CHECK_HEADERS(\
+	AL/al.h \
+	ApplicationServices/ApplicationServices.h \
+	AudioToolbox/AudioConverter.h \
+	AudioUnit/AudioUnit.h \
+	AudioUnit/AudioComponent.h \
+	CL/cl.h \
+	Carbon/Carbon.h \
+	CommonCrypto/CommonCryptor.h \
+	CoreAudio/CoreAudio.h \
+	CoreServices/CoreServices.h \
+	DiskArbitration/DiskArbitration.h \
+	EGL/egl.h \
+	IOKit/IOKitLib.h \
+	IOKit/hid/IOHIDLib.h \
+	OpenAL/al.h \
+	OpenCL/opencl.h \
+	QuickTime/ImageCompression.h \
+	Security/Security.h \
+	alias.h \
+	arpa/inet.h \
+	arpa/nameser.h \
+	asm/types.h \
+	asm/user.h \
+	curses.h \
+	dirent.h \
+	dlfcn.h \
+	elf.h \
+	float.h \
+	fnmatch.h \
+	getopt.h \
+	gettext-po.h \
+	grp.h \
+	gsm.h \
+	gsm/gsm.h \
+	ieeefp.h \
+	inet/mib2.h \
+	kstat.h \
+	libproc.h \
+	link.h \
+	linux/cdrom.h \
+	linux/compiler.h \
+	linux/filter.h \
+	linux/hdreg.h \
+	linux/hidraw.h \
+	linux/input.h \
+	linux/ioctl.h \
+	linux/joystick.h \
+	linux/major.h \
+	linux/param.h \
+	linux/serial.h \
+	linux/types.h \
+	linux/ucdrom.h \
+	lwp.h \
+	mach-o/nlist.h \
+	mach-o/loader.h \
+	mach/mach.h \
+	mach/machine.h \
+	machine/cpu.h \
+	machine/limits.h \
+	machine/sysarch.h \
+	mntent.h \
+	ncurses.h \
+	netdb.h \
+	netinet/in.h \
+	netinet/in_systm.h \
+	netinet/tcp.h \
+	netinet/tcp_fsm.h \
+	pcap/pcap.h \
+	poll.h \
+	port.h \
+	pthread.h \
+	pwd.h \
+	sched.h \
+	scsi/scsi.h \
+	scsi/scsi_ioctl.h \
+	scsi/sg.h \
+	stdbool.h \
+	stdint.h \
+	stropts.h \
+	sys/attr.h \
+	sys/auxv.h \
+	sys/cdio.h \
+	sys/elf32.h \
+	sys/epoll.h \
+	sys/event.h \
+	sys/eventfd.h \
+	sys/exec_elf.h \
+	sys/filio.h \
+	sys/ioctl.h \
+	sys/ipc.h \
+	sys/limits.h \
+	sys/link.h \
+	sys/mman.h \
+	sys/modem.h \
+	sys/msg.h \
+	sys/mtio.h \
+	sys/param.h \
+	sys/poll.h \
+	sys/prctl.h \
+	sys/protosw.h \
+	sys/ptrace.h \
+	sys/queue.h \
+	sys/resource.h \
+	sys/scsiio.h \
+	sys/shm.h \
+	sys/signal.h \
+	sys/socket.h \
+	sys/socketvar.h \
+	sys/sockio.h \
+	sys/statvfs.h \
+	sys/strtio.h \
+	sys/syscall.h \
+	sys/sysinfo.h \
+	sys/tihdr.h \
+	sys/time.h \
+	sys/timeout.h \
+	sys/times.h \
+	sys/uio.h \
+	sys/user.h \
+	sys/utsname.h \
+	sys/vnode.h \
+	sys/wait.h \
+	syscall.h \
+	termios.h \
+	unistd.h \
+	utime.h \
+	valgrind/memcheck.h \
+	valgrind/valgrind.h
+)
+WINE_HEADER_MAJOR()
+AC_HEADER_STAT()
+
+dnl **** Checks for headers that depend on other ones ****
+
+AC_CHECK_HEADERS([sys/mount.h sys/statfs.h sys/sysctl.h sys/user.h sys/vfs.h],,,
+    [#include <sys/types.h>
+     #ifdef HAVE_SYS_PARAM_H
+     # include <sys/param.h>
+     #endif])
+
+AC_CHECK_HEADERS(\
+	netinet/ip.h \
+	net/if.h \
+	net/if_arp.h \
+	net/if_dl.h \
+	net/if_types.h \
+	net/route.h \
+	netinet/if_ether.h \
+	netinet/if_inarp.h \
+	netinet/in_pcb.h \
+	netinet/ip_icmp.h \
+	netinet/ip_var.h \
+	netinet/udp.h \
+	netipx/ipx.h \
+	sys/un.h \
+,,,[#include <sys/types.h>
+     #ifdef HAVE_SYS_SOCKET_H
+     # include <sys/socket.h>
+     #endif
+     #ifdef HAVE_SYS_SOCKETVAR_H
+     # include <sys/socketvar.h>
+     #endif
+     #ifdef HAVE_NET_ROUTE_H
+     # include <net/route.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_H
+     # include <netinet/in.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_SYSTM_H
+     # include <netinet/in_systm.h>
+     #endif
+     #ifdef HAVE_NET_IF_H
+     # include <net/if.h>
+     #endif
+     #ifdef HAVE_NETINET_IP_H
+     # include <netinet/ip.h>
+     #endif])
+
+AC_CHECK_HEADERS([netinet/tcp_timer.h netinet/udp_var.h netinet/icmp_var.h netinet/tcp_var.h ],,,
+    [#include <sys/types.h>
+     #ifdef HAVE_ALIAS_H
+     # include <alias.h>
+     #endif
+     #ifdef HAVE_SYS_SOCKET_H
+     # include <sys/socket.h>
+     #endif
+     #ifdef HAVE_SYS_SOCKETVAR_H
+     # include <sys/socketvar.h>
+     #endif
+     #ifdef HAVE_SYS_TIMEOUT_H
+     # include <sys/timeout.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_H
+     # include <netinet/in.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_SYSTM_H
+     # include <netinet/in_systm.h>
+     #endif
+     #ifdef HAVE_NETINET_IP_H
+     # include <netinet/ip.h>
+     #endif
+     #ifdef HAVE_NETINET_IP_VAR_H
+     # include <netinet/ip_var.h>
+     #endif
+     #ifdef HAVE_NETINET_IP_ICMP_H
+     # include <netinet/ip_icmp.h>
+     #endif
+     #ifdef HAVE_NETINET_UDP_H
+     # include <netinet/udp.h>
+     #endif
+     #ifdef HAVE_NETINET_TCP_H
+     # include <netinet/tcp.h>
+     #endif
+     #ifdef HAVE_NETINET_TCP_TIMER_H
+     #include <netinet/tcp_timer.h>
+     #endif])
+
+AC_CHECK_HEADERS([linux/ipx.h linux/irda.h linux/rtnetlink.h],,,
+    [#include <sys/types.h>
+     #ifdef HAVE_ASM_TYPES_H
+     # include <asm/types.h>
+     #endif
+     #ifdef HAVE_SYS_SOCKET_H
+     # include <sys/socket.h>
+     #endif
+     #ifdef HAVE_LINUX_TYPES_H
+     # include <linux/types.h>
+     #endif])
+
+AC_CHECK_HEADERS([mach-o/dyld_images.h],,,
+    [#ifdef HAVE_STDBOOL_H
+     # include <stdbool.h>
+     #endif
+     #ifdef HAVE_STDINT_H
+     # include <stdint.h>
+     #endif])
+
+AC_CHECK_HEADERS([resolv.h],,,
+    [#include <sys/types.h>
+     #ifdef HAVE_SYS_SOCKET_H
+     # include <sys/socket.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_H
+     # include <netinet/in.h>
+     #endif
+     #ifdef HAVE_ARPA_NAMESER_H
+     # include <arpa/nameser.h>
+     #endif])
+
+AC_CHECK_HEADERS([ifaddrs.h],,,[#include <sys/types.h>])
+
+AC_CHECK_HEADERS(sys/ucontext.h,,,[#include <signal.h>])
+
+AC_CHECK_HEADERS([sys/thr.h],,,
+[#include <sys/types.h>
+#ifdef HAVE_SYS_UCONTEXT_H
+#include <sys/ucontext.h>
+#endif])
+
+AC_CHECK_HEADERS([pthread_np.h],,,
+[#ifdef HAVE_PTHREAD_H
+#include <pthread.h>
+#endif])
+
+AC_CHECK_HEADERS([linux/videodev2.h],,,
+[#ifdef HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+#include <sys/types.h>
+#ifdef HAVE_ASM_TYPES_H
+#include <asm/types.h>
+#endif])
+
+AC_CHECK_HEADERS([libprocstat.h],,,
+[#ifdef HAVE_SYS_PARAM_H
+#include <sys/param.h>
+#endif
+#ifdef HAVE_SYS_QUEUE_H
+#include <sys/queue.h>
+#endif
+#ifdef HAVE_SYS_SOCKET_H
+#include <sys/socket.h>
+#endif])
+
+dnl **** Check for working dll ****
+
+AC_SUBST(DLLFLAGS,"-D_REENTRANT")
+AC_SUBST(LDRPATH_INSTALL,"")
+AC_SUBST(LDRPATH_LOCAL,"")
+AC_SUBST(LDDLLFLAGS,"")
+AC_SUBST(LDEXECFLAGS,"")
+AC_SUBST(TOP_INSTALL_LIB,"")
+AC_SUBST(TOP_INSTALL_DEV,"")
+AC_SUBST(WINELOADER_LDFLAGS,"")
+AC_SUBST(WINEPRELOADER_LDFLAGS,"")
+LIBEXT="so"
+DLLEXT=".so"
+WINE_PATH_SONAME_TOOLS
+WINE_CONFIG_HELPERS
+
+wine_binary="wine"
+test "x$enable_win64" != "xyes" || wine_binary="wine64"
+AC_SUBST(WINELOADER_PROGRAMS,"$wine_binary")
+libwine_soversion=`expr $libwine_version : '\([[0-9]]*\)\..*'`
+
+case $host_os in
+  cygwin*|mingw32*)
+    AC_CHECK_TOOL(DLLTOOL,dlltool,false)
+    LIBEXT="dll"
+    DLLEXT=""
+    dnl Disable stdcall fixups to catch prototype mismatches
+    case $host_cpu in
+      *i[[3456]]86*) LDDLLFLAGS="-Wl,--disable-stdcall-fixup" ;;
+    esac
+    dnl Disable modules that can't be used on Windows
+    enable_iphlpapi=${enable_iphlpapi:-no}
+    enable_kernel32=${enable_kernel32:-no}
+    enable_ntdll=${enable_ntdll:-no}
+    enable_ws2_32=${enable_ws2_32:-no}
+    enable_loader=${enable_loader:-no}
+    enable_server=${enable_server:-no}
+    dnl Disable dependencies that are not useful on Windows
+    with_x=${with_x:-no}
+    with_pthread=${with_pthread:-no}
+    ;;
+
+  darwin*|macosx*)
+    AC_CHECK_HEADERS(libunwind.h)
+    AC_LANG_PUSH([Objective C])
+        AC_CHECK_HEADERS(Metal/Metal.h)
+    AC_LANG_POP([Objective C])
+    LIBEXT="dylib"
+    DLLFLAGS="$DLLFLAGS -fPIC"
+    LDDLLFLAGS="-fPIC"
+    LDRPATH_INSTALL="-Wl,-rpath,@loader_path/\`\$(MAKEDEP) -R \${bindir} \${libdir}\`"
+    LDRPATH_LOCAL="-Wl,-rpath,@loader_path/\$(top_builddir)/libs/wine"
+    dnl declare needed frameworks
+    AC_SUBST(COREFOUNDATION_LIBS,"-framework CoreFoundation")
+    AC_SUBST(IOKIT_LIBS,"-framework IOKit -framework CoreFoundation")
+    AC_SUBST(FORCEFEEDBACK_LIBS,"-framework ForceFeedback -framework CoreFoundation")
+    AC_SUBST(APPLICATIONSERVICES_LIBS,"-framework ApplicationServices")
+    AC_SUBST(CORESERVICES_LIBS,"-framework CoreServices")
+    AC_SUBST(APPKIT_LIBS,"-framework AppKit")
+
+    WINELOADER_LDFLAGS="-Wl,-pie,-pagezero_size,0x1000,-sectcreate,__TEXT,__info_plist,wine_info.plist"
+
+    wine_can_build_preloader=yes
+    WINEPRELOADER_LDFLAGS="-nostartfiles -nodefaultlibs -e _start -ldylib1.o -Wl,-image_base,0x7c400000,-pagezero_size,0x1000,-sectcreate,__TEXT,__info_plist,wine_info.plist"
+    WINE_TRY_CFLAGS([-Wl,-no_new_main -e _main],
+                    [WINEPRELOADER_LDFLAGS="-Wl,-no_new_main $WINEPRELOADER_LDFLAGS"
+                     WINE_TRY_CFLAGS([-Wl,-no_new_main -e _main -nostartfiles -nodefaultlibs],,
+                        [WINE_TRY_CFLAGS([-Wl,-no_new_main -e _main -mmacosx-version-min=10.7 -nostartfiles -nodefaultlibs],
+                                         [WINEPRELOADER_LDFLAGS="-mmacosx-version-min=10.7 $WINEPRELOADER_LDFLAGS"],
+                                         [wine_can_build_preloader=no])])],
+                    [WINE_TRY_CFLAGS([-nostartfiles -nodefaultlibs],,
+                        [WINE_TRY_CFLAGS([-mmacosx-version-min=10.7 -nostartfiles -nodefaultlibs],
+                                         [WINEPRELOADER_LDFLAGS="-mmacosx-version-min=10.7 $WINEPRELOADER_LDFLAGS"],
+                                         [wine_can_build_preloader=no])])])
+    if test "$wine_can_build_preloader" = "yes"
+    then
+        WINE_TRY_CFLAGS([-Wl,-no_pie],
+                        [WINEPRELOADER_LDFLAGS="-Wl,-no_pie $WINEPRELOADER_LDFLAGS"])
+        test "$wine_binary" = wine || WINE_IGNORE_FILE("loader/wine-preloader")
+        WINELOADER_PROGRAMS="$WINELOADER_PROGRAMS $wine_binary-preloader"
+    else
+        WINE_WARNING([can't build Wine preloader; many programs won't work])
+    fi
+
+    if test "$ac_cv_header_DiskArbitration_DiskArbitration_h" = "yes"
+    then
+        dnl DiskArbitration API is not public on Darwin < 8.0, use it only if header found
+        AC_SUBST(DISKARBITRATION_LIBS,"-framework DiskArbitration -framework CoreFoundation")
+    fi
+    if test "$ac_cv_header_Security_Security_h" = "yes"
+    then
+        AC_SUBST(SECURITY_LIBS,"-framework Security -framework CoreFoundation")
+        dnl Check for the SSLCopyPeerCertificates function
+        ac_save_LIBS="$LIBS"
+        LIBS="$LIBS $SECURITY_LIBS"
+        AC_CHECK_FUNCS(SSLCopyPeerCertificates)
+        LIBS="$ac_save_LIBS"
+    fi
+    if test "$ac_cv_header_CoreAudio_CoreAudio_h" = "yes" -a "$ac_cv_header_AudioUnit_AudioUnit_h" = "yes"
+    then
+        if test "$ac_cv_header_AudioUnit_AudioComponent_h" = "yes"
+        then
+            AC_SUBST(COREAUDIO_LIBS,"-framework CoreFoundation -framework CoreAudio -framework AudioUnit -framework AudioToolbox -framework CoreMIDI")
+        else
+            dnl CoreServices needed by AudioUnit
+            AC_SUBST(COREAUDIO_LIBS,"-framework CoreAudio -framework AudioUnit -framework CoreServices -framework AudioToolbox -framework CoreMIDI")
+        fi
+        enable_winecoreaudio_drv=${enable_winecoreaudio_drv:-yes}
+        dnl Check for the AUGraphAddNode function
+        ac_save_LIBS="$LIBS"
+        LIBS="$LIBS $COREAUDIO_LIBS"
+        AC_CHECK_FUNCS(AUGraphAddNode)
+        LIBS="$ac_save_LIBS"
+    fi
+    if test "$ac_cv_header_OpenAL_al_h" = "yes"
+    then
+        AC_SUBST(OPENAL_LIBS,"-framework OpenAL")
+        AC_DEFINE_UNQUOTED(HAVE_OPENAL,1,[Define to 1 if OpenAL is available])
+        ac_cv_lib_openal=yes
+    fi
+    if test "$ac_cv_header_OpenCL_opencl_h" = "yes"
+    then
+        AC_SUBST(OPENCL_LIBS,"-framework OpenCL")
+        ac_cv_lib_OpenCL_clGetPlatformInfo=yes
+    fi
+    if test "$ac_cv_header_IOKit_hid_IOHIDLib_h" = "yes"
+    then
+        ac_save_LIBS="$LIBS"
+        LIBS="$LIBS $IOKIT_LIBS"
+        AC_CHECK_FUNCS(IOHIDManagerCreate)
+        LIBS="$ac_save_LIBS"
+    fi
+    if test "$ac_cv_header_QuickTime_ImageCompression_h" = "yes"
+    then
+        dnl Make sure we can actually use the QuickTime framework
+        ac_save_LIBS="$LIBS"
+        LIBS="-framework QuickTime -framework ApplicationServices -framework CoreVideo $LIBS"
+        AC_MSG_CHECKING([for the QuickTime framework])
+        AC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <QuickTime/ImageCompression.h>]],[[CodecManagerVersion(NULL);]])],
+                       [AC_MSG_RESULT([yes])
+                        AC_SUBST(QUICKTIME_LIBS,"-framework QuickTime -framework ApplicationServices -framework CoreVideo")
+                        enable_wineqtdecoder=${enable_wineqtdecoder:-yes}],
+                       [AC_MSG_RESULT([no])
+                        ac_cv_header_QuickTime_ImageCompression_h=no])
+        LIBS="$ac_save_LIBS"
+    fi
+    if test "$ac_cv_header_QuickTime_ImageCompression_h" != "yes"
+    then
+        WINE_NOTICE([QuickTime ${notice_platform}development files not found, video decoding won't be supported.])
+    fi
+    if test "$ac_cv_header_Carbon_Carbon_h" = "yes"
+    then
+        AC_SUBST(CARBON_LIBS,"-framework Carbon")
+    fi
+    if test "$ac_cv_header_Metal_Metal_h" = "yes"
+    then
+        AC_SUBST(METAL_LIBS,"-framework Metal -framework QuartzCore")
+    fi
+
+    dnl Enable Mac driver on Mac OS X 10.6 or later
+    if test "$ac_cv_header_ApplicationServices_ApplicationServices_h" = "yes"
+    then
+        ac_save_LIBS="$LIBS"
+        LIBS="$LIBS $APPLICATIONSERVICES_LIBS"
+        AC_CHECK_FUNC(CGDisplayModeGetWidth,enable_winemac_drv=${enable_winemac_drv:-yes})
+        LIBS="$ac_save_LIBS"
+    fi
+
+    dnl Check for Xcode 3.x broken 16-bit support
+    if test "x$enable_win16" = "xyes"
+    then
+        AC_MSG_CHECKING([whether 16-bit code can be built correctly])
+        AC_RUN_IFELSE([AC_LANG_PROGRAM([[asm(".text\n"
+                                            "bad:\tnop;nop\n"
+                                            "good:\tnop;nop\n\t"
+                                            ".globl _testfunc\n"
+                                            "_testfunc:\tcallw good");
+                                        extern void testfunc();]],
+                                      [[unsigned short *p = (unsigned short *)testfunc;
+                                        return p[0] != 0xe866 || p[1] != 0xfffa]])],
+                                      AC_MSG_RESULT(yes),
+                                      [AC_MSG_RESULT(no)
+                                       AC_MSG_ERROR([Xcode 3.x cannot build 16-bit code correctly. Use --disable-win16 if you don't need 16-bit support.])],
+                                       AC_MSG_RESULT([[cross-compiling, assuming yes]]))
+    fi
+
+    AC_SUBST(LIBWINE_SHAREDLIB,"libwine.$libwine_version.dylib")
+    AC_SUBST(LIBWINE_LDFLAGS,["-dynamiclib -install_name @rpath/libwine.$libwine_soversion.dylib -Wl,-rpath,@loader_path/ -compatibility_version $libwine_soversion -current_version $libwine_version"])
+    AC_SUBST(WINELOADER_DEPENDS,"wine_info.plist")
+    TOP_INSTALL_LIB="$TOP_INSTALL_LIB libs/wine/libwine.$libwine_version.dylib libs/wine/libwine.$libwine_soversion.dylib"
+    TOP_INSTALL_DEV="$TOP_INSTALL_DEV libs/wine/libwine.dylib"
+    ;;
+
+  linux-android*)
+    DLLFLAGS="$DLLFLAGS -fPIC"
+    LDDLLFLAGS="-fPIC"
+    LDEXECFLAGS="-Wl,-pie"
+    enable_wineandroid_drv=${enable_wineandroid_drv:-yes}
+    WINE_TRY_CFLAGS([-fPIC -Wl,--export-dynamic],
+                    [WINELOADER_LDFLAGS="-Wl,--export-dynamic"])
+    WINEPRELOADER_LDFLAGS="-static -nostartfiles -nodefaultlibs -Wl,-Ttext=0x7c400000"
+    WINE_TRY_CFLAGS([-fPIC -Wl,--rpath,\$ORIGIN/../lib],
+                    [LDRPATH_INSTALL="-Wl,--rpath,\\\$\$ORIGIN/\`\$(MAKEDEP) -R \${bindir} \${libdir}\`"
+                     LDRPATH_LOCAL="-Wl,--rpath,\\\$\$ORIGIN/\$(top_builddir)/libs/wine"],
+        [WINE_TRY_CFLAGS([-fPIC -Wl,-R,\$ORIGIN/../lib],
+                         [LDRPATH_INSTALL="-Wl,-R,\\\$\$ORIGIN/\`\$(MAKEDEP) -R \${bindir} \${libdir}\`"
+                          LDRPATH_LOCAL="-Wl,-R,\\\$\$ORIGIN/\$(top_builddir)/libs/wine"])])
+    WINE_TRY_CFLAGS([-Wl,--enable-new-dtags],
+                    [LDRPATH_INSTALL="$LDRPATH_INSTALL -Wl,--enable-new-dtags"])
+
+    AC_SUBST(LIBWINE_SHAREDLIB,"libwine.so")
+    AC_SUBST(LIBWINE_LDFLAGS,["-shared -Wl,-soname,libwine.so"])
+    TOP_INSTALL_LIB="$TOP_INSTALL_LIB libs/wine/libwine.so"
+
+    WINE_CHECK_SONAME(EGL,eglGetProcAddress)
+    WINE_CHECK_SONAME(GLESv2,glFlush)
+
+    if test "x$exec_prefix" = xNONE
+    then
+      case $host_cpu in
+        *i[[3456]]86*) exec_prefix='${prefix}/x86' ;;
+        *x86_64*)      exec_prefix='${prefix}/x86_64' ;;
+        *arm*)         exec_prefix='${prefix}/armeabi-v7a' ;;
+        *aarch64*)     exec_prefix='${prefix}/arm64-v8a' ;;
+      esac
+    fi
+    ;;
+
+  *)
+    case $host_cpu in
+      *i[[3456789]]86*)
+        DLLFLAGS="$DLLFLAGS -fno-PIC"
+        LDDLLFLAGS="-fno-PIC" ;;
+      *)
+        DLLFLAGS="$DLLFLAGS -fPIC"
+        LDDLLFLAGS="-fPIC" ;;
+    esac
+    AC_CACHE_CHECK([whether we can build a GNU style ELF dll], ac_cv_c_dll_gnuelf,
+        [WINE_TRY_SHLIB_FLAGS([-fPIC -shared -Wl,-Bsymbolic],
+                              ac_cv_c_dll_gnuelf="yes",ac_cv_c_dll_gnuelf="no")])
+    if test "$ac_cv_c_dll_gnuelf" = "yes"
+    then
+      LIBWINE_LDFLAGS="-shared"
+      WINE_TRY_CFLAGS([-shared -Wl,-soname,confest.so.1],
+                      [LIBWINE_LDFLAGS="-shared -Wl,-soname,libwine.so.$libwine_soversion"],
+                      [WINE_TRY_CFLAGS([-shared -Wl,-h,confest.so.1],
+                                       [LIBWINE_LDFLAGS="-shared -Wl,-h,libwine.so.$libwine_soversion"])])
+
+      echo '{ global: *; };' >conftest.map
+      WINE_TRY_CFLAGS([-shared -Wl,--version-script=conftest.map],
+                      [LIBWINE_LDFLAGS="$LIBWINE_LDFLAGS -Wl,--version-script=\$(srcdir)/wine.map"])
+      rm -f conftest.map
+
+      WINE_TRY_CFLAGS([-Wl,--export-dynamic],
+                      [WINELOADER_LDFLAGS="-Wl,--export-dynamic"])
+      WINEPRELOADER_LDFLAGS="-static -nostartfiles -nodefaultlibs -Wl,-Ttext=0x7c400000"
+
+      WINE_TRY_CFLAGS([-Wl,--rpath,\$ORIGIN/../lib],
+                      [LDRPATH_INSTALL="-Wl,--rpath,\\\$\$ORIGIN/\`\$(MAKEDEP) -R \${bindir} \${libdir}\`"
+                       LDRPATH_LOCAL="-Wl,--rpath,\\\$\$ORIGIN/\$(top_builddir)/libs/wine"],
+          [WINE_TRY_CFLAGS([-Wl,-R,\$ORIGIN/../lib],
+                           [LDRPATH_INSTALL="-Wl,-R,\\\$\$ORIGIN/\`\$(MAKEDEP) -R \${bindir} \${libdir}\`"
+                            LDRPATH_LOCAL="-Wl,-R,\\\$\$ORIGIN/\$(top_builddir)/libs/wine"])])
+
+      WINE_TRY_CFLAGS([-Wl,--enable-new-dtags],
+                      [LDRPATH_INSTALL="$LDRPATH_INSTALL -Wl,--enable-new-dtags"])
+
+      case $host_cpu in
+        *i[[3456789]]86* | x86_64 | *aarch64*)
+          WINE_TRY_CFLAGS([-Wl,-Ttext-segment=0x7bc00000],
+                          [case $host_os in
+                           freebsd* | kfreebsd*-gnu) WINELOADER_LDFLAGS="$WINELOADER_LDFLAGS -Wl,-Ttext-segment=0x60000000" ;;
+                           *) WINELOADER_LDFLAGS="$WINELOADER_LDFLAGS -Wl,-Ttext-segment=0x7c000000" ;;
+                           esac],
+                          [WINE_TRY_CFLAGS([-Wl,--section-start,.interp=0x7c000400],
+                                           [case $host_os in
+                                              freebsd* | kfreebsd*-gnu) WINELOADER_LDFLAGS="$WINELOADER_LDFLAGS -Wl,--section-start,.interp=0x60000400" ;;
+                                              *) WINELOADER_LDFLAGS="$WINELOADER_LDFLAGS -Wl,--section-start,.interp=0x7c000400" ;;
+                                           esac])
+                           AC_PATH_PROG(PRELINK, prelink, false, [/sbin /usr/sbin $PATH])
+                           if test "x$PRELINK" = xfalse
+                           then
+                               WINE_WARNING([prelink not found and linker does not support relocation, base address of core dlls won't be set correctly.])
+                           fi])
+          WINE_TRY_CFLAGS([-Wl,-z,max-page-size=0x1000],
+                          [WINELOADER_LDFLAGS="$WINELOADER_LDFLAGS -Wl,-z,max-page-size=0x1000"])
+          ;;
+      esac
+
+    else
+      AC_CACHE_CHECK(whether we can build a UnixWare (Solaris) dll, ac_cv_c_dll_unixware,
+          [WINE_TRY_SHLIB_FLAGS([-fPIC -Wl,-G,-h,conftest.so.1.0,-B,symbolic],
+                                ac_cv_c_dll_unixware="yes",ac_cv_c_dll_unixware="no")])
+      if test "$ac_cv_c_dll_unixware" = "yes"
+      then
+        LIBWINE_LDFLAGS="-Wl,-G,-h,libwine.so.$libwine_soversion"
+      fi
+    fi
+    AC_SUBST(LIBWINE_SHAREDLIB,"libwine.so.$libwine_version")
+    AC_SUBST(LIBWINE_DEPENDS,"wine.map")
+    TOP_INSTALL_LIB="$TOP_INSTALL_LIB libs/wine/libwine.so.$libwine_version libs/wine/libwine.so.$libwine_soversion"
+    TOP_INSTALL_DEV="$TOP_INSTALL_DEV libs/wine/libwine.so"
+    ;;
+esac
+
+enable_winecoreaudio_drv=${enable_winecoreaudio_drv:-no}
+enable_wineqtdecoder=${enable_wineqtdecoder:-no}
+enable_wineandroid_drv=${enable_wineandroid_drv:-no}
+enable_winemac_drv=${enable_winemac_drv:-no}
+test "$ac_cv_header_linux_joystick_h" = "yes" -o "$ac_cv_header_IOKit_hid_IOHIDLib_h" = "yes" || enable_winejoystick_drv=${enable_winejoystick_drv:-no}
+
+dnl Check for cross compiler to build test programs
+AC_SUBST(CROSSTARGET,"")
+if test "x$with_mingw" != xno
+then
+    case "x$with_mingw" in
+      x|xyes) WINE_CHECK_MINGW_PROG(CROSSCC,false) ;;
+      *) CROSSCC=$with_mingw ;;
+    esac
+    if test "$CROSSCC" != "false"
+    then
+        ac_save_CC="$CC"
+        saved_CFLAGS=$CFLAGS
+        AC_SUBST(CROSSCFLAGS,${CROSSCFLAGS:-"-g -O2"})
+        AC_SUBST(EXTRACROSSCFLAGS,"-DWINE_CROSS_PE -Wall")
+
+        CC="$CROSSCC"
+        CFLAGS=$CROSSCFLAGS
+        AC_CACHE_CHECK([whether $CROSSCC works], wine_cv_crosscc,
+            [AC_COMPILE_IFELSE([AC_LANG_PROGRAM([])],[wine_cv_crosscc=yes],[wine_cv_crosscc=no])])
+        if test $wine_cv_crosscc = yes
+        then
+            set x $CROSSCC
+            shift
+            while test $# -ge 1
+            do
+                case "$1" in
+                    *-gcc) CROSSTARGET=`expr "$1" : '\(.*\)-gcc'` ;;
+                    *-clang) CROSSTARGET=`expr "$1" : '\(.*\)-clang'` ;;
+                esac
+                shift
+            done
+        fi
+        WINE_TRY_CROSSCFLAGS([-fno-strict-aliasing])
+        dnl clang needs to be told to fail on unknown options
+        WINE_TRY_CROSSCFLAGS([-Werror=unknown-warning-option],[CFLAGS="$CFLAGS -Werror=unknown-warning-option"])
+        WINE_TRY_CROSSCFLAGS([-Wdeclaration-after-statement])
+        WINE_TRY_CROSSCFLAGS([-Wempty-body])
+        WINE_TRY_CROSSCFLAGS([-Wignored-qualifiers])
+        WINE_TRY_CROSSCFLAGS([-Wpacked-not-aligned],[EXTRACROSSCFLAGS="$EXTRACROSSCFLAGS -Wno-packed-not-aligned"])
+        WINE_TRY_CROSSCFLAGS([-Wpragma-pack],[EXTRACROSSCFLAGS="$EXTRACROSSCFLAGS -Wno-pragma-pack"])
+        WINE_TRY_CROSSCFLAGS([-Wshift-overflow=2])
+        WINE_TRY_CROSSCFLAGS([-Wstrict-prototypes])
+        WINE_TRY_CROSSCFLAGS([-Wtype-limits])
+        WINE_TRY_CROSSCFLAGS([-Wunused-but-set-parameter])
+        WINE_TRY_CROSSCFLAGS([-Wvla])
+        WINE_TRY_CROSSCFLAGS([-Wwrite-strings])
+        WINE_TRY_CROSSCFLAGS([-Wpointer-arith])
+        WINE_TRY_CROSSCFLAGS([-Wlogical-op])
+
+        case $host_cpu in
+          *i[[3456789]]86*) WINE_TRY_CROSSCFLAGS([-fno-omit-frame-pointer]) ;;
+          x86_64) WINE_TRY_CROSSCFLAGS([-Wno-format]) ;;
+        esac
+
+        dnl Default to dwarf-2 debug info
+        for ac_flag in $CROSSCFLAGS; do
+          case $ac_flag in
+            -g) WINE_TRY_CROSSCFLAGS([-gdwarf-2])
+                WINE_TRY_CROSSCFLAGS([-gstrict-dwarf]) ;;
+          esac
+        done
+
+        if test "x$enable_maintainer_mode" = xyes
+        then
+            WINE_TRY_CROSSCFLAGS([-Werror])
+        fi
+
+        CFLAGS=$saved_CFLAGS
+        CC="$ac_save_CC"
+    fi
+fi
+WINE_NOTICE_WITH(mingw,[test "x$CROSSTARGET" = "x"],
+                 [MinGW compiler not found, cross-compiling PE files won't be supported.])
+
+dnl **** Check for pthread ****
+
+if test "$ac_cv_header_pthread_h" = "yes"
+then
+    AC_CHECK_FUNC(pthread_create,,[AC_CHECK_LIB(pthread,pthread_create,[AC_SUBST(PTHREAD_LIBS,"-lpthread")])])
+fi
+WINE_ERROR_WITH(pthread,[test "x$ac_cv_func_pthread_create" != xyes -a "x$PTHREAD_LIBS" = x],
+[pthread ${notice_platform}development files not found.
+Wine cannot support threads without libpthread.])
+
+dnl **** Check for X11 ****
+
+AC_PATH_XTRA
+
+if test "$have_x" = "yes"
+then
+    ac_save_CPPFLAGS="$CPPFLAGS"
+    CPPFLAGS="$CPPFLAGS $X_CFLAGS"
+
+    WINE_CHECK_SONAME(X11,XCreateWindow,,,[$X_LIBS $X_EXTRA_LIBS])
+    WINE_CHECK_SONAME(Xext,XextCreateExtension,[X_LIBS="$X_LIBS -lXext"],,[$X_LIBS -lX11 $X_EXTRA_LIBS])
+    X_LIBS="$X_LIBS -lX11"
+
+    dnl *** All of the following tests require X11/Xlib.h
+    AC_CHECK_HEADERS([X11/Xlib.h \
+                      X11/XKBlib.h \
+                      X11/Xutil.h \
+                      X11/Xcursor/Xcursor.h \
+                      X11/extensions/shape.h \
+                      X11/extensions/XInput.h \
+                      X11/extensions/XInput2.h \
+                      X11/extensions/XShm.h \
+                      X11/extensions/Xcomposite.h \
+                      X11/extensions/Xfixes.h \
+                      X11/extensions/Xinerama.h \
+                      X11/extensions/Xrandr.h \
+                      X11/extensions/Xrender.h \
+                      X11/extensions/xf86vmode.h \
+                      X11/extensions/xf86vmproto.h],,,
+[#ifdef HAVE_X11_XLIB_H
+# include <X11/Xlib.h>
+#endif
+#ifdef HAVE_X11_XUTIL_H
+# include <X11/Xutil.h>
+#endif])
+
+        dnl *** Check for X keyboard extension
+        if test "$ac_cv_header_X11_XKBlib_h" = "yes"
+        then
+              AC_CHECK_LIB(X11, XkbQueryExtension,
+              AC_DEFINE(HAVE_XKB, 1, [Define if you have the XKB extension]),,[$X_LIBS $X_EXTRA_LIBS])
+        fi
+
+        dnl *** Check for X cursor
+        if test "$ac_cv_header_X11_Xcursor_Xcursor_h" = "yes"
+        then
+            WINE_CHECK_SONAME(Xcursor,XcursorImageLoadCursor,,,[$X_LIBS $X_EXTRA_LIBS])
+        fi
+        WINE_NOTICE_WITH(xcursor,[test "x$ac_cv_lib_soname_Xcursor" = "x"],
+                         [libxcursor ${notice_platform}development files not found, the Xcursor extension won't be supported.])
+
+        dnl *** Check for X input extension
+        if test "$ac_cv_header_X11_extensions_XInput_h" = "yes"
+        then
+            WINE_CHECK_SONAME(Xi,XOpenDevice,,,[$X_LIBS $X_EXTRA_LIBS])
+        fi
+        WINE_NOTICE_WITH(xinput,[test "x$ac_cv_lib_soname_Xi" = "x"],
+                         [libxi ${notice_platform}development files not found, the Xinput extension won't be supported.])
+
+        dnl *** Check for X input 2 extension
+        if test "x$ac_cv_lib_soname_Xi" != x
+        then
+            WINE_NOTICE_WITH(xinput2,[test "$ac_cv_header_X11_extensions_XInput2_h" != "yes"],
+                             [XInput2 headers not found, the XInput 2 extension won't be supported.])
+        fi
+
+        dnl *** Check for X Shm extension
+        if test "$ac_cv_header_X11_extensions_XShm_h" = "yes"
+        then
+              AC_CHECK_LIB(Xext, XShmQueryExtension,
+              AC_DEFINE(HAVE_LIBXXSHM, 1, [Define if you have the X Shm extension]),,[$X_LIBS $X_EXTRA_LIBS])
+        fi
+        WINE_NOTICE_WITH(xshm,[test "$ac_cv_lib_Xext_XShmQueryExtension" != "yes"],
+                         [XShm ${notice_platform}development files not found, X Shared Memory won't be supported.])
+
+        dnl *** Check for X shape extension
+        if test "$ac_cv_header_X11_extensions_shape_h" = "yes"
+        then
+              AC_CHECK_LIB(Xext,XShapeQueryExtension,
+	      AC_DEFINE(HAVE_LIBXSHAPE, 1, [Define if you have the X Shape extension]),,[$X_LIBS $X_EXTRA_LIBS])
+        fi
+        WINE_NOTICE_WITH(xshape,[test "$ac_cv_lib_Xext_XShapeQueryExtension" != "yes"],
+                         [XShape ${notice_platform}development files not found, XShape won't be supported.])
+
+        dnl *** Check for XFree86 VMODE extension
+        if test "$ac_cv_header_X11_extensions_xf86vmode_h" = "yes" -o "$ac_cv_header_X11_extensions_xf86vmproto_h" = "yes"
+        then
+            WINE_CHECK_SONAME(Xxf86vm,XF86VidModeQueryExtension,,,[$X_LIBS $X_EXTRA_LIBS])
+        fi
+        WINE_NOTICE_WITH(xxf86vm,[test "x$ac_cv_lib_soname_Xxf86vm" = "x"],
+                         [libXxf86vm ${notice_platform}development files not found, XFree86 Vidmode won't be supported.])
+
+        dnl *** Check for Transform functions in Xrender
+        if test "$ac_cv_header_X11_extensions_Xrender_h" = "yes" -a "x$ac_cv_lib_soname_X11" != "x"
+        then
+            WINE_CHECK_SONAME(Xrender,XRenderQueryExtension,
+              [AC_CHECK_LIB(Xrender,XRenderSetPictureTransform,
+                [AC_DEFINE(HAVE_XRENDERSETPICTURETRANSFORM, 1,
+                 [Define if Xrender has the XRenderSetPictureTransform function])],,[$X_LIBS $X_EXTRA_LIBS])
+               AC_CHECK_LIB(Xrender,XRenderCreateLinearGradient,
+                [AC_DEFINE(HAVE_XRENDERCREATELINEARGRADIENT, 1,
+                 [Define if Xrender has the XRenderCreateLinearGradient function])],,[$X_LIBS $X_EXTRA_LIBS])],,[$X_LIBS $X_EXTRA_LIBS])
+
+        fi
+        WINE_WARNING_WITH(xrender,[test "x$ac_cv_lib_soname_Xrender" = "x"],
+                         [libxrender ${notice_platform}development files not found, XRender won't be supported.])
+
+        dnl *** Check for X RandR extension
+        if test "$ac_cv_header_X11_extensions_Xrandr_h" = "yes" -a "x$ac_cv_lib_soname_Xrender" != "x"
+        then
+                AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <X11/Xlib.h>
+#include <X11/extensions/Xrandr.h>]], [[static typeof(XRRSetScreenConfigAndRate) * func; if (func) return 0;]])],
+                  [WINE_CHECK_SONAME(Xrandr,XRRQueryExtension,
+                    [AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <X11/Xlib.h>
+#include <X11/extensions/Xrandr.h>]], [[static typeof(XRRGetScreenResources) *f; if (f) return 0;]])],
+                      [AC_DEFINE(HAVE_XRRGETSCREENRESOURCES, 1,
+                        [Define if Xrandr has the XRRGetScreenResources function])])],,[$X_LIBS $X_EXTRA_LIBS])])
+        fi
+        WINE_NOTICE_WITH(xrandr,[test "x$ac_cv_lib_soname_Xrandr" = "x"],
+                         [libxrandr ${notice_platform}development files not found, XRandr won't be supported.])
+
+        dnl *** Check for Xfixes extension
+        if test "$ac_cv_header_X11_extensions_Xfixes_h" = "yes"
+        then
+                AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <X11/Xlib.h>
+#include <X11/extensions/Xfixes.h>]], [[static typeof(XFixesQueryVersion) * func; if (func) return 0;]])],
+                  [WINE_CHECK_SONAME(Xfixes,XFixesQueryVersion,,,[$X_LIBS $X_EXTRA_LIBS])])
+        fi
+        WINE_NOTICE_WITH(xfixes,[test "x$ac_cv_lib_soname_Xfixes" = "x"],
+                         [libxfixes ${notice_platform}development files not found, Xfixes won't be supported.])
+
+        dnl *** Check for Xinerama extension
+        if test "$ac_cv_header_X11_extensions_Xinerama_h" = "yes"
+        then
+                AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <X11/Xlib.h>
+#include <X11/extensions/Xinerama.h>]], [[static typeof(XineramaQueryScreens) * func; if (func) return 0;]])],
+                  [WINE_CHECK_SONAME(Xinerama,XineramaQueryScreens,,,[$X_LIBS $X_EXTRA_LIBS])])
+        fi
+        WINE_NOTICE_WITH(xinerama,[test "x$ac_cv_lib_soname_Xinerama" = "x"],
+                         [libxinerama ${notice_platform}development files not found, multi-monitor setups won't be supported.])
+
+        dnl *** Check for X Composite extension
+        if test "$ac_cv_header_X11_extensions_Xcomposite_h" = "yes"
+        then
+            WINE_CHECK_SONAME(Xcomposite,XCompositeRedirectWindow,,,[$X_LIBS $X_EXTRA_LIBS])
+        fi
+        WINE_NOTICE_WITH(xcomposite,[test "x$ac_cv_lib_soname_Xcomposite" = "x"],
+                         [libxcomposite ${notice_platform}development files not found, Xcomposite won't be supported.])
+
+        dnl *** Check for XICCallback struct
+        AC_CHECK_MEMBERS([XICCallback.callback, XEvent.xcookie],,,
+[#ifdef HAVE_X11_XLIB_H
+#include <X11/Xlib.h>
+#endif])
+
+    dnl *** End of X11/Xlib.h check
+
+    dnl Check for the presence of OpenGL
+    opengl_msg=""
+    if test "x$with_opengl" != "xno"
+    then
+	WINE_CHECK_SONAME(GL,glXCreateContext,
+		     [OPENGL_LIBS="-lGL"],
+                     [WINE_CHECK_SONAME(GL,glXCreateContext,
+			    [OPENGL_LIBS="-Xlinker -dylib_file -Xlinker /System/Library/Frameworks/OpenGL.framework/Versions/A/Libraries/libGL.dylib:/System/Library/Frameworks/OpenGL.framework/Versions/A/Libraries/libGL.dylib -lGL"],
+			    [if test -f /usr/X11R6/lib/libGL.a
+                            then
+	                        opengl_msg="/usr/X11R6/lib/libGL.a is present on your system.
+This probably prevents linking to OpenGL. Try deleting the file and restarting configure."
+                            else
+                                opengl_msg="No OpenGL library found on this system."
+                            fi],
+			    $X_LIBS -lm $X_EXTRA_LIBS -dylib_file /System/Library/Frameworks/OpenGL.framework/Versions/A/Libraries/libGL.dylib:/System/Library/Frameworks/OpenGL.framework/Versions/A/Libraries/libGL.dylib)],
+		     $X_LIBS -lm $X_EXTRA_LIBS)
+        if test "x$with_glu" != "xno"
+        then
+            WINE_CHECK_SONAME(GLU,gluLookAt,,,[$OPENGL_LIBS $X_LIBS -lm $X_EXTRA_LIBS])
+            WINE_NOTICE_WITH(glu,[test "x$ac_cv_lib_soname_GLU" = "x"],
+                             [libGLU ${notice_platform}development files not found, GLU won't be supported.])
+        fi
+
+        if test "x$with_osmesa" != "xno"
+        then
+            WINE_CHECK_SONAME(OSMesa,OSMesaGetProcAddress,,,[$X_LIBS -lm $X_EXTRA_LIBS])
+            WINE_NOTICE_WITH(osmesa,[test "x$ac_cv_lib_soname_OSMesa" = "x"],
+                             [libOSMesa ${notice_platform}development files not found (or too old), OpenGL rendering in bitmaps won't be supported.])
+        fi
+    fi
+    WINE_WARNING_WITH(opengl,[test -n "$opengl_msg"],[$opengl_msg
+OpenGL and Direct3D won't be supported.])
+
+    CPPFLAGS="$ac_save_CPPFLAGS"
+else
+    X_CFLAGS=""
+    X_LIBS=""
+fi
+
+if test "$enable_wineandroid_drv$enable_winemac_drv" = "nono"
+then
+    WINE_ERROR_WITH(x,[test "x$X_LIBS" = "x"],
+[X ${notice_platform}development files not found. Wine will be built
+without X support, which probably isn't what you want. You will need
+to install ${notice_platform}development packages of Xlib at the very least.],
+                    [enable_winex11_drv])
+else
+    WINE_NOTICE_WITH(x,[test "x$X_LIBS" = "x"],
+                     [X ${notice_platform}development files not found, the X11 driver won't be supported.],
+                     [enable_winex11_drv])
+fi
+
+dnl **** Check for OpenCL ****
+if test "$ac_cv_header_CL_cl_h" = "yes"
+then
+    AC_CHECK_LIB(OpenCL,clGetPlatformInfo,[AC_SUBST(OPENCL_LIBS,["-lOpenCL"])])
+fi
+WINE_NOTICE_WITH(opencl,[test "x$ac_cv_lib_OpenCL_clGetPlatformInfo" != xyes],
+                 [OpenCL ${notice_platform}development files not found, OpenCL won't be supported.],
+                 [enable_opencl])
+
+dnl **** Check for libpcap ****
+if test "$ac_cv_header_pcap_pcap_h" = "yes"
+then
+    AC_CHECK_LIB(pcap,pcap_create,[AC_SUBST(PCAP_LIBS,["-lpcap"])])
+fi
+WINE_NOTICE_WITH(pcap,[test "x$ac_cv_lib_pcap_pcap_create" != xyes],
+                 [pcap ${notice_platform}development files not found, wpcap won't be supported.],
+                 [enable_wpcap])
+
+dnl **** Check for libxml2 ****
+
+if test "x$with_xml" != "xno"
+then
+    WINE_PACKAGE_FLAGS(XML2,[libxml-2.0],[-lxml2],
+                       [`${XML2_CONFIG:-xml2-config} --cflags 2>/dev/null`],[`${XML2_CONFIG:-xml2-config} --libs 2>/dev/null`],
+        [AC_CHECK_HEADERS([libxml/parser.h libxml/xmlsave.h libxml/SAX2.h])
+        if test "$ac_cv_header_libxml_parser_h" = "yes" -a "$ac_cv_header_libxml_xmlsave_h" = "yes" -a "$ac_cv_header_libxml_SAX2_h" = "yes"
+        then
+            AC_CHECK_LIB(xml2, xmlParseMemory,
+                [AC_DEFINE(HAVE_LIBXML2, 1, [Define if you have the libxml2 library])],[XML2_LIBS=""],[$XML2_LIBS])
+            AC_CHECK_LIB(xml2, xmlReadMemory,
+                [AC_DEFINE(HAVE_XMLREADMEMORY,1,[Define if libxml2 has the xmlReadMemory function])],,[$XML2_LIBS])
+            AC_CHECK_LIB(xml2, xmlNewDocPI,
+                [AC_DEFINE(HAVE_XMLNEWDOCPI,1,[Define if libxml2 has the xmlNewDocPI function])],,[$XML2_LIBS])
+            AC_CHECK_LIB(xml2, xmlSchemaSetParserStructuredErrors,
+                [AC_DEFINE(HAVE_XMLSCHEMASSETPARSERSTRUCTUREDERRORS,1,[Define if libxml2 has the xmlSchemaSetParserStructuredErrors function])],,[$XML2_LIBS])
+            AC_CHECK_LIB(xml2, xmlSchemaSetValidStructuredErrors,
+                [AC_DEFINE(HAVE_XMLSCHEMASSETVALIDSTRUCTUREDERRORS,1,[Define if libxml2 has the xmlSchemaSetValidStructuredErrors function])],,[$XML2_LIBS])
+            AC_CHECK_LIB(xml2, xmlFirstElementChild,
+                [AC_DEFINE(HAVE_XMLFIRSTELEMENTCHILD,1,[Define if libxml2 has the xmlFirstElementChild function])],,[$XML2_LIBS])
+            AC_CHECK_TYPE([xmlDocProperties],
+                [AC_DEFINE(HAVE_XMLDOC_PROPERTIES,1,[Define if libxml2 has the xmlDocProperties enum])],,[[#include <libxml/tree.h>]])
+        else
+            XML2_CFLAGS=""
+            XML2_LIBS=""
+        fi])
+fi
+WINE_WARNING_WITH(xml,[test "$ac_cv_lib_xml2_xmlParseMemory" != "yes"],
+                 [libxml2 ${notice_platform}development files not found (or too old), XML won't be supported.])
+
+if test "x$with_xslt" != "xno"
+then
+    WINE_PACKAGE_FLAGS(XSLT,[libxslt],[-lxml2],
+                       [`${XSLT_CONFIG:-xslt-config} --cflags 2>/dev/null`],[`${XSLT_CONFIG:-xslt-config} --libs 2>/dev/null`],
+        [AC_CHECK_HEADERS([libxslt/pattern.h libxslt/transform.h],,,
+        [#ifdef HAVE_LIBXSLT_PATTERN_H
+# include <libxslt/pattern.h>
+#endif])
+        if test "$ac_cv_header_libxslt_transform_h" = "yes"
+        then
+            WINE_CHECK_SONAME(xslt,xsltCompilePattern,,,[$XSLT_LIBS])
+        else
+            XSLT_CFLAGS=""
+        fi])
+fi
+WINE_WARNING_WITH(xslt,[test "x$ac_cv_lib_soname_xslt" = "x"],
+                 [libxslt ${notice_platform}development files not found, xslt won't be supported.])
+
+dnl **** Check for inotify ****
+if test "x$with_inotify" != "xno"
+then
+    WINE_PACKAGE_FLAGS(INOTIFY,[libinotify],,,,
+        [AC_CHECK_HEADERS([sys/inotify.h])
+         AC_CHECK_LIB(inotify,inotify_add_watch,[:],[INOTIFY_LIBS=""],[$INOTIFY_LIBS])])
+fi
+WINE_NOTICE_WITH(inotify,[test "$ac_cv_header_sys_inotify_h" != "yes"],
+                 [libinotify ${notice_platform}development files not found (or too old), filesystem change notifications won't be supported.])
+
+dnl **** Check for libdbus ****
+if test "x$with_dbus" != "xno"
+then
+    WINE_PACKAGE_FLAGS(DBUS,[dbus-1],,,,
+        [AC_CHECK_HEADER([dbus/dbus.h],
+            [WINE_CHECK_SONAME(dbus-1, dbus_connection_close,,[DBUS_CFLAGS=""],[$DBUS_LIBS])],
+            [DBUS_CFLAGS=""])])
+fi
+WINE_NOTICE_WITH(dbus,[test "x$ac_cv_lib_soname_dbus_1" = "x" -a \
+                            "x$ac_cv_header_DiskArbitration_DiskArbitration_h" != "xyes"],
+                 [libdbus ${notice_platform}development files not found, no dynamic device support.])
+
+dnl **** Check for libhal ****
+if test "x$with_hal" != "xno" -a "x$ac_cv_lib_soname_dbus_1" != x
+then
+    WINE_PACKAGE_FLAGS(HAL,[hal],[-ldbus-1],,,
+        [AC_CHECK_HEADER([hal/libhal.h],
+            [WINE_CHECK_SONAME(hal, libhal_ctx_new,,[HAL_CFLAGS=""],[$HAL_LIBS])],
+            [HAL_CFLAGS=""])])
+    WINE_NOTICE_WITH(hal,[test "x$ac_cv_lib_soname_hal" = "x" -a \
+                               "x$ac_cv_header_DiskArbitration_DiskArbitration_h" != "xyes"],
+                     [libhal ${notice_platform}development files not found, no legacy dynamic device support.])
+fi
+
+dnl **** Check for libgnutls ****
+if test "x$with_gnutls" != "xno"
+then
+    WINE_PACKAGE_FLAGS(GNUTLS,[gnutls],,,,
+        [AC_CHECK_HEADER(gnutls/gnutls.h,
+            [AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <gnutls/gnutls.h>
+#include <gnutls/crypto.h>]], [[static typeof(gnutls_mac_get_key_size) *func; if (func) return 0;]])],
+                [WINE_CHECK_SONAME(gnutls,gnutls_global_init,,[GNUTLS_CFLAGS=""],[$GNUTLS_LIBS],[[libgnutls\\(-deb0\\)\\{0,1\\}]])
+                 WINE_CHECK_LIB_FUNCS(gnutls_cipher_init,[$GNUTLS_LIBS],,
+                                      [WINE_NOTICE([libgnutls ${notice_platform}development files too old, bcrypt encryption won't be supported.])])])],
+            [GNUTLS_CFLAGS=""])])
+fi
+WINE_WARNING_WITH(gnutls,[test "x$ac_cv_lib_soname_gnutls" = "x"],
+                 [libgnutls ${notice_platform}development files not found, no schannel support.])
+
+dnl **** Check which curses lib to use ***
+CURSES_LIBS=""
+if test "$ac_cv_header_ncurses_h" = "yes"
+then
+    WINE_CHECK_SONAME(ncurses,waddch,[CURSES_LIBS="-lncurses"],,,[[libncursesw\\{0,1\\}]])
+elif test "$ac_cv_header_curses_h" = "yes"
+then
+    WINE_CHECK_SONAME(curses,waddch,[CURSES_LIBS="-lcurses"])
+fi
+ac_save_LIBS="$LIBS"
+LIBS="$LIBS $CURSES_LIBS"
+AC_CHECK_FUNCS(mousemask)
+LIBS="$ac_save_LIBS"
+WINE_NOTICE_WITH(curses,[test "x$ac_cv_lib_soname_curses$ac_cv_lib_soname_ncurses" = "x"],
+                 [lib(n)curses ${notice_platform}development files not found, curses won't be supported.])
+
+dnl **** Check for SANE ****
+if test "x$with_sane" != "xno"
+then
+    WINE_PACKAGE_FLAGS(SANE,[libsane],,[`${SANE_CONFIG:-sane-config} --cflags 2>/dev/null`],[`${SANE_CONFIG:-sane-config} --ldflags 2>/dev/null`],
+        [AC_CHECK_HEADER(sane/sane.h,
+            [WINE_CHECK_SONAME(sane,sane_init,,[SANE_CFLAGS=""],[$SANE_LIBS])],
+            [SANE_CFLAGS=""])])
+fi
+WINE_NOTICE_WITH(sane,[test "x$ac_cv_lib_soname_sane" = "x"],
+                 [libsane ${notice_platform}development files not found, scanners won't be supported.])
+
+dnl **** Check for libv4l2 ****
+if test "x$with_v4l2" != "xno"
+then
+    WINE_CHECK_SONAME(v4l2,v4l2_open)
+fi
+WINE_NOTICE_WITH(v4l2,[test "x$ac_cv_lib_soname_v4l2" = "x"],
+                 [libv4l2 ${notice_platform}development files not found.])
+
+dnl **** Check for libgphoto2 ****
+if test "x$with_gphoto" != "xno"
+then
+    WINE_PACKAGE_FLAGS(GPHOTO2,[libgphoto2],[-lgphoto2],
+                       [`${GPHOTO2_CONFIG:-gphoto2-config} --cflags 2>/dev/null`],[`${GPHOTO2_CONFIG:-gphoto2-config} --libs 2>/dev/null`],
+        [AC_CHECK_HEADER(gphoto2-camera.h,
+                        [AC_CHECK_LIB(gphoto2,gp_camera_new,
+                                      [AC_DEFINE(HAVE_GPHOTO2, 1, [Define if we have the libgphoto2 development environment])],
+                                      [GPHOTO2_LIBS=""; GPHOTO2_CFLAGS=""],
+                                      [$GPHOTO2_LIBS])],
+                        [GPHOTO2_LIBS=""; GPHOTO2_CFLAGS=""])])
+    WINE_PACKAGE_FLAGS(GPHOTO2_PORT,[libgphoto2_port],[-lgphoto2_port],
+                       [`${GPHOTO2_PORT_CONFIG:-gphoto2-port-config} --cflags 2>/dev/null`],
+                       [`${GPHOTO2_PORT_CONFIG:-gphoto2-port-config} --libs 2>/dev/null`],
+        [AC_CHECK_HEADER(gphoto2-port.h,
+                        [AC_CHECK_LIB(gphoto2_port,gp_port_info_list_new,
+                                      [AC_DEFINE(HAVE_GPHOTO2_PORT, 1, [Define if we have the libgphoto2_port development environment])],
+                                      [GPHOTO2_PORT_LIBS=""; GPHOTO2_PORT_CFLAGS=""],
+                                      [$GPHOTO2_PORT_LIBS])],
+                        [GPHOTO2_PORT_LIBS=""; GPHOTO2_PORT_CFLAGS=""])])
+fi
+WINE_NOTICE_WITH(gphoto,[test "$ac_cv_lib_gphoto2_gp_camera_new" != "yes"],
+                 [libgphoto2 ${notice_platform}development files not found, digital cameras won't be supported.])
+WINE_NOTICE_WITH(gphoto,[test "$ac_cv_lib_gphoto2_port_gp_port_info_list_new" != "yes"],
+                 [libgphoto2_port ${notice_platform}development files not found, digital cameras won't be auto-detected.])
+
+
+dnl **** Check for resolver library ***
+if test "$ac_cv_header_resolv_h" = "yes"
+then
+    AC_CACHE_CHECK([for resolver library], ac_cv_have_resolv,
+      [ac_save_LIBS="$LIBS"
+       for lib in '' -lresolv
+       do
+         LIBS="$lib $ac_save_LIBS"
+         AC_LINK_IFELSE([AC_LANG_PROGRAM([[#ifdef HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#include <resolv.h>]],[[if (!(_res.options & RES_INIT)) res_init(); res_query("foo",ns_c_in,0,0,0)]])],
+           [ac_cv_have_resolv=${lib:-"none required"}],[ac_cv_have_resolv="not found"])
+         test "x$ac_cv_have_resolv" = "xnot found" || break
+       done
+       LIBS="$ac_save_LIBS"])
+
+    case "$ac_cv_have_resolv" in
+      "not found") ;;
+      "none required")
+        AC_DEFINE(HAVE_RESOLV, 1, [Define if you have the resolver library and header]) ;;
+      *)
+        AC_DEFINE(HAVE_RESOLV, 1)
+        AC_SUBST(RESOLV_LIBS,$ac_cv_have_resolv) ;;
+    esac
+fi
+
+dnl **** Check for LittleCMS ***
+if test "x$with_cms" != "xno"
+then
+    WINE_PACKAGE_FLAGS(LCMS2,[lcms2],[-llcms2],,,
+        [AC_CHECK_HEADERS([lcms2.h])
+        if test "$ac_cv_header_lcms2_h" = "yes"
+        then
+            AC_CHECK_LIB(lcms2, cmsOpenProfileFromFile,
+                [AC_DEFINE(HAVE_LCMS2, 1, [Define if you have the LittleCMS development environment])],[LCMS2_LIBS=""],[$LCMS2_LIBS])
+        else
+            LCMS2_CFLAGS=""
+            LCMS2_LIBS=""
+        fi])
+fi
+WINE_NOTICE_WITH(cms,[test "$ac_cv_lib_lcms2_cmsOpenProfileFromFile" != "yes"],
+                 [liblcms2 ${notice_platform}development files not found, Color Management won't be supported.])
+
+dnl **** Check for FreeType 2 ****
+if test "x$with_freetype" != "xno"
+then
+    WINE_PACKAGE_FLAGS(FREETYPE,[freetype2],[-lfreetype],
+                       [`(${FREETYPE_CONFIG:-freetype-config} --cflags || ${FREETYPE2_CONFIG:-freetype2-config} --cflags) 2>/dev/null`],
+                       [`(${FREETYPE_CONFIG:-freetype-config} --libs || ${FREETYPE2_CONFIG:-freetype2-config} --libs) 2>/dev/null`],
+        [AC_CHECK_HEADERS([ft2build.h])
+        if test "$ac_cv_header_ft2build_h" = "yes"
+        then
+            WINE_CHECK_SONAME(freetype,FT_Init_FreeType,
+                [AC_DEFINE(HAVE_FREETYPE, 1, [Define if FreeType 2 is installed])
+                 AC_CHECK_TYPES(FT_TrueTypeEngineType,,,[#include <ft2build.h>
+#include FT_MODULE_H])],
+                [FREETYPE_LIBS=""],[$FREETYPE_LIBS])
+        else
+            FREETYPE_CFLAGS=""
+            FREETYPE_LIBS=""
+        fi])
+fi
+WINE_ERROR_WITH(freetype,[test "x$ac_cv_lib_soname_freetype" = x],
+                [FreeType ${notice_platform}development files not found. Fonts will not be built.],
+                [enable_fonts])
+
+dnl **** Check for parport (currently Linux only) ****
+AC_CACHE_CHECK([for parport header/ppdev.h], ac_cv_c_ppdev,
+ AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#ifdef HAVE_SYS_IOCTL_H
+# include <sys/ioctl.h>
+#endif
+#include <linux/ppdev.h>]], [[ioctl (1,PPCLAIM,0)]])],
+    [ac_cv_c_ppdev="yes"],[ac_cv_c_ppdev="no"]))
+if test "$ac_cv_c_ppdev" = "yes"
+then
+    AC_DEFINE(HAVE_PPDEV, 1, [Define if we can use ppdev.h for parallel port access])
+fi
+
+dnl **** Check for pthread functions ****
+WINE_CHECK_LIB_FUNCS(\
+        pthread_getthreadid_np \
+        [$PTHREAD_LIBS])
+
+dnl **** Check for zlib ****
+if test "x$with_zlib" != "xno"
+then
+    WINE_PACKAGE_FLAGS(Z,[libz],[-lz],,,
+        [AC_CHECK_HEADERS(zlib.h,
+            [AC_CHECK_LIB(z,inflate,
+                          [AC_DEFINE(HAVE_ZLIB,1,[Define to 1 if you have the `z' library (-lz).])],
+                          [Z_LIBS=""],[$Z_LIBS])],
+            [Z_LIBS=""])])
+fi
+WINE_NOTICE_WITH(zlib,[test "x$Z_LIBS" = "x"],[libz ${notice_platform}development files not found, data compression won't be supported.])
+
+dnl **** Check for gettextpo ****
+if test "x$enable_tools" != xno -a "x$with_gettextpo" = xyes
+then
+    if test "$ac_cv_header_gettext_po_h" = "yes"
+    then
+        AC_CHECK_LIB(gettextpo,po_message_msgctxt,
+                     [AC_DEFINE(HAVE_LIBGETTEXTPO,1,[Define to 1 if you have the `gettextpo' library (-lgettextpo).])
+                      AC_SUBST(GETTEXTPO_LIBS,"-lgettextpo")])
+    fi
+    WINE_NOTICE_WITH(gettextpo,[test "x$GETTEXTPO_LIBS" = "x"],
+      [GetText ${notice_platform}development files not found (or too old), po files can't be rebuilt.])
+    WINE_NOTICE_WITH(gettextpo,[test "$srcdir" != .],
+      [Rebuilding po files is not supported for out of tree builds.])
+fi
+
+dnl **** Check for PulseAudio ****
+if test "x$with_pulse" != "xno";
+then
+    WINE_PACKAGE_FLAGS(PULSE,[libpulse],,,,
+        [AC_CHECK_HEADERS(pulse/pulseaudio.h,
+            [AC_CHECK_LIB(pulse, pa_stream_is_corked,[:],[PULSE_LIBS=""],[$PULSE_LIBS])],
+            [PULSE_LIBS=""])])
+fi
+WINE_NOTICE_WITH(pulse, [test -z "$PULSE_LIBS"],
+        [libpulse ${notice_platform}development files not found or too old, Pulse won't be supported.],
+        [enable_winepulse_drv])
+
+dnl **** Check for gstreamer ****
+if test "x$with_gstreamer" != "xno"
+then
+    WINE_PACKAGE_FLAGS(GSTREAMER,[gstreamer-1.0 gstreamer-video-1.0 gstreamer-audio-1.0],,,,
+        [ac_gst_incl=""
+        for i in $GSTREAMER_CFLAGS
+        do
+            case "$i" in
+                -I*) ac_gst_incl="$ac_gst_incl $i";;
+            esac
+        done
+        GSTREAMER_CFLAGS=$ac_gst_incl
+        CPPFLAGS="$ac_save_CPPFLAGS $GSTREAMER_CFLAGS"
+        AC_CHECK_HEADER([gst/gst.h],
+            [AC_MSG_CHECKING([whether gint64 defined by gst/gst.h is indeed 64-bit])
+              AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <gst/gst.h>]],
+                                                 [[static int a[sizeof(gint64) > 4 ? 1 : -1]; if (a[0]) return 0;]])],
+                [AC_MSG_RESULT([yes])
+                 AC_CHECK_LIB(gstreamer-1.0,gst_pad_new,[:],,[$GSTREAMER_LIBS])],
+                [AC_MSG_RESULT([no])
+                 ac_glib2_broken=yes
+                 WINE_NOTICE([glib-2.0 pkgconfig configuration is for the wrong architecture, winegstreamer won't be built.])])])])
+fi
+WINE_NOTICE_WITH(gstreamer,[test "x$ac_glib2_broken" != xyes -a "x$ac_cv_lib_gstreamer_1_0_gst_pad_new" != xyes -a "x$ac_cv_header_QuickTime_ImageCompression_h" != xyes ],
+                 [gstreamer-1.0 base plugins ${notice_platform}development files not found, GStreamer won't be supported.])
+test "x$ac_cv_lib_gstreamer_1_0_gst_pad_new" = xyes || enable_winegstreamer=${enable_winegstreamer:-no}
+
+dnl **** Check for ALSA 1.x ****
+AC_SUBST(ALSA_LIBS,"")
+if test "x$with_alsa" != "xno"
+then
+    AC_CHECK_LIB(asound,snd_pcm_hw_params_get_access_mask,
+        [AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <alsa/asoundlib.h>]], [[snd_pcm_hw_params_get_access_mask(NULL, NULL)]])],
+                        [ALSA_LIBS="-lasound"])])
+fi
+test -n "$ALSA_LIBS" || enable_winealsa_drv=${enable_winealsa_drv:-no}
+
+dnl **** Check for OSSv4 ****
+if test "x$with_oss" != xno
+then
+    ac_save_CPPFLAGS="$CPPFLAGS"
+    if test -f /etc/oss.conf
+    then
+        . /etc/oss.conf
+    fi
+    ac_oss_incl="-I${OSSLIBDIR:-/usr/lib/oss}/include"
+    CPPFLAGS="$CPPFLAGS $ac_oss_incl"
+    AC_CHECK_HEADER([sys/soundcard.h],
+        [AC_CHECK_MEMBERS([oss_sysinfo.numaudioengines],
+                          [AC_SUBST(OSS4_CFLAGS,"$ac_oss_incl")],,
+                          [#include <sys/soundcard.h>])])
+    CPPFLAGS="$ac_save_CPPFLAGS"
+fi
+WINE_NOTICE_WITH(oss,[test "x$ac_cv_member_oss_sysinfo_numaudioengines" != xyes],
+                 [OSS sound system found but too old (OSSv4 needed), OSS won't be supported.],
+                 [enable_wineoss_drv])
+
+dnl **** Check for libudev ****
+if test "x$with_udev" != "xno"
+then
+    WINE_PACKAGE_FLAGS(UDEV,[libudev],[-ludev],,,
+        [AC_CHECK_HEADERS(libudev.h,
+            [AC_CHECK_LIB(udev,udev_new,
+                AC_DEFINE(HAVE_UDEV,1,[Define to 1 if you have the `udev' library (-ludev).]),
+                [UDEV_LIBS=""],[$UDEV_LIBS])],
+            [UDEV_LIBS=""])])
+fi
+WINE_NOTICE_WITH(udev,[test "x$UDEV_LIBS" = "x"],
+                 [libudev ${notice_platform}development files not found, plug and play won't be supported.])
+
+dnl **** Check for libSDL2 ****
+if test "x$with_sdl" != "xno"
+then
+    WINE_PACKAGE_FLAGS(SDL2,[sdl2],[-lSDL2],,,
+        [AC_CHECK_HEADERS([SDL2/SDL.h],
+            [WINE_CHECK_SONAME(SDL2,SDL_Init,,,[$SDL2_LIBS],[[libSDL2-2.0*]])])])
+fi
+WINE_NOTICE_WITH(sdl,[test "x$ac_cv_lib_soname_SDL2" = "x"],
+                 [libSDL2 ${notice_platform}development files not found, SDL2 won't be supported.])
+
+dnl **** Check for FAudio ****
+if test "x$with_faudio" != "xno"
+then
+    WINE_PACKAGE_FLAGS(FAUDIO,[faudio],[-lFAudio],,,
+        [AC_CHECK_HEADERS([FAudio.h],
+            [WINE_CHECK_SONAME(FAudio,FAudioCreate,,,[$FAUDIO_LIBS],[[libFAudio*]])])])
+    WINE_CHECK_LIB_FUNCS(\
+        FAudio_CommitOperationSet \
+        F3DAudioInitialize8,
+        [$FAUDIO_LIBS])
+fi
+WINE_NOTICE_WITH(faudio,[test "x$ac_cv_lib_soname_FAudio" = "x"],
+                 [libFAudio ${notice_platform}development files not found, XAudio2 won't be supported.])
+
+dnl **** Check for capi4linux ****
+if test "x$with_capi" != "xno"
+then
+    WINE_PACKAGE_FLAGS(CAPI20,[capi20],,,,
+     dnl Check for broken kernel header that doesn't define __user
+    [AC_CHECK_HEADERS([capi20.h linux/capi.h],,,[#define __user])
+    if test "$ac_cv_header_capi20_h" = "yes" -a "$ac_cv_header_linux_capi_h" = "yes"
+    then
+        WINE_CHECK_SONAME(capi20,capi20_register,,,[$CAPI20_LIBS])
+    fi])
+fi
+WINE_NOTICE_WITH(capi,[test "x$ac_cv_lib_soname_capi20" = "x"],
+                 [libcapi20 ${notice_platform}development files not found, ISDN won't be supported.])
+
+dnl **** Check for cups ****
+if test "x$with_cups" != "xno"
+then
+    WINE_PACKAGE_FLAGS(CUPS,[cups],[-lcups],
+                       [`${CUPS_CONFIG:-cups-config} --cflags 2>/dev/null`],
+                       [`${CUPS_CONFIG:-cups-config} --libs 2>/dev/null`],
+                       [AC_CHECK_HEADERS(cups/cups.h cups/ppd.h)
+                        if test "$ac_cv_header_cups_cups_h" = "yes"
+                        then
+                            WINE_CHECK_SONAME(cups,cupsGetDefault,,[CUPS_LIBS=""],[$CUPS_LIBS])
+                        else
+                            CUPS_CFLAGS=""
+                            CUPS_LIBS=""
+                        fi])
+fi
+WINE_NOTICE_WITH(cups,[test "x$ac_cv_lib_soname_cups" = "x"],
+                 [libcups ${notice_platform}development files not found, CUPS won't be supported.])
+
+dnl **** Check for fontconfig ****
+if test "x$with_fontconfig" != "xno"
+then
+    WINE_PACKAGE_FLAGS(FONTCONFIG,[fontconfig],,[$X_CFLAGS],[$X_LIBS],
+        [AC_CHECK_HEADERS([fontconfig/fontconfig.h])
+        if test "$ac_cv_header_fontconfig_fontconfig_h" = "yes"
+        then
+            WINE_CHECK_SONAME(fontconfig,FcInit,,[FONTCONFIG_CFLAGS=""],[$FONTCONFIG_LIBS])
+        else
+            FONTCONFIG_CFLAGS=""
+        fi])
+fi
+WINE_NOTICE_WITH(fontconfig,[test "x$ac_cv_lib_soname_fontconfig" = "x"],
+                 [fontconfig ${notice_platform}development files not found, fontconfig won't be supported.])
+
+dnl **** Check for gsm codec ****
+if test "$ac_cv_header_gsm_h" = "yes" -o "$ac_cv_header_gsm_gsm_h" = "yes"
+then
+    WINE_CHECK_SONAME(gsm,gsm_create)
+fi
+WINE_NOTICE_WITH(gsm,[test "x$ac_cv_lib_soname_gsm" = "x"],
+                 [libgsm ${notice_platform}development files not found, gsm 06.10 codec won't be supported.])
+
+dnl **** Check for krb5 ****
+if test "x$with_krb5" != "xno"
+then
+    WINE_PACKAGE_FLAGS(KRB5,[krb5],,
+                       [`${KRB5_CONFIG:-krb5-config} --cflags 2>/dev/null`],
+                       [`${KRB5_CONFIG:-krb5-config} --libs 2>/dev/null`],
+        [AC_CHECK_HEADERS([krb5/krb5.h])
+         if test "$ac_cv_header_krb5_krb5_h" = "yes"
+         then
+             WINE_CHECK_SONAME(krb5,krb5_is_config_principal,,[KRB5_CFLAGS=""],[$KRB5_LIBS])
+         else
+             KRB5_CFLAGS=""
+         fi])
+else
+    with_gssapi=${with_gssapi:-no}
+fi
+WINE_NOTICE_WITH(krb5,[test "x$ac_cv_lib_soname_krb5" = "x"],
+                 [libkrb5 ${notice_platform}development files not found (or too old), Kerberos won't be supported.])
+
+dnl **** Check for gssapi ****
+if test "x$with_gssapi" != "xno"
+then
+    WINE_PACKAGE_FLAGS(GSSAPI,[krb5-gssapi],,
+                       [`${KRB5_CONFIG:-krb5-config} --cflags gssapi 2>/dev/null`],
+                       [`${KRB5_CONFIG:-krb5-config} --libs gssapi 2>/dev/null`],
+        [AC_CHECK_HEADERS([gssapi/gssapi.h gssapi/gssapi_ext.h])
+        if test "$ac_cv_header_gssapi_gssapi_h" = "yes" -a "$ac_cv_header_gssapi_gssapi_ext_h" = "yes"
+        then
+            WINE_CHECK_SONAME(gssapi_krb5, gss_init_sec_context,,[GSSAPI_CFLAGS=""],[$GSSAPI_LIBS])
+        else
+            GSSAPI_CFLAGS=""
+        fi])
+fi
+WINE_NOTICE_WITH(gssapi,[test "x$ac_cv_lib_soname_gssapi_krb5" = "x"],
+                 [libgssapi_krb5 ${notice_platform}development files not found (or too old), no Kerberos SSP support.])
+
+dnl **** Check for libjpeg ****
+if test "x$with_jpeg" != "xno"
+then
+    WINE_PACKAGE_FLAGS(JPEG,[libjpeg],,,,
+        [AC_CHECK_HEADERS([jpeglib.h])
+        if test "$ac_cv_header_jpeglib_h" = "yes"
+        then
+            WINE_CHECK_SONAME(jpeg,jpeg_start_decompress,,[JPEG_CFLAGS=""],[$JPEG_LIBS])
+        else
+            JPEG_CFLAGS=""
+        fi])
+fi
+WINE_WARNING_WITH(jpeg,[test "x$ac_cv_lib_soname_jpeg" = "x"],
+                 [libjpeg ${notice_platform}development files not found, JPEG won't be supported.])
+
+dnl **** Check for libpng ****
+if test "x$with_png" != "xno"
+then
+    WINE_PACKAGE_FLAGS(PNG,[libpng],,[$X_CFLAGS],[$X_LIBS],
+        [AC_CHECK_HEADERS([png.h])
+        if test "$ac_cv_header_png_h" = "yes"
+        then
+            WINE_CHECK_SONAME(png,png_create_read_struct,,
+                [PNG_CFLAGS=""],[$PNG_LIBS -lm -lz],[[libpng[[0-9]]*]])
+        else
+            PNG_CFLAGS=""
+        fi])
+fi
+WINE_WARNING_WITH(png,[test "x$ac_cv_lib_soname_png" = "x"],
+                 [libpng ${notice_platform}development files not found, PNG won't be supported.])
+
+dnl **** Check for libtiff ****
+if test "x$with_tiff" != "xno"
+then
+    WINE_PACKAGE_FLAGS(TIFF,[libtiff-4],,,,
+        [AC_CHECK_HEADERS([tiffio.h])
+        if test "$ac_cv_header_tiffio_h" = "yes"
+        then
+            WINE_CHECK_SONAME(tiff,TIFFClientOpen,,,[$TIFF_LIBS])
+        fi])
+fi
+WINE_NOTICE_WITH(tiff,[test "x$ac_cv_lib_soname_tiff" = "x"],
+                 [libtiff ${notice_platform}development files not found, TIFF won't be supported.])
+
+dnl **** Check for mpg123 ****
+if test "x$with_mpg123" != "xno"
+then
+    WINE_PACKAGE_FLAGS(MPG123,[libmpg123],[-lmpg123],,,
+        [AC_CHECK_HEADERS([mpg123.h])
+        if test "$ac_cv_header_mpg123_h" = "yes"
+        then
+            AC_CHECK_LIB(mpg123,mpg123_feed,[:],[MPG123_LIBS=""],[$MPG123_LIBS])
+        else
+            MPG123_CFLAGS=""
+            MPG123_LIBS=""
+        fi])
+fi
+WINE_NOTICE_WITH(mpg123,[test "x$ac_cv_lib_mpg123_mpg123_feed" != xyes -a x"$ac_cv_header_CoreAudio_CoreAudio_h" != xyes],
+                 [libmpg123 ${notice_platform}development files not found (or too old), mp3 codec won't be supported.],
+                 [enable_l3codeca_acm])
+test "x$ac_cv_lib_mpg123_mpg123_feed" = xyes || enable_mp3dmod=${enable_mp3dmod:-no}
+
+dnl **** Check for OpenAL 1.1 ****
+if test "$ac_cv_header_AL_al_h" = "yes"
+then
+    WINE_CHECK_SONAME(openal,alGetSource3i,[AC_SUBST(OPENAL_LIBS,"-lopenal")
+                      ac_cv_lib_openal=yes
+                      AC_DEFINE_UNQUOTED(HAVE_OPENAL,1,[Define to 1 if OpenAL is available])],,)
+fi
+WINE_NOTICE_WITH(openal,[test "x$ac_cv_lib_openal" != xyes],
+                 [libopenal ${notice_platform}development files not found (or too old), OpenAL won't be supported.],
+                 [enable_openal32])
+
+if test "x$ac_cv_lib_soname_FAudio" = "x"
+then
+    enable_x3daudio1_0=${enable_x3daudio1_0:-no}
+    enable_x3daudio1_1=${enable_x3daudio1_1:-no}
+    enable_x3daudio1_2=${enable_x3daudio1_2:-no}
+    enable_x3daudio1_3=${enable_x3daudio1_3:-no}
+    enable_x3daudio1_4=${enable_x3daudio1_4:-no}
+    enable_x3daudio1_5=${enable_x3daudio1_5:-no}
+    enable_x3daudio1_6=${enable_x3daudio1_6:-no}
+    enable_x3daudio1_7=${enable_x3daudio1_7:-no}
+    enable_xactengine3_0=${enable_xactengine3_0:-no}
+    enable_xactengine3_1=${enable_xactengine3_1:-no}
+    enable_xactengine3_2=${enable_xactengine3_2:-no}
+    enable_xactengine3_3=${enable_xactengine3_3:-no}
+    enable_xactengine3_4=${enable_xactengine3_4:-no}
+    enable_xactengine3_5=${enable_xactengine3_5:-no}
+    enable_xactengine3_6=${enable_xactengine3_6:-no}
+    enable_xactengine3_7=${enable_xactengine3_7:-no}
+    enable_xapofx1_1=${enable_xapofx1_1:-no}
+    enable_xapofx1_2=${enable_xapofx1_2:-no}
+    enable_xapofx1_3=${enable_xapofx1_3:-no}
+    enable_xapofx1_4=${enable_xapofx1_4:-no}
+    enable_xapofx1_5=${enable_xapofx1_5:-no}
+    enable_xaudio2_0=${enable_xaudio2_0:-no}
+    enable_xaudio2_1=${enable_xaudio2_1:-no}
+    enable_xaudio2_2=${enable_xaudio2_2:-no}
+    enable_xaudio2_3=${enable_xaudio2_3:-no}
+    enable_xaudio2_4=${enable_xaudio2_4:-no}
+    enable_xaudio2_5=${enable_xaudio2_5:-no}
+    enable_xaudio2_6=${enable_xaudio2_6:-no}
+    enable_xaudio2_7=${enable_xaudio2_7:-no}
+    enable_xaudio2_8=${enable_xaudio2_8:-no}
+    enable_xaudio2_9=${enable_xaudio2_9:-no}
+fi
+
+dnl **** Check for libkstat ****
+if test "$ac_cv_header_kstat_h" = "yes"
+then
+    AC_CHECK_LIB(kstat,kstat_open,
+                 [AC_DEFINE(HAVE_LIBKSTAT, 1, [Define to 1 if you have the `kstat' library (-lkstat).])
+                  AC_SUBST(KSTAT_LIBS,"-lkstat")])
+fi
+
+dnl **** Check for libprocstat ****
+if test "$ac_cv_header_libprocstat_h" = "yes"
+then
+    AC_CHECK_LIB(procstat,procstat_open_sysctl,
+                 [AC_DEFINE(HAVE_LIBPROCSTAT, 1, [Define to 1 if you have the `procstat' library (-lprocstat).])
+                  AC_SUBST(PROCSTAT_LIBS,"-lprocstat")])
+fi
+
+dnl **** Check for libodbc ****
+WINE_CHECK_SONAME(odbc,SQLConnect,,[AC_DEFINE_UNQUOTED(SONAME_LIBODBC,["libodbc.$LIBEXT"])])
+
+dnl **** Check for libnetapi ****
+if test "x$with_netapi" != "xno"
+then
+    WINE_PACKAGE_FLAGS(NETAPI,[netapi],,,,
+      [WINE_CHECK_SONAME(netapi,libnetapi_init,,[AC_DEFINE_UNQUOTED(SONAME_LIBNETAPI,["libnetapi.$LIBEXT"])],[$NETAPI_LIBS])])
+fi
+
+dnl **** Check for any sound system ****
+if test "x$enable_winealsa_drv$enable_winecoreaudio_drv$enable_winepulse_drv$enable_wineoss_drv$enable_wineandroid_drv" = xnonononono -a \
+        "x$with_alsa$with_coreaudio$with_oss$with_pulse" != xnononono
+then
+    WINE_WARNING([No sound system was found. Windows applications will be silent.])
+fi
+
+dnl *** Check for Vulkan ***
+if test "x$with_vulkan" != "xno"
+then
+    WINE_CHECK_SONAME(vulkan, vkGetInstanceProcAddr)
+    if test "x$ac_cv_lib_soname_vulkan" = "x"
+    then
+        WINE_CHECK_SONAME(MoltenVK, vkGetInstanceProcAddr)
+    fi
+fi
+WINE_NOTICE_WITH(vulkan,[test "x$ac_cv_lib_soname_vulkan" = "x" -a "x$ac_cv_lib_soname_MoltenVK" = "x"],
+                 [libvulkan and libMoltenVK ${notice_platform}development files not found, Vulkan won't be supported.])
+
+dnl **** Check for vkd3d ****
+if test "x$with_vkd3d" != "xno"
+then
+    WINE_PACKAGE_FLAGS(VKD3D,[libvkd3d],,,,
+        [WINE_CHECK_SONAME(vkd3d,vkd3d_get_dxgi_format,,,[$VKD3D_LIBS])])
+fi
+WINE_NOTICE_WITH(vkd3d,[test "x$ac_cv_lib_soname_vkd3d" = "x"],
+                 [vkd3d ${notice_platform}development files not found (or too old), Direct3D 12 won't be supported.])
+test "x$ac_cv_lib_soname_vkd3d" != "x" || enable_d3d12=${enable_d3d12:-no}
+
+dnl **** Check for gcc specific options ****
+
+AC_SUBST(EXTRACFLAGS,"")
+if test "x${GCC}" = "xyes"
+then
+  EXTRACFLAGS="-Wall -pipe"
+
+  dnl Check for strength-reduce bug
+  AC_CACHE_CHECK( [for gcc strength-reduce bug], ac_cv_c_gcc_strength_bug,
+                  AC_RUN_IFELSE([AC_LANG_PROGRAM([[int L[[4]] = {0,1,2,3};]],
+[[static int Array[[3]];
+  unsigned int B = 3;
+  int i;
+  for(i=0; i<B; i++) Array[[i]] = i - 3;
+  for(i=0; i<4 - 1; i++) L[[i]] = L[[i + 1]];
+  L[[i]] = 4;
+  return (Array[[1]] != -2 || L[[2]] != 3)]])],
+    [ac_cv_c_gcc_strength_bug="no"],[ac_cv_c_gcc_strength_bug="yes"],[ac_cv_c_gcc_strength_bug="no"]) )
+  if test "$ac_cv_c_gcc_strength_bug" = "yes"
+  then
+    EXTRACFLAGS="$EXTRACFLAGS -fno-strength-reduce"
+  fi
+
+  dnl Check for some compiler flags
+  WINE_TRY_CFLAGS([-fno-strict-aliasing])
+  WINE_TRY_CFLAGS([-fexcess-precision=standard],[AC_SUBST(EXCESS_PRECISION_CFLAGS,"-fexcess-precision=standard")])
+  dnl clang needs to be told to fail on unknown options
+  saved_CFLAGS=$CFLAGS
+  WINE_TRY_CFLAGS([-Werror=unknown-warning-option],[CFLAGS="$CFLAGS -Werror=unknown-warning-option"])
+  WINE_TRY_CFLAGS([-Wdeclaration-after-statement])
+  WINE_TRY_CFLAGS([-Wempty-body])
+  WINE_TRY_CFLAGS([-Wignored-qualifiers])
+  WINE_TRY_CFLAGS([-Wpacked-not-aligned],[EXTRACFLAGS="$EXTRACFLAGS -Wno-packed-not-aligned"])
+  WINE_TRY_CFLAGS([-Wpragma-pack],[EXTRACFLAGS="$EXTRACFLAGS -Wno-pragma-pack"])
+  WINE_TRY_CFLAGS([-Wshift-overflow=2])
+  WINE_TRY_CFLAGS([-Wstrict-prototypes])
+  WINE_TRY_CFLAGS([-Wtype-limits])
+  WINE_TRY_CFLAGS([-Wunused-but-set-parameter])
+  WINE_TRY_CFLAGS([-Wvla])
+  WINE_TRY_CFLAGS([-Wwrite-strings])
+
+  dnl Check for noisy string.h
+  WINE_TRY_CFLAGS([-Wpointer-arith],
+     [saved_string_h_CFLAGS=$CFLAGS
+      CFLAGS="$CFLAGS -Wpointer-arith -Werror"
+      AC_CACHE_CHECK([for broken string.h that generates warnings with -Wpointer-arith], ac_cv_c_string_h_warnings,
+          AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <string.h>]])],[ac_cv_c_string_h_warnings=no],[ac_cv_c_string_h_warnings=yes]))
+      test "$ac_cv_c_string_h_warnings" = yes || EXTRACFLAGS="$EXTRACFLAGS -Wpointer-arith"
+      CFLAGS=$saved_string_h_CFLAGS])
+
+  dnl Check for noisy string.h on logical ops
+  WINE_TRY_CFLAGS([-Wlogical-op],
+     [saved_string_h_CFLAGS=$CFLAGS
+      CFLAGS="$CFLAGS -Wlogical-op -Werror"
+      AC_CACHE_CHECK([for broken string.h that generates warnings with -Wlogical-op], ac_cv_c_logicalop_noisy,
+          AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <string.h>
+char*f(const char *h,char n) {return strchr(h,n);}]])],[ac_cv_c_logicalop_noisy=no],[ac_cv_c_logicalop_noisy=yes]))
+      CFLAGS=$saved_string_h_CFLAGS
+      test "$ac_cv_c_logicalop_noisy" = yes || EXTRACFLAGS="$EXTRACFLAGS -Wlogical-op"])
+
+  CFLAGS=$saved_CFLAGS
+
+  dnl Default to dwarf-2 debug info
+  for ac_flag in $CFLAGS; do
+    case $ac_flag in
+      -g) WINE_TRY_CFLAGS([-gdwarf-2])
+          WINE_TRY_CFLAGS([-gstrict-dwarf]) ;;
+    esac
+  done
+
+  dnl Disable gcc builtins except for Mingw
+  AC_SUBST(MSVCRTFLAGS,"")
+  case $host_os in
+    cygwin*|mingw32*) ;;
+    *) WINE_TRY_CFLAGS([-fno-builtin],[MSVCRTFLAGS="$MSVCRTFLAGS -fno-builtin"])
+       WINE_TRY_CFLAGS([-fshort-wchar],[MSVCRTFLAGS="$MSVCRTFLAGS -fshort-wchar"]) ;;
+  esac
+
+  case $host_cpu in
+    dnl gcc-4.6+ omits frame pointers by default, breaking some copy protections
+    *i[[3456789]]86*) WINE_TRY_CFLAGS([-fno-omit-frame-pointer]) ;;
+    *x86_64*)
+      case $host_os in
+        dnl Mingw uses Windows 64-bit types, not Unix ones
+        cygwin*|mingw32*) WINE_TRY_CFLAGS([-Wno-format]) ;;
+        dnl Default to ms_abi on 64-bit
+        *) WINE_TRY_CFLAGS([-mabi=ms],[MSVCRTFLAGS="$MSVCRTFLAGS -mabi=ms"]) ;;
+      esac ;;
+  esac
+
+  dnl Enable -Werror for maintainer mode
+  if test "x$enable_maintainer_mode" = "xyes"
+  then
+      WINE_TRY_CFLAGS([-Werror])
+  fi
+fi
+
+dnl **** Disable Fortify, it has too many false positives
+
+AC_CACHE_CHECK([for the need to disable Fortify], ac_cv_c_fortify_enabled,
+    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <string.h>]],
+[[#if (defined(__USE_FORTIFY_LEVEL) && __USE_FORTIFY_LEVEL > 0) || (defined(_FORTIFY_SOURCE) && _FORTIFY_SOURCE > 0)
+#error Fortify enabled
+#endif]])],
+        [ac_cv_c_fortify_enabled=no],[ac_cv_c_fortify_enabled=yes]))
+if test "$ac_cv_c_fortify_enabled" = yes
+then
+    CFLAGS="$CFLAGS -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=0"
+fi
+
+dnl **** Check for CFI directives support ****
+
+AC_CACHE_CHECK([whether CFI directives are supported in assembly code], ac_cv_c_cfi_support,
+    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[asm(".text\nac_test:\t.cfi_startproc\n\t.long 0\n\t.cfi_endproc");]])],
+                      ac_cv_c_cfi_support="yes",ac_cv_c_cfi_support="no"))
+if test "$ac_cv_c_cfi_support" = "yes"
+then
+   LDDLLFLAGS="$LDDLLFLAGS -fasynchronous-unwind-tables"
+else
+   if test "x$enable_win64" = "xyes"
+   then
+      WINE_WARNING([building 64-bit Wine without support for CFI directives; exception handling will not work properly.])
+   fi
+fi
+
+dnl **** Platform-specific checks ****
+
+case $build_os in
+  cygwin*|mingw32*) AC_SUBST(TOOLSEXT,".exe") ;;
+esac
+
+case $host_os in
+  linux*)
+    case $host_cpu in
+      *i[[3456789]]86*|x86_64*|*aarch64*)
+        test "$wine_binary" = wine || WINE_IGNORE_FILE("loader/wine-preloader")
+        WINELOADER_PROGRAMS="$WINELOADER_PROGRAMS $wine_binary-preloader"
+        ;;
+    esac
+    ;;
+esac
+
+dnl **** Check for functions ****
+
+ac_save_CFLAGS="$CFLAGS"
+CFLAGS="$CFLAGS $BUILTINFLAG"
+AC_CHECK_FUNCS(\
+        __res_get_state \
+        __res_getservers \
+	_spawnvp \
+	dlopen \
+	epoll_create \
+	ffs \
+	finitef \
+	fnmatch \
+	fork \
+	fpclass \
+	fstatfs \
+	fstatvfs \
+	futimens \
+	futimes \
+	futimesat \
+	getattrlist \
+	getauxval \
+	getifaddrs \
+	getopt_long_only \
+	kqueue \
+	lstat \
+	pipe2 \
+	poll \
+	port_create \
+	ppoll \
+	prctl \
+	pread \
+	proc_pidinfo \
+	pwrite \
+	readdir \
+	readlink \
+	sched_yield \
+	select \
+	setproctitle \
+	setprogname \
+	settimeofday \
+	sigprocmask \
+	statfs \
+	statvfs \
+	strnlen \
+	strtold \
+	symlink \
+	sysinfo \
+	tcdrain \
+	thr_kill2 \
+	timegm \
+	usleep
+)
+CFLAGS="$ac_save_CFLAGS"
+
+dnl Check for -ldl
+if test "$ac_cv_func_dlopen" = no
+then
+    AC_CHECK_LIB(dl,dlopen,[AC_DEFINE(HAVE_DLOPEN,1) AC_SUBST(DL_LIBS,"-ldl")])
+fi
+WINE_CHECK_LIB_FUNCS(dladdr,[$DL_LIBS])
+
+dnl Check for -lpoll for Mac OS X/Darwin
+if test "$ac_cv_func_poll" = no
+then
+    AC_CHECK_LIB(poll,poll,[AC_DEFINE(HAVE_POLL,1) AC_SUBST(POLL_LIBS,"-lpoll")])
+fi
+
+dnl Check for -lnsl for Solaris
+AC_SEARCH_LIBS(gethostbyname, nsl)
+
+dnl Check for -lsocket for Solaris
+AC_SEARCH_LIBS(connect, socket)
+
+dnl Check for -lresolv for Solaris
+AC_SEARCH_LIBS(inet_aton, resolv)
+
+dnl **** Check for functions which may rely on -lsocket on Solaris.
+AC_CHECK_FUNCS(\
+	getaddrinfo \
+	getnameinfo \
+	getnetbyname \
+	getprotobyname \
+	getprotobynumber \
+	getservbyport \
+	inet_addr \
+	inet_network \
+	inet_ntop \
+	inet_pton \
+)
+
+dnl Check for clock_gettime which may be in -lrt
+case $host_os in
+    darwin*|macosx*) ;;
+    *) ac_save_LIBS=$LIBS
+        AC_SEARCH_LIBS(clock_gettime, rt,
+            [AC_DEFINE(HAVE_CLOCK_GETTIME, 1, [Define to 1 if you have the `clock_gettime' function.])
+                test "$ac_res" = "none required" || AC_SUBST(RT_LIBS,"$ac_res")])
+    LIBS=$ac_save_LIBS
+    ;;
+esac
+
+dnl Check for shm_open which may be in -lrt
+if test "$ac_cv_header_sys_mman_h" = "yes" -a "x$RT_LIBS" = "x"
+then
+    ac_save_LIBS=$LIBS
+    AC_SEARCH_LIBS(shm_open, rt,
+                   [AC_DEFINE(HAVE_SHM_OPEN, 1, [Define to 1 if you have the `shm_open' function.])
+                    test "$ac_res" = "none required" || AC_SUBST(RT_LIBS,"$ac_res")])
+fi
+LIBS=$ac_save_LIBS
+
+dnl **** Check for OpenLDAP ***
+if test "x$with_ldap" != "xno"
+then
+    dnl Actually there's no pkg-config support for ldap, but this way we can still override the flags
+    WINE_PACKAGE_FLAGS(LDAP,[openldap],[-lldap_r -llber],,,
+        [AC_CHECK_HEADERS([ldap.h lber.h])
+        if test "$ac_cv_header_ldap_h" = "yes" -a "$ac_cv_header_lber_h" = "yes"
+        then
+            AC_CHECK_TYPE(LDAPSortKey,
+                [AC_CHECK_LIB(ldap_r, ldap_initialize,
+                    [AC_CHECK_LIB(lber, ber_init,
+                        [AC_DEFINE(HAVE_LDAP, 1, [Define if you have the OpenLDAP development environment])],
+                        [LDAP_LIBS=""],
+                        [$PTHREAD_LIBS $LDAP_LIBS])],
+                    [LDAP_LIBS=""],
+                    [$PTHREAD_LIBS $LDAP_LIBS])],
+                [LDAP_LIBS=""],
+                [#include <ldap.h>])
+            WINE_CHECK_LIB_FUNCS(\
+                ldap_count_references \
+                ldap_first_reference \
+                ldap_next_reference \
+                ldap_parse_reference \
+                ldap_parse_sort_control \
+                ldap_parse_sortresponse_control \
+                ldap_parse_vlv_control \
+                ldap_parse_vlvresponse_control,
+                [$LDAP_LIBS $PTHREAD_LIBS])
+        else
+            LDAP_LIBS=""
+        fi])
+fi
+WINE_NOTICE_WITH(ldap,[test "x$LDAP_LIBS" = "x"],
+                 [libldap (OpenLDAP) ${notice_platform}development files not found, LDAP won't be supported.])
+
+AC_CACHE_CHECK([for sched_setaffinity],wine_cv_have_sched_setaffinity,
+                AC_LINK_IFELSE([AC_LANG_PROGRAM(
+[[#define _GNU_SOURCE
+#include <sched.h>]], [[sched_setaffinity(0, 0, 0);]])],[wine_cv_have_sched_setaffinity=yes],[wine_cv_have_sched_setaffinity=no]))
+if test "$wine_cv_have_sched_setaffinity" = "yes"
+then
+  AC_DEFINE(HAVE_SCHED_SETAFFINITY, 1, [Define to 1 if you have the `sched_setaffinity' function.])
+fi
+
+AC_CACHE_CHECK([for fallocate],wine_cv_have_fallocate,
+                AC_LINK_IFELSE([AC_LANG_PROGRAM(
+[[#define _GNU_SOURCE
+#include <fcntl.h>]], [[fallocate(-1, 0, 0, 0);]])],[wine_cv_have_fallocate=yes],[wine_cv_have_fallocate=no]))
+if test "$wine_cv_have_fallocate" = "yes"
+then
+  AC_DEFINE(HAVE_FALLOCATE, 1, [Define to 1 if you have the `fallocate' function.])
+fi
+
+dnl **** Check for types ****
+
+AC_C_INLINE
+AC_CHECK_TYPES([fsblkcnt_t, fsfilcnt_t])
+AC_CHECK_TYPES([sigset_t],,,[#include <sys/types.h>
+#include <signal.h>])
+AC_CHECK_TYPES([request_sense],,,[#include <linux/cdrom.h>])
+
+AC_CHECK_TYPES([struct xinpgen],,,
+[#include <sys/types.h>
+#ifdef HAVE_SYS_SOCKET_H
+#include <sys/socket.h>
+#endif
+#ifdef HAVE_SYS_SOCKETVAR_H
+#include <sys/socketvar.h>
+#endif
+#ifdef HAVE_NET_ROUTE_H
+#include <net/route.h>
+#endif
+#ifdef HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#ifdef HAVE_NETINET_IN_SYSTM_H
+#include <netinet/in_systm.h>
+#endif
+#ifdef HAVE_NETINET_IP_H
+#include <netinet/ip.h>
+#endif
+#ifdef HAVE_NETINET_IN_PCB_H
+#include <netinet/in_pcb.h>
+#endif])
+
+AC_CHECK_TYPES([struct r_debug, struct link_map],,,
+[#ifdef HAVE_LINK_H
+#include <link.h>
+#endif
+#ifdef HAVE_SYS_LINK_H
+#include <sys/link.h>
+#endif])
+
+AC_CHECK_MEMBERS([struct ff_effect.direction],,,
+[#ifdef HAVE_LINUX_INPUT_H
+#include <linux/input.h>
+#endif])
+
+AC_CACHE_CHECK([for if_nameindex],wine_cv_have_if_nameindex,
+               AC_LINK_IFELSE([AC_LANG_PROGRAM([[#ifdef HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#ifdef HAVE_SYS_SOCKET_H
+#include <sys/socket.h>
+#endif
+#ifdef HAVE_NET_IF_H
+# include <net/if.h>
+#endif]],
+                              [[struct if_nameindex *p = if_nameindex(); return p->if_index;]])],[wine_cv_have_if_nameindex=yes],[wine_cv_have_if_nameindex=no]))
+if test "$wine_cv_have_if_nameindex" = "yes"
+then
+  AC_DEFINE(HAVE_IF_NAMEINDEX, 1, [Define to 1 if you have the `if_nameindex' function.])
+fi
+
+AC_CACHE_CHECK([for sigaddset],wine_cv_have_sigaddset,
+               AC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <signal.h>]], [[sigset_t set; sigaddset(&set,SIGTERM);]])],[wine_cv_have_sigaddset=yes],[wine_cv_have_sigaddset=no]))
+if test "$wine_cv_have_sigaddset" = "yes"
+then
+  AC_DEFINE(HAVE_SIGADDSET, 1, [Define if sigaddset is supported])
+fi
+
+
+AC_CACHE_CHECK([whether we can use re-entrant gethostbyname_r Linux style],
+   	wine_cv_linux_gethostbyname_r_6,
+	AC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <netdb.h>]],[[
+    char *name=0;
+    struct hostent he;
+    struct hostent *result;
+    char *buf=0;
+    int bufsize=0;
+    int errnr;
+    char *addr=0;
+    int addrlen=0;
+    int addrtype=0;
+    gethostbyname_r(name,&he,buf,bufsize,&result,&errnr);
+    gethostbyaddr_r(addr, addrlen, addrtype,&he,buf,bufsize,&result,&errnr);
+    ]])],[wine_cv_linux_gethostbyname_r_6=yes],[wine_cv_linux_gethostbyname_r_6=no
+	])
+   )
+   if test "$wine_cv_linux_gethostbyname_r_6" = "yes"
+   then
+      AC_DEFINE(HAVE_LINUX_GETHOSTBYNAME_R_6, 1,
+                [Define if Linux-style gethostbyname_r and gethostbyaddr_r are available])
+   fi
+
+if test "$ac_cv_header_linux_joystick_h" = "yes"
+then
+   AC_CACHE_CHECK([whether linux/joystick.h uses the Linux 2.2+ API],
+   	wine_cv_linux_joystick_22_api,
+	AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+	#include <sys/ioctl.h>
+	#include <sys/types.h>
+	#include <linux/joystick.h>
+
+	struct js_event blub;
+	#if !defined(JS_EVENT_AXIS) || !defined(JS_EVENT_BUTTON)
+	#error "no 2.2 header"
+	#endif
+	]], [[/*empty*/]])],[wine_cv_linux_joystick_22_api=yes],[wine_cv_linux_joystick_22_api=no])
+   )
+   if test "$wine_cv_linux_joystick_22_api" = "yes"
+   then
+      AC_DEFINE(HAVE_LINUX_22_JOYSTICK_API, 1,
+                [Define if <linux/joystick.h> defines the Linux 2.2 joystick API])
+   fi
+fi
+
+dnl **** FIXME: what about mixed cases, where we need two of them? ***
+
+dnl Check for statfs members
+AC_CHECK_MEMBERS([struct statfs.f_bfree, struct statfs.f_bavail, struct statfs.f_frsize, struct statfs.f_ffree, struct statfs.f_favail, struct statfs.f_namelen],,,
+[#include <sys/types.h>
+#ifdef HAVE_SYS_PARAM_H
+# include <sys/param.h>
+#endif
+#ifdef HAVE_SYS_MOUNT_H
+# include <sys/mount.h>
+#endif
+#ifdef HAVE_SYS_VFS_H
+# include <sys/vfs.h>
+#endif
+#ifdef HAVE_SYS_STATFS_H
+# include <sys/statfs.h>
+#endif])
+
+AC_CHECK_MEMBERS([struct statvfs.f_blocks],,,
+[#ifdef HAVE_SYS_STATVFS_H
+#include <sys/statvfs.h>
+#endif])
+
+dnl Check for dirent.d_reclen
+AC_CHECK_MEMBERS([struct dirent.d_reclen],,,
+[#ifdef HAVE_DIRENT_H
+#include <dirent.h>
+#endif])
+
+dnl Check for socket structure members
+AC_CHECK_MEMBERS([struct msghdr.msg_accrights, struct sockaddr.sa_len, struct sockaddr_un.sun_len],,,
+[#include <sys/types.h>
+#ifdef HAVE_SYS_SOCKET_H
+# include <sys/socket.h>
+#endif
+#ifdef HAVE_SYS_UN_H
+# include <sys/un.h>
+#endif])
+
+dnl Check for scsireq_t and sg_io_hdr_t members
+AC_CHECK_MEMBERS([scsireq_t.cmd, sg_io_hdr_t.interface_id],,,
+[#include <sys/types.h>
+#ifdef HAVE_SCSI_SG_H
+#include <scsi/sg.h>
+#endif])
+
+dnl Check for siginfo_t members
+AC_CHECK_MEMBERS([siginfo_t.si_fd],,,[#include <signal.h>])
+
+dnl Check for struct mtget members
+AC_CHECK_MEMBERS([struct mtget.mt_blksiz, struct mtget.mt_gstat, struct mtget.mt_blkno],,,
+[#include <sys/types.h>
+#ifdef HAVE_SYS_MTIO_H
+#include <sys/mtio.h>
+#endif])
+
+dnl Check for struct option
+AC_CHECK_MEMBERS([struct option.name],,,
+[#ifdef HAVE_GETOPT_H
+#include <getopt.h>
+#endif])
+
+dnl Check for stat.st_blocks and ns-resolved times
+AC_CHECK_MEMBERS([
+	struct stat.st_blocks,
+	struct stat.st_mtim,
+	struct stat.st_mtimespec,
+	struct stat.st_ctim,
+	struct stat.st_ctimespec,
+	struct stat.st_atim,
+	struct stat.st_atimespec,
+	struct stat.st_birthtime,
+	struct stat.st_birthtim,
+	struct stat.st_birthtimespec,
+	struct stat.__st_birthtime,
+	struct stat.__st_birthtim])
+
+dnl Check for sin6_scope_id
+AC_CHECK_MEMBERS([struct sockaddr_in6.sin6_scope_id],,,
+[#ifdef HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#ifdef HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif])
+
+dnl Check for struct __res_state
+AC_CHECK_TYPES([struct __res_state],,,
+[#ifdef HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#ifdef HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#ifdef HAVE_RESOLV_H
+#include <resolv.h>
+#endif])
+
+dnl Check for _u._ext.nscount6
+AC_CHECK_MEMBERS([struct __res_state._u._ext.nscount6],,,
+[#ifdef HAVE_RESOLV_H
+#include <resolv.h>
+#endif])
+
+dnl Check for ns_msg ptr member
+AC_CHECK_MEMBERS([ns_msg._msg_ptr],,,
+[#ifdef HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#ifdef HAVE_NETINET_IN_H
+# include <netinet/in.h>
+#endif
+#ifdef HAVE_ARPA_NAMESER_H
+# include <arpa/nameser.h>
+#endif])
+
+dnl Check for struct icmpstat
+AC_CHECK_MEMBERS([struct icmpstat.icps_inhist],,,
+[#ifdef HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#ifdef HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#ifdef HAVE_NETINET_IP_H
+#include <netinet/ip.h>
+#endif
+#ifdef HAVE_NETINET_IP_ICMP_H
+#include <netinet/ip_icmp.h>
+#endif
+#ifdef HAVE_NETINET_ICMP_VAR_H
+#include <netinet/icmp_var.h>
+#endif])
+
+dnl Check for struct icmpstat.icps_outhist
+AC_CHECK_MEMBERS([struct icmpstat.icps_outhist],,,
+[#ifdef HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#ifdef HAVE_ALIAS_H
+#include <alias.h>
+#endif
+#ifdef HAVE_SYS_SOCKET_H
+#include <sys/socket.h>
+#endif
+#ifdef HAVE_SYS_SOCKETVAR_H
+#include <sys/socketvar.h>
+#endif
+#ifdef HAVE_SYS_TIMEOUT_H
+#include <sys/timeout.h>
+#endif
+#ifdef HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#ifdef HAVE_NETINET_IN_SYSTM_H
+#include <netinet/in_systm.h>
+#endif
+#ifdef HAVE_NETINET_IP_H
+#include <netinet/ip.h>
+#endif
+#ifdef HAVE_NETINET_IP_VAR_H
+#include <netinet/ip_var.h>
+#endif
+#ifdef HAVE_NETINET_IP_ICMP_H
+#include <netinet/ip_icmp.h>
+#endif
+#ifdef HAVE_NETINET_ICMP_VAR_H
+#include <netinet/icmp_var.h>
+#endif])
+
+dnl Check for struct ipstat
+AC_CHECK_MEMBERS([struct ipstat.ips_total],,,
+[#ifdef HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#ifdef HAVE_SYS_SOCKETVAR_H
+#include <sys/socketvar.h>
+#endif
+#ifdef HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#ifdef HAVE_NETINET_IP_VAR_H
+#include <netinet/ip_var.h>
+#endif])
+
+dnl Check for struct ip_stats
+AC_CHECK_MEMBERS([struct ip_stats.ips_total],,,
+[#ifdef HAVE_NETINET_IP_VAR_H
+#include <netinet/ip_var.h>
+#endif])
+
+dnl Check for struct tcpstat
+AC_CHECK_MEMBERS([struct tcpstat.tcps_connattempt],,,
+[#ifdef HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#ifdef HAVE_SYS_SOCKETVAR_H
+#include <sys/socketvar.h>
+#endif
+#ifdef HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#ifdef HAVE_NETINET_TCP_H
+#include <netinet/tcp.h>
+#endif
+#ifdef HAVE_NETINET_TCP_VAR_H
+#include <netinet/tcp_var.h>
+#endif])
+
+dnl Check for struct tcp_stats
+AC_CHECK_MEMBERS([struct tcp_stats.tcps_connattempt],,,
+[#ifdef HAVE_NETINET_TCP_VAR_H
+#include <netinet/tcp_var.h>
+#endif])
+
+dnl Check for struct udpstat
+AC_CHECK_MEMBERS([struct udpstat.udps_ipackets],,,
+[#ifdef HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#ifdef HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#ifdef HAVE_NETINET_IP_VAR_H
+#include <netinet/ip_var.h>
+#endif
+#ifdef HAVE_NETINET_UDP_H
+#include <netinet/udp.h>
+#endif
+#ifdef HAVE_NETINET_UDP_VAR_H
+#include <netinet/udp_var.h>
+#endif])
+
+dnl Check for struct ifreq.ifr_hwaddr
+AC_CHECK_MEMBERS([struct ifreq.ifr_hwaddr],,,
+[#ifdef HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#ifdef HAVE_NET_IF_H
+# include <net/if.h>
+#endif])
+
+dnl Check for isfinite
+ac_save_LIBS="$LIBS"
+LIBS="$LIBS -lm"
+AC_CACHE_CHECK([for isfinite], ac_cv_have_isfinite,
+               AC_LINK_IFELSE([AC_LANG_PROGRAM([[#define _GNU_SOURCE
+#include <math.h>]], [[float f = 0.0; return isfinite(f)]])],[ac_cv_have_isfinite="yes"],[ac_cv_have_isfinite="no"]))
+if test "$ac_cv_have_isfinite" = "yes"
+then
+    AC_DEFINE(HAVE_ISFINITE, 1, [Define to 1 if you have the `isfinite' function.])
+fi
+
+dnl Check for isinf
+AC_CACHE_CHECK([for isinf], ac_cv_have_isinf,
+               AC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <math.h>]], [[float f = 0.0; return isinf(f)]])],[ac_cv_have_isinf="yes"],[ac_cv_have_isinf="no"]))
+if test "$ac_cv_have_isinf" = "yes"
+then
+    AC_DEFINE(HAVE_ISINF, 1, [Define to 1 if you have the `isinf' function.])
+fi
+
+dnl Check for isnan
+AC_CACHE_CHECK([for isnan], ac_cv_have_isnan,
+               AC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <math.h>]], [[float f = 0.0; return isnan(f)]])],[ac_cv_have_isnan="yes"],[ac_cv_have_isnan="no"]))
+if test "$ac_cv_have_isnan" = "yes"
+then
+    AC_DEFINE(HAVE_ISNAN, 1, [Define to 1 if you have the `isnan' function.])
+fi
+
+AC_CHECK_FUNCS(\
+	acosh \
+	acoshf \
+	asinh \
+	asinhf \
+	atanh \
+	atanhf \
+	cbrt \
+	cbrtf \
+	erf \
+	erfc \
+	erfcf \
+	erff \
+	exp2 \
+	exp2f \
+	expm1 \
+	expm1f \
+	fma \
+	fmaf \
+	ilogb \
+	ilogbf \
+	j0 \
+	j1 \
+	jn \
+	lgamma \
+	lgammaf \
+	llrint \
+	llrintf \
+	llround \
+	llroundf \
+	log1p \
+	log1pf \
+	log2 \
+	log2f \
+	lrint \
+	lrintf \
+	lround \
+	lroundf \
+	nearbyint \
+	nearbyintf \
+	nexttoward \
+	nexttowardf \
+	powl \
+	remainder \
+	remainderf \
+	remquo \
+	remquof \
+	rint \
+	rintf \
+	round \
+	roundf \
+	trunc \
+	truncf \
+	y0 \
+	y1 \
+	yn
+)
+LIBS="$ac_save_LIBS"
+
+dnl Check for __builtin_clz
+AC_CACHE_CHECK([for __builtin_clz], ac_cv_have___builtin_clz,
+               AC_LINK_IFELSE([AC_LANG_PROGRAM(,[[return __builtin_clz(1)]])],
+               [ac_cv_have___builtin_clz="yes"], [ac_cv_have___builtin_clz="no"]))
+if test "$ac_cv_have___builtin_clz" = "yes"
+then
+    AC_DEFINE(HAVE___BUILTIN_CLZ, 1, [Define to 1 if you have the `__builtin_clz' built-in function.])
+fi
+
+dnl Check for __builtin_ctzl
+AC_CACHE_CHECK([for __builtin_ctzl], ac_cv_have___builtin_ctzl,
+               AC_LINK_IFELSE([AC_LANG_PROGRAM(,[[return __builtin_ctzl(1)]])],
+               [ac_cv_have___builtin_ctzl="yes"], [ac_cv_have___builtin_ctzl="no"]))
+if test "$ac_cv_have___builtin_ctzl" = "yes"
+then
+    AC_DEFINE(HAVE___BUILTIN_CTZL, 1, [Define to 1 if you have the `__builtin_ctzl' built-in function.])
+fi
+
+dnl Check for __builtin_popcount
+AC_CACHE_CHECK([for __builtin_popcount], ac_cv_have___builtin_popcount,
+               AC_LINK_IFELSE([AC_LANG_PROGRAM(,[[return __builtin_popcount(1)]])],
+               [ac_cv_have___builtin_popcount="yes"], [ac_cv_have___builtin_popcount="no"]))
+if test "$ac_cv_have___builtin_popcount" = "yes"
+then
+    AC_DEFINE(HAVE___BUILTIN_POPCOUNT, 1, [Define to 1 if you have the `__builtin_popcount' built-in function.])
+fi
+
+AC_CACHE_CHECK([for __clear_cache], ac_cv_have___clear_cache,
+               AC_LINK_IFELSE([AC_LANG_PROGRAM(,[[__clear_cache((void*)0, (void*)0); return 0;]])],
+               [ac_cv_have___clear_cache="yes"], [ac_cv_have___clear_cache="no"]))
+if test "$ac_cv_have___clear_cache" = "yes"
+then
+    AC_DEFINE(HAVE___CLEAR_CACHE, 1, [Define to 1 if you have the `__clear_cache' (potentially built-in) function.])
+fi
+
+dnl *** check for the need to define platform-specific symbols
+
+case $host_cpu in
+  *i[[3456789]]86*) WINE_CHECK_DEFINE([__i386__]) ;;
+  *x86_64*)         WINE_CHECK_DEFINE([__x86_64__]) ;;
+  *sparc64*)        WINE_CHECK_DEFINE([__sparc64__]) ;;
+  *sparc*)          WINE_CHECK_DEFINE([__sparc__]) ;;
+  *powerpc64*)      WINE_CHECK_DEFINE([__powerpc64__]) ;;
+  *powerpc*)        WINE_CHECK_DEFINE([__powerpc__]) ;;
+  *aarch64*)        WINE_CHECK_DEFINE([__aarch64__]) ;;
+  *arm*)            WINE_CHECK_DEFINE([__arm__]) ;;
+esac
+
+case $host_vendor in
+  *sun*) WINE_CHECK_DEFINE([__sun__]) ;;
+esac
+
+dnl **** Generate output files ****
+
+AH_TOP([#ifndef __WINE_CONFIG_H
+#define __WINE_CONFIG_H
+#ifdef WINE_CROSS_PE
+#error config.h should not be used when cross-compiling
+#endif])
+AH_BOTTOM([#endif /* __WINE_CONFIG_H */])
+
+AC_CONFIG_COMMANDS([include/stamp-h], [echo timestamp > include/stamp-h])
+AS_ECHO_N("creating Makefile rules...") >&AS_MESSAGE_FD
+
+AC_SUBST([ALL_VARS_RULES],
+"m4_set_foreach([_AC_SUBST_VARS],[var],[m4_if(m4_bregexp(m4_defn([var]),[\(_CFLAGS\|_LIBS\)$]),-1,,[var = $var
+])])")
+
+dnl Main makefile
+
+WINE_APPEND_RULE([
+# Rules automatically generated by configure
+
+.INIT: Makefile
+.MAKEFILEDEPS:
+all: Makefile
+Makefile: $srcdir/Makefile.in config.status \$(MAKEDEP)
+	@./config.status Make.tmp Makefile
+depend: \$(MAKEDEP) dummy
+	\$(MAKEDEP)])
+
+WINE_CONFIG_SYMLINK(fonts,fonts,[marlett.ttf,symbol.ttf,tahoma.ttf,tahomabd.ttf,wingding.ttf],["x$enable_fonts" != xno])
+WINE_CONFIG_SYMLINK(loader,loader,[l_intl.nls])
+WINE_CONFIG_SYMLINK(,tools,[wine],,winewrapper)
+WINE_CONFIG_SYMLINK(,tools,[wine64],["x$enable_win64" != xno -o -n "$with_wine64"],winewrapper)
+
+WINE_CONFIG_MAKEFILE(dlls/acledit)
+WINE_CONFIG_MAKEFILE(dlls/aclui)
+WINE_CONFIG_MAKEFILE(dlls/activeds)
+WINE_CONFIG_MAKEFILE(dlls/actxprxy)
+WINE_CONFIG_MAKEFILE(dlls/adsiid)
+WINE_CONFIG_MAKEFILE(dlls/adsldp)
+WINE_CONFIG_MAKEFILE(dlls/adsldp/tests)
+WINE_CONFIG_MAKEFILE(dlls/adsldpc)
+WINE_CONFIG_MAKEFILE(dlls/advapi32)
+WINE_CONFIG_MAKEFILE(dlls/advapi32/tests)
+WINE_CONFIG_MAKEFILE(dlls/advpack)
+WINE_CONFIG_MAKEFILE(dlls/advpack/tests)
+WINE_CONFIG_MAKEFILE(dlls/amsi)
+WINE_CONFIG_MAKEFILE(dlls/amd_ags_x64)
+WINE_CONFIG_MAKEFILE(dlls/amstream)
+WINE_CONFIG_MAKEFILE(dlls/amstream/tests)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-appmodel-identity-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-appmodel-runtime-l1-1-1)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-appmodel-runtime-l1-1-2)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-apiquery-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-appcompat-l1-1-1)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-appinit-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-atoms-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-bem-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-com-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-com-l1-1-1)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-com-private-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-comm-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-console-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-console-l2-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-crt-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-crt-l2-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-datetime-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-datetime-l1-1-1)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-debug-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-debug-l1-1-1)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-delayload-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-delayload-l1-1-1)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-errorhandling-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-errorhandling-l1-1-1)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-errorhandling-l1-1-2)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-errorhandling-l1-1-3)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-fibers-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-fibers-l1-1-1)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-file-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-file-l1-2-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-file-l1-2-1)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-file-l1-2-2)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-file-l2-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-file-l2-1-1)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-file-l2-1-2)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-handle-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-heap-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-heap-l1-2-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-heap-l2-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-heap-obsolete-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-interlocked-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-interlocked-l1-2-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-io-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-io-l1-1-1)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-job-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-job-l2-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-kernel32-legacy-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-kernel32-legacy-l1-1-1)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-kernel32-private-l1-1-1)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-largeinteger-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-libraryloader-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-libraryloader-l1-1-1)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-libraryloader-l1-2-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-libraryloader-l1-2-1)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-libraryloader-l1-2-2)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-localization-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-localization-l1-2-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-localization-l1-2-1)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-localization-l2-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-localization-obsolete-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-localization-obsolete-l1-2-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-localization-obsolete-l1-3-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-localization-private-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-localregistry-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-memory-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-memory-l1-1-1)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-memory-l1-1-2)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-misc-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-namedpipe-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-namedpipe-l1-2-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-namespace-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-normalization-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-path-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-privateprofile-l1-1-1)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-processenvironment-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-processenvironment-l1-2-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-processthreads-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-processthreads-l1-1-1)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-processthreads-l1-1-2)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-processthreads-l1-1-3)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-processtopology-obsolete-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-profile-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-psapi-ansi-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-psapi-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-psapi-obsolete-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-quirks-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-realtime-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-registry-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-registry-l2-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-registryuserspecific-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-rtlsupport-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-rtlsupport-l1-2-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-shlwapi-legacy-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-shlwapi-obsolete-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-shlwapi-obsolete-l1-2-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-shutdown-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-sidebyside-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-string-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-string-l2-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-string-obsolete-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-stringansi-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-stringloader-l1-1-1)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-synch-ansi-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-synch-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-synch-l1-2-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-synch-l1-2-1)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-sysinfo-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-sysinfo-l1-2-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-sysinfo-l1-2-1)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-threadpool-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-threadpool-l1-2-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-threadpool-legacy-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-threadpool-private-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-timezone-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-toolhelp-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-url-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-util-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-version-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-version-l1-1-1)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-version-private-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-versionansi-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-windowserrorreporting-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-winrt-error-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-winrt-error-l1-1-1)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-winrt-errorprivate-l1-1-1)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-winrt-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-winrt-registration-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-winrt-roparameterizediid-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-winrt-string-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-winrt-string-l1-1-1)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-wow64-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-wow64-l1-1-1)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-xstate-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-core-xstate-l2-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-crt-conio-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-crt-convert-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-crt-environment-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-crt-filesystem-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-crt-heap-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-crt-locale-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-crt-math-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-crt-multibyte-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-crt-private-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-crt-process-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-crt-runtime-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-crt-stdio-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-crt-string-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-crt-time-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-crt-utility-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-devices-config-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-devices-config-l1-1-1)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-devices-query-l1-1-1)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-downlevel-advapi32-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-downlevel-advapi32-l2-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-downlevel-normaliz-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-downlevel-ole32-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-downlevel-shell32-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-downlevel-shlwapi-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-downlevel-shlwapi-l2-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-downlevel-user32-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-downlevel-version-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-dx-d3dkmt-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-eventing-classicprovider-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-eventing-consumer-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-eventing-controller-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-eventing-legacy-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-eventing-provider-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-eventlog-legacy-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-gdi-dpiinfo-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-mm-joystick-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-mm-misc-l1-1-1)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-mm-mme-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-mm-time-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-ntuser-dc-access-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-ntuser-rectangle-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-ntuser-sysparams-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-perf-legacy-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-power-base-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-power-setting-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-rtcore-ntuser-draw-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-rtcore-ntuser-private-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-rtcore-ntuser-private-l1-1-4)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-rtcore-ntuser-window-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-rtcore-ntuser-winevent-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-rtcore-ntuser-wmpointer-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-rtcore-ntuser-wmpointer-l1-1-3)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-security-activedirectoryclient-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-security-audit-l1-1-1)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-security-base-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-security-base-l1-2-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-security-base-private-l1-1-1)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-security-credentials-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-security-cryptoapi-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-security-grouppolicy-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-security-lsalookup-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-security-lsalookup-l1-1-1)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-security-lsalookup-l2-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-security-lsalookup-l2-1-1)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-security-lsapolicy-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-security-provider-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-security-sddl-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-security-systemfunctions-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-service-core-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-service-core-l1-1-1)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-service-management-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-service-management-l2-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-service-private-l1-1-1)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-service-winsvc-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-service-winsvc-l1-2-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-shcore-obsolete-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-shcore-scaling-l1-1-1)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-shcore-stream-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-shcore-thread-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-shell-shellcom-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/api-ms-win-shell-shellfolders-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/apphelp)
+WINE_CONFIG_MAKEFILE(dlls/apphelp/tests)
+WINE_CONFIG_MAKEFILE(dlls/appwiz.cpl)
+WINE_CONFIG_MAKEFILE(dlls/atl)
+WINE_CONFIG_MAKEFILE(dlls/atl/tests)
+WINE_CONFIG_MAKEFILE(dlls/atl100)
+WINE_CONFIG_MAKEFILE(dlls/atl100/tests)
+WINE_CONFIG_MAKEFILE(dlls/atl110)
+WINE_CONFIG_MAKEFILE(dlls/atl80)
+WINE_CONFIG_MAKEFILE(dlls/atl80/tests)
+WINE_CONFIG_MAKEFILE(dlls/atl90)
+WINE_CONFIG_MAKEFILE(dlls/atlthunk)
+WINE_CONFIG_MAKEFILE(dlls/atlthunk/tests)
+WINE_CONFIG_MAKEFILE(dlls/atmlib)
+WINE_CONFIG_MAKEFILE(dlls/authz)
+WINE_CONFIG_MAKEFILE(dlls/avicap32)
+WINE_CONFIG_MAKEFILE(dlls/avifil32)
+WINE_CONFIG_MAKEFILE(dlls/avifil32/tests)
+WINE_CONFIG_MAKEFILE(dlls/avifile.dll16,enable_win16)
+WINE_CONFIG_MAKEFILE(dlls/avrt)
+WINE_CONFIG_MAKEFILE(dlls/bcrypt)
+WINE_CONFIG_MAKEFILE(dlls/bcrypt/tests)
+WINE_CONFIG_MAKEFILE(dlls/bluetoothapis)
+WINE_CONFIG_MAKEFILE(dlls/browseui)
+WINE_CONFIG_MAKEFILE(dlls/browseui/tests)
+WINE_CONFIG_MAKEFILE(dlls/bthprops.cpl)
+WINE_CONFIG_MAKEFILE(dlls/cabinet)
+WINE_CONFIG_MAKEFILE(dlls/cabinet/tests)
+WINE_CONFIG_MAKEFILE(dlls/capi2032)
+WINE_CONFIG_MAKEFILE(dlls/cards)
+WINE_CONFIG_MAKEFILE(dlls/cdosys)
+WINE_CONFIG_MAKEFILE(dlls/cfgmgr32)
+WINE_CONFIG_MAKEFILE(dlls/clusapi)
+WINE_CONFIG_MAKEFILE(dlls/combase)
+WINE_CONFIG_MAKEFILE(dlls/combase/tests)
+WINE_CONFIG_MAKEFILE(dlls/comcat)
+WINE_CONFIG_MAKEFILE(dlls/comcat/tests)
+WINE_CONFIG_MAKEFILE(dlls/comctl32)
+WINE_CONFIG_MAKEFILE(dlls/comctl32/tests)
+WINE_CONFIG_MAKEFILE(dlls/comdlg32)
+WINE_CONFIG_MAKEFILE(dlls/comdlg32/tests)
+WINE_CONFIG_MAKEFILE(dlls/comm.drv16,enable_win16)
+WINE_CONFIG_MAKEFILE(dlls/commdlg.dll16,enable_win16)
+WINE_CONFIG_MAKEFILE(dlls/compobj.dll16,enable_win16)
+WINE_CONFIG_MAKEFILE(dlls/compstui)
+WINE_CONFIG_MAKEFILE(dlls/comsvcs)
+WINE_CONFIG_MAKEFILE(dlls/comsvcs/tests)
+WINE_CONFIG_MAKEFILE(dlls/concrt140)
+WINE_CONFIG_MAKEFILE(dlls/connect)
+WINE_CONFIG_MAKEFILE(dlls/credui)
+WINE_CONFIG_MAKEFILE(dlls/credui/tests)
+WINE_CONFIG_MAKEFILE(dlls/crtdll)
+WINE_CONFIG_MAKEFILE(dlls/crypt32)
+WINE_CONFIG_MAKEFILE(dlls/crypt32/tests)
+WINE_CONFIG_MAKEFILE(dlls/cryptdlg)
+WINE_CONFIG_MAKEFILE(dlls/cryptdll)
+WINE_CONFIG_MAKEFILE(dlls/cryptext)
+WINE_CONFIG_MAKEFILE(dlls/cryptnet)
+WINE_CONFIG_MAKEFILE(dlls/cryptnet/tests)
+WINE_CONFIG_MAKEFILE(dlls/cryptui)
+WINE_CONFIG_MAKEFILE(dlls/cryptui/tests)
+WINE_CONFIG_MAKEFILE(dlls/ctapi32)
+WINE_CONFIG_MAKEFILE(dlls/ctl3d.dll16,enable_win16)
+WINE_CONFIG_MAKEFILE(dlls/ctl3d32)
+WINE_CONFIG_MAKEFILE(dlls/ctl3dv2.dll16,enable_win16)
+WINE_CONFIG_MAKEFILE(dlls/d2d1)
+WINE_CONFIG_MAKEFILE(dlls/d2d1/tests)
+WINE_CONFIG_MAKEFILE(dlls/d3d10)
+WINE_CONFIG_MAKEFILE(dlls/d3d10/tests)
+WINE_CONFIG_MAKEFILE(dlls/d3d10_1)
+WINE_CONFIG_MAKEFILE(dlls/d3d10_1/tests)
+WINE_CONFIG_MAKEFILE(dlls/d3d10core)
+WINE_CONFIG_MAKEFILE(dlls/d3d10core/tests)
+WINE_CONFIG_MAKEFILE(dlls/d3d11)
+WINE_CONFIG_MAKEFILE(dlls/d3d11/tests)
+WINE_CONFIG_MAKEFILE(dlls/d3d12)
+WINE_CONFIG_MAKEFILE(dlls/d3d12/tests)
+WINE_CONFIG_MAKEFILE(dlls/d3d8)
+WINE_CONFIG_MAKEFILE(dlls/d3d8/tests)
+WINE_CONFIG_MAKEFILE(dlls/d3d9)
+WINE_CONFIG_MAKEFILE(dlls/d3d9/tests)
+WINE_CONFIG_MAKEFILE(dlls/d3dcompiler_33)
+WINE_CONFIG_MAKEFILE(dlls/d3dcompiler_34)
+WINE_CONFIG_MAKEFILE(dlls/d3dcompiler_35)
+WINE_CONFIG_MAKEFILE(dlls/d3dcompiler_36)
+WINE_CONFIG_MAKEFILE(dlls/d3dcompiler_37)
+WINE_CONFIG_MAKEFILE(dlls/d3dcompiler_38)
+WINE_CONFIG_MAKEFILE(dlls/d3dcompiler_39)
+WINE_CONFIG_MAKEFILE(dlls/d3dcompiler_40)
+WINE_CONFIG_MAKEFILE(dlls/d3dcompiler_41)
+WINE_CONFIG_MAKEFILE(dlls/d3dcompiler_42)
+WINE_CONFIG_MAKEFILE(dlls/d3dcompiler_43)
+WINE_CONFIG_MAKEFILE(dlls/d3dcompiler_43/tests)
+WINE_CONFIG_MAKEFILE(dlls/d3dcompiler_46)
+WINE_CONFIG_MAKEFILE(dlls/d3dcompiler_47)
+WINE_CONFIG_MAKEFILE(dlls/d3dim)
+WINE_CONFIG_MAKEFILE(dlls/d3drm)
+WINE_CONFIG_MAKEFILE(dlls/d3drm/tests)
+WINE_CONFIG_MAKEFILE(dlls/d3dx10_33)
+WINE_CONFIG_MAKEFILE(dlls/d3dx10_34)
+WINE_CONFIG_MAKEFILE(dlls/d3dx10_35)
+WINE_CONFIG_MAKEFILE(dlls/d3dx10_36)
+WINE_CONFIG_MAKEFILE(dlls/d3dx10_37)
+WINE_CONFIG_MAKEFILE(dlls/d3dx10_38)
+WINE_CONFIG_MAKEFILE(dlls/d3dx10_39)
+WINE_CONFIG_MAKEFILE(dlls/d3dx10_40)
+WINE_CONFIG_MAKEFILE(dlls/d3dx10_41)
+WINE_CONFIG_MAKEFILE(dlls/d3dx10_42)
+WINE_CONFIG_MAKEFILE(dlls/d3dx10_43)
+WINE_CONFIG_MAKEFILE(dlls/d3dx10_43/tests)
+WINE_CONFIG_MAKEFILE(dlls/d3dx11_42)
+WINE_CONFIG_MAKEFILE(dlls/d3dx11_43)
+WINE_CONFIG_MAKEFILE(dlls/d3dx11_43/tests)
+WINE_CONFIG_MAKEFILE(dlls/d3dx9_24)
+WINE_CONFIG_MAKEFILE(dlls/d3dx9_25)
+WINE_CONFIG_MAKEFILE(dlls/d3dx9_26)
+WINE_CONFIG_MAKEFILE(dlls/d3dx9_27)
+WINE_CONFIG_MAKEFILE(dlls/d3dx9_28)
+WINE_CONFIG_MAKEFILE(dlls/d3dx9_29)
+WINE_CONFIG_MAKEFILE(dlls/d3dx9_30)
+WINE_CONFIG_MAKEFILE(dlls/d3dx9_31)
+WINE_CONFIG_MAKEFILE(dlls/d3dx9_32)
+WINE_CONFIG_MAKEFILE(dlls/d3dx9_33)
+WINE_CONFIG_MAKEFILE(dlls/d3dx9_34)
+WINE_CONFIG_MAKEFILE(dlls/d3dx9_35)
+WINE_CONFIG_MAKEFILE(dlls/d3dx9_36)
+WINE_CONFIG_MAKEFILE(dlls/d3dx9_36/tests)
+WINE_CONFIG_MAKEFILE(dlls/d3dx9_37)
+WINE_CONFIG_MAKEFILE(dlls/d3dx9_38)
+WINE_CONFIG_MAKEFILE(dlls/d3dx9_39)
+WINE_CONFIG_MAKEFILE(dlls/d3dx9_40)
+WINE_CONFIG_MAKEFILE(dlls/d3dx9_41)
+WINE_CONFIG_MAKEFILE(dlls/d3dx9_42)
+WINE_CONFIG_MAKEFILE(dlls/d3dx9_43)
+WINE_CONFIG_MAKEFILE(dlls/d3dxof)
+WINE_CONFIG_MAKEFILE(dlls/d3dxof/tests)
+WINE_CONFIG_MAKEFILE(dlls/davclnt)
+WINE_CONFIG_MAKEFILE(dlls/dbgeng)
+WINE_CONFIG_MAKEFILE(dlls/dbgeng/tests)
+WINE_CONFIG_MAKEFILE(dlls/dbghelp)
+WINE_CONFIG_MAKEFILE(dlls/dbghelp/tests)
+WINE_CONFIG_MAKEFILE(dlls/dciman32)
+WINE_CONFIG_MAKEFILE(dlls/ddeml.dll16,enable_win16)
+WINE_CONFIG_MAKEFILE(dlls/ddraw)
+WINE_CONFIG_MAKEFILE(dlls/ddraw/tests)
+WINE_CONFIG_MAKEFILE(dlls/ddrawex)
+WINE_CONFIG_MAKEFILE(dlls/ddrawex/tests)
+WINE_CONFIG_MAKEFILE(dlls/devenum)
+WINE_CONFIG_MAKEFILE(dlls/devenum/tests)
+WINE_CONFIG_MAKEFILE(dlls/dhcpcsvc)
+WINE_CONFIG_MAKEFILE(dlls/dhtmled.ocx)
+WINE_CONFIG_MAKEFILE(dlls/difxapi)
+WINE_CONFIG_MAKEFILE(dlls/dinput)
+WINE_CONFIG_MAKEFILE(dlls/dinput/tests)
+WINE_CONFIG_MAKEFILE(dlls/dinput8)
+WINE_CONFIG_MAKEFILE(dlls/dinput8/tests)
+WINE_CONFIG_MAKEFILE(dlls/dispdib.dll16,enable_win16)
+WINE_CONFIG_MAKEFILE(dlls/dispex)
+WINE_CONFIG_MAKEFILE(dlls/dispex/tests)
+WINE_CONFIG_MAKEFILE(dlls/display.drv16,enable_win16)
+WINE_CONFIG_MAKEFILE(dlls/dmband)
+WINE_CONFIG_MAKEFILE(dlls/dmband/tests)
+WINE_CONFIG_MAKEFILE(dlls/dmcompos)
+WINE_CONFIG_MAKEFILE(dlls/dmcompos/tests)
+WINE_CONFIG_MAKEFILE(dlls/dmime)
+WINE_CONFIG_MAKEFILE(dlls/dmime/tests)
+WINE_CONFIG_MAKEFILE(dlls/dmloader)
+WINE_CONFIG_MAKEFILE(dlls/dmloader/tests)
+WINE_CONFIG_MAKEFILE(dlls/dmoguids)
+WINE_CONFIG_MAKEFILE(dlls/dmscript)
+WINE_CONFIG_MAKEFILE(dlls/dmscript/tests)
+WINE_CONFIG_MAKEFILE(dlls/dmstyle)
+WINE_CONFIG_MAKEFILE(dlls/dmstyle/tests)
+WINE_CONFIG_MAKEFILE(dlls/dmsynth)
+WINE_CONFIG_MAKEFILE(dlls/dmsynth/tests)
+WINE_CONFIG_MAKEFILE(dlls/dmusic)
+WINE_CONFIG_MAKEFILE(dlls/dmusic/tests)
+WINE_CONFIG_MAKEFILE(dlls/dmusic32)
+WINE_CONFIG_MAKEFILE(dlls/dnsapi)
+WINE_CONFIG_MAKEFILE(dlls/dnsapi/tests)
+WINE_CONFIG_MAKEFILE(dlls/dplay)
+WINE_CONFIG_MAKEFILE(dlls/dplayx)
+WINE_CONFIG_MAKEFILE(dlls/dplayx/tests)
+WINE_CONFIG_MAKEFILE(dlls/dpnaddr)
+WINE_CONFIG_MAKEFILE(dlls/dpnet)
+WINE_CONFIG_MAKEFILE(dlls/dpnet/tests)
+WINE_CONFIG_MAKEFILE(dlls/dpnhpast)
+WINE_CONFIG_MAKEFILE(dlls/dpnlobby)
+WINE_CONFIG_MAKEFILE(dlls/dpvoice)
+WINE_CONFIG_MAKEFILE(dlls/dpvoice/tests)
+WINE_CONFIG_MAKEFILE(dlls/dpwsockx)
+WINE_CONFIG_MAKEFILE(dlls/drmclien)
+WINE_CONFIG_MAKEFILE(dlls/dsound)
+WINE_CONFIG_MAKEFILE(dlls/dsound/tests)
+WINE_CONFIG_MAKEFILE(dlls/dsquery)
+WINE_CONFIG_MAKEFILE(dlls/dssenh)
+WINE_CONFIG_MAKEFILE(dlls/dssenh/tests)
+WINE_CONFIG_MAKEFILE(dlls/dswave)
+WINE_CONFIG_MAKEFILE(dlls/dswave/tests)
+WINE_CONFIG_MAKEFILE(dlls/dwmapi)
+WINE_CONFIG_MAKEFILE(dlls/dwrite)
+WINE_CONFIG_MAKEFILE(dlls/dwrite/tests)
+WINE_CONFIG_MAKEFILE(dlls/dx8vb)
+WINE_CONFIG_MAKEFILE(dlls/dxdiagn)
+WINE_CONFIG_MAKEFILE(dlls/dxdiagn/tests)
+WINE_CONFIG_MAKEFILE(dlls/dxerr8)
+WINE_CONFIG_MAKEFILE(dlls/dxerr9)
+WINE_CONFIG_MAKEFILE(dlls/dxgi)
+WINE_CONFIG_MAKEFILE(dlls/dxgi/tests)
+WINE_CONFIG_MAKEFILE(dlls/dxguid)
+WINE_CONFIG_MAKEFILE(dlls/dxva2)
+WINE_CONFIG_MAKEFILE(dlls/esent)
+WINE_CONFIG_MAKEFILE(dlls/evr)
+WINE_CONFIG_MAKEFILE(dlls/evr/tests)
+WINE_CONFIG_MAKEFILE(dlls/explorerframe)
+WINE_CONFIG_MAKEFILE(dlls/explorerframe/tests)
+WINE_CONFIG_MAKEFILE(dlls/ext-ms-win-authz-context-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/ext-ms-win-domainjoin-netjoin-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/ext-ms-win-dwmapi-ext-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/ext-ms-win-gdi-dc-create-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/ext-ms-win-gdi-dc-create-l1-1-1)
+WINE_CONFIG_MAKEFILE(dlls/ext-ms-win-gdi-dc-l1-2-0)
+WINE_CONFIG_MAKEFILE(dlls/ext-ms-win-gdi-devcaps-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/ext-ms-win-gdi-draw-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/ext-ms-win-gdi-draw-l1-1-1)
+WINE_CONFIG_MAKEFILE(dlls/ext-ms-win-gdi-font-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/ext-ms-win-gdi-font-l1-1-1)
+WINE_CONFIG_MAKEFILE(dlls/ext-ms-win-gdi-render-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/ext-ms-win-kernel32-package-current-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/ext-ms-win-kernel32-package-l1-1-1)
+WINE_CONFIG_MAKEFILE(dlls/ext-ms-win-ntuser-dialogbox-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/ext-ms-win-ntuser-draw-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/ext-ms-win-ntuser-gui-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/ext-ms-win-ntuser-gui-l1-3-0)
+WINE_CONFIG_MAKEFILE(dlls/ext-ms-win-ntuser-keyboard-l1-3-0)
+WINE_CONFIG_MAKEFILE(dlls/ext-ms-win-ntuser-message-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/ext-ms-win-ntuser-message-l1-1-1)
+WINE_CONFIG_MAKEFILE(dlls/ext-ms-win-ntuser-misc-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/ext-ms-win-ntuser-misc-l1-2-0)
+WINE_CONFIG_MAKEFILE(dlls/ext-ms-win-ntuser-misc-l1-5-1)
+WINE_CONFIG_MAKEFILE(dlls/ext-ms-win-ntuser-mouse-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/ext-ms-win-ntuser-private-l1-1-1)
+WINE_CONFIG_MAKEFILE(dlls/ext-ms-win-ntuser-private-l1-3-1)
+WINE_CONFIG_MAKEFILE(dlls/ext-ms-win-ntuser-rectangle-ext-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/ext-ms-win-ntuser-uicontext-ext-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/ext-ms-win-ntuser-window-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/ext-ms-win-ntuser-window-l1-1-1)
+WINE_CONFIG_MAKEFILE(dlls/ext-ms-win-ntuser-window-l1-1-4)
+WINE_CONFIG_MAKEFILE(dlls/ext-ms-win-ntuser-windowclass-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/ext-ms-win-ntuser-windowclass-l1-1-1)
+WINE_CONFIG_MAKEFILE(dlls/ext-ms-win-oleacc-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/ext-ms-win-ras-rasapi32-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/ext-ms-win-rtcore-gdi-devcaps-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/ext-ms-win-rtcore-gdi-object-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/ext-ms-win-rtcore-gdi-rgn-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/ext-ms-win-rtcore-ntuser-cursor-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/ext-ms-win-rtcore-ntuser-dc-access-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/ext-ms-win-rtcore-ntuser-dpi-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/ext-ms-win-rtcore-ntuser-dpi-l1-2-0)
+WINE_CONFIG_MAKEFILE(dlls/ext-ms-win-rtcore-ntuser-rawinput-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/ext-ms-win-rtcore-ntuser-syscolors-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/ext-ms-win-rtcore-ntuser-sysparams-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/ext-ms-win-security-credui-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/ext-ms-win-security-cryptui-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/ext-ms-win-shell-comctl32-init-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/ext-ms-win-shell-comdlg32-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/ext-ms-win-shell-shell32-l1-2-0)
+WINE_CONFIG_MAKEFILE(dlls/ext-ms-win-uxtheme-themes-l1-1-0)
+WINE_CONFIG_MAKEFILE(dlls/faultrep)
+WINE_CONFIG_MAKEFILE(dlls/faultrep/tests)
+WINE_CONFIG_MAKEFILE(dlls/feclient)
+WINE_CONFIG_MAKEFILE(dlls/fltlib)
+WINE_CONFIG_MAKEFILE(dlls/fltmgr.sys)
+WINE_CONFIG_MAKEFILE(dlls/fntcache)
+WINE_CONFIG_MAKEFILE(dlls/fontsub)
+WINE_CONFIG_MAKEFILE(dlls/fusion)
+WINE_CONFIG_MAKEFILE(dlls/fusion/tests)
+WINE_CONFIG_MAKEFILE(dlls/fwpuclnt)
+WINE_CONFIG_MAKEFILE(dlls/gameux)
+WINE_CONFIG_MAKEFILE(dlls/gameux/tests)
+WINE_CONFIG_MAKEFILE(dlls/gdi.exe16,enable_win16)
+WINE_CONFIG_MAKEFILE(dlls/gdi32)
+WINE_CONFIG_MAKEFILE(dlls/gdi32/tests)
+WINE_CONFIG_MAKEFILE(dlls/gdiplus)
+WINE_CONFIG_MAKEFILE(dlls/gdiplus/tests)
+WINE_CONFIG_MAKEFILE(dlls/glu32)
+WINE_CONFIG_MAKEFILE(dlls/gphoto2.ds)
+WINE_CONFIG_MAKEFILE(dlls/gpkcsp)
+WINE_CONFIG_MAKEFILE(dlls/hal)
+WINE_CONFIG_MAKEFILE(dlls/hhctrl.ocx)
+WINE_CONFIG_MAKEFILE(dlls/hid)
+WINE_CONFIG_MAKEFILE(dlls/hid/tests)
+WINE_CONFIG_MAKEFILE(dlls/hidclass.sys)
+WINE_CONFIG_MAKEFILE(dlls/hlink)
+WINE_CONFIG_MAKEFILE(dlls/hlink/tests)
+WINE_CONFIG_MAKEFILE(dlls/hnetcfg)
+WINE_CONFIG_MAKEFILE(dlls/hnetcfg/tests)
+WINE_CONFIG_MAKEFILE(dlls/httpapi)
+WINE_CONFIG_MAKEFILE(dlls/httpapi/tests)
+WINE_CONFIG_MAKEFILE(dlls/iccvid)
+WINE_CONFIG_MAKEFILE(dlls/icmp)
+WINE_CONFIG_MAKEFILE(dlls/ieframe)
+WINE_CONFIG_MAKEFILE(dlls/ieframe/tests)
+WINE_CONFIG_MAKEFILE(dlls/ieproxy)
+WINE_CONFIG_MAKEFILE(dlls/ifsmgr.vxd,enable_win16)
+WINE_CONFIG_MAKEFILE(dlls/imaadp32.acm)
+WINE_CONFIG_MAKEFILE(dlls/imagehlp)
+WINE_CONFIG_MAKEFILE(dlls/imagehlp/tests)
+WINE_CONFIG_MAKEFILE(dlls/imm.dll16,enable_win16)
+WINE_CONFIG_MAKEFILE(dlls/imm32)
+WINE_CONFIG_MAKEFILE(dlls/imm32/tests)
+WINE_CONFIG_MAKEFILE(dlls/inetcomm)
+WINE_CONFIG_MAKEFILE(dlls/inetcomm/tests)
+WINE_CONFIG_MAKEFILE(dlls/inetcpl.cpl)
+WINE_CONFIG_MAKEFILE(dlls/inetmib1)
+WINE_CONFIG_MAKEFILE(dlls/inetmib1/tests)
+WINE_CONFIG_MAKEFILE(dlls/infosoft)
+WINE_CONFIG_MAKEFILE(dlls/infosoft/tests)
+WINE_CONFIG_MAKEFILE(dlls/initpki)
+WINE_CONFIG_MAKEFILE(dlls/inkobj)
+WINE_CONFIG_MAKEFILE(dlls/inseng)
+WINE_CONFIG_MAKEFILE(dlls/iphlpapi)
+WINE_CONFIG_MAKEFILE(dlls/iphlpapi/tests)
+WINE_CONFIG_MAKEFILE(dlls/iprop)
+WINE_CONFIG_MAKEFILE(dlls/irprops.cpl)
+WINE_CONFIG_MAKEFILE(dlls/itircl)
+WINE_CONFIG_MAKEFILE(dlls/itss)
+WINE_CONFIG_MAKEFILE(dlls/itss/tests)
+WINE_CONFIG_MAKEFILE(dlls/joy.cpl)
+WINE_CONFIG_MAKEFILE(dlls/jscript)
+WINE_CONFIG_MAKEFILE(dlls/jscript/tests)
+WINE_CONFIG_MAKEFILE(dlls/jsproxy)
+WINE_CONFIG_MAKEFILE(dlls/jsproxy/tests)
+WINE_CONFIG_MAKEFILE(dlls/kerberos)
+WINE_CONFIG_MAKEFILE(dlls/kernel32)
+WINE_CONFIG_MAKEFILE(dlls/kernel32/tests)
+WINE_CONFIG_MAKEFILE(dlls/kernelbase)
+WINE_CONFIG_MAKEFILE(dlls/kernelbase/tests)
+WINE_CONFIG_MAKEFILE(dlls/keyboard.drv16,enable_win16)
+WINE_CONFIG_MAKEFILE(dlls/krnl386.exe16,enable_win16)
+WINE_CONFIG_MAKEFILE(dlls/ksecdd.sys)
+WINE_CONFIG_MAKEFILE(dlls/ksuser)
+WINE_CONFIG_MAKEFILE(dlls/ktmw32)
+WINE_CONFIG_MAKEFILE(dlls/l3codeca.acm)
+WINE_CONFIG_MAKEFILE(dlls/loadperf)
+WINE_CONFIG_MAKEFILE(dlls/localspl)
+WINE_CONFIG_MAKEFILE(dlls/localspl/tests)
+WINE_CONFIG_MAKEFILE(dlls/localui)
+WINE_CONFIG_MAKEFILE(dlls/localui/tests)
+WINE_CONFIG_MAKEFILE(dlls/lz32)
+WINE_CONFIG_MAKEFILE(dlls/lz32/tests)
+WINE_CONFIG_MAKEFILE(dlls/lzexpand.dll16,enable_win16)
+WINE_CONFIG_MAKEFILE(dlls/mapi32)
+WINE_CONFIG_MAKEFILE(dlls/mapi32/tests)
+WINE_CONFIG_MAKEFILE(dlls/mapistub)
+WINE_CONFIG_MAKEFILE(dlls/mciavi32)
+WINE_CONFIG_MAKEFILE(dlls/mcicda)
+WINE_CONFIG_MAKEFILE(dlls/mciqtz32)
+WINE_CONFIG_MAKEFILE(dlls/mciseq)
+WINE_CONFIG_MAKEFILE(dlls/mciwave)
+WINE_CONFIG_MAKEFILE(dlls/mf)
+WINE_CONFIG_MAKEFILE(dlls/mf/tests)
+WINE_CONFIG_MAKEFILE(dlls/mf3216)
+WINE_CONFIG_MAKEFILE(dlls/mferror)
+WINE_CONFIG_MAKEFILE(dlls/mfplat)
+WINE_CONFIG_MAKEFILE(dlls/mfplat/tests)
+WINE_CONFIG_MAKEFILE(dlls/mfplay)
+WINE_CONFIG_MAKEFILE(dlls/mfreadwrite)
+WINE_CONFIG_MAKEFILE(dlls/mfreadwrite/tests)
+WINE_CONFIG_MAKEFILE(dlls/mfuuid)
+WINE_CONFIG_MAKEFILE(dlls/mgmtapi)
+WINE_CONFIG_MAKEFILE(dlls/midimap)
+WINE_CONFIG_MAKEFILE(dlls/mlang)
+WINE_CONFIG_MAKEFILE(dlls/mlang/tests)
+WINE_CONFIG_MAKEFILE(dlls/mmcndmgr)
+WINE_CONFIG_MAKEFILE(dlls/mmcndmgr/tests)
+WINE_CONFIG_MAKEFILE(dlls/mmdevapi)
+WINE_CONFIG_MAKEFILE(dlls/mmdevapi/tests)
+WINE_CONFIG_MAKEFILE(dlls/mmdevldr.vxd,enable_win16)
+WINE_CONFIG_MAKEFILE(dlls/mmsystem.dll16,enable_win16)
+WINE_CONFIG_MAKEFILE(dlls/monodebg.vxd,enable_win16)
+WINE_CONFIG_MAKEFILE(dlls/mountmgr.sys)
+WINE_CONFIG_MAKEFILE(dlls/mouse.drv16,enable_win16)
+WINE_CONFIG_MAKEFILE(dlls/mp3dmod)
+WINE_CONFIG_MAKEFILE(dlls/mp3dmod/tests)
+WINE_CONFIG_MAKEFILE(dlls/mpr)
+WINE_CONFIG_MAKEFILE(dlls/mpr/tests)
+WINE_CONFIG_MAKEFILE(dlls/mprapi)
+WINE_CONFIG_MAKEFILE(dlls/msacm.dll16,enable_win16)
+WINE_CONFIG_MAKEFILE(dlls/msacm32.drv)
+WINE_CONFIG_MAKEFILE(dlls/msacm32)
+WINE_CONFIG_MAKEFILE(dlls/msacm32/tests)
+WINE_CONFIG_MAKEFILE(dlls/msadp32.acm)
+WINE_CONFIG_MAKEFILE(dlls/msasn1)
+WINE_CONFIG_MAKEFILE(dlls/mscat32)
+WINE_CONFIG_MAKEFILE(dlls/mscms)
+WINE_CONFIG_MAKEFILE(dlls/mscms/tests)
+WINE_CONFIG_MAKEFILE(dlls/mscoree)
+WINE_CONFIG_MAKEFILE(dlls/mscoree/tests)
+WINE_CONFIG_MAKEFILE(dlls/mscorwks)
+WINE_CONFIG_MAKEFILE(dlls/msctf)
+WINE_CONFIG_MAKEFILE(dlls/msctf/tests)
+WINE_CONFIG_MAKEFILE(dlls/msctfp)
+WINE_CONFIG_MAKEFILE(dlls/msdaps)
+WINE_CONFIG_MAKEFILE(dlls/msdelta)
+WINE_CONFIG_MAKEFILE(dlls/msdmo)
+WINE_CONFIG_MAKEFILE(dlls/msdmo/tests)
+WINE_CONFIG_MAKEFILE(dlls/msdrm)
+WINE_CONFIG_MAKEFILE(dlls/msftedit)
+WINE_CONFIG_MAKEFILE(dlls/msftedit/tests)
+WINE_CONFIG_MAKEFILE(dlls/msg711.acm)
+WINE_CONFIG_MAKEFILE(dlls/msgsm32.acm)
+WINE_CONFIG_MAKEFILE(dlls/mshtml.tlb)
+WINE_CONFIG_MAKEFILE(dlls/mshtml)
+WINE_CONFIG_MAKEFILE(dlls/mshtml/tests)
+WINE_CONFIG_MAKEFILE(dlls/msi)
+WINE_CONFIG_MAKEFILE(dlls/msi/tests)
+WINE_CONFIG_MAKEFILE(dlls/msident)
+WINE_CONFIG_MAKEFILE(dlls/msimg32)
+WINE_CONFIG_MAKEFILE(dlls/msimsg)
+WINE_CONFIG_MAKEFILE(dlls/msimtf)
+WINE_CONFIG_MAKEFILE(dlls/msisip)
+WINE_CONFIG_MAKEFILE(dlls/msisys.ocx)
+WINE_CONFIG_MAKEFILE(dlls/msls31)
+WINE_CONFIG_MAKEFILE(dlls/msnet32)
+WINE_CONFIG_MAKEFILE(dlls/mspatcha)
+WINE_CONFIG_MAKEFILE(dlls/mspatcha/tests)
+WINE_CONFIG_MAKEFILE(dlls/msports)
+WINE_CONFIG_MAKEFILE(dlls/msrle32)
+WINE_CONFIG_MAKEFILE(dlls/msrle32/tests)
+WINE_CONFIG_MAKEFILE(dlls/msscript.ocx)
+WINE_CONFIG_MAKEFILE(dlls/msscript.ocx/tests)
+WINE_CONFIG_MAKEFILE(dlls/mssign32)
+WINE_CONFIG_MAKEFILE(dlls/mssip32)
+WINE_CONFIG_MAKEFILE(dlls/mstask)
+WINE_CONFIG_MAKEFILE(dlls/mstask/tests)
+WINE_CONFIG_MAKEFILE(dlls/msvcirt)
+WINE_CONFIG_MAKEFILE(dlls/msvcirt/tests)
+WINE_CONFIG_MAKEFILE(dlls/msvcm80)
+WINE_CONFIG_MAKEFILE(dlls/msvcm90)
+WINE_CONFIG_MAKEFILE(dlls/msvcp100)
+WINE_CONFIG_MAKEFILE(dlls/msvcp100/tests)
+WINE_CONFIG_MAKEFILE(dlls/msvcp110)
+WINE_CONFIG_MAKEFILE(dlls/msvcp110/tests)
+WINE_CONFIG_MAKEFILE(dlls/msvcp120)
+WINE_CONFIG_MAKEFILE(dlls/msvcp120/tests)
+WINE_CONFIG_MAKEFILE(dlls/msvcp120_app)
+WINE_CONFIG_MAKEFILE(dlls/msvcp140)
+WINE_CONFIG_MAKEFILE(dlls/msvcp140/tests)
+WINE_CONFIG_MAKEFILE(dlls/msvcp60)
+WINE_CONFIG_MAKEFILE(dlls/msvcp60/tests)
+WINE_CONFIG_MAKEFILE(dlls/msvcp70)
+WINE_CONFIG_MAKEFILE(dlls/msvcp71)
+WINE_CONFIG_MAKEFILE(dlls/msvcp80)
+WINE_CONFIG_MAKEFILE(dlls/msvcp90)
+WINE_CONFIG_MAKEFILE(dlls/msvcp90/tests)
+WINE_CONFIG_MAKEFILE(dlls/msvcr100)
+WINE_CONFIG_MAKEFILE(dlls/msvcr100/tests)
+WINE_CONFIG_MAKEFILE(dlls/msvcr110)
+WINE_CONFIG_MAKEFILE(dlls/msvcr110/tests)
+WINE_CONFIG_MAKEFILE(dlls/msvcr120)
+WINE_CONFIG_MAKEFILE(dlls/msvcr120/tests)
+WINE_CONFIG_MAKEFILE(dlls/msvcr120_app)
+WINE_CONFIG_MAKEFILE(dlls/msvcr70)
+WINE_CONFIG_MAKEFILE(dlls/msvcr71)
+WINE_CONFIG_MAKEFILE(dlls/msvcr80)
+WINE_CONFIG_MAKEFILE(dlls/msvcr90)
+WINE_CONFIG_MAKEFILE(dlls/msvcr90/tests)
+WINE_CONFIG_MAKEFILE(dlls/msvcrt)
+WINE_CONFIG_MAKEFILE(dlls/msvcrt/tests)
+WINE_CONFIG_MAKEFILE(dlls/msvcrt20)
+WINE_CONFIG_MAKEFILE(dlls/msvcrt40)
+WINE_CONFIG_MAKEFILE(dlls/msvcrtd)
+WINE_CONFIG_MAKEFILE(dlls/msvcrtd/tests)
+WINE_CONFIG_MAKEFILE(dlls/msvfw32)
+WINE_CONFIG_MAKEFILE(dlls/msvfw32/tests)
+WINE_CONFIG_MAKEFILE(dlls/msvidc32)
+WINE_CONFIG_MAKEFILE(dlls/msvideo.dll16,enable_win16)
+WINE_CONFIG_MAKEFILE(dlls/mswsock)
+WINE_CONFIG_MAKEFILE(dlls/msxml)
+WINE_CONFIG_MAKEFILE(dlls/msxml2)
+WINE_CONFIG_MAKEFILE(dlls/msxml3)
+WINE_CONFIG_MAKEFILE(dlls/msxml3/tests)
+WINE_CONFIG_MAKEFILE(dlls/msxml4)
+WINE_CONFIG_MAKEFILE(dlls/msxml6)
+WINE_CONFIG_MAKEFILE(dlls/mtxdm)
+WINE_CONFIG_MAKEFILE(dlls/ncrypt)
+WINE_CONFIG_MAKEFILE(dlls/nddeapi)
+WINE_CONFIG_MAKEFILE(dlls/ndis.sys)
+WINE_CONFIG_MAKEFILE(dlls/netapi32)
+WINE_CONFIG_MAKEFILE(dlls/netapi32/tests)
+WINE_CONFIG_MAKEFILE(dlls/netcfgx)
+WINE_CONFIG_MAKEFILE(dlls/netcfgx/tests)
+WINE_CONFIG_MAKEFILE(dlls/netprofm)
+WINE_CONFIG_MAKEFILE(dlls/netprofm/tests)
+WINE_CONFIG_MAKEFILE(dlls/newdev)
+WINE_CONFIG_MAKEFILE(dlls/ninput)
+WINE_CONFIG_MAKEFILE(dlls/ninput/tests)
+WINE_CONFIG_MAKEFILE(dlls/normaliz)
+WINE_CONFIG_MAKEFILE(dlls/npmshtml)
+WINE_CONFIG_MAKEFILE(dlls/npptools)
+WINE_CONFIG_MAKEFILE(dlls/ntdll)
+WINE_CONFIG_MAKEFILE(dlls/ntdll/tests)
+WINE_CONFIG_MAKEFILE(dlls/ntdsapi)
+WINE_CONFIG_MAKEFILE(dlls/ntdsapi/tests)
+WINE_CONFIG_MAKEFILE(dlls/ntoskrnl.exe)
+WINE_CONFIG_MAKEFILE(dlls/ntoskrnl.exe/tests)
+WINE_CONFIG_MAKEFILE(dlls/ntprint)
+WINE_CONFIG_MAKEFILE(dlls/ntprint/tests)
+WINE_CONFIG_MAKEFILE(dlls/objsel)
+WINE_CONFIG_MAKEFILE(dlls/odbc32)
+WINE_CONFIG_MAKEFILE(dlls/odbccp32)
+WINE_CONFIG_MAKEFILE(dlls/odbccp32/tests)
+WINE_CONFIG_MAKEFILE(dlls/odbccu32)
+WINE_CONFIG_MAKEFILE(dlls/ole2.dll16,enable_win16)
+WINE_CONFIG_MAKEFILE(dlls/ole2conv.dll16,enable_win16)
+WINE_CONFIG_MAKEFILE(dlls/ole2disp.dll16,enable_win16)
+WINE_CONFIG_MAKEFILE(dlls/ole2nls.dll16,enable_win16)
+WINE_CONFIG_MAKEFILE(dlls/ole2prox.dll16,enable_win16)
+WINE_CONFIG_MAKEFILE(dlls/ole2thk.dll16,enable_win16)
+WINE_CONFIG_MAKEFILE(dlls/ole32)
+WINE_CONFIG_MAKEFILE(dlls/ole32/tests)
+WINE_CONFIG_MAKEFILE(dlls/oleacc)
+WINE_CONFIG_MAKEFILE(dlls/oleacc/tests)
+WINE_CONFIG_MAKEFILE(dlls/oleaut32)
+WINE_CONFIG_MAKEFILE(dlls/oleaut32/tests)
+WINE_CONFIG_MAKEFILE(dlls/olecli.dll16,enable_win16)
+WINE_CONFIG_MAKEFILE(dlls/olecli32)
+WINE_CONFIG_MAKEFILE(dlls/oledb32)
+WINE_CONFIG_MAKEFILE(dlls/oledb32/tests)
+WINE_CONFIG_MAKEFILE(dlls/oledlg)
+WINE_CONFIG_MAKEFILE(dlls/oledlg/tests)
+WINE_CONFIG_MAKEFILE(dlls/olepro32)
+WINE_CONFIG_MAKEFILE(dlls/olesvr.dll16,enable_win16)
+WINE_CONFIG_MAKEFILE(dlls/olesvr32)
+WINE_CONFIG_MAKEFILE(dlls/olethk32)
+WINE_CONFIG_MAKEFILE(dlls/opcservices)
+WINE_CONFIG_MAKEFILE(dlls/opcservices/tests)
+WINE_CONFIG_MAKEFILE(dlls/openal32)
+WINE_CONFIG_MAKEFILE(dlls/opencl)
+WINE_CONFIG_MAKEFILE(dlls/opengl32)
+WINE_CONFIG_MAKEFILE(dlls/opengl32/tests)
+WINE_CONFIG_MAKEFILE(dlls/packager)
+WINE_CONFIG_MAKEFILE(dlls/packager/tests)
+WINE_CONFIG_MAKEFILE(dlls/pdh)
+WINE_CONFIG_MAKEFILE(dlls/pdh/tests)
+WINE_CONFIG_MAKEFILE(dlls/photometadatahandler)
+WINE_CONFIG_MAKEFILE(dlls/pidgen)
+WINE_CONFIG_MAKEFILE(dlls/powrprof)
+WINE_CONFIG_MAKEFILE(dlls/printui)
+WINE_CONFIG_MAKEFILE(dlls/prntvpt)
+WINE_CONFIG_MAKEFILE(dlls/propsys)
+WINE_CONFIG_MAKEFILE(dlls/propsys/tests)
+WINE_CONFIG_MAKEFILE(dlls/psapi)
+WINE_CONFIG_MAKEFILE(dlls/psapi/tests)
+WINE_CONFIG_MAKEFILE(dlls/pstorec)
+WINE_CONFIG_MAKEFILE(dlls/pstorec/tests)
+WINE_CONFIG_MAKEFILE(dlls/qcap)
+WINE_CONFIG_MAKEFILE(dlls/qcap/tests)
+WINE_CONFIG_MAKEFILE(dlls/qedit)
+WINE_CONFIG_MAKEFILE(dlls/qedit/tests)
+WINE_CONFIG_MAKEFILE(dlls/qmgr)
+WINE_CONFIG_MAKEFILE(dlls/qmgr/tests)
+WINE_CONFIG_MAKEFILE(dlls/qmgrprxy)
+WINE_CONFIG_MAKEFILE(dlls/quartz)
+WINE_CONFIG_MAKEFILE(dlls/quartz/tests)
+WINE_CONFIG_MAKEFILE(dlls/query)
+WINE_CONFIG_MAKEFILE(dlls/qwave)
+WINE_CONFIG_MAKEFILE(dlls/qwave/tests)
+WINE_CONFIG_MAKEFILE(dlls/rasapi16.dll16,enable_win16)
+WINE_CONFIG_MAKEFILE(dlls/rasapi32)
+WINE_CONFIG_MAKEFILE(dlls/rasapi32/tests)
+WINE_CONFIG_MAKEFILE(dlls/rasdlg)
+WINE_CONFIG_MAKEFILE(dlls/regapi)
+WINE_CONFIG_MAKEFILE(dlls/resutils)
+WINE_CONFIG_MAKEFILE(dlls/riched20)
+WINE_CONFIG_MAKEFILE(dlls/riched20/tests)
+WINE_CONFIG_MAKEFILE(dlls/riched32)
+WINE_CONFIG_MAKEFILE(dlls/riched32/tests)
+WINE_CONFIG_MAKEFILE(dlls/rpcrt4)
+WINE_CONFIG_MAKEFILE(dlls/rpcrt4/tests)
+WINE_CONFIG_MAKEFILE(dlls/rsabase)
+WINE_CONFIG_MAKEFILE(dlls/rsaenh)
+WINE_CONFIG_MAKEFILE(dlls/rsaenh/tests)
+WINE_CONFIG_MAKEFILE(dlls/rstrtmgr)
+WINE_CONFIG_MAKEFILE(dlls/rtutils)
+WINE_CONFIG_MAKEFILE(dlls/samlib)
+WINE_CONFIG_MAKEFILE(dlls/sane.ds)
+WINE_CONFIG_MAKEFILE(dlls/sapi)
+WINE_CONFIG_MAKEFILE(dlls/sapi/tests)
+WINE_CONFIG_MAKEFILE(dlls/sas)
+WINE_CONFIG_MAKEFILE(dlls/scarddlg)
+WINE_CONFIG_MAKEFILE(dlls/sccbase)
+WINE_CONFIG_MAKEFILE(dlls/schannel)
+WINE_CONFIG_MAKEFILE(dlls/schannel/tests)
+WINE_CONFIG_MAKEFILE(dlls/schedsvc)
+WINE_CONFIG_MAKEFILE(dlls/schedsvc/tests)
+WINE_CONFIG_MAKEFILE(dlls/scrobj)
+WINE_CONFIG_MAKEFILE(dlls/scrrun)
+WINE_CONFIG_MAKEFILE(dlls/scrrun/tests)
+WINE_CONFIG_MAKEFILE(dlls/scsiport.sys)
+WINE_CONFIG_MAKEFILE(dlls/secur32)
+WINE_CONFIG_MAKEFILE(dlls/secur32/tests)
+WINE_CONFIG_MAKEFILE(dlls/security)
+WINE_CONFIG_MAKEFILE(dlls/sensapi)
+WINE_CONFIG_MAKEFILE(dlls/serialui)
+WINE_CONFIG_MAKEFILE(dlls/serialui/tests)
+WINE_CONFIG_MAKEFILE(dlls/setupapi)
+WINE_CONFIG_MAKEFILE(dlls/setupapi/tests)
+WINE_CONFIG_MAKEFILE(dlls/setupx.dll16,enable_win16)
+WINE_CONFIG_MAKEFILE(dlls/sfc)
+WINE_CONFIG_MAKEFILE(dlls/sfc_os)
+WINE_CONFIG_MAKEFILE(dlls/shcore)
+WINE_CONFIG_MAKEFILE(dlls/shcore/tests)
+WINE_CONFIG_MAKEFILE(dlls/shdoclc)
+WINE_CONFIG_MAKEFILE(dlls/shdocvw)
+WINE_CONFIG_MAKEFILE(dlls/shdocvw/tests)
+WINE_CONFIG_MAKEFILE(dlls/shell.dll16,enable_win16)
+WINE_CONFIG_MAKEFILE(dlls/shell32)
+WINE_CONFIG_MAKEFILE(dlls/shell32/tests)
+WINE_CONFIG_MAKEFILE(dlls/shfolder)
+WINE_CONFIG_MAKEFILE(dlls/shlwapi)
+WINE_CONFIG_MAKEFILE(dlls/shlwapi/tests)
+WINE_CONFIG_MAKEFILE(dlls/slbcsp)
+WINE_CONFIG_MAKEFILE(dlls/slc)
+WINE_CONFIG_MAKEFILE(dlls/slc/tests)
+WINE_CONFIG_MAKEFILE(dlls/snmpapi)
+WINE_CONFIG_MAKEFILE(dlls/snmpapi/tests)
+WINE_CONFIG_MAKEFILE(dlls/softpub)
+WINE_CONFIG_MAKEFILE(dlls/sound.drv16,enable_win16)
+WINE_CONFIG_MAKEFILE(dlls/spoolss)
+WINE_CONFIG_MAKEFILE(dlls/spoolss/tests)
+WINE_CONFIG_MAKEFILE(dlls/srclient)
+WINE_CONFIG_MAKEFILE(dlls/sspicli)
+WINE_CONFIG_MAKEFILE(dlls/stdole2.tlb)
+WINE_CONFIG_MAKEFILE(dlls/stdole32.tlb)
+WINE_CONFIG_MAKEFILE(dlls/sti)
+WINE_CONFIG_MAKEFILE(dlls/sti/tests)
+WINE_CONFIG_MAKEFILE(dlls/storage.dll16,enable_win16)
+WINE_CONFIG_MAKEFILE(dlls/stress.dll16,enable_win16)
+WINE_CONFIG_MAKEFILE(dlls/strmbase)
+WINE_CONFIG_MAKEFILE(dlls/strmdll)
+WINE_CONFIG_MAKEFILE(dlls/strmiids)
+WINE_CONFIG_MAKEFILE(dlls/svrapi)
+WINE_CONFIG_MAKEFILE(dlls/sxs)
+WINE_CONFIG_MAKEFILE(dlls/sxs/tests)
+WINE_CONFIG_MAKEFILE(dlls/system.drv16,enable_win16)
+WINE_CONFIG_MAKEFILE(dlls/t2embed)
+WINE_CONFIG_MAKEFILE(dlls/t2embed/tests)
+WINE_CONFIG_MAKEFILE(dlls/tapi32)
+WINE_CONFIG_MAKEFILE(dlls/taskschd)
+WINE_CONFIG_MAKEFILE(dlls/taskschd/tests)
+WINE_CONFIG_MAKEFILE(dlls/tdh)
+WINE_CONFIG_MAKEFILE(dlls/tdi.sys)
+WINE_CONFIG_MAKEFILE(dlls/toolhelp.dll16,enable_win16)
+WINE_CONFIG_MAKEFILE(dlls/traffic)
+WINE_CONFIG_MAKEFILE(dlls/twain.dll16,enable_win16)
+WINE_CONFIG_MAKEFILE(dlls/twain_32)
+WINE_CONFIG_MAKEFILE(dlls/twain_32/tests)
+WINE_CONFIG_MAKEFILE(dlls/typelib.dll16,enable_win16)
+WINE_CONFIG_MAKEFILE(dlls/tzres)
+WINE_CONFIG_MAKEFILE(dlls/ucrtbase)
+WINE_CONFIG_MAKEFILE(dlls/ucrtbase/tests)
+WINE_CONFIG_MAKEFILE(dlls/uianimation)
+WINE_CONFIG_MAKEFILE(dlls/uiautomationcore)
+WINE_CONFIG_MAKEFILE(dlls/uiautomationcore/tests)
+WINE_CONFIG_MAKEFILE(dlls/uiribbon)
+WINE_CONFIG_MAKEFILE(dlls/unicows)
+WINE_CONFIG_MAKEFILE(dlls/updspapi)
+WINE_CONFIG_MAKEFILE(dlls/url)
+WINE_CONFIG_MAKEFILE(dlls/urlmon)
+WINE_CONFIG_MAKEFILE(dlls/urlmon/tests)
+WINE_CONFIG_MAKEFILE(dlls/usbd.sys)
+WINE_CONFIG_MAKEFILE(dlls/user.exe16,enable_win16)
+WINE_CONFIG_MAKEFILE(dlls/user32)
+WINE_CONFIG_MAKEFILE(dlls/user32/tests)
+WINE_CONFIG_MAKEFILE(dlls/userenv)
+WINE_CONFIG_MAKEFILE(dlls/userenv/tests)
+WINE_CONFIG_MAKEFILE(dlls/usp10)
+WINE_CONFIG_MAKEFILE(dlls/usp10/tests)
+WINE_CONFIG_MAKEFILE(dlls/uuid)
+WINE_CONFIG_MAKEFILE(dlls/uxtheme)
+WINE_CONFIG_MAKEFILE(dlls/uxtheme/tests)
+WINE_CONFIG_MAKEFILE(dlls/vbscript)
+WINE_CONFIG_MAKEFILE(dlls/vbscript/tests)
+WINE_CONFIG_MAKEFILE(dlls/vcomp)
+WINE_CONFIG_MAKEFILE(dlls/vcomp/tests)
+WINE_CONFIG_MAKEFILE(dlls/vcomp100)
+WINE_CONFIG_MAKEFILE(dlls/vcomp110)
+WINE_CONFIG_MAKEFILE(dlls/vcomp120)
+WINE_CONFIG_MAKEFILE(dlls/vcomp140)
+WINE_CONFIG_MAKEFILE(dlls/vcomp90)
+WINE_CONFIG_MAKEFILE(dlls/vcruntime140)
+WINE_CONFIG_MAKEFILE(dlls/vdhcp.vxd,enable_win16)
+WINE_CONFIG_MAKEFILE(dlls/vdmdbg)
+WINE_CONFIG_MAKEFILE(dlls/ver.dll16,enable_win16)
+WINE_CONFIG_MAKEFILE(dlls/version)
+WINE_CONFIG_MAKEFILE(dlls/version/tests)
+WINE_CONFIG_MAKEFILE(dlls/virtdisk)
+WINE_CONFIG_MAKEFILE(dlls/virtdisk/tests)
+WINE_CONFIG_MAKEFILE(dlls/vmm.vxd,enable_win16)
+WINE_CONFIG_MAKEFILE(dlls/vnbt.vxd,enable_win16)
+WINE_CONFIG_MAKEFILE(dlls/vnetbios.vxd,enable_win16)
+WINE_CONFIG_MAKEFILE(dlls/vssapi)
+WINE_CONFIG_MAKEFILE(dlls/vtdapi.vxd,enable_win16)
+WINE_CONFIG_MAKEFILE(dlls/vulkan-1)
+WINE_CONFIG_MAKEFILE(dlls/vulkan-1/tests)
+WINE_CONFIG_MAKEFILE(dlls/vwin32.vxd,enable_win16)
+WINE_CONFIG_MAKEFILE(dlls/w32skrnl,enable_win16)
+WINE_CONFIG_MAKEFILE(dlls/w32sys.dll16,enable_win16)
+WINE_CONFIG_MAKEFILE(dlls/wbemdisp)
+WINE_CONFIG_MAKEFILE(dlls/wbemdisp/tests)
+WINE_CONFIG_MAKEFILE(dlls/wbemprox)
+WINE_CONFIG_MAKEFILE(dlls/wbemprox/tests)
+WINE_CONFIG_MAKEFILE(dlls/wdscore)
+WINE_CONFIG_MAKEFILE(dlls/webservices)
+WINE_CONFIG_MAKEFILE(dlls/webservices/tests)
+WINE_CONFIG_MAKEFILE(dlls/wer)
+WINE_CONFIG_MAKEFILE(dlls/wer/tests)
+WINE_CONFIG_MAKEFILE(dlls/wevtapi)
+WINE_CONFIG_MAKEFILE(dlls/wiaservc)
+WINE_CONFIG_MAKEFILE(dlls/wiaservc/tests)
+WINE_CONFIG_MAKEFILE(dlls/wimgapi)
+WINE_CONFIG_MAKEFILE(dlls/win32s16.dll16,enable_win16)
+WINE_CONFIG_MAKEFILE(dlls/win87em.dll16,enable_win16)
+WINE_CONFIG_MAKEFILE(dlls/winaspi.dll16,enable_win16)
+WINE_CONFIG_MAKEFILE(dlls/windebug.dll16,enable_win16)
+WINE_CONFIG_MAKEFILE(dlls/windowscodecs)
+WINE_CONFIG_MAKEFILE(dlls/windowscodecs/tests)
+WINE_CONFIG_MAKEFILE(dlls/windowscodecsext)
+WINE_CONFIG_MAKEFILE(dlls/windowscodecsext/tests)
+WINE_CONFIG_MAKEFILE(dlls/winealsa.drv)
+WINE_CONFIG_MAKEFILE(dlls/wineandroid.drv)
+WINE_CONFIG_MAKEFILE(dlls/winebus.sys)
+WINE_CONFIG_MAKEFILE(dlls/winecoreaudio.drv)
+WINE_CONFIG_MAKEFILE(dlls/winecrt0)
+WINE_CONFIG_MAKEFILE(dlls/wined3d)
+WINE_CONFIG_MAKEFILE(dlls/winegstreamer)
+WINE_CONFIG_MAKEFILE(dlls/winehid.sys)
+WINE_CONFIG_MAKEFILE(dlls/winejoystick.drv)
+WINE_CONFIG_MAKEFILE(dlls/winemac.drv)
+WINE_CONFIG_MAKEFILE(dlls/winemapi)
+WINE_CONFIG_MAKEFILE(dlls/wineoss.drv)
+WINE_CONFIG_MAKEFILE(dlls/wineps.drv)
+WINE_CONFIG_MAKEFILE(dlls/wineps16.drv16,enable_win16)
+WINE_CONFIG_MAKEFILE(dlls/winepulse.drv)
+WINE_CONFIG_MAKEFILE(dlls/wineqtdecoder)
+WINE_CONFIG_MAKEFILE(dlls/winevulkan)
+WINE_CONFIG_MAKEFILE(dlls/winex11.drv)
+WINE_CONFIG_MAKEFILE(dlls/wing.dll16,enable_win16)
+WINE_CONFIG_MAKEFILE(dlls/wing32)
+WINE_CONFIG_MAKEFILE(dlls/winhttp)
+WINE_CONFIG_MAKEFILE(dlls/winhttp/tests)
+WINE_CONFIG_MAKEFILE(dlls/wininet)
+WINE_CONFIG_MAKEFILE(dlls/wininet/tests)
+WINE_CONFIG_MAKEFILE(dlls/winmm)
+WINE_CONFIG_MAKEFILE(dlls/winmm/tests)
+WINE_CONFIG_MAKEFILE(dlls/winnls.dll16,enable_win16)
+WINE_CONFIG_MAKEFILE(dlls/winnls32)
+WINE_CONFIG_MAKEFILE(dlls/winscard)
+WINE_CONFIG_MAKEFILE(dlls/winsock.dll16,enable_win16)
+WINE_CONFIG_MAKEFILE(dlls/winspool.drv)
+WINE_CONFIG_MAKEFILE(dlls/winspool.drv/tests)
+WINE_CONFIG_MAKEFILE(dlls/winsta)
+WINE_CONFIG_MAKEFILE(dlls/wintab.dll16,enable_win16)
+WINE_CONFIG_MAKEFILE(dlls/wintab32)
+WINE_CONFIG_MAKEFILE(dlls/wintab32/tests)
+WINE_CONFIG_MAKEFILE(dlls/wintrust)
+WINE_CONFIG_MAKEFILE(dlls/wintrust/tests)
+WINE_CONFIG_MAKEFILE(dlls/winusb)
+WINE_CONFIG_MAKEFILE(dlls/wlanapi)
+WINE_CONFIG_MAKEFILE(dlls/wlanapi/tests)
+WINE_CONFIG_MAKEFILE(dlls/wldap32)
+WINE_CONFIG_MAKEFILE(dlls/wldap32/tests)
+WINE_CONFIG_MAKEFILE(dlls/wmasf)
+WINE_CONFIG_MAKEFILE(dlls/wmcodecdspuuid)
+WINE_CONFIG_MAKEFILE(dlls/wmi)
+WINE_CONFIG_MAKEFILE(dlls/wmiutils)
+WINE_CONFIG_MAKEFILE(dlls/wmiutils/tests)
+WINE_CONFIG_MAKEFILE(dlls/wmp)
+WINE_CONFIG_MAKEFILE(dlls/wmp/tests)
+WINE_CONFIG_MAKEFILE(dlls/wmphoto)
+WINE_CONFIG_MAKEFILE(dlls/wmvcore)
+WINE_CONFIG_MAKEFILE(dlls/wmvcore/tests)
+WINE_CONFIG_MAKEFILE(dlls/wnaspi32)
+WINE_CONFIG_MAKEFILE(dlls/wow32,enable_win16)
+WINE_CONFIG_MAKEFILE(dlls/wpc)
+WINE_CONFIG_MAKEFILE(dlls/wpc/tests)
+WINE_CONFIG_MAKEFILE(dlls/wpcap)
+WINE_CONFIG_MAKEFILE(dlls/ws2_32)
+WINE_CONFIG_MAKEFILE(dlls/ws2_32/tests)
+WINE_CONFIG_MAKEFILE(dlls/wsdapi)
+WINE_CONFIG_MAKEFILE(dlls/wsdapi/tests)
+WINE_CONFIG_MAKEFILE(dlls/wshom.ocx)
+WINE_CONFIG_MAKEFILE(dlls/wshom.ocx/tests)
+WINE_CONFIG_MAKEFILE(dlls/wsnmp32)
+WINE_CONFIG_MAKEFILE(dlls/wsnmp32/tests)
+WINE_CONFIG_MAKEFILE(dlls/wsock32)
+WINE_CONFIG_MAKEFILE(dlls/wtsapi32)
+WINE_CONFIG_MAKEFILE(dlls/wtsapi32/tests)
+WINE_CONFIG_MAKEFILE(dlls/wuapi)
+WINE_CONFIG_MAKEFILE(dlls/wuaueng)
+WINE_CONFIG_MAKEFILE(dlls/x3daudio1_0)
+WINE_CONFIG_MAKEFILE(dlls/x3daudio1_1)
+WINE_CONFIG_MAKEFILE(dlls/x3daudio1_2)
+WINE_CONFIG_MAKEFILE(dlls/x3daudio1_3)
+WINE_CONFIG_MAKEFILE(dlls/x3daudio1_4)
+WINE_CONFIG_MAKEFILE(dlls/x3daudio1_5)
+WINE_CONFIG_MAKEFILE(dlls/x3daudio1_6)
+WINE_CONFIG_MAKEFILE(dlls/x3daudio1_7)
+WINE_CONFIG_MAKEFILE(dlls/xactengine3_0)
+WINE_CONFIG_MAKEFILE(dlls/xactengine3_1)
+WINE_CONFIG_MAKEFILE(dlls/xactengine3_2)
+WINE_CONFIG_MAKEFILE(dlls/xactengine3_3)
+WINE_CONFIG_MAKEFILE(dlls/xactengine3_4)
+WINE_CONFIG_MAKEFILE(dlls/xactengine3_5)
+WINE_CONFIG_MAKEFILE(dlls/xactengine3_6)
+WINE_CONFIG_MAKEFILE(dlls/xactengine3_7)
+WINE_CONFIG_MAKEFILE(dlls/xapofx1_1)
+WINE_CONFIG_MAKEFILE(dlls/xapofx1_2)
+WINE_CONFIG_MAKEFILE(dlls/xapofx1_3)
+WINE_CONFIG_MAKEFILE(dlls/xapofx1_4)
+WINE_CONFIG_MAKEFILE(dlls/xapofx1_5)
+WINE_CONFIG_MAKEFILE(dlls/xaudio2_0)
+WINE_CONFIG_MAKEFILE(dlls/xaudio2_1)
+WINE_CONFIG_MAKEFILE(dlls/xaudio2_2)
+WINE_CONFIG_MAKEFILE(dlls/xaudio2_3)
+WINE_CONFIG_MAKEFILE(dlls/xaudio2_4)
+WINE_CONFIG_MAKEFILE(dlls/xaudio2_5)
+WINE_CONFIG_MAKEFILE(dlls/xaudio2_6)
+WINE_CONFIG_MAKEFILE(dlls/xaudio2_7)
+WINE_CONFIG_MAKEFILE(dlls/xaudio2_7/tests)
+WINE_CONFIG_MAKEFILE(dlls/xaudio2_8)
+WINE_CONFIG_MAKEFILE(dlls/xaudio2_9)
+WINE_CONFIG_MAKEFILE(dlls/xinput1_1)
+WINE_CONFIG_MAKEFILE(dlls/xinput1_2)
+WINE_CONFIG_MAKEFILE(dlls/xinput1_3)
+WINE_CONFIG_MAKEFILE(dlls/xinput1_3/tests)
+WINE_CONFIG_MAKEFILE(dlls/xinput1_4)
+WINE_CONFIG_MAKEFILE(dlls/xinput9_1_0)
+WINE_CONFIG_MAKEFILE(dlls/xmllite)
+WINE_CONFIG_MAKEFILE(dlls/xmllite/tests)
+WINE_CONFIG_MAKEFILE(dlls/xolehlp)
+WINE_CONFIG_MAKEFILE(dlls/xpsprint)
+WINE_CONFIG_MAKEFILE(dlls/xpssvcs)
+WINE_CONFIG_MAKEFILE(fonts)
+WINE_CONFIG_MAKEFILE(include)
+WINE_CONFIG_MAKEFILE(libs/port)
+WINE_CONFIG_MAKEFILE(libs/wine)
+WINE_CONFIG_MAKEFILE(libs/wpp)
+WINE_CONFIG_MAKEFILE(loader)
+WINE_CONFIG_MAKEFILE(po)
+WINE_CONFIG_MAKEFILE(programs/arp)
+WINE_CONFIG_MAKEFILE(programs/aspnet_regiis)
+WINE_CONFIG_MAKEFILE(programs/attrib)
+WINE_CONFIG_MAKEFILE(programs/cabarc)
+WINE_CONFIG_MAKEFILE(programs/cacls)
+WINE_CONFIG_MAKEFILE(programs/clock)
+WINE_CONFIG_MAKEFILE(programs/cmd)
+WINE_CONFIG_MAKEFILE(programs/cmd/tests)
+WINE_CONFIG_MAKEFILE(programs/conhost)
+WINE_CONFIG_MAKEFILE(programs/control)
+WINE_CONFIG_MAKEFILE(programs/cscript)
+WINE_CONFIG_MAKEFILE(programs/dism)
+WINE_CONFIG_MAKEFILE(programs/dpnsvr)
+WINE_CONFIG_MAKEFILE(programs/dxdiag)
+WINE_CONFIG_MAKEFILE(programs/eject)
+WINE_CONFIG_MAKEFILE(programs/expand)
+WINE_CONFIG_MAKEFILE(programs/explorer)
+WINE_CONFIG_MAKEFILE(programs/extrac32)
+WINE_CONFIG_MAKEFILE(programs/fc)
+WINE_CONFIG_MAKEFILE(programs/find)
+WINE_CONFIG_MAKEFILE(programs/findstr)
+WINE_CONFIG_MAKEFILE(programs/fsutil)
+WINE_CONFIG_MAKEFILE(programs/hh)
+WINE_CONFIG_MAKEFILE(programs/hostname)
+WINE_CONFIG_MAKEFILE(programs/icacls)
+WINE_CONFIG_MAKEFILE(programs/icinfo)
+WINE_CONFIG_MAKEFILE(programs/iexplore)
+WINE_CONFIG_MAKEFILE(programs/ipconfig)
+WINE_CONFIG_MAKEFILE(programs/lodctr)
+WINE_CONFIG_MAKEFILE(programs/mofcomp)
+WINE_CONFIG_MAKEFILE(programs/mshta)
+WINE_CONFIG_MAKEFILE(programs/msidb)
+WINE_CONFIG_MAKEFILE(programs/msiexec)
+WINE_CONFIG_MAKEFILE(programs/msinfo32)
+WINE_CONFIG_MAKEFILE(programs/net)
+WINE_CONFIG_MAKEFILE(programs/netsh)
+WINE_CONFIG_MAKEFILE(programs/netstat)
+WINE_CONFIG_MAKEFILE(programs/ngen)
+WINE_CONFIG_MAKEFILE(programs/notepad)
+WINE_CONFIG_MAKEFILE(programs/oleview)
+WINE_CONFIG_MAKEFILE(programs/ping)
+WINE_CONFIG_MAKEFILE(programs/plugplay)
+WINE_CONFIG_MAKEFILE(programs/powershell)
+WINE_CONFIG_MAKEFILE(programs/presentationfontcache)
+WINE_CONFIG_MAKEFILE(programs/progman)
+WINE_CONFIG_MAKEFILE(programs/reg)
+WINE_CONFIG_MAKEFILE(programs/reg/tests)
+WINE_CONFIG_MAKEFILE(programs/regasm)
+WINE_CONFIG_MAKEFILE(programs/regedit)
+WINE_CONFIG_MAKEFILE(programs/regedit/tests)
+WINE_CONFIG_MAKEFILE(programs/regsvcs)
+WINE_CONFIG_MAKEFILE(programs/regsvr32)
+WINE_CONFIG_MAKEFILE(programs/rpcss)
+WINE_CONFIG_MAKEFILE(programs/rundll.exe16,enable_win16)
+WINE_CONFIG_MAKEFILE(programs/rundll32)
+WINE_CONFIG_MAKEFILE(programs/sc)
+WINE_CONFIG_MAKEFILE(programs/schtasks)
+WINE_CONFIG_MAKEFILE(programs/schtasks/tests)
+WINE_CONFIG_MAKEFILE(programs/sdbinst)
+WINE_CONFIG_MAKEFILE(programs/secedit)
+WINE_CONFIG_MAKEFILE(programs/servicemodelreg)
+WINE_CONFIG_MAKEFILE(programs/services)
+WINE_CONFIG_MAKEFILE(programs/services/tests)
+WINE_CONFIG_MAKEFILE(programs/shutdown)
+WINE_CONFIG_MAKEFILE(programs/spoolsv)
+WINE_CONFIG_MAKEFILE(programs/start)
+WINE_CONFIG_MAKEFILE(programs/subst)
+WINE_CONFIG_MAKEFILE(programs/svchost)
+WINE_CONFIG_MAKEFILE(programs/systeminfo)
+WINE_CONFIG_MAKEFILE(programs/taskkill)
+WINE_CONFIG_MAKEFILE(programs/tasklist)
+WINE_CONFIG_MAKEFILE(programs/taskmgr)
+WINE_CONFIG_MAKEFILE(programs/termsv)
+WINE_CONFIG_MAKEFILE(programs/uninstaller)
+WINE_CONFIG_MAKEFILE(programs/unlodctr)
+WINE_CONFIG_MAKEFILE(programs/view)
+WINE_CONFIG_MAKEFILE(programs/wevtutil)
+WINE_CONFIG_MAKEFILE(programs/wineboot)
+WINE_CONFIG_MAKEFILE(programs/winebrowser)
+WINE_CONFIG_MAKEFILE(programs/winecfg)
+WINE_CONFIG_MAKEFILE(programs/wineconsole)
+WINE_CONFIG_MAKEFILE(programs/winedbg)
+WINE_CONFIG_MAKEFILE(programs/winedevice)
+WINE_CONFIG_MAKEFILE(programs/winefile)
+WINE_CONFIG_MAKEFILE(programs/winemine)
+WINE_CONFIG_MAKEFILE(programs/winemsibuilder)
+WINE_CONFIG_MAKEFILE(programs/winepath)
+WINE_CONFIG_MAKEFILE(programs/winetest)
+WINE_CONFIG_MAKEFILE(programs/winevdm,enable_win16)
+WINE_CONFIG_MAKEFILE(programs/winhelp.exe16,enable_win16)
+WINE_CONFIG_MAKEFILE(programs/winhlp32)
+WINE_CONFIG_MAKEFILE(programs/winmgmt)
+WINE_CONFIG_MAKEFILE(programs/winoldap.mod16,enable_win16)
+WINE_CONFIG_MAKEFILE(programs/winver)
+WINE_CONFIG_MAKEFILE(programs/wmic)
+WINE_CONFIG_MAKEFILE(programs/wmplayer)
+WINE_CONFIG_MAKEFILE(programs/wordpad)
+WINE_CONFIG_MAKEFILE(programs/write)
+WINE_CONFIG_MAKEFILE(programs/wscript)
+WINE_CONFIG_MAKEFILE(programs/wscript/tests)
+WINE_CONFIG_MAKEFILE(programs/wusa)
+WINE_CONFIG_MAKEFILE(programs/xcopy)
+WINE_CONFIG_MAKEFILE(programs/xcopy/tests)
+WINE_CONFIG_MAKEFILE(server)
+WINE_CONFIG_MAKEFILE(tools,,[test "x$enable_tools" = xno])
+WINE_CONFIG_MAKEFILE(tools/sfnt2fon,,[test "x$enable_tools" = xno])
+WINE_CONFIG_MAKEFILE(tools/widl,,[test "x$enable_tools" = xno])
+WINE_CONFIG_MAKEFILE(tools/winebuild,,[test "x$enable_tools" = xno])
+WINE_CONFIG_MAKEFILE(tools/winedump,,[test "x$enable_tools" = xno])
+WINE_CONFIG_MAKEFILE(tools/winegcc,,[test "x$enable_tools" = xno])
+WINE_CONFIG_MAKEFILE(tools/winemaker,,[test "x$enable_tools" = xno])
+WINE_CONFIG_MAKEFILE(tools/wmc,,[test "x$enable_tools" = xno])
+WINE_CONFIG_MAKEFILE(tools/wrc,,[test "x$enable_tools" = xno])
+dnl End of auto-generated output commands
+
+dnl Main ignore file
+
+WINE_IGNORE_FILE("TAGS")
+WINE_IGNORE_FILE("tags")
+WINE_IGNORE_FILE("autom4te.cache")
+WINE_IGNORE_FILE("config.log")
+WINE_IGNORE_FILE("config.status")
+WINE_IGNORE_FILE("include/config.h")
+WINE_IGNORE_FILE("include/stamp-h")
+test "$wine_binary" = wine || WINE_IGNORE_FILE("loader/wine")
+
+if test "x$enable_tools" != xno
+then
+    WINE_IGNORE_FILE("tools/makedep$ac_exeext")
+    AC_CONFIG_COMMANDS([tools/makedep],[wine_fn_output_makedep || AS_EXIT],
+[wine_fn_output_makedep ()
+{
+    AS_MKDIR_P(tools)
+    $CC -Iinclude -I$srcdir/include -D__WINESRC__ $EXTRACFLAGS $CPPFLAGS $CFLAGS -o tools/makedep$ac_exeext $srcdir/tools/makedep.c $LDFLAGS
+}])
+fi
+
+AC_CONFIG_COMMANDS([Makefile], [wine_fn_output_makefile Makefile],
+[wine_fn_output_makefile ()
+{
+    cat Make.tmp - <<\_WINE_EOF >\$tmp/makefile && mv -f \$tmp/makefile \$[]1 && rm -f Make.tmp && "$wine_makedep" && return
+`cat $wine_rules_file`
+_WINE_EOF
+    AS_ERROR([could not create Makefile])
+}])
+
+AC_CONFIG_FILES([Make.tmp:Makefile.in])
+
+dnl Some final makefile rules
+
+if test "x$enable_maintainer_mode" = xyes
+then
+    WINE_APPEND_RULE(
+[configure: configure.ac aclocal.m4
+	autoconf --warnings=all
+include/config.h.in: include/stamp-h.in
+include/stamp-h.in: configure.ac aclocal.m4
+	autoheader --warnings=all
+	@echo timestamp > \$[@]])
+fi
+
+if test "x$enable_tools" != xno
+then
+    WINE_APPEND_RULE(
+[tools/makedep$ac_exeext: $srcdir/tools/makedep.c include/config.h config.status
+	@./config.status tools/makedep
+Makefile: tools/makedep$ac_exeext
+fonts: tools/sfnt2fon
+include: tools tools/widl])
+else
+    WINE_APPEND_RULE(
+[\$(MAKEDEP):
+	@echo \"You need to run make in $TOOLSDIR first\" && false])
+fi
+
+if test -n "$with_wine64"
+then
+    case "$with_wine64" in
+      /*) reldir="" ;;
+      *)  reldir="../" ;;
+    esac
+    dnl Get rid of old symlinks
+    rm -f fonts server 2>/dev/null
+    WINE_APPEND_RULE(
+[all: loader/wine64 loader/wine64-preloader $with_wine64/loader/wine $with_wine64/loader/wine-preloader
+loader/wine64 loader/wine64-preloader:
+	rm -f \$[@] && \$(LN_S) $reldir$with_wine64/\$[@] \$[@]
+$with_wine64/loader/wine:
+	rm -f \$[@] && \$(LN_S) $ac_pwd/loader/wine \$[@]
+$with_wine64/loader/wine-preloader:
+	rm -f \$[@] && \$(LN_S) $ac_pwd/loader/wine-preloader \$[@]
+clean::
+	rm -f loader/wine64 loader/wine64-preloader $with_wine64/loader/wine $with_wine64/loader/wine-preloader])
+else
+    TOP_INSTALL_DEV="$TOP_INSTALL_DEV include"
+    TOP_INSTALL_LIB="$TOP_INSTALL_LIB \
+fonts \
+loader/l_intl.nls \
+loader/wine.inf \
+loader/winehid.inf \
+programs/msidb/msidb \
+programs/msiexec/msiexec \
+programs/notepad/notepad \
+programs/regedit/regedit \
+programs/regsvr32/regsvr32 \
+programs/wineboot/wineboot \
+programs/winecfg/winecfg \
+programs/wineconsole/wineconsole \
+programs/winedbg/winedbg \
+programs/winefile/winefile \
+programs/winemine/winemine \
+programs/winepath/winepath \
+server/wineserver"
+
+    case $host_os in
+      cygwin*|mingw32*|darwin*|macosx*|linux-android*) ;;
+      *) TOP_INSTALL_LIB="$TOP_INSTALL_LIB loader/wine.desktop" ;;
+    esac
+fi
+
+AS_ECHO(" done") >&AS_MESSAGE_FD
+AC_OUTPUT
+
+if test "$no_create" = "yes"
+then
+  exit 0
+fi
+
+WINE_PRINT_MESSAGES
+
+AS_ECHO("
+$as_me: Finished.  Do '${ac_make}' to compile Wine.
+") >&AS_MESSAGE_FD
+
+dnl Local Variables:
+dnl comment-start: "dnl "
+dnl comment-end: ""
+dnl comment-start-skip: "\\bdnl\\b\\s *"
+dnl compile-command: "autoreconf --warnings=all"
+dnl End:
diff -purN a/dlls/d3d9-nine/backend.c b/dlls/d3d9-nine/backend.c
--- a/dlls/d3d9-nine/backend.c	1970-01-01 03:00:00.000000000 +0300
+++ b/dlls/d3d9-nine/backend.c	2019-09-12 21:01:47.923318961 +0300
@@ -0,0 +1,138 @@
+/* SPDX-License-Identifier: LGPL-2.1-or-later */
+/*
+ * Wine D3D9 DRI backend interface
+ *
+ * Copyright 2019 Patrick Rudolph
+ * Copyright 2014-2015 Axel Davy
+ * Copyright 2015-2019 Patrick Rudolph
+ */
+
+#include <config.h>
+#include <windows.h>
+#include <wine/debug.h>
+#include <X11/Xlib-xcb.h>
+#include <stdlib.h>
+
+#include "backend.h"
+#include "xcb_present.h"
+#include "registry.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(d3d9nine);
+
+extern const struct dri_backend_funcs dri3_funcs;
+#ifdef D3D9NINE_DRI2
+extern const struct dri_backend_funcs dri2_funcs;
+#endif
+
+static const struct dri_backend_funcs *backends[] = {
+    &dri3_funcs,
+#ifdef D3D9NINE_DRI2
+    &dri2_funcs,
+#endif
+};
+
+static const int backends_count = sizeof(backends) / sizeof(*backends);
+
+static const char *backend_getenv()
+{
+    const char *env = getenv("D3D_BACKEND");
+    static BOOL first = TRUE;
+
+    if (env && first)
+    {
+        first = FALSE;
+        WINE_WARN("Backend overwritten by D3D_BACKEND: %s\n", env);
+    }
+
+    return env;
+}
+
+BOOL backend_probe(Display *dpy)
+{
+    int i;
+    const char *env;
+
+    WINE_TRACE("dpy=%p\n", dpy);
+
+    if (!dpy)
+        return FALSE;
+
+    env = backend_getenv();
+
+    for (i = 0; i < backends_count; ++i)
+    {
+        if (env && strcmp(env, backends[i]->name))
+            continue;
+
+        if (backends[i]->probe(dpy))
+        {
+            if (i != 0)
+                wine_dbg_printf("\033[1;31mDRI3 backend not active (slower performance)\033[0m\n");
+
+            return TRUE;
+        }
+
+        WINE_ERR("Error probing backend %s\n", backends[i]->name);
+    }
+
+    return FALSE;
+}
+
+struct dri_backend *backend_create(Display *dpy, int screen)
+{
+    struct dri_backend *dri_backend;
+    int i;
+    const char *env;
+
+    WINE_TRACE("dpy=%p screen=%d\n", dpy, screen);
+
+    dri_backend = HeapAlloc(GetProcessHeap(), 0, sizeof(struct dri_backend));
+    if (!dri_backend)
+        return NULL;
+
+    dri_backend->funcs = NULL;
+    dri_backend->priv = NULL;
+
+    env = backend_getenv();
+
+    for (i = 0; i < backends_count; ++i)
+    {
+        if (env && strcmp(env, backends[i]->name))
+            continue;
+
+        if (backends[i]->create(dpy, screen, &dri_backend->priv))
+        {
+            WINE_TRACE("Active backend: %s\n", backends[i]->name);
+
+#ifndef NDEBUG
+            if (!common_set_registry_string(reg_path_nine,
+                    reg_key_debug_active_backend, backends[i]->name))
+            {
+                WINE_ERR("Failed to set registry key %s\n",
+                        reg_key_debug_active_backend);
+            }
+#endif
+
+            dri_backend->funcs = backends[i];
+            return dri_backend;
+        }
+
+        WINE_ERR("Error creating backend %s\n", backends[i]->name);
+    }
+
+    HeapFree(GetProcessHeap(), 0, dri_backend);
+    return NULL;
+}
+
+void backend_destroy(struct dri_backend *dri_backend)
+{
+    WINE_TRACE("dri_backend=%p\n", dri_backend);
+
+    if (!dri_backend)
+        return;
+
+    if (dri_backend->priv)
+        dri_backend->funcs->destroy(dri_backend->priv);
+
+    HeapFree(GetProcessHeap(), 0, dri_backend);
+}
diff -purN a/dlls/d3d9-nine/backend.h b/dlls/d3d9-nine/backend.h
--- a/dlls/d3d9-nine/backend.h	1970-01-01 03:00:00.000000000 +0300
+++ b/dlls/d3d9-nine/backend.h	2019-09-12 21:01:47.923318961 +0300
@@ -0,0 +1,57 @@
+/* SPDX-License-Identifier: LGPL-2.1-or-later */
+/*
+ * Wine D3D9 DRI backend interface
+ *
+ * Copyright 2019 Patrick Rudolph
+ */
+
+#ifndef __NINE_BACKEND_H
+#define __NINE_BACKEND_H
+
+#include <X11/Xlib.h>
+
+struct dri_backend_priv;
+struct buffer_priv;
+struct PRESENTpriv;
+struct PRESENTPixmapPriv;
+typedef struct PRESENTPriv PRESENTpriv;
+typedef struct PRESENTPixmapPriv PRESENTPixmapPriv;
+
+struct D3DWindowBuffer
+{
+    PRESENTPixmapPriv *present_pixmap_priv;
+    struct buffer_priv *priv; /* backend private data */
+};
+
+struct dri_backend_funcs {
+    const char * const name;
+
+    BOOL (*probe)(Display *dpy);
+
+    BOOL (*create)(Display *dpy, int screen, struct dri_backend_priv **priv);
+    void (*destroy)(struct dri_backend_priv *priv);
+
+    BOOL (*init)(struct dri_backend_priv *priv);
+    void (*deinit)(struct dri_backend_priv *priv);
+    int (*get_fd)(struct dri_backend_priv *priv);
+
+    BOOL (*window_buffer_from_dmabuf)(struct dri_backend_priv *priv,
+        PRESENTpriv *present_priv, int fd, int width, int height,
+        int stride, int depth, int bpp, struct D3DWindowBuffer **out);
+    BOOL (*copy_front)(PRESENTPixmapPriv *present_pixmap_priv);
+
+    BOOL (*present_pixmap)(struct dri_backend_priv *priv, struct buffer_priv *buffer_priv);
+    void (*destroy_pixmap)(struct dri_backend_priv *priv, struct buffer_priv *buffer_priv);
+};
+
+struct dri_backend {
+    const struct dri_backend_funcs *funcs;
+    struct dri_backend_priv *priv; /* backend private data */
+};
+
+BOOL backend_probe(Display *dpy);
+
+struct dri_backend *backend_create(Display *dpy, int screen);
+void backend_destroy(struct dri_backend *dri_backend);
+
+#endif /* __NINE_BACKEND_H */
diff -purN a/dlls/d3d9-nine/d3d9_main.c b/dlls/d3d9-nine/d3d9_main.c
--- a/dlls/d3d9-nine/d3d9_main.c	1970-01-01 03:00:00.000000000 +0300
+++ b/dlls/d3d9-nine/d3d9_main.c	2019-09-12 21:01:47.923318961 +0300
@@ -0,0 +1,158 @@
+/* SPDX-License-Identifier: LGPL-2.1-or-later */
+/*
+ * Direct3D 9
+ *
+ * Copyright 2002-2003 Jason Edmeades
+ * Copyright 2002-2003 Raphael Junqueira
+ * Copyright 2005 Oliver Stieber
+ * Copyright 2015 Patrick Rudolph
+ */
+
+#include <config.h>
+#include <d3d9.h>
+#include <wine/debug.h>
+#include <fcntl.h>
+
+#include "d3dadapter9.h"
+#include "wndproc.h"
+#include "shader_validator.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(d3d9nine);
+
+static int D3DPERF_event_level = 0;
+static Display *gdi_display;
+
+void WINAPI DebugSetMute(void)
+{
+    /* nothing to do */
+}
+
+IDirect3D9 * WINAPI DECLSPEC_HOTPATCH Direct3DCreate9(UINT sdk_version)
+{
+    IDirect3D9 *native;
+    WINE_TRACE("sdk_version %#x.\n", sdk_version);
+
+    if (SUCCEEDED(d3dadapter9_new(gdi_display, FALSE, (IDirect3D9Ex **)&native)))
+        return native;
+
+    return NULL;
+}
+
+HRESULT WINAPI DECLSPEC_HOTPATCH Direct3DCreate9Ex(UINT sdk_version, IDirect3D9Ex **d3d9ex)
+{
+    WINE_TRACE("sdk_version %#x, d3d9ex %p.\n", sdk_version, d3d9ex);
+
+    return d3dadapter9_new(gdi_display, TRUE, d3d9ex);
+}
+
+/*******************************************************************
+ *       Direct3DShaderValidatorCreate9 (D3D9.@)
+ *
+ * No documentation available for this function.
+ * SDK only says it is internal and shouldn't be used.
+ */
+
+void* WINAPI Direct3DShaderValidatorCreate9(void)
+{
+    IDirect3DShaderValidator9Impl* object =
+            HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
+                    sizeof(IDirect3DShaderValidator9Impl));
+
+    object->lpVtbl = &IDirect3DShaderValidator9Vtbl;
+    object->ref = 1;
+
+    WINE_TRACE("Returning interface %p\n", object);
+    return (void*) object;
+}
+
+/*******************************************************************
+ *       DllMain
+ */
+BOOL WINAPI DllMain(HINSTANCE inst, DWORD reason, void *reserved)
+{
+    switch (reason)
+    {
+        case DLL_PROCESS_ATTACH:
+            if (!(gdi_display = XOpenDisplay( NULL )))
+            {
+                WINE_ERR("Failed to open display\n");
+                return FALSE;
+            }
+
+            fcntl( ConnectionNumber(gdi_display), F_SETFD, 1 ); /* set close on exec flag */
+
+            nine_dll_init(inst);
+            break;
+        case DLL_PROCESS_DETACH:
+            if (!reserved)
+                return nine_dll_destroy(inst);
+            break;
+    }
+
+    return TRUE;
+}
+
+/***********************************************************************
+ *              D3DPERF_BeginEvent (D3D9.@)
+ */
+int WINAPI D3DPERF_BeginEvent(D3DCOLOR color, const WCHAR *name)
+{
+    WINE_TRACE("color 0x%08x, name %s.\n", color, wine_dbgstr_w(name));
+
+    return D3DPERF_event_level++;
+}
+
+/***********************************************************************
+ *              D3DPERF_EndEvent (D3D9.@)
+ */
+int WINAPI D3DPERF_EndEvent(void)
+{
+    WINE_TRACE("(void) : stub\n");
+
+    return --D3DPERF_event_level;
+}
+
+/***********************************************************************
+ *              D3DPERF_GetStatus (D3D9.@)
+ */
+DWORD WINAPI D3DPERF_GetStatus(void)
+{
+    WINE_FIXME("(void) : stub\n");
+
+    return 0;
+}
+
+/***********************************************************************
+ *              D3DPERF_SetOptions (D3D9.@)
+ *
+ */
+void WINAPI D3DPERF_SetOptions(DWORD options)
+{
+  WINE_FIXME("(%#x) : stub\n", options);
+}
+
+/***********************************************************************
+ *              D3DPERF_QueryRepeatFrame (D3D9.@)
+ */
+BOOL WINAPI D3DPERF_QueryRepeatFrame(void)
+{
+    WINE_FIXME("(void) : stub\n");
+
+    return FALSE;
+}
+
+/***********************************************************************
+ *              D3DPERF_SetMarker (D3D9.@)
+ */
+void WINAPI D3DPERF_SetMarker(D3DCOLOR color, const WCHAR *name)
+{
+    WINE_FIXME("color 0x%08x, name %s stub!\n", color, wine_dbgstr_w(name));
+}
+
+/***********************************************************************
+ *              D3DPERF_SetRegion (D3D9.@)
+ */
+void WINAPI D3DPERF_SetRegion(D3DCOLOR color, const WCHAR *name)
+{
+    WINE_FIXME("color 0x%08x, name %s stub!\n", color, wine_dbgstr_w(name));
+}
diff -purN a/dlls/d3d9-nine/d3d9-nine.spec b/dlls/d3d9-nine/d3d9-nine.spec
--- a/dlls/d3d9-nine/d3d9-nine.spec	1970-01-01 03:00:00.000000000 +0300
+++ b/dlls/d3d9-nine/d3d9-nine.spec	2019-09-12 21:01:47.923318961 +0300
@@ -0,0 +1,15 @@
+# SPDX-License-Identifier: LGPL-2.1-or-later
+@ stdcall Direct3DShaderValidatorCreate9()
+@ stub PSGPError
+@ stub PSGPSampleTexture
+@ stdcall D3DPERF_BeginEvent(long wstr)
+@ stdcall D3DPERF_EndEvent()
+@ stdcall D3DPERF_GetStatus()
+@ stdcall D3DPERF_QueryRepeatFrame()
+@ stdcall D3DPERF_SetMarker(long wstr)
+@ stdcall D3DPERF_SetOptions(long)
+@ stdcall D3DPERF_SetRegion(long wstr)
+@ stub DebugSetLevel
+@ stdcall DebugSetMute()
+@ stdcall Direct3DCreate9(long)
+@ stdcall Direct3DCreate9Ex(long ptr)
diff -purN a/dlls/d3d9-nine/d3dadapter9.c b/dlls/d3d9-nine/d3dadapter9.c
--- a/dlls/d3d9-nine/d3dadapter9.c	1970-01-01 03:00:00.000000000 +0300
+++ b/dlls/d3d9-nine/d3dadapter9.c	2019-09-12 21:01:47.923318961 +0300
@@ -0,0 +1,903 @@
+/* SPDX-License-Identifier: LGPL-2.1-or-later */
+/*
+ * Wine IDirect3D9 interface using ID3DAdapter9
+ *
+ * Copyright 2013 Joakim Sindholt
+ *                Christoph Bumiller
+ * Copyright 2014 David Heidelberger
+ * Copyright 2014-2015 Axel Davy
+ * Copyright 2015 Nick Sarnie
+ *                Patrick Rudolph
+ */
+
+#include <config.h>
+#include <d3dadapter/d3dadapter9.h>
+#include <wine/debug.h>
+
+#include "present.h"
+#include "device_wrap.h"
+#include "backend.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(d3d9nine);
+
+/* this represents a snapshot taken at the moment of creation */
+struct output
+{
+    D3DDISPLAYROTATION rotation; /* current rotation */
+    D3DDISPLAYMODEEX *modes;
+    unsigned nmodes;
+    unsigned nmodesalloc;
+    unsigned current; /* current mode num */
+
+    HMONITOR monitor;
+};
+
+struct adapter_group
+{
+    struct output *outputs;
+    unsigned noutputs;
+    unsigned noutputsalloc;
+
+    /* override driver provided DeviceName with this to homogenize device names
+     * with wine */
+    WCHAR devname[32];
+
+    /* driver stuff */
+    ID3DAdapter9 *adapter;
+    /* DRI backend */
+    struct dri_backend *dri_backend;
+};
+
+struct adapter_map
+{
+    unsigned group;
+    unsigned master;
+};
+
+struct d3dadapter9
+{
+    /* COM vtable */
+    void *vtable;
+    /* IUnknown reference count */
+    LONG refs;
+
+    /* adapter groups and mappings */
+    struct adapter_group *groups;
+    struct adapter_map *map;
+    unsigned nadapters;
+    unsigned ngroups;
+    unsigned ngroupsalloc;
+
+    /* true if it implements IDirect3D9Ex */
+    boolean ex;
+    Display *gdi_display;
+};
+
+/* convenience wrapper for calls into ID3D9Adapter */
+#define ADAPTER_GROUP \
+    This->groups[This->map[Adapter].group]
+
+#define ADAPTER_PROC(name, ...) \
+    ID3DAdapter9_##name(ADAPTER_GROUP.adapter, ## __VA_ARGS__)
+
+#define ADAPTER_OUTPUT \
+    ADAPTER_GROUP.outputs[Adapter-This->map[Adapter].master]
+
+static HRESULT WINAPI d3dadapter9_CheckDeviceFormat(struct d3dadapter9 *This,
+        UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT AdapterFormat,
+        DWORD Usage, D3DRESOURCETYPE RType, D3DFORMAT CheckFormat);
+
+static ULONG WINAPI d3dadapter9_AddRef(struct d3dadapter9 *This)
+{
+    ULONG refs = InterlockedIncrement(&This->refs);
+    WINE_TRACE("%p increasing refcount to %u.\n", This, refs);
+    return refs;
+}
+
+static ULONG WINAPI d3dadapter9_Release(struct d3dadapter9 *This)
+{
+    ULONG refs = InterlockedDecrement(&This->refs);
+    WINE_TRACE("%p decreasing refcount to %u.\n", This, refs);
+    if (refs == 0)
+    {
+        /* dtor */
+        if (This->map)
+        {
+            HeapFree(GetProcessHeap(), 0, This->map);
+        }
+
+        if (This->groups)
+        {
+            int i, j;
+            for (i = 0; i < This->ngroups; ++i)
+            {
+                if (This->groups[i].outputs)
+                {
+                    for (j = 0; j < This->groups[i].noutputs; ++j)
+                    {
+                        if (This->groups[i].outputs[j].modes)
+                        {
+                            HeapFree(GetProcessHeap(), 0,
+                                     This->groups[i].outputs[j].modes);
+                        }
+                    }
+                    HeapFree(GetProcessHeap(), 0, This->groups[i].outputs);
+                }
+
+                if (This->groups[i].adapter)
+                    ID3DAdapter9_Release(This->groups[i].adapter);
+
+                backend_destroy(This->groups[i].dri_backend);
+            }
+            HeapFree(GetProcessHeap(), 0, This->groups);
+        }
+
+        HeapFree(GetProcessHeap(), 0, This);
+    }
+    return refs;
+}
+
+static HRESULT WINAPI d3dadapter9_QueryInterface(struct d3dadapter9 *This,
+        REFIID riid, void **ppvObject)
+{
+    if (!ppvObject)
+        return E_POINTER;
+
+    if ((IsEqualGUID(&IID_IDirect3D9Ex, riid) && This->ex) ||
+            IsEqualGUID(&IID_IDirect3D9, riid) ||
+            IsEqualGUID(&IID_IUnknown, riid))
+    {
+        *ppvObject = This;
+        d3dadapter9_AddRef(This);
+        return S_OK;
+    }
+
+    WINE_WARN("%s not implemented, returning E_NOINTERFACE.\n", wine_dbgstr_guid(riid));
+    *ppvObject = NULL;
+
+    return E_NOINTERFACE;
+}
+
+static HRESULT WINAPI d3dadapter9_RegisterSoftwareDevice(struct d3dadapter9 *This,
+        void *pInitializeFunction)
+{
+    WINE_FIXME("(%p, %p), stub!\n", This, pInitializeFunction);
+    return D3DERR_INVALIDCALL;
+}
+
+static UINT WINAPI d3dadapter9_GetAdapterCount(struct d3dadapter9 *This)
+{
+    return This->nadapters;
+}
+
+static HRESULT WINAPI d3dadapter9_GetAdapterIdentifier(struct d3dadapter9 *This,
+        UINT Adapter, DWORD Flags, D3DADAPTER_IDENTIFIER9 *pIdentifier)
+{
+    HRESULT hr;
+    HKEY regkey;
+
+    if (Adapter >= d3dadapter9_GetAdapterCount(This))
+        return D3DERR_INVALIDCALL;
+
+    hr = ADAPTER_PROC(GetAdapterIdentifier, Flags, pIdentifier);
+    if (SUCCEEDED(hr))
+    {
+        /* Override the driver provided DeviceName with what Wine provided */
+        ZeroMemory(pIdentifier->DeviceName, sizeof(pIdentifier->DeviceName));
+        if (!WideCharToMultiByte(CP_ACP, 0, ADAPTER_GROUP.devname, -1,
+                pIdentifier->DeviceName, sizeof(pIdentifier->DeviceName), NULL, NULL))
+            return D3DERR_INVALIDCALL;
+
+        WINE_TRACE("DeviceName overriden: %s\n", pIdentifier->DeviceName);
+
+        /* Override PCI IDs when wined3d registry keys are set */
+        if (!RegOpenKeyA(HKEY_CURRENT_USER, "Software\\Wine\\Direct3DNine", &regkey))
+        {
+            DWORD type, data;
+            DWORD size = sizeof(DWORD);
+
+            if (!RegQueryValueExA(regkey, "VideoPciDeviceID", 0, &type, (BYTE *)&data, &size) &&
+                    (type == REG_DWORD) && (size == sizeof(DWORD)))
+                pIdentifier->DeviceId = data;
+            if (size != sizeof(DWORD))
+            {
+                WINE_ERR("VideoPciDeviceID is not a DWORD\n");
+                size = sizeof(DWORD);
+            }
+            if (!RegQueryValueExA(regkey, "VideoPciVendorID", 0, &type, (BYTE *)&data, &size) &&
+                    (type == REG_DWORD) && (size == sizeof(DWORD)))
+                pIdentifier->VendorId = data;
+            if (size != sizeof(DWORD))
+                WINE_ERR("VideoPciVendorID is not a DWORD\n");
+            RegCloseKey(regkey);
+
+            WINE_TRACE("DeviceId:VendorId overridden: %04X:%04X\n", pIdentifier->DeviceId, pIdentifier->VendorId);
+        }
+    }
+    return hr;
+}
+
+static UINT WINAPI d3dadapter9_GetAdapterModeCount(struct d3dadapter9 *This,
+        UINT Adapter, D3DFORMAT Format)
+{
+    if (Adapter >= d3dadapter9_GetAdapterCount(This))
+        return D3DERR_INVALIDCALL;
+
+    if (FAILED(d3dadapter9_CheckDeviceFormat(This, Adapter, D3DDEVTYPE_HAL,
+            Format, D3DUSAGE_RENDERTARGET, D3DRTYPE_SURFACE, Format)))
+    {
+        WINE_WARN("DeviceFormat not available.\n");
+        return 0;
+    }
+
+    WINE_TRACE("%u modes.\n", ADAPTER_OUTPUT.nmodes);
+    return ADAPTER_OUTPUT.nmodes;
+}
+
+static HRESULT WINAPI d3dadapter9_EnumAdapterModes(struct d3dadapter9 *This,
+        UINT Adapter, D3DFORMAT Format, UINT Mode, D3DDISPLAYMODE *pMode)
+{
+    HRESULT hr;
+
+    if (Adapter >= d3dadapter9_GetAdapterCount(This))
+        return D3DERR_INVALIDCALL;
+
+    hr = d3dadapter9_CheckDeviceFormat(This, Adapter, D3DDEVTYPE_HAL,
+            Format, D3DUSAGE_RENDERTARGET, D3DRTYPE_SURFACE, Format);
+
+    if (FAILED(hr))
+    {
+        WINE_TRACE("DeviceFormat not available.\n");
+        return hr;
+    }
+
+    if (Mode >= ADAPTER_OUTPUT.nmodes)
+    {
+        WINE_WARN("Mode %u does not exist.\n", Mode);
+        return D3DERR_INVALIDCALL;
+    }
+
+    pMode->Width = ADAPTER_OUTPUT.modes[Mode].Width;
+    pMode->Height = ADAPTER_OUTPUT.modes[Mode].Height;
+    pMode->RefreshRate = ADAPTER_OUTPUT.modes[Mode].RefreshRate;
+    pMode->Format = Format;
+
+    return D3D_OK;
+}
+
+static HRESULT WINAPI d3dadapter9_GetAdapterDisplayMode(struct d3dadapter9 *This,
+        UINT Adapter, D3DDISPLAYMODE *pMode)
+{
+    UINT Mode;
+
+    if (Adapter >= d3dadapter9_GetAdapterCount(This))
+        return D3DERR_INVALIDCALL;
+
+    Mode = ADAPTER_OUTPUT.current;
+    pMode->Width = ADAPTER_OUTPUT.modes[Mode].Width;
+    pMode->Height = ADAPTER_OUTPUT.modes[Mode].Height;
+    pMode->RefreshRate = ADAPTER_OUTPUT.modes[Mode].RefreshRate;
+    pMode->Format = ADAPTER_OUTPUT.modes[Mode].Format;
+
+    return D3D_OK;
+}
+
+static HRESULT WINAPI d3dadapter9_CheckDeviceType(struct d3dadapter9 *This,
+        UINT Adapter, D3DDEVTYPE DevType, D3DFORMAT AdapterFormat,
+        D3DFORMAT BackBufferFormat, BOOL bWindowed)
+{
+    if (Adapter >= d3dadapter9_GetAdapterCount(This))
+        return D3DERR_INVALIDCALL;
+
+    return ADAPTER_PROC(CheckDeviceType,
+            DevType, AdapterFormat, BackBufferFormat, bWindowed);
+}
+
+static HRESULT WINAPI d3dadapter9_CheckDeviceFormat(struct d3dadapter9 *This,
+        UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT AdapterFormat,
+        DWORD Usage, D3DRESOURCETYPE RType, D3DFORMAT CheckFormat)
+{
+    if (Adapter >= d3dadapter9_GetAdapterCount(This))
+        return D3DERR_INVALIDCALL;
+
+    return ADAPTER_PROC(CheckDeviceFormat,
+             DeviceType, AdapterFormat, Usage, RType, CheckFormat);
+}
+
+static HRESULT WINAPI d3dadapter9_CheckDeviceMultiSampleType(struct d3dadapter9 *This,
+        UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT SurfaceFormat,
+        BOOL Windowed, D3DMULTISAMPLE_TYPE MultiSampleType, DWORD *pQualityLevels)
+{
+    if (Adapter >= d3dadapter9_GetAdapterCount(This))
+        return D3DERR_INVALIDCALL;
+
+    return ADAPTER_PROC(CheckDeviceMultiSampleType, DeviceType, SurfaceFormat,
+            Windowed, MultiSampleType, pQualityLevels);
+}
+
+static HRESULT WINAPI d3dadapter9_CheckDepthStencilMatch(struct d3dadapter9 *This,
+        UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT AdapterFormat,
+        D3DFORMAT RenderTargetFormat, D3DFORMAT DepthStencilFormat)
+{
+    if (Adapter >= d3dadapter9_GetAdapterCount(This))
+        return D3DERR_INVALIDCALL;
+
+    return ADAPTER_PROC(CheckDepthStencilMatch, DeviceType, AdapterFormat,
+            RenderTargetFormat, DepthStencilFormat);
+}
+
+static HRESULT WINAPI d3dadapter9_CheckDeviceFormatConversion(struct d3dadapter9 *This,
+        UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT SourceFormat, D3DFORMAT TargetFormat)
+{
+    if (Adapter >= d3dadapter9_GetAdapterCount(This))
+        return D3DERR_INVALIDCALL;
+
+    return ADAPTER_PROC(CheckDeviceFormatConversion,
+            DeviceType, SourceFormat, TargetFormat);
+}
+
+static HRESULT WINAPI d3dadapter9_GetDeviceCaps(struct d3dadapter9 *This,
+        UINT Adapter, D3DDEVTYPE DeviceType, D3DCAPS9 *pCaps)
+{
+    HRESULT hr;
+
+    if (Adapter >= d3dadapter9_GetAdapterCount(This))
+        return D3DERR_INVALIDCALL;
+
+    hr = ADAPTER_PROC(GetDeviceCaps, DeviceType, pCaps);
+    if (FAILED(hr))
+        return hr;
+
+    pCaps->MasterAdapterOrdinal = This->map[Adapter].master;
+    pCaps->AdapterOrdinalInGroup = Adapter-This->map[Adapter].master;
+    pCaps->NumberOfAdaptersInGroup = ADAPTER_GROUP.noutputs;
+
+    return hr;
+}
+
+static HMONITOR WINAPI d3dadapter9_GetAdapterMonitor(struct d3dadapter9 *This,
+        UINT Adapter)
+{
+    if (Adapter >= d3dadapter9_GetAdapterCount(This))
+        return (HMONITOR)0;
+
+    return (HMONITOR)ADAPTER_OUTPUT.monitor;
+}
+
+static HRESULT WINAPI DECLSPEC_HOTPATCH d3dadapter9_CreateDeviceEx(struct d3dadapter9 *This,
+        UINT Adapter, D3DDEVTYPE DeviceType, HWND hFocusWindow, DWORD BehaviorFlags,
+        D3DPRESENT_PARAMETERS *pPresentationParameters,
+        D3DDISPLAYMODEEX *pFullscreenDisplayMode,
+        IDirect3DDevice9Ex **ppReturnedDeviceInterface);
+
+static HRESULT WINAPI DECLSPEC_HOTPATCH d3dadapter9_CreateDevice(struct d3dadapter9 *This,
+        UINT Adapter, D3DDEVTYPE DeviceType, HWND hFocusWindow, DWORD BehaviorFlags,
+        D3DPRESENT_PARAMETERS *pPresentationParameters,
+        IDirect3DDevice9 **ppReturnedDeviceInterface)
+{
+    HRESULT hr;
+    hr = d3dadapter9_CreateDeviceEx(This, Adapter, DeviceType, hFocusWindow,
+            BehaviorFlags, pPresentationParameters, NULL,
+            (IDirect3DDevice9Ex **)ppReturnedDeviceInterface);
+    if (FAILED(hr))
+        return hr;
+
+    return D3D_OK;
+}
+
+static UINT WINAPI d3dadapter9_GetAdapterModeCountEx(struct d3dadapter9 *This,
+        UINT Adapter, const D3DDISPLAYMODEFILTER *pFilter)
+{
+    WINE_FIXME("(%p, %u, %p), half stub!\n", This, Adapter, pFilter);
+    return d3dadapter9_GetAdapterModeCount(This, Adapter, pFilter->Format);
+}
+
+static HRESULT WINAPI d3dadapter9_EnumAdapterModesEx(struct d3dadapter9 *This,
+        UINT Adapter, const D3DDISPLAYMODEFILTER *pFilter, UINT Mode,
+        D3DDISPLAYMODEEX *pMode)
+{
+    HRESULT hr;
+
+    WINE_FIXME("(%p, %u, %p, %u, %p), half stub!\n", This, Adapter, pFilter, Mode, pMode);
+
+    if (Adapter >= d3dadapter9_GetAdapterCount(This))
+        return D3DERR_INVALIDCALL;
+
+    hr = d3dadapter9_CheckDeviceFormat(This, Adapter, D3DDEVTYPE_HAL,
+            pFilter->Format, D3DUSAGE_RENDERTARGET, D3DRTYPE_SURFACE, pFilter->Format);
+
+    if (FAILED(hr))
+    {
+        WINE_TRACE("DeviceFormat not available.\n");
+        return hr;
+    }
+
+    if (Mode >= ADAPTER_OUTPUT.nmodes)
+    {
+        WINE_WARN("Mode %u does not exist.\n", Mode);
+        return D3DERR_INVALIDCALL;
+    }
+
+    pMode->Size = ADAPTER_OUTPUT.modes[Mode].Size;
+    pMode->Width = ADAPTER_OUTPUT.modes[Mode].Width;
+    pMode->Height = ADAPTER_OUTPUT.modes[Mode].Height;
+    pMode->RefreshRate = ADAPTER_OUTPUT.modes[Mode].RefreshRate;
+    pMode->Format = ADAPTER_OUTPUT.modes[Mode].Format;
+    pMode->ScanLineOrdering = ADAPTER_OUTPUT.modes[Mode].ScanLineOrdering;
+
+    return D3D_OK;
+}
+
+static HRESULT WINAPI d3dadapter9_GetAdapterDisplayModeEx(struct d3dadapter9 *This,
+        UINT Adapter, D3DDISPLAYMODEEX *pMode, D3DDISPLAYROTATION *pRotation)
+{
+    UINT Mode;
+
+    if (Adapter >= d3dadapter9_GetAdapterCount(This))
+        return D3DERR_INVALIDCALL;
+
+    if (pMode)
+    {
+        Mode = ADAPTER_OUTPUT.current;
+        pMode->Size = sizeof(D3DDISPLAYMODEEX);
+        pMode->Width = ADAPTER_OUTPUT.modes[Mode].Width;
+        pMode->Height = ADAPTER_OUTPUT.modes[Mode].Height;
+        pMode->RefreshRate = ADAPTER_OUTPUT.modes[Mode].RefreshRate;
+        pMode->Format = ADAPTER_OUTPUT.modes[Mode].Format;
+        pMode->ScanLineOrdering = ADAPTER_OUTPUT.modes[Mode].ScanLineOrdering;
+    }
+    if (pRotation)
+        *pRotation = ADAPTER_OUTPUT.rotation;
+
+    return D3D_OK;
+}
+
+static HRESULT WINAPI DECLSPEC_HOTPATCH d3dadapter9_CreateDeviceEx(struct d3dadapter9 *This,
+        UINT Adapter, D3DDEVTYPE DeviceType, HWND hFocusWindow, DWORD BehaviorFlags,
+        D3DPRESENT_PARAMETERS *pPresentationParameters,
+        D3DDISPLAYMODEEX *pFullscreenDisplayMode,
+        IDirect3DDevice9Ex **ppReturnedDeviceInterface)
+{
+    ID3DPresentGroup *present;
+    HRESULT hr;
+
+    if (Adapter >= d3dadapter9_GetAdapterCount(This))
+        return D3DERR_INVALIDCALL;
+
+    {
+        struct adapter_group *group = &ADAPTER_GROUP;
+        unsigned nparams, ordinal;
+
+        if (BehaviorFlags & D3DCREATE_ADAPTERGROUP_DEVICE)
+        {
+            nparams = group->noutputs;
+            ordinal = 0;
+        }
+        else
+        {
+            nparams = 1;
+            ordinal = Adapter - This->map[Adapter].master;
+        }
+        hr = present_create_present_group(This->gdi_display, group->devname, ordinal,
+                hFocusWindow, pPresentationParameters, nparams, &present, This->ex,
+                BehaviorFlags, group->dri_backend);
+    }
+
+    if (FAILED(hr))
+    {
+        WINE_WARN("Failed to create PresentGroup.\n");
+        return hr;
+    }
+
+    if (This->ex)
+    {
+        hr = ADAPTER_PROC(CreateDeviceEx, Adapter, DeviceType, hFocusWindow,
+                BehaviorFlags, pPresentationParameters, pFullscreenDisplayMode,
+                (IDirect3D9Ex *)This, present, ppReturnedDeviceInterface);
+    }
+    else
+    {
+        /* CreateDevice on non-ex */
+        hr = ADAPTER_PROC(CreateDevice, Adapter, DeviceType, hFocusWindow,
+                BehaviorFlags, pPresentationParameters, (IDirect3D9 *)This, present,
+                (IDirect3DDevice9 **)ppReturnedDeviceInterface);
+    }
+    if (FAILED(hr))
+    {
+        WINE_WARN("ADAPTER_PROC failed.\n");
+        ID3DPresentGroup_Release(present);
+        return hr;
+    }
+
+    /* Nine returns different vtables for Ex, non Ex and
+     * if you use the multithread flag or not. This prevents
+     * things like Steam overlay to work, in addition to the problem
+     * that functions nine side are not recognized by wine as
+     * hotpatch-able. If possible, we use our vtable wrapper,
+     * which solves the problem described above. */
+    if (enable_device_vtable_wrapper())
+        (*ppReturnedDeviceInterface)->lpVtbl = get_device_vtable();
+    return hr;
+}
+
+static HRESULT WINAPI d3dadapter9_GetAdapterLUID(struct d3dadapter9 *This,
+        UINT Adapter, LUID *pLUID)
+{
+    WINE_FIXME("(%p, %u, %p), stub!\n", This, Adapter, pLUID);
+    return D3DERR_INVALIDCALL;
+}
+
+static struct adapter_group *add_group(struct d3dadapter9 *This)
+{
+    if (This->ngroups >= This->ngroupsalloc)
+    {
+        void *r;
+
+        if (This->ngroupsalloc == 0)
+        {
+            This->ngroupsalloc = 2;
+            r = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
+                    This->ngroupsalloc*sizeof(struct adapter_group));
+        }
+        else
+        {
+            This->ngroupsalloc <<= 1;
+            r = HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, This->groups,
+                    This->ngroupsalloc*sizeof(struct adapter_group));
+        }
+
+        if (!r)
+            return NULL;
+        This->groups = r;
+    }
+
+    return &This->groups[This->ngroups++];
+}
+
+static void remove_group(struct d3dadapter9 *This)
+{
+    struct adapter_group *group = &This->groups[This->ngroups-1];
+    int i;
+
+    for (i = 0; i < group->noutputs; ++i)
+    {
+        HeapFree(GetProcessHeap(), 0, group->outputs[i].modes);
+    }
+    HeapFree(GetProcessHeap(), 0, group->outputs);
+
+    backend_destroy(group->dri_backend);
+
+    ZeroMemory(group, sizeof(struct adapter_group));
+    This->ngroups--;
+}
+
+static struct output *add_output(struct d3dadapter9 *This)
+{
+    struct adapter_group *group = &This->groups[This->ngroups-1];
+
+    if (group->noutputs >= group->noutputsalloc)
+    {
+        void *r;
+
+        if (group->noutputsalloc == 0)
+        {
+            group->noutputsalloc = 2;
+            r = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
+                    group->noutputsalloc*sizeof(struct output));
+        }
+        else
+        {
+            group->noutputsalloc <<= 1;
+            r = HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, group->outputs,
+                    group->noutputsalloc*sizeof(struct output));
+        }
+
+        if (!r)
+            return NULL;
+        group->outputs = r;
+    }
+
+    return &group->outputs[group->noutputs++];
+}
+
+static void remove_output(struct d3dadapter9 *This)
+{
+    struct adapter_group *group = &This->groups[This->ngroups-1];
+    struct output *out = &group->outputs[group->noutputs-1];
+
+    HeapFree(GetProcessHeap(), 0, out->modes);
+
+    ZeroMemory(out, sizeof(struct output));
+    group->noutputs--;
+}
+
+static D3DDISPLAYMODEEX *add_mode(struct d3dadapter9 *This)
+{
+    struct adapter_group *group = &This->groups[This->ngroups-1];
+    struct output *out = &group->outputs[group->noutputs-1];
+
+    if (out->nmodes >= out->nmodesalloc)
+    {
+        void *r;
+
+        if (out->nmodesalloc == 0)
+        {
+            out->nmodesalloc = 8;
+            r = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
+                    out->nmodesalloc*sizeof(struct D3DDISPLAYMODEEX));
+        }
+        else
+        {
+            out->nmodesalloc <<= 1;
+            r = HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, out->modes,
+                    out->nmodesalloc*sizeof(struct D3DDISPLAYMODEEX));
+        }
+
+        if (!r)
+            return NULL;
+        out->modes = r;
+    }
+
+    return &out->modes[out->nmodes++];
+}
+
+static void remove_mode(struct d3dadapter9 *This)
+{
+    struct adapter_group *group = &This->groups[This->ngroups-1];
+    struct output *out = &group->outputs[group->noutputs-1];
+    out->nmodes--;
+}
+
+static HRESULT fill_groups(struct d3dadapter9 *This)
+{
+    DISPLAY_DEVICEW dd;
+    DEVMODEW dm;
+    POINT pt;
+    HDC hdc;
+    HRESULT hr;
+    int i, j, k;
+
+    const WCHAR wdisp[] = {'D','I','S','P','L','A','Y',0};
+
+    ZeroMemory(&dd, sizeof(dd));
+    ZeroMemory(&dm, sizeof(dm));
+    dd.cb = sizeof(dd);
+    dm.dmSize = sizeof(dm);
+
+    for (i = 0; EnumDisplayDevicesW(NULL, i, &dd, 0); ++i)
+    {
+        struct adapter_group *group = add_group(This);
+        if (!group)
+        {
+            WINE_ERR("Out of memory.\n");
+            return E_OUTOFMEMORY;
+        }
+
+        hdc = CreateDCW(wdisp, dd.DeviceName, NULL, NULL);
+        if (!hdc)
+        {
+            remove_group(This);
+            WINE_WARN("Unable to create DC for display %d.\n", i);
+            goto end_group;
+        }
+
+        group->dri_backend = backend_create(This->gdi_display, DefaultScreen(This->gdi_display));
+        if (!group->dri_backend)
+        {
+            WINE_ERR("Unable to open backend for display %d.\n", i);
+            goto end_group;
+        }
+
+        hr = present_create_adapter9(This->gdi_display, hdc, group->dri_backend,
+               &group->adapter);
+
+        DeleteDC(hdc);
+        if (FAILED(hr))
+        {
+            remove_group(This);
+            goto end_group;
+        }
+
+        CopyMemory(group->devname, dd.DeviceName, sizeof(group->devname));
+        for (j = 0; EnumDisplayDevicesW(group->devname, j, &dd, 0); ++j)
+        {
+            struct output *out = add_output(This);
+            boolean orient = FALSE, monit = FALSE;
+            if (!out)
+            {
+                WINE_ERR("Out of memory.\n");
+                return E_OUTOFMEMORY;
+            }
+
+            for (k = 0; EnumDisplaySettingsExW(dd.DeviceName, k, &dm, 0); ++k)
+            {
+                D3DDISPLAYMODEEX *mode = add_mode(This);
+                if (!out)
+                {
+                    WINE_ERR("Out of memory.\n");
+                    return E_OUTOFMEMORY;
+                }
+
+                mode->Size = sizeof(D3DDISPLAYMODEEX);
+                mode->Width = dm.dmPelsWidth;
+                mode->Height = dm.dmPelsHeight;
+                mode->RefreshRate = dm.dmDisplayFrequency;
+                mode->ScanLineOrdering =
+                        (dm.dmDisplayFlags & DM_INTERLACED) ?
+                        D3DSCANLINEORDERING_INTERLACED :
+                        D3DSCANLINEORDERING_PROGRESSIVE;
+
+                switch (dm.dmBitsPerPel)
+                {
+                    case 32: mode->Format = D3DFMT_X8R8G8B8; break;
+                    case 24: mode->Format = D3DFMT_R8G8B8; break;
+                    case 16: mode->Format = D3DFMT_R5G6B5; break;
+                    case 8:
+                        remove_mode(This);
+                        goto end_mode;
+
+                    default:
+                        remove_mode(This);
+                        WINE_WARN("Unknown format (%u bpp) in display %d, monitor "
+                                "%d, mode %d.\n", dm.dmBitsPerPel, i, j, k);
+                        goto end_mode;
+                }
+
+                if (!orient)
+                {
+                    switch (dm.dmDisplayOrientation)
+                    {
+                        case DMDO_DEFAULT:
+                            out->rotation = D3DDISPLAYROTATION_IDENTITY;
+                            break;
+
+                        case DMDO_90:
+                            out->rotation = D3DDISPLAYROTATION_90;
+                            break;
+
+                        case DMDO_180:
+                            out->rotation = D3DDISPLAYROTATION_180;
+                            break;
+
+                        case DMDO_270:
+                            out->rotation = D3DDISPLAYROTATION_270;
+                            break;
+
+                        default:
+                            remove_output(This);
+                            WINE_WARN("Unknown display rotation in display %d, "
+                                    "monitor %d\n", i, j);
+                            goto end_output;
+                    }
+                    orient = TRUE;
+                }
+
+                if (!monit)
+                {
+                    pt.x = dm.dmPosition.x;
+                    pt.y = dm.dmPosition.y;
+                    out->monitor = MonitorFromPoint(pt, 0);
+                    if (!out->monitor)
+                    {
+                        remove_output(This);
+                        WINE_WARN("Unable to get monitor handle for display %d, "
+                                "monitor %d.\n", i, j);
+                        goto end_output;
+                    }
+                    monit = TRUE;
+                }
+
+end_mode:
+                ZeroMemory(&dm, sizeof(dm));
+                dm.dmSize = sizeof(dm);
+            }
+
+end_output:
+            ZeroMemory(&dd, sizeof(dd));
+            dd.cb = sizeof(dd);
+        }
+
+end_group:
+        ZeroMemory(&dd, sizeof(dd));
+        dd.cb = sizeof(dd);
+    }
+
+    return D3D_OK;
+}
+
+static IDirect3D9ExVtbl d3dadapter9_vtable = {
+    (void *)d3dadapter9_QueryInterface,
+    (void *)d3dadapter9_AddRef,
+    (void *)d3dadapter9_Release,
+    (void *)d3dadapter9_RegisterSoftwareDevice,
+    (void *)d3dadapter9_GetAdapterCount,
+    (void *)d3dadapter9_GetAdapterIdentifier,
+    (void *)d3dadapter9_GetAdapterModeCount,
+    (void *)d3dadapter9_EnumAdapterModes,
+    (void *)d3dadapter9_GetAdapterDisplayMode,
+    (void *)d3dadapter9_CheckDeviceType,
+    (void *)d3dadapter9_CheckDeviceFormat,
+    (void *)d3dadapter9_CheckDeviceMultiSampleType,
+    (void *)d3dadapter9_CheckDepthStencilMatch,
+    (void *)d3dadapter9_CheckDeviceFormatConversion,
+    (void *)d3dadapter9_GetDeviceCaps,
+    (void *)d3dadapter9_GetAdapterMonitor,
+    (void *)d3dadapter9_CreateDevice,
+    (void *)d3dadapter9_GetAdapterModeCountEx,
+    (void *)d3dadapter9_EnumAdapterModesEx,
+    (void *)d3dadapter9_GetAdapterDisplayModeEx,
+    (void *)d3dadapter9_CreateDeviceEx,
+    (void *)d3dadapter9_GetAdapterLUID
+};
+
+HRESULT d3dadapter9_new(Display *gdi_display, boolean ex, IDirect3D9Ex **ppOut)
+{
+    struct d3dadapter9 *This;
+    HRESULT hr;
+    unsigned i, j, k;
+
+    This = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(struct d3dadapter9));
+    if (!This)
+    {
+        WINE_ERR("Out of memory.\n");
+        return E_OUTOFMEMORY;
+    }
+
+    This->vtable = &d3dadapter9_vtable;
+    This->refs = 1;
+    This->ex = ex;
+    This->gdi_display = gdi_display;
+
+    if (!present_has_d3dadapter(gdi_display))
+    {
+        WINE_ERR("Your display driver doesn't support native D3D9 adapters.\n");
+        d3dadapter9_Release(This);
+        return D3DERR_NOTAVAILABLE;
+    }
+
+    if (FAILED(hr = fill_groups(This)))
+    {
+        d3dadapter9_Release(This);
+        return hr;
+    }
+
+    /* map absolute adapter IDs with internal adapters */
+    for (i = 0; i < This->ngroups; ++i)
+    {
+        for (j = 0; j < This->groups[i].noutputs; ++j)
+        {
+            This->nadapters++;
+        }
+    }
+    if (This->nadapters == 0)
+    {
+        WINE_ERR("No available native adapters in system.\n");
+        d3dadapter9_Release(This);
+        return D3DERR_NOTAVAILABLE;
+    }
+
+    This->map = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
+            This->nadapters * sizeof(struct adapter_map));
+
+    if (!This->map)
+    {
+        d3dadapter9_Release(This);
+        WINE_ERR("Out of memory.\n");
+        return E_OUTOFMEMORY;
+    }
+    for (i = k = 0; i < This->ngroups; ++i)
+    {
+        for (j = 0; j < This->groups[i].noutputs; ++j, ++k)
+        {
+            This->map[k].master = k-j;
+            This->map[k].group = i;
+        }
+    }
+
+    *ppOut = (IDirect3D9Ex *)This;
+
+    wine_dbg_printf("\033[1;32mNative Direct3D 9 " NINE_VERSION " is active.\n"
+                    "For more information visit " NINE_URL "\033[0m\n");
+
+    return D3D_OK;
+}
diff -purN a/dlls/d3d9-nine/d3dadapter9.h b/dlls/d3d9-nine/d3dadapter9.h
--- a/dlls/d3d9-nine/d3dadapter9.h	1970-01-01 03:00:00.000000000 +0300
+++ b/dlls/d3d9-nine/d3dadapter9.h	2019-09-12 21:01:47.923318961 +0300
@@ -0,0 +1,24 @@
+/* SPDX-License-Identifier: LGPL-2.1-or-later */
+/*
+ * D3DAdapter9 interface
+ *
+ * Copyright 2015 Patrick Rudolph
+ */
+
+#ifndef __NINE_D3D9ADAPTER_H
+#define __NINE_D3D9ADAPTER_H
+
+#include <d3d9.h>
+#include <X11/Xlib.h>
+
+#ifndef DECLSPEC_HOTPATCH
+#define DECLSPEC_HOTPATCH __attribute__((__ms_hook_prologue__))
+#endif
+
+void d3dadapter9_init(HINSTANCE hinst);
+
+void d3dadapter9_destroy(HINSTANCE hinst);
+
+HRESULT d3dadapter9_new(Display *gdi_display, boolean ex, IDirect3D9Ex **ppOut);
+
+#endif /* __NINE_D3D9ADAPTER_H */
diff -purN a/dlls/d3d9-nine/device_wrap.c b/dlls/d3d9-nine/device_wrap.c
--- a/dlls/d3d9-nine/device_wrap.c	1970-01-01 03:00:00.000000000 +0300
+++ b/dlls/d3d9-nine/device_wrap.c	2019-09-12 21:01:47.923318961 +0300
@@ -0,0 +1,484 @@
+/* SPDX-License-Identifier: LGPL-2.1-or-later */
+/*
+ * Copyright 2016 Axel Davy
+ */
+
+#include <config.h>
+#include <d3d9.h>
+
+#include "device_wrap.h"
+
+struct IDirect3DDevice9Ex_Minor1
+{
+        IDirect3DDevice9ExVtbl *lpVtbl;
+        IDirect3DDevice9ExVtbl *lpVtbl_internal;
+};
+
+struct IDirect3DSwapChain9Ex_Minor1
+{
+        IDirect3DSwapChain9ExVtbl *lpVtbl;
+        IDirect3DSwapChain9ExVtbl *lpVtbl_internal;
+};
+
+typedef struct IDirect3DDevice9Ex_Minor1 IDirect3DDevice9Ex_Minor1;
+typedef struct IDirect3DSwapChain9Ex_Minor1 IDirect3DSwapChain9Ex_Minor1;
+
+#define SWAPCHAIN_WRAP0(ret, func)  \
+    ret WINAPI WineNineSwapChain9_ ## func(IDirect3DSwapChain9Ex *This) \
+    { \
+        return ((IDirect3DSwapChain9Ex_Minor1 *)This)->lpVtbl_internal->func(This); \
+    }
+
+#define SWAPCHAIN_WRAP1(ret, func, type1)  \
+    ret WINAPI WineNineSwapChain9_ ## func(IDirect3DSwapChain9Ex *This, type1 arg1) \
+    { \
+        return ((IDirect3DSwapChain9Ex_Minor1 *)This)->lpVtbl_internal->func(This, arg1); \
+    }
+
+#define SWAPCHAIN_WRAP2(ret, func, type1, type2)  \
+    ret WINAPI WineNineSwapChain9_ ## func(IDirect3DSwapChain9Ex *This, type1 arg1, type2 arg2) \
+    { \
+        return ((IDirect3DSwapChain9Ex_Minor1 *)This)->lpVtbl_internal->func(This, arg1, arg2); \
+    }
+
+#define SWAPCHAIN_WRAP3(ret, func, type1, type2, type3)  \
+    ret WINAPI WineNineSwapChain9_ ## func(IDirect3DSwapChain9Ex *This, type1 arg1, type2 arg2, type3 arg3) \
+    { \
+        return ((IDirect3DSwapChain9Ex_Minor1 *)This)->lpVtbl_internal->func(This, arg1, arg2, arg3); \
+    }
+
+#define SWAPCHAIN_H_WRAP5(ret, func, type1, type2, type3, type4, type5)  \
+    ret WINAPI DECLSPEC_HOTPATCH WineNineSwapChain9_ ## func(IDirect3DSwapChain9Ex *This, type1 arg1, type2 arg2, type3 arg3, type4 arg4, type5 arg5) \
+    { \
+        return ((IDirect3DSwapChain9Ex_Minor1 *)This)->lpVtbl_internal->func(This, arg1, arg2, arg3, arg4, arg5); \
+    }
+
+#define DEVICE_WRAP0(ret, func)  \
+    ret WINAPI WineNineDevice9_ ## func(IDirect3DDevice9Ex *This) \
+    { \
+        return ((IDirect3DDevice9Ex_Minor1 *)This)->lpVtbl_internal->func(This); \
+    }
+
+#define DEVICE_WRAP1(ret, func, type1)  \
+    ret WINAPI WineNineDevice9_ ## func(IDirect3DDevice9Ex *This, type1 arg1) \
+    { \
+        return ((IDirect3DDevice9Ex_Minor1 *)This)->lpVtbl_internal->func(This, arg1); \
+    }
+
+#define DEVICE_WRAP2(ret, func, type1, type2)  \
+    ret WINAPI WineNineDevice9_ ## func(IDirect3DDevice9Ex *This, type1 arg1, type2 arg2) \
+    { \
+        return ((IDirect3DDevice9Ex_Minor1 *)This)->lpVtbl_internal->func(This, arg1, arg2); \
+    }
+
+#define DEVICE_WRAP3(ret, func, type1, type2, type3)  \
+    ret WINAPI WineNineDevice9_ ## func(IDirect3DDevice9Ex *This, type1 arg1, type2 arg2, type3 arg3) \
+    { \
+        return ((IDirect3DDevice9Ex_Minor1 *)This)->lpVtbl_internal->func(This, arg1, arg2, arg3); \
+    }
+
+#define DEVICE_WRAP4(ret, func, type1, type2, type3, type4)  \
+    ret WINAPI WineNineDevice9_ ## func(IDirect3DDevice9Ex *This, type1 arg1, type2 arg2, type3 arg3, type4 arg4) \
+    { \
+        return ((IDirect3DDevice9Ex_Minor1 *)This)->lpVtbl_internal->func(This, arg1, arg2, arg3, arg4); \
+    }
+
+#define DEVICE_WRAP5(ret, func, type1, type2, type3, type4, type5)  \
+    ret WINAPI WineNineDevice9_ ## func(IDirect3DDevice9Ex *This, type1 arg1, type2 arg2, type3 arg3, type4 arg4, type5 arg5) \
+    { \
+        return ((IDirect3DDevice9Ex_Minor1 *)This)->lpVtbl_internal->func(This, arg1, arg2, arg3, arg4, arg5); \
+    }
+
+#define DEVICE_WRAP6(ret, func, type1, type2, type3, type4, type5, type6)  \
+    ret WINAPI WineNineDevice9_ ## func(IDirect3DDevice9Ex *This, type1 arg1, type2 arg2, type3 arg3, type4 arg4, type5 arg5, type6 arg6) \
+    { \
+        return ((IDirect3DDevice9Ex_Minor1 *)This)->lpVtbl_internal->func(This, arg1, arg2, arg3, arg4, arg5, arg6); \
+    }
+
+#define DEVICE_WRAP7(ret, func, type1, type2, type3, type4, type5, type6, type7)  \
+    ret WINAPI WineNineDevice9_ ## func(IDirect3DDevice9Ex *This, type1 arg1, type2 arg2, type3 arg3, type4 arg4, type5 arg5, type6 arg6, type7 arg7) \
+    { \
+        return ((IDirect3DDevice9Ex_Minor1 *)This)->lpVtbl_internal->func(This, arg1, arg2, arg3, arg4, arg5, arg6, arg7); \
+    }
+
+#define DEVICE_WRAP8(ret, func, type1, type2, type3, type4, type5, type6, type7, type8)  \
+    ret WINAPI WineNineDevice9_ ## func(IDirect3DDevice9Ex *This, type1 arg1, type2 arg2, type3 arg3, type4 arg4, type5 arg5, type6 arg6, type7 arg7, type8 arg8) \
+    { \
+        return ((IDirect3DDevice9Ex_Minor1 *)This)->lpVtbl_internal->func(This, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8); \
+    }
+
+#define DEVICE_WRAP9(ret, func, type1, type2, type3, type4, type5, type6, type7, type8, type9)  \
+    ret WINAPI WineNineDevice9_ ## func(IDirect3DDevice9Ex *This, type1 arg1, type2 arg2, type3 arg3, type4 arg4, type5 arg5, type6 arg6, type7 arg7, type8 arg8, type9 arg9) \
+    { \
+        return ((IDirect3DDevice9Ex_Minor1 *)This)->lpVtbl_internal->func(This, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9); \
+    }
+
+#define DEVICE_H_WRAP0(ret, func)  \
+    ret WINAPI DECLSPEC_HOTPATCH WineNineDevice9_ ## func(IDirect3DDevice9Ex *This) \
+    { \
+        return ((IDirect3DDevice9Ex_Minor1 *)This)->lpVtbl_internal->func(This); \
+    }
+
+#define DEVICE_H_WRAP1(ret, func, type1)  \
+    ret WINAPI DECLSPEC_HOTPATCH WineNineDevice9_ ## func(IDirect3DDevice9Ex *This, type1 arg1) \
+    { \
+        return ((IDirect3DDevice9Ex_Minor1 *)This)->lpVtbl_internal->func(This, arg1); \
+    }
+
+#define DEVICE_H_WRAP2(ret, func, type1, type2)  \
+    ret WINAPI DECLSPEC_HOTPATCH WineNineDevice9_ ## func(IDirect3DDevice9Ex *This, type1 arg1, type2 arg2) \
+    { \
+        return ((IDirect3DDevice9Ex_Minor1 *)This)->lpVtbl_internal->func(This, arg1, arg2); \
+    }
+
+#define DEVICE_H_WRAP3(ret, func, type1, type2, type3)  \
+    ret WINAPI DECLSPEC_HOTPATCH WineNineDevice9_ ## func(IDirect3DDevice9Ex *This, type1 arg1, type2 arg2, type3 arg3) \
+    { \
+        return ((IDirect3DDevice9Ex_Minor1 *)This)->lpVtbl_internal->func(This, arg1, arg2, arg3); \
+    }
+
+#define DEVICE_H_WRAP4(ret, func, type1, type2, type3, type4)  \
+    ret WINAPI DECLSPEC_HOTPATCH WineNineDevice9_ ## func(IDirect3DDevice9Ex *This, type1 arg1, type2 arg2, type3 arg3, type4 arg4) \
+    { \
+        return ((IDirect3DDevice9Ex_Minor1 *)This)->lpVtbl_internal->func(This, arg1, arg2, arg3, arg4); \
+    }
+
+#define DEVICE_H_WRAP5(ret, func, type1, type2, type3, type4, type5)  \
+    ret WINAPI DECLSPEC_HOTPATCH WineNineDevice9_ ## func(IDirect3DDevice9Ex *This, type1 arg1, type2 arg2, type3 arg3, type4 arg4, type5 arg5) \
+    { \
+        return ((IDirect3DDevice9Ex_Minor1 *)This)->lpVtbl_internal->func(This, arg1, arg2, arg3, arg4, arg5); \
+    }
+
+SWAPCHAIN_WRAP2(HRESULT, QueryInterface, REFIID, void **)
+SWAPCHAIN_WRAP0(ULONG, AddRef)
+SWAPCHAIN_WRAP0(ULONG, Release)
+SWAPCHAIN_H_WRAP5(HRESULT, Present, const RECT *, const RECT *, HWND, const RGNDATA *, DWORD)
+SWAPCHAIN_WRAP1(HRESULT, GetFrontBufferData, IDirect3DSurface9 *)
+SWAPCHAIN_WRAP3(HRESULT, GetBackBuffer, UINT, D3DBACKBUFFER_TYPE, IDirect3DSurface9 **)
+SWAPCHAIN_WRAP1(HRESULT, GetRasterStatus, D3DRASTER_STATUS *)
+SWAPCHAIN_WRAP1(HRESULT, GetDisplayMode, D3DDISPLAYMODE *)
+SWAPCHAIN_WRAP1(HRESULT, GetDevice, IDirect3DDevice9 **)
+SWAPCHAIN_WRAP1(HRESULT, GetPresentParameters, D3DPRESENT_PARAMETERS *)
+SWAPCHAIN_WRAP1(HRESULT, GetLastPresentCount, UINT *)
+SWAPCHAIN_WRAP1(HRESULT, GetPresentStats, D3DPRESENTSTATS *)
+SWAPCHAIN_WRAP2(HRESULT, GetDisplayModeEx, D3DDISPLAYMODEEX *, D3DDISPLAYROTATION *)
+
+DEVICE_WRAP2(HRESULT, QueryInterface, REFIID, void **)
+DEVICE_WRAP0(ULONG, AddRef)
+DEVICE_H_WRAP0(ULONG, Release)
+DEVICE_WRAP0(HRESULT, TestCooperativeLevel)
+DEVICE_WRAP0(UINT, GetAvailableTextureMem)
+DEVICE_WRAP0(HRESULT, EvictManagedResources)
+DEVICE_WRAP1(HRESULT, GetDirect3D, IDirect3D9 **)
+DEVICE_WRAP1(HRESULT, GetDeviceCaps, D3DCAPS9 *)
+DEVICE_WRAP2(HRESULT, GetDisplayMode, UINT, D3DDISPLAYMODE*)
+DEVICE_WRAP1(HRESULT, GetCreationParameters, D3DDEVICE_CREATION_PARAMETERS *)
+DEVICE_WRAP3(HRESULT, SetCursorProperties, UINT, UINT, IDirect3DSurface9 *)
+DEVICE_WRAP3(void, SetCursorPosition, int, int, DWORD)
+DEVICE_WRAP1(BOOL, ShowCursor, BOOL)
+/*DEVICE_H_WRAP2(HRESULT, CreateAdditionalSwapChain, D3DPRESENT_PARAMETERS *, IDirect3DSwapChain9 **)*/
+/*DEVICE_H_WRAP2(HRESULT, GetSwapChain, UINT, IDirect3DSwapChain9 **)*/
+DEVICE_WRAP0(UINT, GetNumberOfSwapChains)
+DEVICE_H_WRAP1(HRESULT, Reset, D3DPRESENT_PARAMETERS *)
+DEVICE_H_WRAP4(HRESULT, Present, const RECT *, const RECT *, HWND, const RGNDATA *)
+DEVICE_WRAP4(HRESULT, GetBackBuffer, UINT, UINT, D3DBACKBUFFER_TYPE, IDirect3DSurface9 **)
+DEVICE_WRAP2(HRESULT, GetRasterStatus, UINT, D3DRASTER_STATUS *)
+DEVICE_WRAP1(HRESULT, SetDialogBoxMode, BOOL)
+DEVICE_H_WRAP3(void, SetGammaRamp, UINT, DWORD, const D3DGAMMARAMP *)
+DEVICE_WRAP2(void, GetGammaRamp, UINT, D3DGAMMARAMP *)
+DEVICE_WRAP8(HRESULT, CreateTexture, UINT, UINT, UINT, DWORD, D3DFORMAT, D3DPOOL, IDirect3DTexture9 **, HANDLE *)
+DEVICE_WRAP9(HRESULT, CreateVolumeTexture, UINT, UINT, UINT, UINT, DWORD, D3DFORMAT, D3DPOOL, IDirect3DVolumeTexture9 **, HANDLE *)
+DEVICE_WRAP7(HRESULT, CreateCubeTexture, UINT, UINT, DWORD, D3DFORMAT, D3DPOOL, IDirect3DCubeTexture9 **, HANDLE *)
+DEVICE_WRAP6(HRESULT, CreateVertexBuffer, UINT, DWORD, DWORD, D3DPOOL, IDirect3DVertexBuffer9 **, HANDLE *)
+DEVICE_WRAP6(HRESULT, CreateIndexBuffer, UINT, DWORD, D3DFORMAT, D3DPOOL, IDirect3DIndexBuffer9 **, HANDLE *)
+DEVICE_WRAP8(HRESULT, CreateRenderTarget, UINT, UINT, D3DFORMAT, D3DMULTISAMPLE_TYPE, DWORD, BOOL, IDirect3DSurface9 **, HANDLE *)
+DEVICE_WRAP8(HRESULT, CreateDepthStencilSurface, UINT, UINT, D3DFORMAT, D3DMULTISAMPLE_TYPE, DWORD, BOOL, IDirect3DSurface9 **, HANDLE *)
+DEVICE_WRAP4(HRESULT, UpdateSurface, IDirect3DSurface9 *, const RECT *, IDirect3DSurface9 *, const POINT *)
+DEVICE_WRAP2(HRESULT, UpdateTexture, IDirect3DBaseTexture9 *, IDirect3DBaseTexture9 *)
+DEVICE_WRAP2(HRESULT, GetRenderTargetData, IDirect3DSurface9 *, IDirect3DSurface9 *)
+DEVICE_WRAP2(HRESULT, GetFrontBufferData, UINT, IDirect3DSurface9 *)
+DEVICE_WRAP5(HRESULT, StretchRect, IDirect3DSurface9 *, const RECT *, IDirect3DSurface9 *, const RECT *, D3DTEXTUREFILTERTYPE)
+DEVICE_WRAP3(HRESULT, ColorFill, IDirect3DSurface9 *, const RECT *, D3DCOLOR)
+DEVICE_WRAP6(HRESULT, CreateOffscreenPlainSurface, UINT, UINT, D3DFORMAT, D3DPOOL, IDirect3DSurface9 **, HANDLE *)
+DEVICE_WRAP2(HRESULT, SetRenderTarget, DWORD, IDirect3DSurface9 *)
+DEVICE_WRAP2(HRESULT, GetRenderTarget, DWORD, IDirect3DSurface9 **)
+DEVICE_WRAP1(HRESULT, SetDepthStencilSurface, IDirect3DSurface9 *)
+DEVICE_WRAP1(HRESULT, GetDepthStencilSurface, IDirect3DSurface9 **)
+DEVICE_WRAP0(HRESULT, BeginScene)
+DEVICE_H_WRAP0(HRESULT, EndScene)
+DEVICE_WRAP6(HRESULT, Clear, DWORD, const D3DRECT *, DWORD, D3DCOLOR, float, DWORD)
+DEVICE_WRAP2(HRESULT, SetTransform, D3DTRANSFORMSTATETYPE, const D3DMATRIX *)
+DEVICE_WRAP2(HRESULT, GetTransform, D3DTRANSFORMSTATETYPE, D3DMATRIX *)
+DEVICE_WRAP2(HRESULT, MultiplyTransform, D3DTRANSFORMSTATETYPE, const D3DMATRIX *)
+DEVICE_WRAP1(HRESULT, SetViewport, const D3DVIEWPORT9 *)
+DEVICE_WRAP1(HRESULT, GetViewport, D3DVIEWPORT9 *)
+DEVICE_WRAP1(HRESULT, SetMaterial, const D3DMATERIAL9 *)
+DEVICE_WRAP1(HRESULT, GetMaterial, D3DMATERIAL9 *)
+DEVICE_WRAP2(HRESULT, SetLight, DWORD, const D3DLIGHT9 *)
+DEVICE_WRAP2(HRESULT, GetLight, DWORD, D3DLIGHT9 *)
+DEVICE_WRAP2(HRESULT, LightEnable, DWORD, BOOL)
+DEVICE_WRAP2(HRESULT, GetLightEnable, DWORD, BOOL *)
+DEVICE_WRAP2(HRESULT, SetClipPlane, DWORD, const float *)
+DEVICE_WRAP2(HRESULT, GetClipPlane, DWORD, float *)
+DEVICE_H_WRAP2(HRESULT, SetRenderState, D3DRENDERSTATETYPE, DWORD)
+DEVICE_WRAP2(HRESULT, GetRenderState, D3DRENDERSTATETYPE, DWORD *)
+DEVICE_WRAP2(HRESULT, CreateStateBlock, D3DSTATEBLOCKTYPE, IDirect3DStateBlock9 **)
+DEVICE_WRAP0(HRESULT, BeginStateBlock)
+DEVICE_WRAP1(HRESULT, EndStateBlock, IDirect3DStateBlock9 **)
+DEVICE_WRAP1(HRESULT, SetClipStatus, const D3DCLIPSTATUS9 *)
+DEVICE_WRAP1(HRESULT, GetClipStatus, D3DCLIPSTATUS9 *)
+DEVICE_WRAP2(HRESULT, GetTexture, DWORD, IDirect3DBaseTexture9 **)
+DEVICE_WRAP2(HRESULT, SetTexture, DWORD, IDirect3DBaseTexture9 *)
+DEVICE_WRAP3(HRESULT, GetTextureStageState, DWORD, D3DTEXTURESTAGESTATETYPE, DWORD *)
+DEVICE_WRAP3(HRESULT, SetTextureStageState, DWORD, D3DTEXTURESTAGESTATETYPE, DWORD)
+DEVICE_WRAP3(HRESULT, GetSamplerState, DWORD, D3DSAMPLERSTATETYPE, DWORD *)
+DEVICE_H_WRAP3(HRESULT, SetSamplerState, DWORD, D3DSAMPLERSTATETYPE, DWORD)
+DEVICE_WRAP1(HRESULT, ValidateDevice, DWORD *)
+DEVICE_WRAP2(HRESULT, SetPaletteEntries, UINT, const PALETTEENTRY *)
+DEVICE_WRAP2(HRESULT, GetPaletteEntries, UINT, PALETTEENTRY *)
+DEVICE_WRAP1(HRESULT, SetCurrentTexturePalette, UINT)
+DEVICE_WRAP1(HRESULT, GetCurrentTexturePalette, UINT *)
+DEVICE_WRAP1(HRESULT, SetScissorRect, const RECT *)
+DEVICE_WRAP1(HRESULT, GetScissorRect, RECT *)
+DEVICE_WRAP1(HRESULT, SetSoftwareVertexProcessing, BOOL)
+DEVICE_WRAP0(BOOL, GetSoftwareVertexProcessing)
+DEVICE_WRAP1(HRESULT, SetNPatchMode, float)
+DEVICE_WRAP0(float, GetNPatchMode)
+DEVICE_WRAP3(HRESULT, DrawPrimitive, D3DPRIMITIVETYPE, UINT, UINT)
+DEVICE_WRAP6(HRESULT, DrawIndexedPrimitive, D3DPRIMITIVETYPE, INT, UINT, UINT, UINT, UINT)
+DEVICE_WRAP4(HRESULT, DrawPrimitiveUP, D3DPRIMITIVETYPE, UINT, const void *, UINT)
+DEVICE_WRAP8(HRESULT, DrawIndexedPrimitiveUP, D3DPRIMITIVETYPE, UINT, UINT, UINT, const void *, D3DFORMAT, const void *, UINT)
+DEVICE_WRAP6(HRESULT, ProcessVertices, UINT, UINT, UINT, IDirect3DVertexBuffer9 *, IDirect3DVertexDeclaration9 *, DWORD)
+DEVICE_WRAP2(HRESULT, CreateVertexDeclaration, const D3DVERTEXELEMENT9 *, IDirect3DVertexDeclaration9 **)
+DEVICE_WRAP1(HRESULT, SetVertexDeclaration, IDirect3DVertexDeclaration9 *)
+DEVICE_WRAP1(HRESULT, GetVertexDeclaration, IDirect3DVertexDeclaration9 **)
+DEVICE_WRAP1(HRESULT, SetFVF, DWORD)
+DEVICE_WRAP1(HRESULT, GetFVF, DWORD *)
+DEVICE_WRAP2(HRESULT, CreateVertexShader, const DWORD *, IDirect3DVertexShader9 **)
+DEVICE_WRAP1(HRESULT, SetVertexShader, IDirect3DVertexShader9 *)
+DEVICE_WRAP1(HRESULT, GetVertexShader, IDirect3DVertexShader9 **)
+DEVICE_WRAP3(HRESULT, SetVertexShaderConstantF, UINT, const float *, UINT)
+DEVICE_WRAP3(HRESULT, GetVertexShaderConstantF, UINT, float *, UINT)
+DEVICE_WRAP3(HRESULT, SetVertexShaderConstantI, UINT, const int *, UINT)
+DEVICE_WRAP3(HRESULT, GetVertexShaderConstantI, UINT, int *, UINT)
+DEVICE_WRAP3(HRESULT, SetVertexShaderConstantB, UINT, const BOOL *, UINT)
+DEVICE_WRAP3(HRESULT, GetVertexShaderConstantB, UINT, BOOL *, UINT)
+DEVICE_WRAP4(HRESULT, SetStreamSource, UINT, IDirect3DVertexBuffer9 *, UINT, UINT)
+DEVICE_WRAP4(HRESULT, GetStreamSource, UINT, IDirect3DVertexBuffer9 **, UINT *, UINT *)
+DEVICE_WRAP2(HRESULT, SetStreamSourceFreq, UINT, UINT)
+DEVICE_WRAP2(HRESULT, GetStreamSourceFreq, UINT, UINT *)
+DEVICE_WRAP1(HRESULT, SetIndices, IDirect3DIndexBuffer9 *)
+DEVICE_WRAP1(HRESULT, GetIndices, IDirect3DIndexBuffer9 **)
+DEVICE_WRAP2(HRESULT, CreatePixelShader, const DWORD *, IDirect3DPixelShader9 **)
+DEVICE_WRAP1(HRESULT, SetPixelShader, IDirect3DPixelShader9 *)
+DEVICE_WRAP1(HRESULT, GetPixelShader, IDirect3DPixelShader9 **)
+DEVICE_WRAP3(HRESULT, SetPixelShaderConstantF, UINT, const float *, UINT)
+DEVICE_WRAP3(HRESULT, GetPixelShaderConstantF, UINT, float *, UINT)
+DEVICE_WRAP3(HRESULT, SetPixelShaderConstantI, UINT, const int *, UINT)
+DEVICE_WRAP3(HRESULT, GetPixelShaderConstantI, UINT, int *, UINT)
+DEVICE_WRAP3(HRESULT, SetPixelShaderConstantB, UINT, const BOOL *, UINT)
+DEVICE_WRAP3(HRESULT, GetPixelShaderConstantB, UINT, BOOL *, UINT)
+DEVICE_WRAP3(HRESULT, DrawRectPatch, UINT, const float *, const D3DRECTPATCH_INFO *)
+DEVICE_WRAP3(HRESULT, DrawTriPatch, UINT, const float *, const D3DTRIPATCH_INFO *)
+DEVICE_WRAP1(HRESULT, DeletePatch, UINT)
+DEVICE_WRAP2(HRESULT, CreateQuery, D3DQUERYTYPE, IDirect3DQuery9 **)
+DEVICE_WRAP4(HRESULT, SetConvolutionMonoKernel, UINT, UINT, float *, float *)
+DEVICE_WRAP8(HRESULT, ComposeRects, IDirect3DSurface9 *, IDirect3DSurface9 *, IDirect3DVertexBuffer9 *, UINT, IDirect3DVertexBuffer9 *, D3DCOMPOSERECTSOP, int, int)
+DEVICE_H_WRAP5(HRESULT, PresentEx, const RECT *, const RECT *, HWND, const RGNDATA *, DWORD)
+DEVICE_WRAP1(HRESULT, GetGPUThreadPriority, INT *)
+DEVICE_WRAP1(HRESULT, SetGPUThreadPriority, INT)
+DEVICE_WRAP1(HRESULT, WaitForVBlank, UINT)
+DEVICE_WRAP2(HRESULT, CheckResourceResidency, IDirect3DResource9 **, UINT32)
+DEVICE_WRAP1(HRESULT, SetMaximumFrameLatency, UINT)
+DEVICE_WRAP1(HRESULT, GetMaximumFrameLatency, UINT *)
+DEVICE_WRAP1(HRESULT, CheckDeviceState, HWND)
+DEVICE_WRAP9(HRESULT, CreateRenderTargetEx, UINT, UINT, D3DFORMAT, D3DMULTISAMPLE_TYPE, DWORD, BOOL, IDirect3DSurface9 **, HANDLE *, DWORD)
+DEVICE_WRAP7(HRESULT, CreateOffscreenPlainSurfaceEx, UINT, UINT, D3DFORMAT, D3DPOOL, IDirect3DSurface9 **, HANDLE *, DWORD)
+DEVICE_WRAP9(HRESULT, CreateDepthStencilSurfaceEx, UINT, UINT, D3DFORMAT, D3DMULTISAMPLE_TYPE, DWORD, BOOL, IDirect3DSurface9 **, HANDLE *, DWORD)
+DEVICE_H_WRAP2(HRESULT, ResetEx, D3DPRESENT_PARAMETERS *, D3DDISPLAYMODEEX *)
+DEVICE_WRAP3(HRESULT, GetDisplayModeEx, UINT, D3DDISPLAYMODEEX *, D3DDISPLAYROTATION *)
+
+IDirect3DSwapChain9ExVtbl WineNineSwapChain9Ex_vtable = {
+    WineNineSwapChain9_QueryInterface,
+    WineNineSwapChain9_AddRef,
+    WineNineSwapChain9_Release,
+    WineNineSwapChain9_Present,
+    WineNineSwapChain9_GetFrontBufferData,
+    WineNineSwapChain9_GetBackBuffer,
+    WineNineSwapChain9_GetRasterStatus,
+    WineNineSwapChain9_GetDisplayMode,
+    WineNineSwapChain9_GetDevice,
+    WineNineSwapChain9_GetPresentParameters,
+    WineNineSwapChain9_GetLastPresentCount,
+    WineNineSwapChain9_GetPresentStats,
+    WineNineSwapChain9_GetDisplayModeEx
+};
+
+HRESULT WINAPI DECLSPEC_HOTPATCH WineNineDevice9_CreateAdditionalSwapChain(IDirect3DDevice9Ex *This, D3DPRESENT_PARAMETERS *pPresentationParameters, IDirect3DSwapChain9 **pSwapChain)
+{
+    HRESULT hr;
+
+    hr = ((IDirect3DDevice9Ex_Minor1 *)This)->lpVtbl_internal->CreateAdditionalSwapChain(This, pPresentationParameters, pSwapChain);
+    if (FAILED(hr))
+        return hr;
+
+    (*pSwapChain)->lpVtbl = (IDirect3DSwapChain9Vtbl *)&WineNineSwapChain9Ex_vtable;
+
+    return hr;
+}
+
+HRESULT WINAPI DECLSPEC_HOTPATCH WineNineDevice9_GetSwapChain(IDirect3DDevice9Ex *This, UINT iSwapChain, IDirect3DSwapChain9 **pSwapChain)
+{
+    HRESULT hr;
+
+    hr = ((IDirect3DDevice9Ex_Minor1 *)This)->lpVtbl_internal->GetSwapChain(This, iSwapChain, pSwapChain);
+    if (FAILED(hr))
+        return hr;
+
+    (*pSwapChain)->lpVtbl = (IDirect3DSwapChain9Vtbl *)&WineNineSwapChain9Ex_vtable;
+
+    return hr;
+}
+
+
+IDirect3DDevice9ExVtbl WineNineDevice9_vtable = {
+    WineNineDevice9_QueryInterface,
+    WineNineDevice9_AddRef,
+    WineNineDevice9_Release,
+    WineNineDevice9_TestCooperativeLevel,
+    WineNineDevice9_GetAvailableTextureMem,
+    WineNineDevice9_EvictManagedResources,
+    WineNineDevice9_GetDirect3D,
+    WineNineDevice9_GetDeviceCaps,
+    WineNineDevice9_GetDisplayMode,
+    WineNineDevice9_GetCreationParameters,
+    WineNineDevice9_SetCursorProperties,
+    WineNineDevice9_SetCursorPosition,
+    WineNineDevice9_ShowCursor,
+    WineNineDevice9_CreateAdditionalSwapChain,
+    WineNineDevice9_GetSwapChain,
+    WineNineDevice9_GetNumberOfSwapChains,
+    WineNineDevice9_Reset,
+    WineNineDevice9_Present,
+    WineNineDevice9_GetBackBuffer,
+    WineNineDevice9_GetRasterStatus,
+    WineNineDevice9_SetDialogBoxMode,
+    WineNineDevice9_SetGammaRamp,
+    WineNineDevice9_GetGammaRamp,
+    WineNineDevice9_CreateTexture,
+    WineNineDevice9_CreateVolumeTexture,
+    WineNineDevice9_CreateCubeTexture,
+    WineNineDevice9_CreateVertexBuffer,
+    WineNineDevice9_CreateIndexBuffer,
+    WineNineDevice9_CreateRenderTarget,
+    WineNineDevice9_CreateDepthStencilSurface,
+    WineNineDevice9_UpdateSurface,
+    WineNineDevice9_UpdateTexture,
+    WineNineDevice9_GetRenderTargetData,
+    WineNineDevice9_GetFrontBufferData,
+    WineNineDevice9_StretchRect,
+    WineNineDevice9_ColorFill,
+    WineNineDevice9_CreateOffscreenPlainSurface,
+    WineNineDevice9_SetRenderTarget,
+    WineNineDevice9_GetRenderTarget,
+    WineNineDevice9_SetDepthStencilSurface,
+    WineNineDevice9_GetDepthStencilSurface,
+    WineNineDevice9_BeginScene,
+    WineNineDevice9_EndScene,
+    WineNineDevice9_Clear,
+    WineNineDevice9_SetTransform,
+    WineNineDevice9_GetTransform,
+    WineNineDevice9_MultiplyTransform,
+    WineNineDevice9_SetViewport,
+    WineNineDevice9_GetViewport,
+    WineNineDevice9_SetMaterial,
+    WineNineDevice9_GetMaterial,
+    WineNineDevice9_SetLight,
+    WineNineDevice9_GetLight,
+    WineNineDevice9_LightEnable,
+    WineNineDevice9_GetLightEnable,
+    WineNineDevice9_SetClipPlane,
+    WineNineDevice9_GetClipPlane,
+    WineNineDevice9_SetRenderState,
+    WineNineDevice9_GetRenderState,
+    WineNineDevice9_CreateStateBlock,
+    WineNineDevice9_BeginStateBlock,
+    WineNineDevice9_EndStateBlock,
+    WineNineDevice9_SetClipStatus,
+    WineNineDevice9_GetClipStatus,
+    WineNineDevice9_GetTexture,
+    WineNineDevice9_SetTexture,
+    WineNineDevice9_GetTextureStageState,
+    WineNineDevice9_SetTextureStageState,
+    WineNineDevice9_GetSamplerState,
+    WineNineDevice9_SetSamplerState,
+    WineNineDevice9_ValidateDevice,
+    WineNineDevice9_SetPaletteEntries,
+    WineNineDevice9_GetPaletteEntries,
+    WineNineDevice9_SetCurrentTexturePalette,
+    WineNineDevice9_GetCurrentTexturePalette,
+    WineNineDevice9_SetScissorRect,
+    WineNineDevice9_GetScissorRect,
+    WineNineDevice9_SetSoftwareVertexProcessing,
+    WineNineDevice9_GetSoftwareVertexProcessing,
+    WineNineDevice9_SetNPatchMode,
+    WineNineDevice9_GetNPatchMode,
+    WineNineDevice9_DrawPrimitive,
+    WineNineDevice9_DrawIndexedPrimitive,
+    WineNineDevice9_DrawPrimitiveUP,
+    WineNineDevice9_DrawIndexedPrimitiveUP,
+    WineNineDevice9_ProcessVertices,
+    WineNineDevice9_CreateVertexDeclaration,
+    WineNineDevice9_SetVertexDeclaration,
+    WineNineDevice9_GetVertexDeclaration,
+    WineNineDevice9_SetFVF,
+    WineNineDevice9_GetFVF,
+    WineNineDevice9_CreateVertexShader,
+    WineNineDevice9_SetVertexShader,
+    WineNineDevice9_GetVertexShader,
+    WineNineDevice9_SetVertexShaderConstantF,
+    WineNineDevice9_GetVertexShaderConstantF,
+    WineNineDevice9_SetVertexShaderConstantI,
+    WineNineDevice9_GetVertexShaderConstantI,
+    WineNineDevice9_SetVertexShaderConstantB,
+    WineNineDevice9_GetVertexShaderConstantB,
+    WineNineDevice9_SetStreamSource,
+    WineNineDevice9_GetStreamSource,
+    WineNineDevice9_SetStreamSourceFreq,
+    WineNineDevice9_GetStreamSourceFreq,
+    WineNineDevice9_SetIndices,
+    WineNineDevice9_GetIndices,
+    WineNineDevice9_CreatePixelShader,
+    WineNineDevice9_SetPixelShader,
+    WineNineDevice9_GetPixelShader,
+    WineNineDevice9_SetPixelShaderConstantF,
+    WineNineDevice9_GetPixelShaderConstantF,
+    WineNineDevice9_SetPixelShaderConstantI,
+    WineNineDevice9_GetPixelShaderConstantI,
+    WineNineDevice9_SetPixelShaderConstantB,
+    WineNineDevice9_GetPixelShaderConstantB,
+    WineNineDevice9_DrawRectPatch,
+    WineNineDevice9_DrawTriPatch,
+    WineNineDevice9_DeletePatch,
+    WineNineDevice9_CreateQuery,
+    WineNineDevice9_SetConvolutionMonoKernel,
+    WineNineDevice9_ComposeRects,
+    WineNineDevice9_PresentEx,
+    WineNineDevice9_GetGPUThreadPriority,
+    WineNineDevice9_SetGPUThreadPriority,
+    WineNineDevice9_WaitForVBlank,
+    WineNineDevice9_CheckResourceResidency,
+    WineNineDevice9_SetMaximumFrameLatency,
+    WineNineDevice9_GetMaximumFrameLatency,
+    WineNineDevice9_CheckDeviceState,
+    WineNineDevice9_CreateRenderTargetEx,
+    WineNineDevice9_CreateOffscreenPlainSurfaceEx,
+    WineNineDevice9_CreateDepthStencilSurfaceEx,
+    WineNineDevice9_ResetEx,
+    WineNineDevice9_GetDisplayModeEx
+};
+
+IDirect3DDevice9ExVtbl *get_device_vtable()
+{
+    return &WineNineDevice9_vtable;
+}
diff -purN a/dlls/d3d9-nine/device_wrap.h b/dlls/d3d9-nine/device_wrap.h
--- a/dlls/d3d9-nine/device_wrap.h	1970-01-01 03:00:00.000000000 +0300
+++ b/dlls/d3d9-nine/device_wrap.h	2019-09-12 21:01:47.923318961 +0300
@@ -0,0 +1,13 @@
+/* SPDX-License-Identifier: LGPL-2.1-or-later */
+/*
+ * Copyright 2016 Axel Davy
+ */
+
+#ifndef __NINE_DEVICE_WRAP_H
+#define __NINE_DEVICE_WRAP_H
+
+#include <d3dadapter/d3dadapter9.h>
+
+IDirect3DDevice9ExVtbl *get_device_vtable(void);
+
+#endif /* __NINE_DEVICE_WRAP_H */
diff -purN a/dlls/d3d9-nine/dri2.c b/dlls/d3d9-nine/dri2.c
--- a/dlls/d3d9-nine/dri2.c	1970-01-01 03:00:00.000000000 +0300
+++ b/dlls/d3d9-nine/dri2.c	2019-09-12 21:01:47.926652315 +0300
@@ -0,0 +1,669 @@
+/* SPDX-License-Identifier: LGPL-2.1-or-later */
+/*
+ * Wine DRI2 interface
+ *
+ * Copyright 2014-2015 Axel Davy
+ * Copyright 2015-2019 Patrick Rudolph
+ */
+
+#ifdef D3D9NINE_DRI2
+
+#include <config.h>
+#include <windows.h>
+#include <wine/debug.h>
+#include <sys/ioctl.h>
+#include <X11/Xlib-xcb.h>
+#include <xcb/dri2.h>
+#include <libdrm/drm_fourcc.h>
+#include <libdrm/drm.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <dlfcn.h>
+#include <stdlib.h>
+
+#include <GL/gl.h>
+#include <EGL/egl.h>
+#include <EGL/eglext.h>
+
+#include "backend.h"
+#include "xcb_present.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(d3d9nine);
+
+const char * const lib_egl = "libEGL.so.1";
+
+static EGLDisplay display = NULL;
+static int display_ref = 0;
+
+struct dri2_pixmap_priv {
+    GLuint fbo_read;
+    GLuint fbo_write;
+    GLuint texture_read;
+    GLuint texture_write;
+    unsigned int width;
+    unsigned int height;
+    struct dri2_pixmap_priv *next;
+};
+
+struct dri2_priv {
+    struct dri2_pixmap_priv *first_dri2_priv;
+    Display *dpy;
+    int screen;
+    int fd;
+    EGLDisplay display;
+    EGLContext context;
+    void *h_egl;
+
+    /* egl */
+    void *(*eglGetProcAddress)(const char *procname);
+    EGLContext (*eglCreateContext)(EGLDisplay dpy, EGLConfig config, EGLContext share_context, const EGLint *attrib_list);
+    EGLBoolean (*eglDestroyContext)(EGLDisplay dpy, EGLContext ctx);
+    EGLint (*eglGetError)(void);
+    EGLBoolean (*eglInitialize)(EGLDisplay dpy, EGLint *major, EGLint *minor);
+    EGLBoolean (*eglMakeCurrent)(EGLDisplay dpy, EGLSurface draw, EGLSurface read, EGLContext ctx);
+    const char *(*eglQueryString)(EGLDisplay dpy, EGLint name);
+    EGLBoolean (*eglTerminate)(EGLDisplay dpy);
+    EGLBoolean (*eglChooseConfig)(EGLDisplay dpy, const EGLint *attrib_list, EGLConfig *configs, EGLint config_size, EGLint *num_config);
+    EGLBoolean (*eglBindAPI)(EGLenum api);
+    EGLenum (*eglQueryAPI)(void);
+
+    /* eglext */
+    EGLImageKHR (*eglCreateImageKHR)(EGLDisplay dpy, EGLContext ctx, EGLenum target, EGLClientBuffer buffer, const EGLint *attrib_list);
+    EGLBoolean (*eglDestroyImageKHR)(EGLDisplay dpy, EGLImageKHR image);
+    EGLDisplay (*eglGetPlatformDisplayEXT)(EGLenum platform, void *native_display, const EGLint *attrib_list);
+
+    /* gl */
+    void (*glFlush)(void);
+    void (*glTexParameteri)(GLenum target, GLenum pname, GLint param);
+    void (*glGenTextures)(GLsizei n, GLuint *textures);
+    void (*glDeleteTextures)(GLsizei n, const GLuint *textures);
+    void (*glBindTexture)(GLenum target, GLuint texture);
+    void (*glEGLImageTargetTexture2DOES)(GLenum target, GLeglImageOES image);
+
+    /* glext */
+    void (*glBindFramebuffer)(GLenum target, GLuint framebuffer);
+    void (*glDeleteFramebuffers)(GLsizei n, const GLuint *framebuffers);
+    void (*glGenFramebuffers)(GLsizei n, GLuint *framebuffers);
+    GLenum (*glCheckFramebufferStatus)(GLenum target);
+    void (*glFramebufferTexture2D)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
+    void (*glBlitFramebuffer)(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
+};
+
+static BOOL dri2_connect(Display *dpy, XID window, unsigned driver_type, char **device)
+{
+    xcb_connection_t *conn = XGetXCBConnection(dpy);
+    xcb_dri2_connect_cookie_t cookie;
+    xcb_dri2_connect_reply_t *reply;
+    xcb_generic_error_t *conn_error = NULL;
+
+    *device = NULL;
+
+    cookie = xcb_dri2_connect(conn, window, driver_type);
+    reply = xcb_dri2_connect_reply(conn, cookie, &conn_error);
+
+    if (conn_error) {
+        free(conn_error);
+        return False;
+    }
+
+    if (!reply) {
+        return False;
+    }
+
+    /* read out device */
+    *device = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
+        xcb_dri2_connect_device_name_length(reply) + 1);
+    if (!*device) {
+        free(reply);
+        return False;
+    }
+    strcpy(*device, xcb_dri2_connect_device_name(reply));
+
+    free(reply);
+
+    return True;
+}
+
+static Bool dri2_authenticate(Display *dpy, XID window, uint32_t token)
+{
+    xcb_generic_error_t *auth_error = NULL;
+    xcb_dri2_authenticate_cookie_t cookie;
+    xcb_connection_t *conn = XGetXCBConnection(dpy);
+
+    cookie = xcb_dri2_authenticate(conn, window, token);
+    Bool authenticated;
+
+    xcb_dri2_authenticate_reply_t *reply =
+        xcb_dri2_authenticate_reply(conn, cookie, &auth_error);
+    if (auth_error) {
+        free(auth_error);
+        return FALSE;
+    }
+    if (!reply) {
+        return FALSE;
+    }
+
+    authenticated = reply->authenticated;
+    free(reply);
+
+    return authenticated;
+}
+
+static void *dri2_eglGetProcAddress(struct dri2_priv *priv, const char *procname)
+{
+    void *p;
+
+    p = dlsym(priv->h_egl, procname);
+    if (p)
+        return p;
+
+    if (priv->eglGetProcAddress)
+        p = priv->eglGetProcAddress(procname);
+
+    if (!p)
+        WINE_ERR("%s is missing but required\n", procname);
+
+    return p;
+}
+
+static BOOL dri2_create(Display *dpy, int screen, struct dri_backend_priv **priv)
+{
+    struct dri2_priv *p;
+    char *device;
+    int fd;
+    Window root = RootWindow(dpy, screen);
+    drm_auth_t auth;
+
+    if (!dri2_connect(dpy, root, XCB_DRI2_DRIVER_TYPE_DRI, &device))
+        return FALSE;
+
+    fd = open(device, O_RDWR);
+    HeapFree(GetProcessHeap(), 0, device);
+    if (fd < 0)
+        return FALSE;
+
+    if (ioctl(fd, DRM_IOCTL_GET_MAGIC, &auth) != 0)
+    {
+        close(fd);
+        return FALSE;
+    }
+
+    if (!dri2_authenticate(dpy, root, auth.magic))
+    {
+        close(fd);
+        return FALSE;
+    }
+
+    p = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(struct dri2_priv));
+    if (!p)
+    {
+        close(fd);
+        return FALSE;
+    }
+
+    p->dpy = dpy;
+    p->screen = screen;
+    p->fd = fd;
+
+    p->h_egl = dlopen(lib_egl, RTLD_LAZY);
+    if (!p->h_egl)
+    {
+        WINE_ERR("failed to open %s: %s\n", lib_egl, dlerror());
+        goto err_egl;
+    }
+
+#define DRI2_EGLGETPROCADDRESS(procname) \
+    p->procname = dri2_eglGetProcAddress(p, #procname); \
+    if (!p->procname) \
+        goto err_egl;
+
+    DRI2_EGLGETPROCADDRESS(eglGetProcAddress);
+    DRI2_EGLGETPROCADDRESS(eglCreateContext);
+    DRI2_EGLGETPROCADDRESS(eglDestroyContext);
+    DRI2_EGLGETPROCADDRESS(eglGetError);
+    DRI2_EGLGETPROCADDRESS(eglInitialize);
+    DRI2_EGLGETPROCADDRESS(eglMakeCurrent);
+    DRI2_EGLGETPROCADDRESS(eglQueryString);
+    DRI2_EGLGETPROCADDRESS(eglTerminate);
+    DRI2_EGLGETPROCADDRESS(eglChooseConfig);
+    DRI2_EGLGETPROCADDRESS(eglBindAPI);
+    DRI2_EGLGETPROCADDRESS(eglQueryAPI);
+    DRI2_EGLGETPROCADDRESS(eglCreateImageKHR);
+    DRI2_EGLGETPROCADDRESS(eglDestroyImageKHR);
+    DRI2_EGLGETPROCADDRESS(eglGetPlatformDisplayEXT);
+
+    DRI2_EGLGETPROCADDRESS(glFlush);
+    DRI2_EGLGETPROCADDRESS(glTexParameteri);
+    DRI2_EGLGETPROCADDRESS(glGenTextures);
+    DRI2_EGLGETPROCADDRESS(glDeleteTextures);
+    DRI2_EGLGETPROCADDRESS(glBindTexture);
+    DRI2_EGLGETPROCADDRESS(glEGLImageTargetTexture2DOES);
+    DRI2_EGLGETPROCADDRESS(glBindFramebuffer);
+    DRI2_EGLGETPROCADDRESS(glDeleteFramebuffers);
+    DRI2_EGLGETPROCADDRESS(glGenFramebuffers);
+    DRI2_EGLGETPROCADDRESS(glCheckFramebufferStatus);
+    DRI2_EGLGETPROCADDRESS(glFramebufferTexture2D);
+    DRI2_EGLGETPROCADDRESS(glBlitFramebuffer);
+
+#undef DRI2_EGLGETPROCADDRESS
+
+    *priv = (struct dri_backend_priv *)p;
+
+    return TRUE;
+
+err_egl:
+    close(fd);
+    HeapFree(GetProcessHeap(), 0, p);
+    return FALSE;
+}
+
+static BOOL dri2_init(struct dri_backend_priv *priv)
+{
+    struct dri2_priv *p = (struct dri2_priv *)priv;
+    EGLint major, minor;
+    EGLConfig config;
+    EGLContext context;
+    EGLint i;
+    EGLBoolean b;
+    EGLenum current_api = 0;
+    const char *extensions;
+    EGLint config_attribs[] = {
+        EGL_RENDERABLE_TYPE, EGL_OPENGL_BIT,
+        EGL_NONE
+    };
+    EGLint context_compatibility_attribs[] = {
+        EGL_CONTEXT_OPENGL_PROFILE_MASK_KHR, EGL_CONTEXT_OPENGL_COMPATIBILITY_PROFILE_BIT_KHR,
+        EGL_NONE
+    };
+
+    current_api = p->eglQueryAPI();
+
+    if (!display)
+        display = p->eglGetPlatformDisplayEXT(EGL_PLATFORM_X11_EXT, p->dpy, NULL);
+    if (!display)
+        return FALSE;
+    /* count references on display for multi device setups */
+    display_ref++;
+
+    if (p->eglInitialize(display, &major, &minor) != EGL_TRUE)
+        goto clean_egl_display;
+
+    extensions = p->eglQueryString(display, EGL_CLIENT_APIS);
+    if (!extensions || !strstr(extensions, "OpenGL"))
+        goto clean_egl_display;
+
+    extensions = p->eglQueryString(display, EGL_EXTENSIONS);
+    if (!extensions || !strstr(extensions, "EGL_EXT_image_dma_buf_import") ||
+            !strstr(extensions, "EGL_KHR_create_context") ||
+            !strstr(extensions, "EGL_KHR_surfaceless_context") ||
+            !strstr(extensions, "EGL_KHR_image_base"))
+        goto clean_egl_display;
+
+    if (!p->eglChooseConfig(display, config_attribs, &config, 1, &i))
+        goto clean_egl_display;
+
+    b = p->eglBindAPI(EGL_OPENGL_API);
+    if (b == EGL_FALSE)
+        goto clean_egl_display;
+    context = p->eglCreateContext(display, config, EGL_NO_CONTEXT, context_compatibility_attribs);
+    if (context == EGL_NO_CONTEXT)
+        goto clean_egl_display;
+
+    p->eglMakeCurrent(display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
+
+    p->display = display;
+    p->context = context;
+
+    p->eglBindAPI(current_api);
+    return TRUE;
+
+clean_egl_display:
+    p->eglTerminate(display);
+    p->eglBindAPI(current_api);
+    return FALSE;
+}
+
+static int dri2_get_fd(struct dri_backend_priv *priv)
+{
+    struct dri2_priv *p = (struct dri2_priv *)priv;
+
+    return p->fd;
+}
+
+static BOOL dri2_present_pixmap(struct dri_backend_priv *priv, struct buffer_priv *buffer_priv)
+{
+    struct dri2_priv *p = (struct dri2_priv *)priv;
+    struct dri2_pixmap_priv *pp = (struct dri2_pixmap_priv *)buffer_priv;
+    EGLenum current_api = 0;
+
+    current_api = p->eglQueryAPI();
+    p->eglBindAPI(EGL_OPENGL_API);
+    if (p->eglMakeCurrent(p->display, EGL_NO_SURFACE, EGL_NO_SURFACE, p->context))
+    {
+        p->glBindFramebuffer(GL_READ_FRAMEBUFFER, pp->fbo_read);
+        p->glBindFramebuffer(GL_DRAW_FRAMEBUFFER, pp->fbo_write);
+
+        p->glBlitFramebuffer(0, 0, pp->width, pp->height, 0, 0, pp->width, pp->height,
+                GL_COLOR_BUFFER_BIT, GL_NEAREST);
+        p->glFlush(); /* Perhaps useless */
+    }
+    else
+    {
+        WINE_ERR("eglMakeCurrent failed with 0x%0X\n", p->eglGetError());
+        return FALSE;
+    }
+
+    p->eglMakeCurrent(p->display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
+    p->eglBindAPI(current_api);
+
+    return TRUE;
+}
+
+static BOOL dri2_present(struct dri_backend_priv *priv, int fd, int width, int height, int stride,
+        int depth, int bpp, struct buffer_priv **buffer_priv, Pixmap *pixmap)
+{
+    struct dri2_priv *p = (struct dri2_priv *)priv;
+    struct dri2_pixmap_priv *pp;
+    EGLImageKHR image;
+    GLuint texture_read, texture_write, fbo_read, fbo_write;
+    EGLint attribs[] = {
+        EGL_WIDTH, 0,
+        EGL_HEIGHT, 0,
+        EGL_LINUX_DRM_FOURCC_EXT, DRM_FORMAT_ARGB8888,
+        EGL_DMA_BUF_PLANE0_FD_EXT, 0,
+        EGL_DMA_BUF_PLANE0_OFFSET_EXT, 0,
+        EGL_DMA_BUF_PLANE0_PITCH_EXT, 0,
+        EGL_NONE
+    };
+    EGLenum current_api = 0;
+    int status;
+
+    WINE_TRACE("fd=%d, width=%d, height=%d, stride=%d, depth=%d, bpp=%d\n",
+            fd, width, height, stride, depth, bpp);
+
+    attribs[1] = width;
+    attribs[3] = height;
+    attribs[7] = fd;
+    attribs[11] = stride;
+
+    current_api = p->eglQueryAPI();
+    p->eglBindAPI(EGL_OPENGL_API);
+
+    /* We bind the dma-buf to a EGLImage, then to a texture, and then to a fbo.
+     * Note that we can delete the EGLImage, but we shouldn't delete the texture,
+     * else the fbo is invalid */
+
+    image = p->eglCreateImageKHR(p->display, EGL_NO_CONTEXT, EGL_LINUX_DMA_BUF_EXT,
+                                 NULL, attribs);
+
+    if (image == EGL_NO_IMAGE_KHR) {
+        WINE_ERR("eglCreateImageKHR failed with 0x%0X\n", p->eglGetError());
+        goto fail;
+    }
+    close(fd);
+
+    if (p->eglMakeCurrent(p->display, EGL_NO_SURFACE, EGL_NO_SURFACE, p->context))
+    {
+        p->glGenTextures(1, &texture_read);
+        p->glBindTexture(GL_TEXTURE_2D, texture_read);
+        p->glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+        p->glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+        p->glEGLImageTargetTexture2DOES(GL_TEXTURE_2D, image);
+        p->glGenFramebuffers(1, &fbo_read);
+        p->glBindFramebuffer(GL_FRAMEBUFFER, fbo_read);
+        p->glFramebufferTexture2D(GL_FRAMEBUFFER,
+                                  GL_COLOR_ATTACHMENT0,
+                                  GL_TEXTURE_2D, texture_read,
+                                  0);
+        status = p->glCheckFramebufferStatus(GL_FRAMEBUFFER);
+        if (status != GL_FRAMEBUFFER_COMPLETE)
+            goto fail;
+        p->glBindTexture(GL_TEXTURE_2D, 0);
+        p->eglDestroyImageKHR(p->display, image);
+
+        /* We bind a newly created pixmap (to which we want to copy the content)
+         * to an EGLImage, then to a texture, then to a fbo. */
+        image = p->eglCreateImageKHR(p->display, p->context, EGL_NATIVE_PIXMAP_KHR,
+                                     (void *)*pixmap, NULL);
+        if (image == EGL_NO_IMAGE_KHR)
+            goto fail;
+
+        p->glGenTextures(1, &texture_write);
+        p->glBindTexture(GL_TEXTURE_2D, texture_write);
+        p->glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+        p->glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+        p->glEGLImageTargetTexture2DOES(GL_TEXTURE_2D, image);
+        p->glGenFramebuffers(1, &fbo_write);
+        p->glBindFramebuffer(GL_FRAMEBUFFER, fbo_write);
+        p->glFramebufferTexture2D(GL_FRAMEBUFFER,
+                                  GL_COLOR_ATTACHMENT0,
+                                  GL_TEXTURE_2D, texture_write,
+                                  0);
+        status = p->glCheckFramebufferStatus(GL_FRAMEBUFFER);
+        if (status != GL_FRAMEBUFFER_COMPLETE)
+            goto fail;
+        p->glBindTexture(GL_TEXTURE_2D, 0);
+        p->eglDestroyImageKHR(p->display, image);
+    }
+    else
+        WINE_ERR("eglMakeCurrent failed with 0x%0X\n", p->eglGetError());
+
+    p->eglMakeCurrent(p->display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
+
+    pp = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(struct dri2_pixmap_priv));
+
+    if (!pp)
+        goto fail;
+
+    pp->fbo_read = fbo_read;
+    pp->fbo_write = fbo_write;
+    pp->texture_read = texture_read;
+    pp->texture_write = texture_write;
+    pp->width = width;
+    pp->height = height;
+    pp->next = p->first_dri2_priv;
+    p->first_dri2_priv = pp;
+
+    *buffer_priv = (struct buffer_priv *)pp;
+
+    p->eglBindAPI(current_api);
+
+    return TRUE;
+fail:
+    p->eglMakeCurrent(p->display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
+    p->eglBindAPI(current_api);
+    return FALSE;
+}
+
+static BOOL dri2_window_buffer_from_dmabuf(struct dri_backend_priv *priv,
+    PRESENTpriv *present_priv, int fd, int width, int height,
+    int stride, int depth, int bpp, struct D3DWindowBuffer **out)
+{
+    struct dri2_priv *p = (struct dri2_priv *)priv;
+    Pixmap pixmap;
+
+    WINE_TRACE("present_priv=%p dmaBufFd=%d\n", present_priv, fd);
+
+    if (!out)
+        return FALSE;
+
+    *out = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
+            sizeof(struct D3DWindowBuffer));
+    if (!*out)
+        return FALSE;
+
+    if (!PRESENTPixmapCreate(present_priv, p->screen, &pixmap,
+            width, height, stride, depth, bpp))
+    {
+        HeapFree(GetProcessHeap(), 0, *out);
+        WINE_ERR("Failed to create pixmap\n");
+        return FALSE;
+    }
+
+    if (!dri2_present(priv, fd, width, height, stride, depth, bpp,
+            &(*out)->priv, &pixmap))
+    {
+        WINE_ERR("dri2_present failed\n");
+        HeapFree(GetProcessHeap(), 0, *out);
+        return FALSE;
+    }
+
+    if (!PRESENTPixmapInit(present_priv, pixmap, &((*out)->present_pixmap_priv)))
+    {
+        WINE_ERR("PRESENTPixmapInit failed\n");
+        HeapFree(GetProcessHeap(), 0, *out);
+        return FALSE;
+    }
+
+    return TRUE;
+}
+
+static BOOL dri2_copy_front(PRESENTPixmapPriv *present_pixmap_priv)
+{
+    return FALSE;
+}
+
+static void dri2_destroy_pixmap(struct dri_backend_priv *priv, struct buffer_priv *buffer_priv)
+{
+    struct dri2_priv *p = (struct dri2_priv *)priv;
+    struct dri2_pixmap_priv *pp = (struct dri2_pixmap_priv *)buffer_priv;
+    EGLenum current_api;
+
+    if (p->first_dri2_priv == pp)
+    {
+        p->first_dri2_priv = pp->next;
+    }
+    else
+    {
+        struct dri2_pixmap_priv *current;
+
+        current = p->first_dri2_priv;
+        while (current->next != pp)
+            current = current->next;
+        current->next = pp->next;
+    }
+
+    current_api = p->eglQueryAPI();
+
+    p->eglBindAPI(EGL_OPENGL_API);
+    if (p->eglMakeCurrent(p->display, EGL_NO_SURFACE, EGL_NO_SURFACE, p->context))
+    {
+        p->glDeleteFramebuffers(1, &pp->fbo_read);
+        p->glDeleteFramebuffers(1, &pp->fbo_write);
+        p->glDeleteTextures(1, &pp->texture_read);
+        p->glDeleteTextures(1, &pp->texture_write);
+    }
+    else
+        WINE_ERR("eglMakeCurrent failed with 0x%0X\n", p->eglGetError());
+
+    p->eglMakeCurrent(p->display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
+    p->eglBindAPI(current_api);
+
+    HeapFree(GetProcessHeap(), 0, pp);
+}
+
+/* hypothesis: at this step all textures, etc are destroyed */
+static void dri2_deinit(struct dri_backend_priv *priv)
+{
+    struct dri2_priv *p = (struct dri2_priv *)priv;
+    EGLenum current_api;
+    struct dri2_pixmap_priv *current;
+
+    current = p->first_dri2_priv;
+    while (current)
+    {
+        struct dri2_pixmap_priv *next = current->next;
+        dri2_destroy_pixmap(priv, (struct buffer_priv *)current);
+        current = next;
+    }
+
+    current_api = p->eglQueryAPI();
+    p->eglBindAPI(EGL_OPENGL_API);
+    p->eglMakeCurrent(p->display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
+    p->eglDestroyContext(p->display, p->context);
+    if (display)
+    {
+        /* destroy display connection with last device */
+        display_ref--;
+        if (!display_ref)
+        {
+            p->eglTerminate(display);
+            display = NULL;
+        }
+    }
+    p->eglBindAPI(current_api);
+}
+
+static void dri2_destroy(struct dri_backend_priv *priv)
+{
+    struct dri2_priv *p = (struct dri2_priv *)priv;
+
+    if (!display_ref)
+        dlclose(p->h_egl);
+
+    close(p->fd);
+
+    HeapFree(GetProcessHeap(), 0, p);
+}
+
+static BOOL dri2_probe(Display *dpy)
+{
+    struct dri_backend_priv *priv;
+    BOOL res;
+
+    xcb_connection_t *conn = XGetXCBConnection(dpy);
+    xcb_dri2_query_version_cookie_t dri2_cookie;
+    xcb_dri2_query_version_reply_t *dri2_reply;
+    xcb_generic_error_t *error;
+    const xcb_query_extension_reply_t *extension;
+    /* Request API version 1.4 */
+    const int major = 1;
+    const int minor = 4;
+
+    xcb_prefetch_extension_data(conn, &xcb_dri2_id);
+
+    extension = xcb_get_extension_data(conn, &xcb_dri2_id);
+    if (!(extension && extension->present))
+    {
+        WINE_ERR("DRI2 extension is not present\n");
+        return FALSE;
+    }
+
+    dri2_cookie = xcb_dri2_query_version(conn, major, minor);
+
+    dri2_reply = xcb_dri2_query_version_reply(conn, dri2_cookie, &error);
+    if (!dri2_reply)
+    {
+        free(error);
+        WINE_ERR("Issue getting requested v%d.%d of DRI2\n", major, minor);
+        return FALSE;
+    }
+
+    WINE_TRACE("DRI2 v%d.%d requested, v%d.%d found\n", major, minor,
+            (int)dri2_reply->major_version, (int)dri2_reply->minor_version);
+    free(dri2_reply);
+
+    if (!dri2_create(dpy, DefaultScreen(dpy), &priv))
+        return FALSE;
+
+    res = dri2_init(priv);
+
+    dri2_destroy(priv);
+
+    return res;
+}
+
+const struct dri_backend_funcs dri2_funcs = {
+    .name = "dri2",
+    .probe = dri2_probe,
+    .create = dri2_create,
+    .destroy = dri2_destroy,
+    .init = dri2_init,
+    .deinit = dri2_deinit,
+    .get_fd = dri2_get_fd,
+    .window_buffer_from_dmabuf = dri2_window_buffer_from_dmabuf,
+    .copy_front = dri2_copy_front,
+    .present_pixmap = dri2_present_pixmap,
+    .destroy_pixmap = dri2_destroy_pixmap,
+};
+#endif
diff -purN a/dlls/d3d9-nine/dri3.c b/dlls/d3d9-nine/dri3.c
--- a/dlls/d3d9-nine/dri3.c	1970-01-01 03:00:00.000000000 +0300
+++ b/dlls/d3d9-nine/dri3.c	2019-09-12 21:01:47.926652315 +0300
@@ -0,0 +1,218 @@
+/* SPDX-License-Identifier: LGPL-2.1-or-later */
+/*
+ * Wine DRI3 interface
+ *
+ * Copyright 2014-2015 Axel Davy
+ * Copyright 2015 Patrick Rudolph
+ */
+
+#include <config.h>
+#include <windows.h>
+#include <wine/debug.h>
+#include <X11/Xlib-xcb.h>
+#include <xcb/dri3.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+#include "backend.h"
+#include "xcb_present.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(d3d9nine);
+
+struct dri3_priv {
+    Display *dpy;
+    int screen;
+    int fd;
+};
+
+static BOOL dri3_create(Display *dpy, int screen, struct dri_backend_priv **priv)
+{
+    struct dri3_priv *p;
+    xcb_dri3_open_cookie_t cookie;
+    xcb_dri3_open_reply_t *reply;
+    xcb_connection_t *xcb_connection = XGetXCBConnection(dpy);
+    int fd;
+    Window root = RootWindow(dpy, screen);
+
+    cookie = xcb_dri3_open(xcb_connection, root, 0);
+
+    reply = xcb_dri3_open_reply(xcb_connection, cookie, NULL);
+    if (!reply)
+        return FALSE;
+
+    if (reply->nfd != 1)
+    {
+        free(reply);
+        return FALSE;
+    }
+
+    fd = xcb_dri3_open_reply_fds(xcb_connection, reply)[0];
+    fcntl(fd, F_SETFD, FD_CLOEXEC);
+
+    free(reply);
+
+    p = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(struct dri3_priv));
+    if (!p)
+    {
+        close(fd);
+        return FALSE;
+    }
+
+    p->dpy = dpy;
+    p->screen = screen;
+    p->fd = fd;
+
+    *priv = (struct dri_backend_priv *)p;
+
+    return TRUE;
+}
+
+static void dri3_destroy(struct dri_backend_priv *priv)
+{
+    struct dri3_priv *p = (struct dri3_priv *)priv;
+
+    close(p->fd);
+
+    HeapFree(GetProcessHeap(), 0, p);
+}
+
+static BOOL dri3_init(struct dri_backend_priv *priv)
+{
+    return TRUE;
+}
+
+static void dri3_deinit(struct dri_backend_priv *priv)
+{
+}
+
+static int dri3_get_fd(struct dri_backend_priv *priv)
+{
+    struct dri3_priv *p = (struct dri3_priv *)priv;
+
+    return p->fd;
+}
+
+static BOOL dri3_window_buffer_from_dmabuf(struct dri_backend_priv *priv,
+    PRESENTpriv *present_priv, int fd, int width, int height,
+    int stride, int depth, int bpp, struct D3DWindowBuffer **out)
+{
+    struct dri3_priv *p = (struct dri3_priv *)priv;
+    Pixmap pixmap;
+    xcb_connection_t *xcb_connection = XGetXCBConnection(p->dpy);
+    Window root = RootWindow(p->dpy, p->screen);
+    xcb_void_cookie_t cookie;
+    xcb_generic_error_t *error;
+
+    WINE_TRACE("present_priv=%p dmaBufFd=%d\n", present_priv, fd);
+
+    if (!out)
+        goto err;
+
+    *out = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
+            sizeof(struct D3DWindowBuffer));
+    if (!*out)
+        goto err;
+
+    cookie = xcb_dri3_pixmap_from_buffer_checked(xcb_connection,
+            (pixmap = xcb_generate_id(xcb_connection)), root, 0,
+            width, height, stride, depth, bpp, fd);
+
+    error = xcb_request_check(xcb_connection, cookie); /* performs a flush */
+    if (error)
+    {
+        WINE_ERR("Error using DRI3 to convert a DmaBufFd to pixmap\n");
+        goto err;
+    }
+
+    if (!PRESENTPixmapInit(present_priv, pixmap, &((*out)->present_pixmap_priv)))
+    {
+        WINE_ERR("PRESENTPixmapInit failed\n");
+        HeapFree(GetProcessHeap(), 0, *out);
+        return FALSE;
+    }
+
+    return TRUE;
+
+err:
+    WINE_ERR("dri3_window_buffer_from_dmabuf failed\n");
+    if (out)
+        HeapFree(GetProcessHeap(), 0, *out);
+    return FALSE;
+}
+
+static BOOL dri3_copy_front(PRESENTPixmapPriv *present_pixmap_priv)
+{
+    return PRESENTHelperCopyFront(present_pixmap_priv);
+}
+
+static BOOL dri3_present_pixmap(struct dri_backend_priv *priv, struct buffer_priv *buffer_priv)
+{
+    return TRUE;
+}
+
+static void dri3_destroy_pixmap(struct dri_backend_priv *priv, struct buffer_priv *buffer_priv)
+{
+}
+
+static BOOL dri3_probe(Display *dpy)
+{
+    struct dri_backend_priv *p;
+    xcb_connection_t *xcb_connection = XGetXCBConnection(dpy);
+    xcb_dri3_query_version_cookie_t dri3_cookie;
+    xcb_dri3_query_version_reply_t *dri3_reply;
+    xcb_generic_error_t *error;
+    const xcb_query_extension_reply_t *extension;
+    BOOL res;
+    const int major = 1;
+    const int minor = 0;
+
+    xcb_prefetch_extension_data(xcb_connection, &xcb_dri3_id);
+
+    extension = xcb_get_extension_data(xcb_connection, &xcb_dri3_id);
+    if (!(extension && extension->present))
+    {
+        WINE_ERR("DRI3 extension is not present\n");
+        return FALSE;
+    }
+
+    dri3_cookie = xcb_dri3_query_version(xcb_connection, major, minor);
+
+    dri3_reply = xcb_dri3_query_version_reply(xcb_connection, dri3_cookie, &error);
+    if (!dri3_reply)
+    {
+        free(error);
+        WINE_ERR("Issue getting requested v%d.%d of DRI3\n", major, minor);
+        return FALSE;
+    }
+
+    WINE_TRACE("DRI3 v%d.%d found, v%d.%d requested\n", major, minor,
+            (int)dri3_reply->major_version, (int)dri3_reply->minor_version);
+    free(dri3_reply);
+
+    if (!dri3_create(dpy, DefaultScreen(dpy), &p))
+    {
+        WINE_ERR("DRI3 advertised, but not working\n");
+        return FALSE;
+    }
+
+    res = dri3_init(p);
+
+    dri3_destroy(p);
+
+    return res;
+}
+
+const struct dri_backend_funcs dri3_funcs = {
+    .name = "dri3",
+    .probe = dri3_probe,
+    .create = dri3_create,
+    .destroy = dri3_destroy,
+    .init = dri3_init,
+    .deinit = dri3_deinit,
+    .get_fd = dri3_get_fd,
+    .window_buffer_from_dmabuf = dri3_window_buffer_from_dmabuf,
+    .copy_front = dri3_copy_front,
+    .present_pixmap = dri3_present_pixmap,
+    .destroy_pixmap = dri3_destroy_pixmap,
+};
diff -purN a/dlls/d3d9-nine/dri3.h b/dlls/d3d9-nine/dri3.h
--- a/dlls/d3d9-nine/dri3.h	1970-01-01 03:00:00.000000000 +0300
+++ b/dlls/d3d9-nine/dri3.h	2019-09-12 21:01:47.926652315 +0300
@@ -0,0 +1,91 @@
+/*
+ * Wine X11DRV DRI3 interface
+ *
+ * Copyright 2014 Axel Davy
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __WINE_DRI3_H
+#define __WINE_DRI3_H
+
+#ifndef __WINE_CONFIG_H
+# error You must include config.h to use this header
+#endif
+
+#include <X11/Xlib.h>
+#include <wingdi.h>
+
+BOOL DRI3CheckExtension(Display *dpy, int major, int minor);
+
+#ifdef D3D9NINE_DRI2
+struct DRI2priv;
+
+BOOL DRI2FallbackInit(Display *dpy, struct DRI2priv **priv);
+
+void DRI2FallbackDestroy(struct DRI2priv *priv);
+
+BOOL DRI2FallbackCheckSupport(Display *dpy);
+#endif
+
+BOOL PRESENTCheckExtension(Display *dpy, int major, int minor);
+
+BOOL DRI3Open(Display *dpy, int screen, int *device_fd);
+
+#ifdef D3D9NINE_DRI2
+BOOL DRI2FallbackOpen(Display *dpy, int screen, int *device_fd);
+#endif
+
+BOOL DRI3PixmapFromDmaBuf(Display *dpy, int screen, int fd, int width, int height,
+        int stride, int depth, int bpp, Pixmap *pixmap);
+
+BOOL DRI3DmaBufFromPixmap(Display *dpy, Pixmap pixmap, int *fd, int *width, int *height,
+        int *stride, int *depth, int *bpp);
+
+typedef struct PRESENTPriv PRESENTpriv;
+typedef struct PRESENTPixmapPriv PRESENTPixmapPriv;
+
+BOOL PRESENTInit(Display *dpy, PRESENTpriv **present_priv);
+
+/* will clean properly and free all PRESENTPixmapPriv associated to PRESENTpriv.
+ * PRESENTPixmapPriv should not be freed by something else.
+ * If never a PRESENTPixmapPriv has to be destroyed,
+ * please destroy the current PRESENTpriv and create a new one.
+ * This will take care than all pixmaps are released */
+void PRESENTDestroy(Display *dpy, PRESENTpriv *present_priv);
+
+BOOL PRESENTPixmapInit(PRESENTpriv *present_priv, Pixmap pixmap, PRESENTPixmapPriv **present_pixmap_priv);
+
+#ifdef D3D9NINE_DRI2
+BOOL DRI2FallbackPRESENTPixmap(PRESENTpriv *present_priv, struct DRI2priv *priv,
+        int fd, int width, int height, int stride, int depth,
+        int bpp, PRESENTPixmapPriv **present_pixmap_priv);
+#endif
+
+BOOL PRESENTTryFreePixmap(Display *dpy, PRESENTPixmapPriv *present_pixmap_priv);
+
+BOOL PRESENTHelperCopyFront(Display *dpy, PRESENTPixmapPriv *present_pixmap_priv);
+
+BOOL PRESENTPixmap(Display *dpy, XID window, PRESENTPixmapPriv *present_pixmap_priv,
+        const UINT PresentationInterval, const BOOL PresentAsync, const BOOL SwapEffectCopy,
+        const RECT *pSourceRect, const RECT *pDestRect, const RGNDATA *pDirtyRegion);
+
+BOOL PRESENTWaitPixmapReleased(PRESENTPixmapPriv *present_pixmap_priv);
+
+BOOL PRESENTIsPixmapReleased(PRESENTPixmapPriv *present_pixmap_priv);
+
+BOOL PRESENTWaitReleaseEvent(PRESENTpriv *present_priv);
+
+#endif /* __WINE_DRI3_H */
diff -purN a/dlls/d3d9-nine/library.c b/dlls/d3d9-nine/library.c
--- a/dlls/d3d9-nine/library.c	1970-01-01 03:00:00.000000000 +0300
+++ b/dlls/d3d9-nine/library.c	2019-09-12 21:01:47.926652315 +0300
@@ -0,0 +1,123 @@
+/* SPDX-License-Identifier: LGPL-2.1-or-later */
+
+#include <config.h>
+#include <wine/debug.h>
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <dlfcn.h>
+#include <unistd.h>
+
+#include "library.h"
+#include "registry.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(d3d9nine);
+
+#define D3DADAPTER9 "d3dadapter9.so.1"
+
+static void *open_d3dadapter(char *paths, char **res, char **err)
+{
+    char *next, *end, *p, *lasterr = NULL;
+    void *handle = NULL;
+    char path[MAX_PATH];
+    struct stat st;
+    int len;
+
+    end = paths + strlen(paths);
+    for (p = paths; p < end; p = next + 1)
+    {
+        next = strchr(p, ':');
+        if (!next)
+            next = end;
+
+        len = next - p;
+        snprintf(path, sizeof(path), "%.*s", len, p);
+
+        if (!stat(path, &st) && S_ISDIR(st.st_mode))
+            strcat(path, "/" D3DADAPTER9);
+
+        WINE_TRACE("Trying to load '%s'\n", path);
+        handle = dlopen(path, RTLD_GLOBAL | RTLD_NOW);
+
+        if (handle) {
+            if (res)
+              *res = strdup(path);
+
+            break;
+        }
+
+        free(lasterr);
+        lasterr = strdup(dlerror());
+
+        WINE_TRACE("Failed to load '%s': %s\n", path, lasterr);
+    }
+
+    if (handle || !err)
+    {
+        free(lasterr);
+        lasterr = NULL;
+    }
+
+    if (handle)
+        WINE_TRACE("Loaded '%s'\n", path);
+
+    if (err)
+        *err = lasterr;
+
+    return handle;
+}
+
+void *common_load_d3dadapter(char **path, char **err)
+{
+    static void *handle = NULL;
+    char *env, *reg;
+
+    env = getenv("D3D_MODULE_PATH");
+    if (env)
+    {
+        handle = open_d3dadapter(env, path, err);
+
+        if (!handle)
+            WINE_ERR("Failed to load " D3DADAPTER9 " set by D3D_MODULE_PATH (%s)\n", env);
+
+        return handle;
+    }
+
+    if (common_get_registry_string(reg_path_nine, reg_key_module_path, &reg))
+    {
+        handle = open_d3dadapter(reg, path, err);
+
+        if (!handle)
+            WINE_ERR("Failed to load " D3DADAPTER9 " set by ModulePath (%s)\n", reg);
+
+        HeapFree(GetProcessHeap(), 0, reg);
+
+        return handle;
+    }
+
+#if defined(D3D9NINE_MODULEPATH)
+    handle = open_d3dadapter(D3D9NINE_MODULEPATH, path, err);
+
+    if (!handle)
+        WINE_ERR("Failed to load " D3DADAPTER9 " set by builtin default '%s'\n",
+                 D3D9NINE_MODULEPATH);
+
+    return handle;
+#else
+    handle = open_d3dadapter("/usr/lib/x86_64-linux-gnu/d3d:" // 64bit debian/ubuntu
+                             "/usr/lib/i386-linux-gnu/d3d:"   // 32bit debian/ubuntu
+                             "/usr/lib64/d3d:"                // 64bit gentoo/suse/fedora
+                             "/usr/lib/d3d:"                  // 32bit suse/fedora, 64bit arch
+                             "/usr/lib32/d3d"                 // 32bit arch/gentoo
+                             , path, err);
+
+    if (!handle)
+        WINE_ERR(D3DADAPTER9 " was not found on your system.\n"
+                 "Setting the envvar D3D_MODULE_PATH or "
+                 "regkey Software\\Wine\\Direct3DNine\\ModulePath is required\n");
+
+    return handle;
+#endif
+}
diff -purN a/dlls/d3d9-nine/library.h b/dlls/d3d9-nine/library.h
--- a/dlls/d3d9-nine/library.h	1970-01-01 03:00:00.000000000 +0300
+++ b/dlls/d3d9-nine/library.h	2019-09-12 21:01:47.926652315 +0300
@@ -0,0 +1,8 @@
+/* SPDX-License-Identifier: LGPL-2.1-or-later */
+
+#ifndef __COMMON_LIBRARY_H
+#define __COMMON_LIBRARY_H
+
+void *common_load_d3dadapter(char **path, char **err);
+
+#endif /* __COMMON_LIBRARY_H */
diff -purN a/dlls/d3d9-nine/Makefile.in b/dlls/d3d9-nine/Makefile.in
--- a/dlls/d3d9-nine/Makefile.in	1970-01-01 03:00:00.000000000 +0300
+++ b/dlls/d3d9-nine/Makefile.in	2019-09-12 21:01:47.926652315 +0300
@@ -0,0 +1,21 @@
+MODULE    = d3d9-nine.dll
+IMPORTS   = dxguid uuid advapi32 gdi32 user32
+EXTRAINCL = $(X_CFLAGS) $(D3D9NINE_HEADERS_CFLAGS)
+EXTRALIBS = $(D3D9NINE_LIBS) -ldl -lxcb-dri2
+EXTRADEFS = -DNINE_VERSION=\"v0.4\" -DNINE_URL=\"https://github.com/iXit/wine-nine-standalone\" -DNINE_MAJOR=0 -DNINE_MINOR=4 -DNINE_BUILD=1 -DNINE_REVISION=1 -DD3D9NINE_DRI2=1
+
+C_SRCS = \
+        backend.c \
+        d3d9_main.c \
+        d3dadapter9.c \
+        device_wrap.c \
+        library.c \
+        present.c \
+        registry.c \
+        dri2.c \
+        dri3.c \
+        wndproc.c \
+        shader_validator.c \
+        xcb_present.c
+
+RC_SRCS = version.rc
diff -purN a/dlls/d3d9-nine/present.c b/dlls/d3d9-nine/present.c
--- a/dlls/d3d9-nine/present.c	1970-01-01 03:00:00.000000000 +0300
+++ b/dlls/d3d9-nine/present.c	2019-09-12 21:01:47.926652315 +0300
@@ -0,0 +1,1749 @@
+/* SPDX-License-Identifier: LGPL-2.1-or-later */
+/*
+ * Wine ID3DAdapter9 support functions
+ *
+ * Copyright 2013 Joakim Sindholt
+ *                Christoph Bumiller
+ * Copyright 2014 Tiziano Bacocco
+ *                David Heidelberger
+ * Copyright 2014-2015 Axel Davy
+ * Copyright 2015 Patrick Rudolph
+ */
+
+#include <config.h>
+#include <d3dadapter/drm.h>
+#include <wine/debug.h>
+#include <X11/Xatom.h>
+#include <X11/Xlib.h>
+#include <X11/Xutil.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <dlfcn.h>
+
+#include "library.h"
+#include "backend.h"
+#include "wndproc.h"
+#include "xcb_present.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(d3d9nine);
+
+#ifndef D3DPRESENT_DONOTWAIT
+#define D3DPRESENT_DONOTWAIT      0x00000001
+#endif
+
+#define WINE_D3DADAPTER_DRIVER_PRESENT_VERSION_MAJOR 1
+#if defined (ID3DPresent_SetPresentParameters2)
+#define WINE_D3DADAPTER_DRIVER_PRESENT_VERSION_MINOR 3
+#elif defined (ID3DPresent_ResolutionMismatch)
+#define WINE_D3DADAPTER_DRIVER_PRESENT_VERSION_MINOR 2
+#elif defined (ID3DPresent_GetWindowOccluded)
+#define WINE_D3DADAPTER_DRIVER_PRESENT_VERSION_MINOR 1
+#else
+#define WINE_D3DADAPTER_DRIVER_PRESENT_VERSION_MINOR 0
+#endif
+
+static const struct D3DAdapter9DRM *d3d9_drm = NULL;
+
+/* Start section of x11drv.h */
+#define X11DRV_ESCAPE 6789
+enum x11drv_escape_codes
+{
+    X11DRV_SET_DRAWABLE,     /* set current drawable for a DC */
+    X11DRV_GET_DRAWABLE,     /* get current drawable for a DC */
+    X11DRV_START_EXPOSURES,  /* start graphics exposures */
+    X11DRV_END_EXPOSURES,    /* end graphics exposures */
+    X11DRV_FLUSH_GL_DRAWABLE /* flush changes made to the gl drawable */
+};
+
+struct x11drv_escape_get_drawable
+{
+    enum x11drv_escape_codes code;         /* escape code (X11DRV_GET_DRAWABLE) */
+    Drawable                 drawable;     /* X drawable */
+    Drawable                 gl_drawable;  /* GL drawable */
+    int                      pixel_format; /* internal GL pixel format */
+};
+/* End section x11drv.h */
+
+static XContext d3d_hwnd_context;
+static CRITICAL_SECTION context_section;
+static CRITICAL_SECTION_DEBUG critsect_debug =
+{
+    0, 0, &context_section,
+    { &critsect_debug.ProcessLocksList, &critsect_debug.ProcessLocksList },
+      0, 0, { /*(DWORD_PTR)(__FILE__ ": context_section")*/ }
+};
+static CRITICAL_SECTION context_section = { &critsect_debug, -1, 0, 0, 0, 0 };
+
+const GUID IID_ID3DPresent = { 0x77D60E80, 0xF1E6, 0x11DF, { 0x9E, 0x39, 0x95, 0x0C, 0xDF, 0xD7, 0x20, 0x85 } };
+const GUID IID_ID3DPresentGroup = { 0xB9C3016E, 0xF32A, 0x11DF, { 0x9C, 0x18, 0x92, 0xEA, 0xDE, 0xD7, 0x20, 0x85 } };
+
+struct d3d_drawable
+{
+    Drawable drawable; /* X11 drawable */
+    HDC hdc;
+    HWND wnd; /* HWND (for convenience) */
+    RECT windowRect;
+    POINT offset; /* offset of the client area compared to the X11 drawable */
+    unsigned int width;
+    unsigned int height;
+    unsigned int depth;
+};
+
+struct DRIPresent
+{
+    /* COM vtable */
+    void *vtable;
+    /* IUnknown reference count */
+    LONG refs;
+
+    D3DPRESENT_PARAMETERS params;
+    HWND focus_wnd;
+    PRESENTpriv *present_priv;
+
+    WCHAR devname[32];
+    HCURSOR hCursor;
+
+    DEVMODEW initial_mode;
+
+    DWORD style;
+    DWORD style_ex;
+
+    BOOL reapply_mode;
+    BOOL ex;
+    BOOL resolution_mismatch;
+    BOOL occluded;
+    BOOL drop_wnd_messages;
+    BOOL no_window_changes;
+    Display *gdi_display;
+
+    UINT present_interval;
+    BOOL present_async;
+    BOOL present_swapeffectcopy;
+    BOOL allow_discard_delayed_release;
+    BOOL tear_free_discard;
+    struct d3d_drawable *d3d;
+
+    struct dri_backend *dri_backend;
+};
+
+static void free_d3dadapter_drawable(struct d3d_drawable *d3d)
+{
+    ReleaseDC(d3d->wnd, d3d->hdc);
+    HeapFree(GetProcessHeap(), 0, d3d);
+}
+
+static void destroy_d3dadapter_drawable(Display *gdi_display, HWND hwnd)
+{
+    struct d3d_drawable *d3d;
+    //WINE_TRACE("This=%p hwnd=%p\n", gdi_display, hwnd);
+
+    EnterCriticalSection(&context_section);
+    if (!XFindContext(gdi_display, (XID)hwnd,
+            d3d_hwnd_context, (char **)&d3d))
+    {
+        XDeleteContext(gdi_display, (XID)hwnd, d3d_hwnd_context);
+        free_d3dadapter_drawable(d3d);
+    }
+    LeaveCriticalSection(&context_section);
+}
+
+/* Compute the position of a drawable compared to a parent */
+static void get_relative_position(Display *display, Drawable drawable, Drawable parent, POINT *offset)
+{
+    Window Wroot, Wparent, *Wchildren;
+    int resx = 0, resy = 0, dx, dy;
+    unsigned int width, height, border_width, depth, children;
+
+    while (1) {
+        if (!XGetGeometry(display, drawable, &Wroot, &dx, &dy, &width, &height, &border_width, &depth))
+            break;
+
+        WINE_TRACE("Next geometry: %d %d\n", dx, dy);
+
+        /* Should we really add border_width ? */
+        resx += dx + border_width;
+        resy += dy + border_width;
+
+        if (!XQueryTree(display, drawable, &Wroot, &Wparent, &Wchildren, &children))
+            break;
+
+        if (Wchildren)
+            XFree(Wchildren);
+
+        if (Wparent == Wroot || Wparent == parent)
+        {
+            WINE_TRACE("Successfully determined drawable pos (debug: %ld, %ld, %ld)\n", drawable, Wroot, parent);
+            break;
+        }
+
+        drawable = Wparent;
+    }
+
+    offset->x = resx;
+    offset->y = resy;
+}
+
+static BOOL CALLBACK edm_callback(HMONITOR monitor, HDC hdc, LPRECT rect, LPARAM lp)
+{
+    RECT *r = (RECT *)lp;
+
+    UnionRect(r, r, rect);
+    return TRUE;
+}
+
+/* see wine's get_virtual_screen_rect() */
+static void offset_by_virtual_screen(POINT *pt)
+{
+    RECT r;
+
+    SetRectEmpty(&r);
+    EnumDisplayMonitors(0, NULL, edm_callback, (LPARAM)&r);
+
+    WINE_TRACE("Virtual screen size: %s\n", wine_dbgstr_rect(&r));
+
+    pt->x -= r.left;
+    pt->y -= r.top;
+}
+
+static BOOL get_wine_drawable_from_dc(HDC hdc, Drawable *drawable)
+{
+    struct x11drv_escape_get_drawable extesc = { X11DRV_GET_DRAWABLE };
+
+    if (ExtEscape(hdc, X11DRV_ESCAPE, sizeof(extesc), (LPCSTR)&extesc,
+                  sizeof(extesc), (LPSTR)&extesc) <= 0)
+    {
+        WINE_ERR("Unexpected error in X Drawable lookup (hdc=%p)\n", hdc);
+        return FALSE;
+    }
+
+    if (drawable)
+        *drawable = extesc.drawable;
+
+    return TRUE;
+}
+
+static BOOL get_wine_drawable_from_wnd(HWND hwnd, Drawable *drawable, HDC *hdc)
+{
+    HDC h;
+
+    h = GetDCEx(hwnd, 0, DCX_CACHE | DCX_CLIPSIBLINGS);
+    if (!h)
+        return FALSE;
+
+    if (!get_wine_drawable_from_dc(h, drawable))
+    {
+        ReleaseDC(hwnd, h);
+        return FALSE;
+    }
+
+    if (hdc)
+        *hdc = h;
+    else
+        ReleaseDC(hwnd, h);
+
+    return TRUE;
+}
+
+static void DRIPresent_FillOffset(Display *gdi_display, struct d3d_drawable *d3d)
+{
+    Drawable wineRoot;
+    POINT pt;
+    Window Wroot;
+    int x, y;
+    unsigned int border_width;
+
+    //WINE_TRACE("hwnd=%p\n", d3d->wnd);
+
+    /* Finding the offset is hard because a drawable
+     * doesn't always start a the top left of a hwnd window,
+     * for example if the windows window decoration is replaced
+     * by the window managed.
+     * In the case of non-virtual desktop, wine root is
+     * the X root.
+     * In the case of virtual desktop, We assume the root drawable
+     * begins at pos (0, 0) */
+
+    d3d->offset.x = d3d->offset.y = 0;
+
+    if (!get_wine_drawable_from_wnd(GetDesktopWindow(), &wineRoot, NULL))
+        return;
+
+    if (!XGetGeometry(gdi_display, d3d->drawable, &Wroot, &x, &y, &d3d->width, &d3d->height, &border_width, &d3d->depth))
+    {
+        d3d->width = 0;
+        d3d->height = 0;
+        d3d->depth= 0;
+    }
+
+    /* The position of the top left client area compared to wine root window */
+    pt.x = pt.y = 0;
+    if (!ClientToScreen(d3d->wnd, &pt))
+    {
+        WINE_ERR("ClientToScreen failed: 0x%x\n", GetLastError());
+        return;
+    }
+    WINE_TRACE("Relative coord client area: %d %d\n", pt.x, pt.y);
+    offset_by_virtual_screen(&pt);
+    WINE_TRACE("Coord client area: %d %d\n", pt.x, pt.y);
+    d3d->offset.x += pt.x;
+    d3d->offset.y += pt.y;
+
+    get_relative_position(gdi_display, d3d->drawable, wineRoot, &pt);
+    WINE_TRACE("Coord drawable: %d %d\n", pt.x, pt.y);
+    d3d->offset.x -= pt.x;
+    d3d->offset.y -= pt.y;
+
+    WINE_TRACE("Offset: %d %d\n", d3d->offset.x, d3d->offset.y);
+}
+
+static struct d3d_drawable *create_d3dadapter_drawable(Display *gdi_display, HWND hwnd)
+{
+    struct d3d_drawable *d3d;
+
+    //WINE_TRACE("hwnd=%p\n", hwnd);
+
+    d3d = HeapAlloc(GetProcessHeap(), 0, sizeof(*d3d));
+    if (!d3d)
+    {
+        WINE_ERR("Couldn't allocate d3d_drawable.\n");
+        return NULL;
+    }
+
+    if (!get_wine_drawable_from_wnd(hwnd, &d3d->drawable, &d3d->hdc))
+    {
+        ReleaseDC(hwnd, d3d->hdc);
+        HeapFree(GetProcessHeap(), 0, d3d);
+        return NULL;
+    }
+
+    WINE_TRACE("hwnd drawable: %ld\n", d3d->drawable);
+    d3d->wnd = hwnd;
+    GetWindowRect(hwnd, &d3d->windowRect);
+    DRIPresent_FillOffset(gdi_display, d3d);
+
+    return d3d;
+}
+
+static struct d3d_drawable *get_d3d_drawable(Display *gdi_display, HWND hwnd)
+{
+    struct d3d_drawable *d3d, *race;
+
+    //WINE_TRACE("hwnd=%p\n", hwnd);
+
+    EnterCriticalSection(&context_section);
+    if (!XFindContext(gdi_display, (XID)hwnd, d3d_hwnd_context, (char **)&d3d))
+    {
+        return d3d;
+    }
+    LeaveCriticalSection(&context_section);
+
+    WINE_TRACE("No d3d_drawable attached to hwnd %p, creating one.\n", hwnd);
+
+    d3d = create_d3dadapter_drawable(gdi_display, hwnd);
+    if (!d3d)
+        return NULL;
+
+    EnterCriticalSection(&context_section);
+    if (!XFindContext(gdi_display, (XID)hwnd,
+            d3d_hwnd_context, (char **)&race))
+    {
+        /* apparently someone beat us to creating this d3d drawable. Let's not
+           waste more time with X11 calls and just use theirs instead. */
+        free_d3dadapter_drawable(d3d);
+        return race;
+    }
+    XSaveContext(gdi_display, (XID)hwnd, d3d_hwnd_context, (char *)d3d);
+    return d3d;
+}
+
+static void release_d3d_drawable(struct d3d_drawable *d3d)
+{
+    if (!d3d)
+        WINE_ERR("Driver internal error: d3d_drawable is NULL\n");
+    LeaveCriticalSection(&context_section);
+}
+
+static ULONG WINAPI DRIPresent_AddRef(struct DRIPresent *This)
+{
+    ULONG refs = InterlockedIncrement(&This->refs);
+    WINE_TRACE("%p increasing refcount to %u.\n", This, refs);
+    return refs;
+}
+
+static ULONG WINAPI DRIPresent_Release(struct DRIPresent *This)
+{
+    ULONG refs = InterlockedDecrement(&This->refs);
+    WINE_TRACE("%p decreasing refcount to %u.\n", This, refs);
+    if (refs == 0)
+    {
+        /* dtor */
+        (void) nine_unregister_window(This->focus_wnd);
+        if (This->d3d)
+            destroy_d3dadapter_drawable(This->gdi_display, This->d3d->wnd);
+        ChangeDisplaySettingsExW(This->devname, &(This->initial_mode), 0, CDS_FULLSCREEN, NULL);
+        PRESENTDestroy(This->present_priv);
+        This->dri_backend->funcs->deinit(This->dri_backend->priv);
+        HeapFree(GetProcessHeap(), 0, This);
+    }
+    return refs;
+}
+
+static HRESULT WINAPI DRIPresent_QueryInterface(struct DRIPresent *This,
+        REFIID riid, void **ppvObject)
+{
+    if (!ppvObject)
+        return E_POINTER;
+
+    if (IsEqualGUID(&IID_ID3DPresent, riid) ||
+            IsEqualGUID(&IID_IUnknown, riid))
+    {
+        *ppvObject = This;
+        DRIPresent_AddRef(This);
+        return S_OK;
+    }
+
+    WINE_WARN("%s not implemented, returning E_NOINTERFACE.\n", wine_dbgstr_guid(riid));
+    *ppvObject = NULL;
+
+    return E_NOINTERFACE;
+}
+
+static HRESULT DRIPresent_ChangePresentParameters(struct DRIPresent *This,
+        D3DPRESENT_PARAMETERS *params);
+
+static HRESULT WINAPI DRIPresent_SetPresentParameters(struct DRIPresent *This,
+        D3DPRESENT_PARAMETERS *pPresentationParameters,
+        D3DDISPLAYMODEEX *pFullscreenDisplayMode)
+{
+    if (pFullscreenDisplayMode)
+        WINE_FIXME("Ignoring pFullscreenDisplayMode\n");
+    return DRIPresent_ChangePresentParameters(This, pPresentationParameters);
+}
+
+static HRESULT WINAPI DRIPresent_D3DWindowBufferFromDmaBuf(struct DRIPresent *This,
+        int dmaBufFd, int width, int height, int stride, int depth,
+        int bpp, struct D3DWindowBuffer **out)
+{
+    const struct dri_backend *dri_backend = This->dri_backend;
+
+    if (!dri_backend->funcs->window_buffer_from_dmabuf(dri_backend->priv,
+            This->present_priv, dmaBufFd, width, height, stride, depth, bpp, out))
+    {
+        WINE_ERR("window_buffer_from_dmabuf failed\n");
+        return D3DERR_DRIVERINTERNALERROR;
+    }
+
+    //WINE_TRACE("This=%p buffer=%p\n", This, *out);
+    return D3D_OK;
+}
+
+static HRESULT WINAPI DRIPresent_DestroyD3DWindowBuffer(struct DRIPresent *This,
+        struct D3DWindowBuffer *buffer)
+{
+    const struct dri_backend *dri_backend = This->dri_backend;
+
+    /* the pixmap is managed by the PRESENT backend.
+     * But if it can delete it right away, we may have
+     * better performance */
+    //WINE_TRACE("This=%p buffer=%p of priv %p\n", This, buffer, buffer->present_pixmap_priv);
+    PRESENTTryFreePixmap(buffer->present_pixmap_priv);
+    dri_backend->funcs->destroy_pixmap(dri_backend->priv, buffer->priv);
+    HeapFree(GetProcessHeap(), 0, buffer);
+    return D3D_OK;
+}
+
+static HRESULT WINAPI DRIPresent_WaitBufferReleased(struct DRIPresent *This,
+        struct D3DWindowBuffer *buffer)
+{
+    //WINE_TRACE("This=%p buffer=%p\n", This, buffer);
+    if(!PRESENTWaitPixmapReleased(buffer->present_pixmap_priv))
+    {
+        WINE_ERR("PRESENTWaitPixmapReleased failed\n");
+        return D3DERR_DRIVERINTERNALERROR;
+    }
+    return D3D_OK;
+}
+
+static HRESULT WINAPI DRIPresent_FrontBufferCopy(struct DRIPresent *This,
+        struct D3DWindowBuffer *buffer)
+{
+    const struct dri_backend *dri_backend = This->dri_backend;
+
+    if (!dri_backend->funcs->copy_front(buffer->present_pixmap_priv))
+        return D3DERR_DRIVERINTERNALERROR;
+
+    return D3D_OK;
+}
+
+static HRESULT WINAPI DRIPresent_PresentBuffer( struct DRIPresent *This,
+        struct D3DWindowBuffer *buffer, HWND hWndOverride, const RECT *pSourceRect,
+        const RECT *pDestRect, const RGNDATA *pDirtyRegion, DWORD Flags )
+{
+    const struct dri_backend *dri_backend = This->dri_backend;
+    struct d3d_drawable *d3d;
+    RECT dest_translate;
+    RECT windowRect;
+    RECT offset;
+    HWND hwnd;
+
+    if (hWndOverride)
+        hwnd = hWndOverride;
+    else if (This->params.hDeviceWindow)
+        hwnd = This->params.hDeviceWindow;
+    else
+        hwnd = This->focus_wnd;
+
+    //WINE_TRACE("This=%p hwnd=%p\n", This, hwnd);
+
+    d3d = get_d3d_drawable(This->gdi_display, hwnd);
+
+    if (!d3d)
+        return D3DERR_DRIVERINTERNALERROR;
+
+    /* TODO: should we use a list here instead ? */
+    if (This->d3d && (This->d3d->wnd != d3d->wnd))
+        destroy_d3dadapter_drawable(This->gdi_display, This->d3d->wnd);
+
+    This->d3d = d3d;
+
+    GetWindowRect(d3d->wnd, &windowRect);
+    /* The "correct" way to detect offset changes
+     * would be to catch any window related change with a
+     * listener. But it is complicated and this heuristic
+     * is fast and should work well. */
+    if (windowRect.top != d3d->windowRect.top ||
+        windowRect.left != d3d->windowRect.left ||
+        windowRect.bottom != d3d->windowRect.bottom ||
+        windowRect.right != d3d->windowRect.right)
+    {
+        d3d->windowRect = windowRect;
+        DRIPresent_FillOffset(This->gdi_display, d3d);
+    }
+
+    GetClientRect(d3d->wnd, &offset);
+    offset.left += d3d->offset.x;
+    offset.top += d3d->offset.y;
+    offset.right += d3d->offset.x;
+    offset.bottom += d3d->offset.y;
+
+    if ((offset.top != 0) || (offset.left != 0))
+    {
+        if (!pDestRect)
+            pDestRect = (const RECT *) &offset;
+        else
+        {
+            dest_translate.top = pDestRect->top + offset.top;
+            dest_translate.left = pDestRect->left + offset.left;
+            dest_translate.bottom = pDestRect->bottom + offset.bottom;
+            dest_translate.right = pDestRect->right + offset.right;
+            pDestRect = (const RECT *) &dest_translate;
+        }
+    }
+
+    if (!PRESENTPixmapPrepare(d3d->drawable, buffer->present_pixmap_priv))
+    {
+        release_d3d_drawable(d3d);
+        WINE_ERR("PresentPrepare call failed\n");
+        return D3DERR_DRIVERINTERNALERROR;
+    }
+
+    /* FIMXE: Do we need to aquire present mutex here? */
+    dri_backend->funcs->present_pixmap(dri_backend->priv, buffer->priv);
+
+    if (!PRESENTPixmap(d3d->drawable, buffer->present_pixmap_priv,
+            This->present_interval, This->present_async, This->present_swapeffectcopy,
+            pSourceRect, pDestRect, pDirtyRegion))
+    {
+        release_d3d_drawable(d3d);
+        WINE_TRACE("Present call failed\n");
+        return D3DERR_DRIVERINTERNALERROR;
+    }
+    release_d3d_drawable(d3d);
+
+    return D3D_OK;
+}
+
+/* Based on wine's wined3d_get_adapter_raster_status. */
+static HRESULT WINAPI DRIPresent_GetRasterStatus( struct DRIPresent *This,
+        D3DRASTER_STATUS *pRasterStatus )
+{
+    LONGLONG freq_per_frame, freq_per_line;
+    LARGE_INTEGER counter, freq_per_sec;
+    unsigned refresh_rate, height;
+
+    WINE_TRACE("This=%p, pRasterStatus=%p\n", This, pRasterStatus);
+
+    if (!QueryPerformanceCounter(&counter) || !QueryPerformanceFrequency(&freq_per_sec))
+        return D3DERR_INVALIDCALL;
+
+    if (This->params.Windowed)
+    {
+        refresh_rate = This->initial_mode.dmDisplayFrequency;
+        height = This->initial_mode.dmPelsHeight;
+    }
+    else
+    {
+        refresh_rate = This->params.FullScreen_RefreshRateInHz;
+        height = This->params.BackBufferHeight;
+    }
+
+    if (refresh_rate == 0)
+        refresh_rate = 60;
+
+    WINE_TRACE("refresh_rate=%u, height=%u\n", refresh_rate, height);
+
+    freq_per_frame = freq_per_sec.QuadPart / refresh_rate;
+    /* Assume 20 scan lines in the vertical blank. */
+    freq_per_line = freq_per_frame / (height + 20);
+    pRasterStatus->ScanLine = (counter.QuadPart % freq_per_frame) / freq_per_line;
+    if (pRasterStatus->ScanLine < height)
+        pRasterStatus->InVBlank = FALSE;
+    else
+    {
+        pRasterStatus->ScanLine = 0;
+        pRasterStatus->InVBlank = TRUE;
+    }
+
+    WINE_TRACE("Returning fake value, InVBlank %u, ScanLine %u.\n",
+            pRasterStatus->InVBlank, pRasterStatus->ScanLine);
+
+    return D3D_OK;
+}
+
+static HRESULT WINAPI DRIPresent_GetDisplayMode( struct DRIPresent *This,
+        D3DDISPLAYMODEEX *pMode, D3DDISPLAYROTATION *pRotation )
+{
+    DEVMODEW dm;
+
+    ZeroMemory(&dm, sizeof(dm));
+    dm.dmSize = sizeof(dm);
+
+    EnumDisplaySettingsExW(This->devname, ENUM_CURRENT_SETTINGS, &dm, 0);
+    pMode->Width = dm.dmPelsWidth;
+    pMode->Height = dm.dmPelsHeight;
+    pMode->RefreshRate = dm.dmDisplayFrequency;
+    pMode->ScanLineOrdering = (dm.dmDisplayFlags & DM_INTERLACED) ?
+            D3DSCANLINEORDERING_INTERLACED : D3DSCANLINEORDERING_PROGRESSIVE;
+
+    /* XXX This is called "guessing" */
+    switch (dm.dmBitsPerPel)
+    {
+        case 32: pMode->Format = D3DFMT_X8R8G8B8; break;
+        case 24: pMode->Format = D3DFMT_R8G8B8; break;
+        case 16: pMode->Format = D3DFMT_R5G6B5; break;
+        default:
+            WINE_WARN("Unknown display format with %u bpp.\n", dm.dmBitsPerPel);
+            pMode->Format = D3DFMT_UNKNOWN;
+    }
+
+    switch (dm.dmDisplayOrientation)
+    {
+        case DMDO_DEFAULT: *pRotation = D3DDISPLAYROTATION_IDENTITY; break;
+        case DMDO_90:      *pRotation = D3DDISPLAYROTATION_90; break;
+        case DMDO_180:     *pRotation = D3DDISPLAYROTATION_180; break;
+        case DMDO_270:     *pRotation = D3DDISPLAYROTATION_270; break;
+        default:
+            WINE_WARN("Unknown display rotation %u.\n", dm.dmDisplayOrientation);
+            *pRotation = D3DDISPLAYROTATION_IDENTITY;
+    }
+
+    return D3D_OK;
+}
+
+static HRESULT WINAPI DRIPresent_GetPresentStats( struct DRIPresent *This, D3DPRESENTSTATS *pStats )
+{
+    WINE_FIXME("(%p, %p), stub!\n", This, pStats);
+    return D3DERR_INVALIDCALL;
+}
+
+static HRESULT WINAPI DRIPresent_GetCursorPos( struct DRIPresent *This, POINT *pPoint )
+{
+    BOOL ok;
+    HWND draw_window;
+
+    if (!pPoint)
+        return D3DERR_INVALIDCALL;
+
+    draw_window = This->params.hDeviceWindow ?
+            This->params.hDeviceWindow : This->focus_wnd;
+
+    ok = GetCursorPos(pPoint);
+    ok = ok && ScreenToClient(draw_window, pPoint);
+    return ok ? S_OK : D3DERR_DRIVERINTERNALERROR;
+}
+
+static HRESULT WINAPI DRIPresent_SetCursorPos( struct DRIPresent *This, POINT *pPoint )
+{
+    BOOL ok;
+    POINT real_pos;
+
+    if (!pPoint)
+        return D3DERR_INVALIDCALL;
+
+    ok = SetCursorPos(pPoint->x, pPoint->y);
+    if (!ok)
+        goto error;
+
+    ok = GetCursorPos(&real_pos);
+    if (!ok || real_pos.x != pPoint->x || real_pos.y != pPoint->y)
+        goto error;
+
+    return D3D_OK;
+
+error:
+    SetCursor(NULL); /* Hide cursor rather than put wrong pos */
+    return D3DERR_DRIVERINTERNALERROR;
+}
+
+/* Note: assuming 32x32 cursor */
+static HRESULT WINAPI DRIPresent_SetCursor( struct DRIPresent *This, void *pBitmap,
+        POINT *pHotspot, BOOL bShow )
+{
+   if (pBitmap)
+   {
+      ICONINFO info;
+      HCURSOR cursor;
+
+      DWORD mask[32];
+      memset(mask, ~0, sizeof(mask));
+
+      if (!pHotspot)
+         return D3DERR_INVALIDCALL;
+      info.fIcon = FALSE;
+      info.xHotspot = pHotspot->x;
+      info.yHotspot = pHotspot->y;
+      info.hbmMask = CreateBitmap(32, 32, 1, 1, mask);
+      info.hbmColor = CreateBitmap(32, 32, 1, 32, pBitmap);
+
+      cursor = CreateIconIndirect(&info);
+      if (info.hbmMask) DeleteObject(info.hbmMask);
+      if (info.hbmColor) DeleteObject(info.hbmColor);
+      if (cursor)
+         DestroyCursor(This->hCursor);
+      This->hCursor = cursor;
+   }
+   SetCursor(bShow ? This->hCursor : NULL);
+
+   return D3D_OK;
+}
+
+static HRESULT WINAPI DRIPresent_SetGammaRamp( struct DRIPresent *This,
+        const D3DGAMMARAMP *pRamp, HWND hWndOverride )
+{
+    HWND draw_window = This->params.hDeviceWindow ?
+        This->params.hDeviceWindow : This->focus_wnd;
+    HWND hWnd = hWndOverride ? hWndOverride : draw_window;
+    HDC hdc;
+    BOOL ok;
+    if (!pRamp)
+        return D3DERR_INVALIDCALL;
+
+    hdc = GetDC(hWnd);
+    ok = SetDeviceGammaRamp(hdc, (void *)pRamp);
+    ReleaseDC(hWnd, hdc);
+    return ok ? D3D_OK : D3DERR_DRIVERINTERNALERROR;
+}
+
+static HRESULT WINAPI DRIPresent_GetWindowInfo( struct DRIPresent *This,
+        HWND hWnd, int *width, int *height, int *depth )
+{
+    HWND draw_window = This->params.hDeviceWindow ?
+        This->params.hDeviceWindow : This->focus_wnd;
+    HRESULT hr;
+    RECT pRect;
+
+    //WINE_TRACE("This=%p hwnd=%p\n", This, hWnd);
+
+    /* For fullscreen modes, use the dimensions of the X11 window instead of
+     * the game window. This is for compability with Valve's "fullscreen hack",
+     * which won't switch to the game's resolution anymore, but instead scales
+     * the game window to the root window. Only then can page flipping be used.
+     */
+    if (!This->params.Windowed && This->d3d)
+        if (This->d3d->width > 0 && This->d3d->height > 0 && This->d3d->depth > 0)
+        {
+            *width = This->d3d->width;
+            *height = This->d3d->height;
+            *depth = This->d3d->depth;
+            return D3D_OK;
+        }
+
+    if (!hWnd)
+        hWnd = draw_window;
+    hr = GetClientRect(hWnd, &pRect);
+    if (!hr)
+        return D3DERR_INVALIDCALL;
+    //WINE_TRACE("pRect: %d %d %d %d\n", pRect.left, pRect.top, pRect.right, pRect.bottom);
+    *width = pRect.right - pRect.left;
+    *height = pRect.bottom - pRect.top;
+    *depth = 24; //TODO
+    return D3D_OK;
+}
+
+#if WINE_D3DADAPTER_DRIVER_PRESENT_VERSION_MINOR >= 1
+static BOOL WINAPI DRIPresent_GetWindowOccluded(struct DRIPresent *This)
+{
+    return This->occluded;
+}
+#endif
+
+#if WINE_D3DADAPTER_DRIVER_PRESENT_VERSION_MINOR >= 2
+static BOOL WINAPI DRIPresent_ResolutionMismatch(struct DRIPresent *This)
+{
+    /* The resolution might change due to a third party app.
+     * Poll this function to get the device's resolution match.
+     * A device reset is required to restore the requested resolution.
+     */
+    return This->resolution_mismatch;
+}
+
+static HANDLE WINAPI DRIPresent_CreateThread( struct DRIPresent *This,
+        void *pThreadfunc, void *pParam )
+{
+    LPTHREAD_START_ROUTINE lpStartAddress =
+            (LPTHREAD_START_ROUTINE) pThreadfunc;
+
+    return CreateThread(NULL, 0, lpStartAddress, pParam, 0, NULL);
+}
+
+static BOOL WINAPI DRIPresent_WaitForThread( struct DRIPresent *This, HANDLE thread )
+{
+    DWORD ExitCode = 0;
+    while (GetExitCodeThread(thread, &ExitCode) && ExitCode == STILL_ACTIVE)
+        Sleep(10);
+
+    return TRUE;
+}
+#endif
+
+#if WINE_D3DADAPTER_DRIVER_PRESENT_VERSION_MINOR >= 3
+static HRESULT WINAPI DRIPresent_SetPresentParameters2( struct DRIPresent *This, D3DPRESENT_PARAMETERS2 *pParams )
+{
+    This->allow_discard_delayed_release = pParams->AllowDISCARDDelayedRelease;
+    This->tear_free_discard = pParams->AllowDISCARDDelayedRelease && pParams->TearFreeDISCARD;
+    return D3D_OK;
+}
+
+static BOOL WINAPI DRIPresent_IsBufferReleased( struct DRIPresent *This, struct D3DWindowBuffer *buffer )
+{
+    //WINE_TRACE("This=%p buffer=%p\n", This, buffer);
+    return PRESENTIsPixmapReleased(buffer->present_pixmap_priv);
+}
+
+static HRESULT WINAPI DRIPresent_WaitBufferReleaseEvent( struct DRIPresent *This )
+{
+    PRESENTWaitReleaseEvent(This->present_priv);
+    return D3D_OK;
+}
+#endif
+
+/*----------*/
+
+static ID3DPresentVtbl DRIPresent_vtable = {
+    (void *)DRIPresent_QueryInterface,
+    (void *)DRIPresent_AddRef,
+    (void *)DRIPresent_Release,
+    (void *)DRIPresent_SetPresentParameters,
+    (void *)DRIPresent_D3DWindowBufferFromDmaBuf,
+    (void *)DRIPresent_DestroyD3DWindowBuffer,
+    (void *)DRIPresent_WaitBufferReleased,
+    (void *)DRIPresent_FrontBufferCopy,
+    (void *)DRIPresent_PresentBuffer,
+    (void *)DRIPresent_GetRasterStatus,
+    (void *)DRIPresent_GetDisplayMode,
+    (void *)DRIPresent_GetPresentStats,
+    (void *)DRIPresent_GetCursorPos,
+    (void *)DRIPresent_SetCursorPos,
+    (void *)DRIPresent_SetCursor,
+    (void *)DRIPresent_SetGammaRamp,
+    (void *)DRIPresent_GetWindowInfo,
+#if WINE_D3DADAPTER_DRIVER_PRESENT_VERSION_MINOR >= 1
+    (void *)DRIPresent_GetWindowOccluded,
+#endif
+#if WINE_D3DADAPTER_DRIVER_PRESENT_VERSION_MINOR >= 2
+    (void *)DRIPresent_ResolutionMismatch,
+    (void *)DRIPresent_CreateThread,
+    (void *)DRIPresent_WaitForThread,
+#endif
+#if WINE_D3DADAPTER_DRIVER_PRESENT_VERSION_MINOR >= 3
+    (void *)DRIPresent_SetPresentParameters2,
+    (void *)DRIPresent_IsBufferReleased,
+    (void *)DRIPresent_WaitBufferReleaseEvent,
+#endif
+};
+
+/* The following code is based on WINE's wined3d/device.c and
+ * wined3d/swapchain.c and WINE's d3d9 files. */
+
+static LONG fullscreen_style(LONG style)
+{
+    /* Make sure the window is managed, otherwise we won't get keyboard input. */
+    style |= WS_POPUP | WS_SYSMENU;
+    style &= ~(WS_CAPTION | WS_THICKFRAME);
+
+    return style;
+}
+
+static LONG fullscreen_exstyle(LONG exstyle)
+{
+    /* Filter out window decorations. */
+    exstyle &= ~(WS_EX_WINDOWEDGE | WS_EX_CLIENTEDGE);
+
+    return exstyle;
+}
+
+static HRESULT DRIPresent_ChangeDisplaySettingsIfNeccessary(struct DRIPresent *This, DEVMODEW *new_mode)
+{
+    DEVMODEW current_mode;
+    LONG hr;
+
+    /* Filter invalid resolution */
+    if (!new_mode->dmPelsWidth || !new_mode->dmPelsHeight)
+        return D3DERR_INVALIDCALL;
+
+    /* Ignore invalid frequency requested */
+    if (new_mode->dmDisplayFrequency > 1000)
+        new_mode->dmDisplayFrequency = 0;
+
+    ZeroMemory(&current_mode, sizeof(DEVMODEW));
+    current_mode.dmSize = sizeof(DEVMODEW);
+    /* Only change the mode if necessary. */
+    if (!EnumDisplaySettingsW(This->devname, ENUM_CURRENT_SETTINGS, &current_mode))
+       WINE_ERR("Failed to get current display mode.\n");
+    else if (current_mode.dmPelsWidth != new_mode->dmPelsWidth
+           || current_mode.dmPelsHeight != new_mode->dmPelsHeight
+           || (current_mode.dmDisplayFrequency != new_mode->dmDisplayFrequency
+           && (new_mode->dmFields & DM_DISPLAYFREQUENCY)))
+    {
+        hr = ChangeDisplaySettingsExW(This->devname, new_mode, 0, CDS_FULLSCREEN, NULL);
+        if (hr != DISP_CHANGE_SUCCESSFUL)
+        {
+            /* try again without display RefreshRate */
+            if (new_mode->dmFields & DM_DISPLAYFREQUENCY)
+            {
+                new_mode->dmFields &= ~DM_DISPLAYFREQUENCY;
+                new_mode->dmDisplayFrequency = 0;
+                hr = ChangeDisplaySettingsExW(This->devname, new_mode, 0, CDS_FULLSCREEN, NULL);
+                if (hr != DISP_CHANGE_SUCCESSFUL)
+                {
+                    WINE_ERR("ChangeDisplaySettingsExW failed with 0x%08X\n", hr);
+                    return D3DERR_INVALIDCALL;
+                }
+            }
+            else
+            {
+                WINE_ERR("ChangeDisplaySettingsExW failed with 0x%08X\n", hr);
+                return D3DERR_INVALIDCALL;
+            }
+        }
+    }
+    return D3D_OK;
+}
+
+LRESULT device_process_message(struct DRIPresent *present, HWND window, BOOL unicode,
+        UINT message, WPARAM wparam, LPARAM lparam, WNDPROC proc)
+{
+    boolean drop_wnd_messages;
+    DEVMODEW current_mode;
+    DEVMODEW new_mode;
+
+    WINE_TRACE("Got message: window %p, message %#x, wparam %#lx, lparam %#lx.\n",
+                    window, message, wparam, lparam);
+
+    if (present->drop_wnd_messages && message != WM_DISPLAYCHANGE)
+    {
+        WINE_TRACE("Filtering message: window %p, message %#x, wparam %#lx, lparam %#lx.\n",
+                window, message, wparam, lparam);
+        if (unicode)
+            return DefWindowProcW(window, message, wparam, lparam);
+        else
+            return DefWindowProcA(window, message, wparam, lparam);
+    }
+
+    if (message == WM_DESTROY)
+    {
+        WINE_TRACE("unregister window %p.\n", window);
+        (void) nine_unregister_window(window);
+    }
+    else if (message == WM_DISPLAYCHANGE)
+    {
+        /* Ex restores display mode, while non Ex requires the
+         * user to call Device::Reset() */
+        ZeroMemory(&current_mode, sizeof(DEVMODEW));
+        current_mode.dmSize = sizeof(current_mode);
+        if (!present->ex &&
+            !present->params.Windowed &&
+            present->params.hDeviceWindow &&
+            EnumDisplaySettingsW(present->devname, ENUM_CURRENT_SETTINGS, &current_mode) &&
+            (current_mode.dmPelsWidth != present->params.BackBufferWidth ||
+             current_mode.dmPelsHeight != present->params.BackBufferHeight))
+        {
+            present->resolution_mismatch = TRUE;
+        }
+        else
+        {
+            present->resolution_mismatch = FALSE;
+        }
+    }
+    else if (message == WM_ACTIVATEAPP)
+    {
+        drop_wnd_messages = present->drop_wnd_messages;
+        present->drop_wnd_messages = TRUE;
+
+        if (wparam == WA_INACTIVE)
+        {
+            present->occluded = TRUE;
+            present->reapply_mode = TRUE;
+
+            ZeroMemory(&new_mode, sizeof(DEVMODEW));
+            new_mode.dmSize = sizeof(new_mode);
+            if (EnumDisplaySettingsW(present->devname, ENUM_REGISTRY_SETTINGS, &new_mode))
+                DRIPresent_ChangeDisplaySettingsIfNeccessary(present, &new_mode);
+
+            if (!present->no_window_changes &&
+                    IsWindowVisible(present->params.hDeviceWindow))
+                ShowWindow(present->params.hDeviceWindow, SW_MINIMIZE);
+        }
+        else
+        {
+            present->occluded = FALSE;
+
+            if (!present->no_window_changes)
+            {
+                /* restore window */
+                SetWindowPos(present->params.hDeviceWindow, NULL, 0, 0,
+                             present->params.BackBufferWidth, present->params.BackBufferHeight,
+                             SWP_NOACTIVATE | SWP_NOZORDER);
+            }
+
+            if (present->ex)
+            {
+                ZeroMemory(&new_mode, sizeof(DEVMODEW));
+                new_mode.dmSize = sizeof(new_mode);
+                new_mode.dmPelsWidth = present->params.BackBufferWidth;
+                new_mode.dmPelsHeight = present->params.BackBufferHeight;
+                new_mode.dmFields = DM_PELSWIDTH | DM_PELSHEIGHT;
+                if (present->params.FullScreen_RefreshRateInHz)
+                {
+                    new_mode.dmFields |= DM_DISPLAYFREQUENCY;
+                    new_mode.dmDisplayFrequency = present->params.FullScreen_RefreshRateInHz;
+                }
+                DRIPresent_ChangeDisplaySettingsIfNeccessary(present, &new_mode);
+            }
+        }
+        present->drop_wnd_messages = drop_wnd_messages;
+    }
+    else if (message == WM_SYSCOMMAND)
+    {
+        if (wparam == SC_RESTORE)
+        {
+            if (unicode)
+                DefWindowProcW(window, message, wparam, lparam);
+            else
+                DefWindowProcA(window, message, wparam, lparam);
+        }
+    }
+
+    if (unicode)
+        return CallWindowProcW(proc, window, message, wparam, lparam);
+    else
+        return CallWindowProcA(proc, window, message, wparam, lparam);
+}
+
+static void setup_fullscreen_window(struct DRIPresent *This,
+        HWND hwnd, int w, int h)
+{
+    boolean drop_wnd_messages;
+    LONG style, style_ex;
+
+    This->style = GetWindowLongW(hwnd, GWL_STYLE);
+    This->style_ex = GetWindowLongW(hwnd, GWL_EXSTYLE);
+
+    style = fullscreen_style(This->style);
+    style_ex = fullscreen_exstyle(This->style_ex);
+
+    drop_wnd_messages = This->drop_wnd_messages;
+    This->drop_wnd_messages = TRUE;
+
+    SetWindowLongW(hwnd, GWL_STYLE, style);
+    SetWindowLongW(hwnd, GWL_EXSTYLE, style_ex);
+
+    SetWindowPos(hwnd, HWND_TOPMOST, 0, 0, w, h,
+            SWP_FRAMECHANGED | SWP_SHOWWINDOW | SWP_NOACTIVATE);
+
+    This->drop_wnd_messages = drop_wnd_messages;
+}
+
+static void move_fullscreen_window(struct DRIPresent *This,
+        HWND hwnd, int w, int h)
+{
+    boolean drop_wnd_messages;
+    LONG style, style_ex;
+
+    /* move draw window back to place */
+
+    style = GetWindowLongW(hwnd, GWL_STYLE);
+    style_ex = GetWindowLongW(hwnd, GWL_EXSTYLE);
+
+    style = fullscreen_style(style);
+    style_ex = fullscreen_exstyle(style_ex);
+
+    drop_wnd_messages = This->drop_wnd_messages;
+    This->drop_wnd_messages = TRUE;
+    SetWindowLongW(hwnd, GWL_STYLE, style);
+    SetWindowLongW(hwnd, GWL_EXSTYLE, style_ex);
+    SetWindowPos(hwnd, HWND_TOPMOST, 0, 0, w, h,
+            SWP_FRAMECHANGED | SWP_SHOWWINDOW | SWP_NOACTIVATE);
+    This->drop_wnd_messages = drop_wnd_messages;
+}
+
+static void restore_fullscreen_window(struct DRIPresent *This,
+        HWND hwnd)
+{
+    boolean drop_wnd_messages;
+    LONG style, style_ex;
+
+    /* switch from fullscreen to window */
+    style = GetWindowLongW(hwnd, GWL_STYLE);
+    style_ex = GetWindowLongW(hwnd, GWL_EXSTYLE);
+    /* These flags are set by us, not the
+     * application, and we want to ignore them in the test below, since it's
+     * not the application's fault that they changed. Additionally, we want to
+     * preserve the current status of these flags (i.e. don't restore them) to
+     * more closely emulate the behavior of Direct3D, which leaves these flags
+     * alone when returning to windowed mode. */
+    This->style ^= (This->style ^ style) & WS_VISIBLE;
+    This->style_ex ^= (This->style_ex ^ style_ex) & WS_EX_TOPMOST;
+
+    /* Only restore the style if the application didn't modify it during the
+     * fullscreen phase. Some applications change it before calling Reset()
+     * when switching between windowed and fullscreen modes (HL2), some
+     * depend on the original style (Eve Online). */
+    drop_wnd_messages = This->drop_wnd_messages;
+    This->drop_wnd_messages = TRUE;
+    if (style == fullscreen_style(This->style) &&
+            style_ex == fullscreen_exstyle(This->style_ex))
+    {
+        SetWindowLongW(hwnd, GWL_STYLE, This->style);
+        SetWindowLongW(hwnd, GWL_EXSTYLE, This->style_ex);
+    }
+    SetWindowPos(hwnd, 0, 0, 0, 0, 0, SWP_FRAMECHANGED |
+                 SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER |
+                 SWP_NOACTIVATE);
+    This->drop_wnd_messages = drop_wnd_messages;
+
+    This->style = 0;
+    This->style_ex = 0;
+}
+
+static void DRIPresent_UpdatePresentationInterval(struct DRIPresent *This)
+{
+    switch(This->params.PresentationInterval)
+    {
+        case D3DPRESENT_INTERVAL_DEFAULT:
+        case D3DPRESENT_INTERVAL_ONE:
+            This->present_interval = 1;
+            This->present_async = FALSE;
+            break;
+        case D3DPRESENT_INTERVAL_TWO:
+            This->present_interval = 2;
+            This->present_async = FALSE;
+            break;
+        case D3DPRESENT_INTERVAL_THREE:
+            This->present_interval = 3;
+            This->present_async = FALSE;
+            break;
+        case D3DPRESENT_INTERVAL_FOUR:
+            This->present_interval = 4;
+            This->present_async = FALSE;
+            break;
+        case D3DPRESENT_INTERVAL_IMMEDIATE:
+        default:
+            This->present_interval = 0;
+            This->present_async =
+                !(This->params.SwapEffect == D3DSWAPEFFECT_DISCARD &&
+                  This->tear_free_discard);
+            break;
+    }
+
+    /* D3DSWAPEFFECT_COPY: Force Copy.
+     * This->present_interval == 0: Force Copy to have buffers
+     * release as soon as possible (the display server/compositor
+     * won't hold any buffer), unless DISCARD and
+     * allow_discard_delayed_release */
+    This->present_swapeffectcopy =
+        This->params.SwapEffect == D3DSWAPEFFECT_COPY ||
+        (This->present_interval == 0 &&
+        !(This->params.SwapEffect == D3DSWAPEFFECT_DISCARD &&
+          This->allow_discard_delayed_release));
+}
+
+static HRESULT DRIPresent_ChangePresentParameters(struct DRIPresent *This,
+        D3DPRESENT_PARAMETERS *params)
+{
+    HWND focus_window = This->focus_wnd ? This->focus_wnd : params->hDeviceWindow;
+    RECT rect;
+    DEVMODEW new_mode;
+    HRESULT hr;
+    boolean drop_wnd_messages;
+
+    WINE_TRACE("This=%p, params=%p, focus_window=%p, params->hDeviceWindow=%p\n",
+            This, params, focus_window, params->hDeviceWindow);
+
+    This->params.SwapEffect = params->SwapEffect;
+    This->params.AutoDepthStencilFormat = params->AutoDepthStencilFormat;
+    This->params.Flags = params->Flags;
+    This->params.FullScreen_RefreshRateInHz = params->FullScreen_RefreshRateInHz;
+    This->params.PresentationInterval = params->PresentationInterval;
+    This->params.EnableAutoDepthStencil = params->EnableAutoDepthStencil;
+    if (!params->hDeviceWindow)
+        params->hDeviceWindow = This->params.hDeviceWindow;
+    else
+        This->params.hDeviceWindow = params->hDeviceWindow;
+
+    if ((This->params.BackBufferWidth != params->BackBufferWidth) ||
+            (This->params.BackBufferHeight != params->BackBufferHeight) ||
+            (This->params.Windowed != params->Windowed) ||
+            This->reapply_mode)
+    {
+        This->reapply_mode = FALSE;
+
+        if (!params->Windowed)
+        {
+            WINE_TRACE("Setting fullscreen mode: %dx%d@%d\n", params->BackBufferWidth,
+                     params->BackBufferHeight, params->FullScreen_RefreshRateInHz);
+
+            /* switch display mode */
+            ZeroMemory(&new_mode, sizeof(DEVMODEW));
+            new_mode.dmPelsWidth = params->BackBufferWidth;
+            new_mode.dmPelsHeight = params->BackBufferHeight;
+            new_mode.dmFields = DM_PELSWIDTH | DM_PELSHEIGHT;
+            if (params->FullScreen_RefreshRateInHz)
+            {
+                new_mode.dmFields |= DM_DISPLAYFREQUENCY;
+                new_mode.dmDisplayFrequency = params->FullScreen_RefreshRateInHz;
+            }
+            new_mode.dmSize = sizeof(DEVMODEW);
+            hr = DRIPresent_ChangeDisplaySettingsIfNeccessary(This, &new_mode);
+            if (FAILED(hr))
+                return hr;
+
+            /* Dirty as BackBufferWidth and BackBufferHeight hasn't been set yet */
+            This->resolution_mismatch = FALSE;
+        }
+        else if(!This->params.Windowed && params->Windowed)
+        {
+            WINE_TRACE("Setting fullscreen mode: %dx%d@%d\n", This->initial_mode.dmPelsWidth,
+                    This->initial_mode.dmPelsHeight, This->initial_mode.dmDisplayFrequency);
+
+            hr = DRIPresent_ChangeDisplaySettingsIfNeccessary(This, &This->initial_mode);
+            if (FAILED(hr))
+                return hr;
+
+            /* Dirty as BackBufferWidth and BackBufferHeight hasn't been set yet */
+            This->resolution_mismatch = FALSE;
+        }
+
+        if (This->params.Windowed)
+        {
+            if (!params->Windowed)
+            {
+                /* switch from window to fullscreen */
+                if (!nine_register_window(focus_window, This))
+                    return D3DERR_INVALIDCALL;
+
+                SetWindowPos(focus_window, 0, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE);
+
+                setup_fullscreen_window(This, params->hDeviceWindow,
+                        params->BackBufferWidth, params->BackBufferHeight);
+            }
+        }
+        else
+        {
+            if (!params->Windowed)
+            {
+                /* switch from fullscreen to fullscreen */
+                drop_wnd_messages = This->drop_wnd_messages;
+                This->drop_wnd_messages = TRUE;
+                MoveWindow(params->hDeviceWindow, 0, 0,
+                        params->BackBufferWidth,
+                        params->BackBufferHeight,
+                        TRUE);
+                This->drop_wnd_messages = drop_wnd_messages;
+            }
+            else if (This->style || This->style_ex)
+            {
+                restore_fullscreen_window(This, params->hDeviceWindow);
+            }
+
+            if (params->Windowed && !nine_unregister_window(focus_window))
+                WINE_ERR("Window %p is not registered with nine.\n", focus_window);
+        }
+        This->params.Windowed = params->Windowed;
+    }
+    else if (!params->Windowed)
+    {
+        move_fullscreen_window(This, params->hDeviceWindow, params->BackBufferWidth, params->BackBufferHeight);
+    }
+    else
+    {
+        WINE_TRACE("Nothing changed.\n");
+    }
+    if (!params->BackBufferWidth || !params->BackBufferHeight) {
+        if (!params->Windowed)
+            return D3DERR_INVALIDCALL;
+
+        if (!GetClientRect(params->hDeviceWindow, &rect))
+            return D3DERR_INVALIDCALL;
+
+        if (params->BackBufferWidth == 0)
+            params->BackBufferWidth = rect.right - rect.left;
+
+        if (params->BackBufferHeight == 0)
+            params->BackBufferHeight = rect.bottom - rect.top;
+    }
+
+    /* Set as last in case of failed reset those aren't updated */
+    This->params.BackBufferWidth = params->BackBufferWidth;
+    This->params.BackBufferHeight = params->BackBufferHeight;
+    This->params.BackBufferFormat = params->BackBufferFormat;
+    This->params.BackBufferCount = params->BackBufferCount;
+    This->params.MultiSampleType = params->MultiSampleType;
+    This->params.MultiSampleQuality = params->MultiSampleQuality;
+
+    DRIPresent_UpdatePresentationInterval(This);
+
+    if (!params->Windowed) {
+        struct d3d_drawable *d3d = get_d3d_drawable(This->gdi_display, focus_window);
+        Atom _NET_WM_BYPASS_COMPOSITOR = XInternAtom(This->gdi_display,
+                                                     "_NET_WM_BYPASS_COMPOSITOR",
+                                                     False);
+
+        Atom _VARIABLE_REFRESH = XInternAtom(This->gdi_display,
+                                             "_VARIABLE_REFRESH",
+                                             False);
+        if (!d3d)
+            return D3D_OK;
+
+        /* Disable compositing for fullscreen windows */
+        int bypass_value = 1;
+        XChangeProperty(This->gdi_display, d3d->drawable,
+                        _NET_WM_BYPASS_COMPOSITOR, XA_CARDINAL, 32,
+                        PropModeReplace, (unsigned char *)&bypass_value, 1);
+
+        /* Enable variable sync */
+        int vrr_value = 1;
+        XChangeProperty(This->gdi_display, d3d->drawable,
+                        _VARIABLE_REFRESH, XA_CARDINAL, 32,
+                        PropModeReplace, (unsigned char *)&vrr_value, 1);
+
+        release_d3d_drawable(d3d);
+    }
+
+    return D3D_OK;
+}
+
+/* The following code isn't based on WINE's wined3d or d3d9. */
+
+static HRESULT DRIPresent_new(Display *gdi_display, const WCHAR *devname,
+        D3DPRESENT_PARAMETERS *params, HWND focus_wnd, struct DRIPresent **out,
+        boolean ex, boolean no_window_changes, struct dri_backend *dri_backend)
+{
+    struct DRIPresent *This;
+    HWND focus_window;
+    DEVMODEW new_mode;
+    HRESULT hr;
+    RECT rect;
+
+    if (!focus_wnd && !params->hDeviceWindow)
+    {
+        WINE_ERR("No focus HWND specified for presentation backend.\n");
+        return D3DERR_INVALIDCALL;
+    }
+
+    This = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
+                     sizeof(struct DRIPresent));
+    if (!This)
+    {
+        WINE_ERR("Out of memory.\n");
+        return E_OUTOFMEMORY;
+    }
+
+    This->gdi_display = gdi_display;
+    This->vtable = &DRIPresent_vtable;
+    This->refs = 1;
+    This->focus_wnd = focus_wnd;
+    This->ex = ex;
+    This->no_window_changes = no_window_changes;
+    This->dri_backend = dri_backend;
+
+    /* store current resolution */
+    ZeroMemory(&(This->initial_mode), sizeof(This->initial_mode));
+    This->initial_mode.dmSize = sizeof(This->initial_mode);
+    EnumDisplaySettingsExW(This->devname, ENUM_CURRENT_SETTINGS, &(This->initial_mode), 0);
+
+    if (!params->hDeviceWindow)
+        params->hDeviceWindow = This->focus_wnd;
+
+    if (!params->Windowed) {
+        focus_window = This->focus_wnd ? This->focus_wnd : params->hDeviceWindow;
+
+        if (!nine_register_window(focus_window, This))
+            return D3DERR_INVALIDCALL;
+
+        SetWindowPos(focus_window, 0, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE);
+
+        /* switch display mode */
+        ZeroMemory(&new_mode, sizeof(DEVMODEW));
+        new_mode.dmSize = sizeof(DEVMODEW);
+        new_mode.dmPelsWidth = params->BackBufferWidth;
+        new_mode.dmPelsHeight = params->BackBufferHeight;
+        new_mode.dmFields = DM_PELSWIDTH | DM_PELSHEIGHT;
+
+        if (params->FullScreen_RefreshRateInHz)
+        {
+            new_mode.dmFields |= DM_DISPLAYFREQUENCY;
+            new_mode.dmDisplayFrequency = params->FullScreen_RefreshRateInHz;
+        }
+
+        hr = DRIPresent_ChangeDisplaySettingsIfNeccessary(This, &new_mode);
+        if (FAILED(hr))
+        {
+            nine_unregister_window(focus_window);
+            HeapFree(GetProcessHeap(), 0, This);
+            return hr;
+        }
+
+        /* Dirty as BackBufferWidth and BackBufferHeight hasn't been set yet */
+        This->resolution_mismatch = FALSE;
+
+        setup_fullscreen_window(This, params->hDeviceWindow,
+                params->BackBufferWidth, params->BackBufferHeight);
+    } else {
+        GetClientRect(params->hDeviceWindow, &rect);
+        if (!params->BackBufferWidth || !params->BackBufferHeight) {
+
+            if (params->BackBufferWidth == 0)
+                params->BackBufferWidth = rect.right - rect.left;
+
+            if (params->BackBufferHeight == 0)
+                params->BackBufferHeight = rect.bottom - rect.top;
+        }
+    }
+
+    This->params = *params;
+
+    DRIPresent_UpdatePresentationInterval(This);
+
+    lstrcpyW(This->devname, devname);
+
+    if (!PRESENTInit(gdi_display, &(This->present_priv)))
+    {
+        WINE_ERR("Failed to init Present backend\n");
+        return D3DERR_DRIVERINTERNALERROR;
+    }
+
+    if (!dri_backend->funcs->init(dri_backend->priv))
+    {
+        HeapFree(GetProcessHeap(), 0, This);
+        return D3DERR_DRIVERINTERNALERROR;
+    }
+
+    *out = This;
+
+    return D3D_OK;
+}
+
+struct DRIPresentGroup
+{
+    /* COM vtable */
+    void *vtable;
+    /* IUnknown reference count */
+    LONG refs;
+
+    boolean ex;
+    struct DRIPresent **present_backends;
+    unsigned npresent_backends;
+    Display *gdi_display;
+    boolean no_window_changes;
+    struct dri_backend *dri_backend;
+};
+
+static ULONG WINAPI DRIPresentGroup_AddRef(struct DRIPresentGroup *This)
+{
+    ULONG refs = InterlockedIncrement(&This->refs);
+    WINE_TRACE("%p increasing refcount to %u.\n", This, refs);
+    return refs;
+}
+
+static ULONG WINAPI DRIPresentGroup_Release(struct DRIPresentGroup *This)
+{
+    ULONG refs = InterlockedDecrement(&This->refs);
+    WINE_TRACE("%p decreasing refcount to %u.\n", This, refs);
+    if (refs == 0)
+    {
+        unsigned i;
+        if (This->present_backends)
+        {
+            for (i = 0; i < This->npresent_backends; ++i)
+            {
+                if (This->present_backends[i])
+                    DRIPresent_Release(This->present_backends[i]);
+            }
+            HeapFree(GetProcessHeap(), 0, This->present_backends);
+        }
+        HeapFree(GetProcessHeap(), 0, This);
+    }
+    return refs;
+}
+
+static HRESULT WINAPI DRIPresentGroup_QueryInterface(struct DRIPresentGroup *This,
+        REFIID riid, void **ppvObject )
+{
+    if (!ppvObject)
+        return E_POINTER;
+    if (IsEqualGUID(&IID_ID3DPresentGroup, riid) ||
+            IsEqualGUID(&IID_IUnknown, riid))
+    {
+        *ppvObject = This;
+        DRIPresentGroup_AddRef(This);
+        return S_OK;
+    }
+
+    WINE_WARN("%s not implemented, returning E_NOINTERFACE.\n", wine_dbgstr_guid(riid));
+    *ppvObject = NULL;
+
+    return E_NOINTERFACE;
+}
+
+static UINT WINAPI DRIPresentGroup_GetMultiheadCount(struct DRIPresentGroup *This)
+{
+    WINE_FIXME("(%p), stub!\n", This);
+    return 1;
+}
+
+static HRESULT WINAPI DRIPresentGroup_GetPresent(struct DRIPresentGroup *This,
+        UINT Index, ID3DPresent **ppPresent)
+{
+    if (Index >= DRIPresentGroup_GetMultiheadCount(This))
+    {
+        WINE_ERR("Index >= MultiHeadCount\n");
+        return D3DERR_INVALIDCALL;
+    }
+    DRIPresent_AddRef(This->present_backends[Index]);
+    *ppPresent = (ID3DPresent *)This->present_backends[Index];
+
+    return D3D_OK;
+}
+
+static HRESULT WINAPI DRIPresentGroup_CreateAdditionalPresent(struct DRIPresentGroup *This,
+        D3DPRESENT_PARAMETERS *pPresentationParameters, ID3DPresent **ppPresent)
+{
+    HRESULT hr;
+    hr = DRIPresent_new(This->gdi_display, This->present_backends[0]->devname,
+            pPresentationParameters, 0, (struct DRIPresent **)ppPresent,
+            This->ex, This->no_window_changes, This->dri_backend);
+
+    return hr;
+}
+
+static void WINAPI DRIPresentGroup_GetVersion(struct DRIPresentGroup *This,
+        int *major, int *minor)
+{
+    *major = WINE_D3DADAPTER_DRIVER_PRESENT_VERSION_MAJOR;
+    *minor = WINE_D3DADAPTER_DRIVER_PRESENT_VERSION_MINOR;
+}
+
+static ID3DPresentGroupVtbl DRIPresentGroup_vtable = {
+    (void *)DRIPresentGroup_QueryInterface,
+    (void *)DRIPresentGroup_AddRef,
+    (void *)DRIPresentGroup_Release,
+    (void *)DRIPresentGroup_GetMultiheadCount,
+    (void *)DRIPresentGroup_GetPresent,
+    (void *)DRIPresentGroup_CreateAdditionalPresent,
+    (void *)DRIPresentGroup_GetVersion
+};
+
+HRESULT present_create_present_group(Display *gdi_display, const WCHAR *device_name,
+        UINT adapter, HWND focus_wnd, D3DPRESENT_PARAMETERS *params,
+        unsigned nparams, ID3DPresentGroup **group, boolean ex, DWORD BehaviorFlags,
+        struct dri_backend *dri_backend)
+{
+    struct DRIPresentGroup *This;
+    DISPLAY_DEVICEW dd;
+    HRESULT hr;
+    unsigned i;
+
+    This = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
+            sizeof(struct DRIPresentGroup));
+    if (!This)
+    {
+        WINE_ERR("Out of memory.\n");
+        return E_OUTOFMEMORY;
+    }
+
+    This->gdi_display = gdi_display;
+    This->vtable = &DRIPresentGroup_vtable;
+    This->refs = 1;
+    This->ex = ex;
+    This->dri_backend = dri_backend;
+    This->npresent_backends = nparams;
+    This->no_window_changes = !!(BehaviorFlags & D3DCREATE_NOWINDOWCHANGES);
+    This->present_backends = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
+            This->npresent_backends * sizeof(struct DRIPresent *));
+    if (!This->present_backends)
+    {
+        DRIPresentGroup_Release(This);
+        WINE_ERR("Out of memory.\n");
+        return E_OUTOFMEMORY;
+    }
+
+    if (nparams != 1)
+        adapter = 0;
+
+    for (i = 0; i < This->npresent_backends; ++i)
+    {
+        ZeroMemory(&dd, sizeof(dd));
+        dd.cb = sizeof(dd);
+        /* find final device name */
+        if (!EnumDisplayDevicesW(device_name, adapter + i, &dd, 0))
+        {
+            WINE_WARN("Couldn't find subdevice %d from `%s'\n",
+                    i, wine_dbgstr_w(device_name));
+        }
+
+        /* create an ID3DPresent for it */
+        hr = DRIPresent_new(gdi_display, dd.DeviceName, &params[i],
+                focus_wnd, &This->present_backends[i], ex, This->no_window_changes,
+                This->dri_backend);
+        if (FAILED(hr))
+        {
+            DRIPresentGroup_Release(This);
+            return hr;
+        }
+    }
+
+    *group = (ID3DPresentGroup *)This;
+    WINE_TRACE("Returning %p\n", *group);
+
+    return D3D_OK;
+}
+
+HRESULT present_create_adapter9(Display *gdi_display, HDC hdc,
+        struct dri_backend *dri_backend, ID3DAdapter9 **out)
+{
+    HRESULT hr;
+    int fd;
+
+    if (!d3d9_drm)
+    {
+        WINE_ERR("DRM drivers are not supported on your system.\n");
+        return D3DERR_DRIVERINTERNALERROR;
+    }
+
+    if (!get_wine_drawable_from_dc(hdc, NULL))
+        return D3DERR_DRIVERINTERNALERROR;
+
+    fd = dri_backend->funcs->get_fd(dri_backend->priv);
+    if (fd < 0) {
+        WINE_ERR("Got invalid fd from backend (fd=%d)\n", fd);
+        return D3DERR_DRIVERINTERNALERROR;
+    }
+
+    hr = d3d9_drm->create_adapter(fd, out);
+    if (FAILED(hr))
+    {
+        WINE_ERR("Unable to create ID3DAdapter9 (fd=%d)\n", fd);
+        return hr;
+    }
+
+    WINE_TRACE("Created ID3DAdapter9 with fd %d\n", fd);
+
+    return D3D_OK;
+}
+
+BOOL present_has_d3dadapter(Display *gdi_display)
+{
+    static const void * WINAPI (*pD3DAdapter9GetProc)(const char *);
+    static void *handle = NULL;
+    static int done = 0;
+    char *pathbuf = NULL;
+
+    /* like in opengl.c (single threaded assumption OK?) */
+    if (done)
+        return handle != NULL;
+    done = 1;
+
+    handle = common_load_d3dadapter(&pathbuf, NULL);
+
+    if (!handle)
+        goto cleanup;
+
+    /* find our entry point in d3dadapter9 */
+    pD3DAdapter9GetProc = dlsym(handle, "D3DAdapter9GetProc");
+    if (!pD3DAdapter9GetProc)
+    {
+        WINE_ERR("Failed to get the entry point from %s: %s\n", pathbuf, dlerror());
+        goto cleanup;
+    }
+
+    /* get a handle to the drm backend struct */
+    d3d9_drm = pD3DAdapter9GetProc("drm");
+    if (!d3d9_drm)
+    {
+        WINE_ERR("%s doesn't support the drm backend.\n", pathbuf);
+        goto cleanup;
+    }
+
+    /* verify that we're binary compatible */
+    if (d3d9_drm->major_version != 0)
+    {
+        WINE_ERR("Version mismatch. %s has %d.%d, was expecting 0.x\n",
+                pathbuf, d3d9_drm->major_version, d3d9_drm->minor_version);
+        goto cleanup;
+    }
+
+    /* this will be used to store d3d_drawables */
+    d3d_hwnd_context = XUniqueContext();
+
+    if (!PRESENTCheckExtension(gdi_display, 1, 0))
+    {
+        WINE_ERR("Unable to query PRESENT.\n");
+        goto cleanup;
+    }
+
+    if (!backend_probe(gdi_display))
+    {
+        WINE_ERR("No available backends.\n");
+        goto cleanup;
+    }
+
+    return TRUE;
+
+cleanup:
+    wine_dbg_printf("\033[1;31mNative Direct3D 9 will be unavailable."
+            "\nFor more information visit " NINE_URL "\033[0m\n");
+
+    if (handle)
+    {
+        dlclose(handle);
+        handle = NULL;
+    }
+
+    free(pathbuf);
+
+    return FALSE;
+}
+
+BOOL enable_device_vtable_wrapper(void)
+{
+    if (!d3d9_drm)
+    {
+        WINE_ERR("enable_device_vtable_wrapper call before init.\n");
+        return FALSE;
+    }
+    /* Since minor version 1, we can assume a copy of the internal vtable is stored in second pos.
+     * For now always enable if possible the wrapper (enables Steam overlay for example),
+     * we might in the future let user choose. */
+    return d3d9_drm->minor_version >= 1;
+}
diff -purN a/dlls/d3d9-nine/present.h b/dlls/d3d9-nine/present.h
--- a/dlls/d3d9-nine/present.h	1970-01-01 03:00:00.000000000 +0300
+++ b/dlls/d3d9-nine/present.h	2019-09-12 21:01:47.926652315 +0300
@@ -0,0 +1,27 @@
+/* SPDX-License-Identifier: LGPL-2.1-or-later */
+/*
+ * Wine present interface
+ *
+ * Copyright 2015 Patrick Rudolph
+ */
+
+#ifndef __NINE_PRESENT_H
+#define __NINE_PRESENT_H
+
+#include <d3dadapter/present.h>
+#include <X11/Xlib.h>
+
+struct dri_backend;
+
+HRESULT present_create_present_group(Display *gdi_display, const WCHAR *device_name, UINT adapter,
+        HWND focus, D3DPRESENT_PARAMETERS *params, unsigned nparams, ID3DPresentGroup **group,
+        boolean ex, DWORD BehaviorFlags, struct dri_backend *dri_backend);
+
+HRESULT present_create_adapter9(Display *gdi_display, HDC hdc,
+        struct dri_backend *dri_backend, ID3DAdapter9 **adapter);
+
+BOOL present_has_d3dadapter(Display *gdi_display);
+
+BOOL enable_device_vtable_wrapper(void);
+
+#endif /* __NINE_PRESENT_H */
diff -purN a/dlls/d3d9-nine/registry.c b/dlls/d3d9-nine/registry.c
--- a/dlls/d3d9-nine/registry.c	1970-01-01 03:00:00.000000000 +0300
+++ b/dlls/d3d9-nine/registry.c	2019-09-12 21:01:47.926652315 +0300
@@ -0,0 +1,121 @@
+/* SPDX-License-Identifier: LGPL-2.1-or-later */
+
+#include <config.h>
+#include <windows.h>
+#include <wine/debug.h>
+
+#include "registry.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(ninecfg);
+
+const char * const reg_path_dll_overrides = "Software\\Wine\\DllOverrides";
+const char * const reg_path_dll_redirects = "Software\\Wine\\DllRedirects";
+const char * const reg_key_d3d9 = "d3d9";
+const char * const reg_path_nine = "Software\\Wine\\Direct3DNine";
+const char * const reg_key_module_path = "ModulePath";
+const char * const reg_value_override = "native";
+const char * const reg_key_debug_active_backend = "ActiveBackend";
+
+BOOL common_get_registry_string(LPCSTR path, LPCSTR name, LPSTR *value)
+{
+    HKEY regkey;
+    DWORD type;
+    DWORD size = 0;
+
+    WINE_TRACE("Getting string key '%s' at 'HKCU\\%s'\n", name, path);
+
+    if (RegOpenKeyA(HKEY_CURRENT_USER, path, &regkey) != ERROR_SUCCESS)
+    {
+        WINE_TRACE("Failed to open path 'HKCU\\%s'\n", path);
+        return FALSE;
+    }
+
+    if (RegQueryValueExA(regkey, name, 0, &type, NULL, &size) != ERROR_SUCCESS)
+    {
+        WINE_TRACE("Failed to query key '%s' at 'HKCU\\%s'\n", name, path);
+        RegCloseKey(regkey);
+        return FALSE;
+    }
+
+    if (type != REG_SZ)
+    {
+        WINE_TRACE("Key '%s' at 'HKCU\\%s' is not a string\n", name, path);
+        RegCloseKey(regkey);
+        return FALSE;
+    }
+
+    *value = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, size + 1);
+    if (!(*value))
+    {
+        RegCloseKey(regkey);
+        return FALSE;
+    }
+
+    if (RegQueryValueExA(regkey, name, 0, &type, (LPBYTE)*value, &size) != ERROR_SUCCESS)
+    {
+        WINE_TRACE("Failed to read value of key '%s' at 'HKCU\\%s'\n", name, path);
+        HeapFree(GetProcessHeap(), 0, *value);
+        RegCloseKey(regkey);
+        return FALSE;
+    }
+
+    RegCloseKey(regkey);
+
+    WINE_TRACE("Value is '%s'\n", *value);
+
+    return TRUE;
+}
+
+BOOL common_set_registry_string(LPCSTR path, LPCSTR name, LPCSTR value)
+{
+    HKEY regkey;
+
+    WINE_TRACE("Setting key '%s' at 'HKCU\\%s' to '%s'\n", name, path, value);
+
+    if (RegCreateKeyA(HKEY_CURRENT_USER, path, &regkey) != ERROR_SUCCESS)
+    {
+        WINE_TRACE("Failed to open path 'HKCU\\%s'\n", path);
+        return FALSE;
+    }
+
+    if (RegSetValueExA(regkey, name, 0, REG_SZ, (LPBYTE)value, strlen(value)) != ERROR_SUCCESS)
+    {
+        WINE_TRACE("Failed to write key '%s' at 'HKCU\\%s'\n", name, path);
+        RegCloseKey(regkey);
+        return FALSE;
+    }
+
+    RegCloseKey(regkey);
+
+    return TRUE;
+}
+
+BOOL common_del_registry_key(LPCSTR path, LPCSTR name)
+{
+    HKEY regkey;
+    LSTATUS rc;
+
+    WINE_TRACE("Deleting key '%s' at 'HKCU\\%s'\n", name, path);
+
+    rc = RegOpenKeyA(HKEY_CURRENT_USER, path, &regkey);
+    if (rc == ERROR_FILE_NOT_FOUND)
+        return TRUE;
+
+    if (rc != ERROR_SUCCESS)
+    {
+        WINE_TRACE("Failed to open path 'HKCU\\%s'\n", path);
+        return FALSE;
+    }
+
+    rc = RegDeleteValueA(regkey, name);
+    if (rc != ERROR_FILE_NOT_FOUND && rc != ERROR_SUCCESS)
+    {
+        WINE_TRACE("Failed to delete key '%s' at 'HKCU\\%s'\n", name, path);
+        RegCloseKey(regkey);
+        return FALSE;
+    }
+
+    RegCloseKey(regkey);
+
+    return TRUE;
+}
diff -purN a/dlls/d3d9-nine/registry.h b/dlls/d3d9-nine/registry.h
--- a/dlls/d3d9-nine/registry.h	1970-01-01 03:00:00.000000000 +0300
+++ b/dlls/d3d9-nine/registry.h	2019-09-12 21:01:47.926652315 +0300
@@ -0,0 +1,20 @@
+/* SPDX-License-Identifier: LGPL-2.1-or-later */
+
+#ifndef __COMMON_REGISTRY_H
+#define __COMMON_REGISTRY_H
+
+#include <windows.h>
+
+extern const char * const reg_path_dll_overrides;
+extern const char * const reg_path_dll_redirects;
+extern const char * const reg_key_d3d9;
+extern const char * const reg_path_nine;
+extern const char * const reg_key_module_path;
+extern const char * const reg_value_override;
+extern const char * const reg_key_debug_active_backend;
+
+BOOL common_get_registry_string(LPCSTR path, LPCSTR name, LPSTR *value);
+BOOL common_set_registry_string(LPCSTR path, LPCSTR name, LPCSTR value);
+BOOL common_del_registry_key(LPCSTR path, LPCSTR name);
+
+#endif /* __COMMON_REGISTRY_H */
diff -purN a/dlls/d3d9-nine/shader_validator.c b/dlls/d3d9-nine/shader_validator.c
--- a/dlls/d3d9-nine/shader_validator.c	1970-01-01 03:00:00.000000000 +0300
+++ b/dlls/d3d9-nine/shader_validator.c	2019-09-12 21:01:47.926652315 +0300
@@ -0,0 +1,76 @@
+/* SPDX-License-Identifier: LGPL-2.1-or-later */
+/*
+ * Direct3D 9 ShaderValidator
+ *
+ * Copyright 2016 Patrick Rudolph
+ */
+
+#include <config.h>
+#include <windows.h>
+#include <wine/debug.h>
+
+#include "shader_validator.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(d3d9nine);
+
+static HRESULT WINAPI IDirect3DShaderValidator9Impl_QueryInterface(IDirect3DShaderValidator9Impl *This,
+        REFIID riid, LPVOID* ppobj)
+{
+    /* TODO: AddRef(iface). */
+    *ppobj = This;
+    WINE_TRACE("This=%p, riid=%s, object=%p.\n", This, wine_dbgstr_guid(riid), ppobj);
+
+    return S_OK;
+}
+
+static ULONG WINAPI IDirect3DShaderValidator9Impl_AddRef(IDirect3DShaderValidator9Impl *This)
+{
+    ULONG ref = InterlockedIncrement(&This->ref);
+    WINE_TRACE("This=%p increasing refcount to %u.\n", This, ref);
+
+    return ref;
+}
+
+static ULONG WINAPI IDirect3DShaderValidator9Impl_Release(IDirect3DShaderValidator9Impl *This)
+{
+    ULONG ref = InterlockedDecrement(&This->ref);
+    WINE_TRACE("This=%p decreasing refcount to %u.\n", This, ref);
+
+    if (ref == 0)
+        HeapFree(GetProcessHeap(), 0, This);
+
+    return ref;
+}
+
+static LONG WINAPI IDirect3DShaderValidator9Impl_Begin(IDirect3DShaderValidator9Impl *This,
+        void* callback, void* unknown1, ULONG unknown2)
+{
+    WINE_TRACE("This=%p, callback=%p, unknown1=%p, unknown2=%u\n", This, callback, unknown1, unknown2);
+    return 1;
+}
+
+static LONG WINAPI IDirect3DShaderValidator9Impl_Instruction(IDirect3DShaderValidator9Impl *This,
+        const char* unknown1, unsigned int unknown2, const unsigned long* unknown3, unsigned int unknown4)
+{
+    WINE_TRACE("This=%p, unknown1=%p, unknown2=%u, unknown3=%p, unknown4=%u\n", This, unknown1, unknown2, unknown3, unknown4);
+    return 1;
+}
+
+static LONG WINAPI IDirect3DShaderValidator9Impl_End(IDirect3DShaderValidator9Impl *This)
+{
+    WINE_TRACE("This=%p\n", This);
+    return 1;
+}
+
+const void *IDirect3DShaderValidator9Vtbl[] =
+{
+    /* IUnknown */
+    IDirect3DShaderValidator9Impl_QueryInterface,
+    IDirect3DShaderValidator9Impl_AddRef,
+    IDirect3DShaderValidator9Impl_Release,
+    /* IDirect3DShaderValidator9 */
+    IDirect3DShaderValidator9Impl_Begin,
+    IDirect3DShaderValidator9Impl_Instruction,
+    IDirect3DShaderValidator9Impl_End
+};
+
diff -purN a/dlls/d3d9-nine/shader_validator.h b/dlls/d3d9-nine/shader_validator.h
--- a/dlls/d3d9-nine/shader_validator.h	1970-01-01 03:00:00.000000000 +0300
+++ b/dlls/d3d9-nine/shader_validator.h	2019-09-12 21:01:47.926652315 +0300
@@ -0,0 +1,22 @@
+/* SPDX-License-Identifier: LGPL-2.1-or-later */
+/*
+ * Direct3D 9 ShaderValidator
+ *
+ * Copyright 2016 Patrick Rudolph
+ */
+
+#ifndef __NINE_SHADER_VALIDATOR_H
+#define __NINE_SHADER_VALIDATOR_H
+
+#include <windef.h>
+
+typedef struct IDirect3DShaderValidator9Impl
+{
+    /* IUnknown fields */
+    void *lpVtbl;
+    LONG ref;
+} IDirect3DShaderValidator9Impl;
+
+const void *IDirect3DShaderValidator9Vtbl[6];
+
+#endif /* __NINE_SHADER_VALIDATOR_H */
diff -purN a/dlls/d3d9-nine/version.rc b/dlls/d3d9-nine/version.rc
--- a/dlls/d3d9-nine/version.rc	1970-01-01 03:00:00.000000000 +0300
+++ b/dlls/d3d9-nine/version.rc	2019-09-12 21:01:47.926652315 +0300
@@ -0,0 +1,37 @@
+/* SPDX-License-Identifier: LGPL-2.1-or-later */
+/*
+ * Copyright 2015 Patrick Rudolph
+ */
+
+#include <verrsrc.h>
+
+VS_VERSION_INFO VERSIONINFO
+FILEVERSION    NINE_MAJOR,NINE_MINOR,NINE_BUILD,NINE_REVISION
+PRODUCTVERSION NINE_MAJOR,NINE_MINOR,NINE_BUILD,NINE_REVISION
+FILEFLAGSMASK  63
+FILEFLAGS      0
+FILEOS         VOS_UNKNOWN
+FILETYPE       VFT_DLL
+FILESUBTYPE    VFT2_UNKNOWN
+{
+    BLOCK "StringFileInfo"
+    {
+        /* LANG_ENGLISH/SUBLANG_DEFAULT, CP1200 (Unicode) */
+        BLOCK "0409" "04B0"
+        {
+            VALUE "CompanyName", ""
+            VALUE "FileDescription", "Wine Gallium Nine Direct3D"
+            VALUE "FileVersion", NINE_VERSION
+            VALUE "InternalName", ""
+            VALUE "LegalCopyright", ""
+            VALUE "OriginalFilename", "d3d9-nine.dll"
+            VALUE "ProductName", "Wine"
+            VALUE "ProductVersion", NINE_VERSION
+        }
+    }
+    BLOCK "VarFileInfo"
+    {
+        /* LANG_ENGLISH/SUBLANG_DEFAULT, CP1200 (Unicode) */
+        VALUE "Translation", 0x0409, 0x04B0
+    }
+}
diff -purN a/dlls/d3d9-nine/wndproc.c b/dlls/d3d9-nine/wndproc.c
--- a/dlls/d3d9-nine/wndproc.c	1970-01-01 03:00:00.000000000 +0300
+++ b/dlls/d3d9-nine/wndproc.c	2019-09-12 21:01:47.926652315 +0300
@@ -0,0 +1,253 @@
+/* SPDX-License-Identifier: LGPL-2.1-or-later */
+/*
+ * Copyright 2016 Patrick Rudolph
+ *
+ * Based on the file wined3d_main.c taken from wined3d:
+ * All credits go to the original developers:
+ *
+ * Copyright 2002-2003 The wine-d3d team
+ * Copyright 2002-2003 Raphael Junqueira
+ * Copyright 2004      Jason Edmeades
+ * Copyright 2007-2008 Stefan Dsinger for CodeWeavers
+ * Copyright 2009 Henri Verbeet for CodeWeavers
+ */
+
+#include <windows.h>
+#include <wine/debug.h>
+#include <stdarg.h>
+#include <math.h>
+#include <limits.h>
+
+#include "wndproc.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(d3dadapter);
+
+struct nine_wndproc
+{
+    HWND window;
+    BOOL unicode;
+    WNDPROC proc;
+    struct DRIPresent *present;
+};
+
+struct nine_wndproc_table
+{
+    struct nine_wndproc *entries;
+    unsigned int count;
+    unsigned int size;
+};
+
+static struct nine_wndproc_table wndproc_table;
+
+static CRITICAL_SECTION nine_wndproc_cs;
+static CRITICAL_SECTION_DEBUG nine_wndproc_cs_debug =
+{
+    0, 0, &nine_wndproc_cs,
+    {&nine_wndproc_cs_debug.ProcessLocksList,
+    &nine_wndproc_cs_debug.ProcessLocksList},
+    0, 0, {/*(DWORD_PTR)(__FILE__ ": nine_wndproc_cs")*/}
+};
+static CRITICAL_SECTION nine_wndproc_cs = {&nine_wndproc_cs_debug, -1, 0, 0, 0, 0};
+
+BOOL nine_dll_init(HINSTANCE hInstDLL)
+{
+    WNDCLASSA wc;
+
+    /* We need our own window class for a fake window which we use to retrieve GL capabilities */
+    /* We might need CS_OWNDC in the future if we notice strange things on Windows.
+     * Various articles/posts about OpenGL problems on Windows recommend this. */
+    wc.style                = CS_HREDRAW | CS_VREDRAW;
+    wc.lpfnWndProc          = DefWindowProcA;
+    wc.cbClsExtra           = 0;
+    wc.cbWndExtra           = 0;
+    wc.hInstance            = hInstDLL;
+    wc.hIcon                = LoadIconA(NULL, (const char *)IDI_WINLOGO);
+    wc.hCursor              = LoadCursorA(NULL, (const char *)IDC_ARROW);
+    wc.hbrBackground        = NULL;
+    wc.lpszMenuName         = NULL;
+    wc.lpszClassName        = NINE_WINDOW_CLASS_NAME;
+
+    if (!RegisterClassA(&wc))
+    {
+        WINE_ERR("Failed to register window class '%s'!\n", NINE_WINDOW_CLASS_NAME);
+        return FALSE;
+    }
+
+    DisableThreadLibraryCalls(hInstDLL);
+
+    return TRUE;
+}
+
+BOOL nine_dll_destroy(HINSTANCE hInstDLL)
+{
+    unsigned int i;
+
+    for (i = 0; i < wndproc_table.count; ++i)
+    {
+        /* Trying to unregister these would be futile. These entries can only
+         * exist if either we skipped them in nine_unregister_window() due
+         * to the application replacing the wndproc after the entry was
+         * registered, or if the application still has an active nine
+         * device. In the latter case the application has bigger problems than
+         * these entries. */
+        WINE_WARN("Leftover wndproc table entry %p.\n", &wndproc_table.entries[i]);
+    }
+    HeapFree(GetProcessHeap(), 0, wndproc_table.entries);
+
+    UnregisterClassA(NINE_WINDOW_CLASS_NAME, hInstDLL);
+
+    DeleteCriticalSection(&nine_wndproc_cs);
+    return TRUE;
+}
+
+static void nine_wndproc_mutex_lock(void)
+{
+    EnterCriticalSection(&nine_wndproc_cs);
+}
+
+static void nine_wndproc_mutex_unlock(void)
+{
+    LeaveCriticalSection(&nine_wndproc_cs);
+}
+
+static struct nine_wndproc *nine_find_wndproc(HWND window)
+{
+    unsigned int i;
+
+    for (i = 0; i < wndproc_table.count; ++i)
+    {
+        if (wndproc_table.entries[i].window == window)
+        {
+            return &wndproc_table.entries[i];
+        }
+    }
+
+    return NULL;
+}
+
+static LRESULT CALLBACK nine_wndproc(HWND window, UINT message, WPARAM wparam, LPARAM lparam)
+{
+    struct nine_wndproc *entry;
+    struct DRIPresent *present;
+    BOOL unicode;
+    WNDPROC proc;
+
+    nine_wndproc_mutex_lock();
+    entry = nine_find_wndproc(window);
+
+    if (!entry)
+    {
+        nine_wndproc_mutex_unlock();
+        WINE_ERR("Window %p is not registered with nine.\n", window);
+        return DefWindowProcW(window, message, wparam, lparam);
+    }
+
+    present = entry->present;
+    unicode = entry->unicode;
+    proc = entry->proc;
+    nine_wndproc_mutex_unlock();
+
+    if (present)
+        return device_process_message(present, window, unicode, message, wparam, lparam, proc);
+    if (unicode)
+        return CallWindowProcW(proc, window, message, wparam, lparam);
+    return CallWindowProcA(proc, window, message, wparam, lparam);
+}
+
+BOOL nine_register_window(HWND window, struct DRIPresent *present)
+{
+    struct nine_wndproc *entry;
+
+    nine_wndproc_mutex_lock();
+
+    if (nine_find_wndproc(window))
+    {
+        nine_wndproc_mutex_unlock();
+        WINE_WARN("Window %p is already registered with nine.\n", window);
+        return TRUE;
+    }
+
+    if (wndproc_table.size == wndproc_table.count)
+    {
+        unsigned int new_size = max(1, wndproc_table.size * 2);
+        struct nine_wndproc *new_entries;
+
+        if (!wndproc_table.entries) new_entries = HeapAlloc(GetProcessHeap(), 0, new_size * sizeof(*new_entries));
+        else new_entries = HeapReAlloc(GetProcessHeap(), 0, wndproc_table.entries, new_size * sizeof(*new_entries));
+
+        if (!new_entries)
+        {
+            nine_wndproc_mutex_unlock();
+            WINE_ERR("Failed to grow table.\n");
+            return FALSE;
+        }
+
+        wndproc_table.entries = new_entries;
+        wndproc_table.size = new_size;
+    }
+
+    entry = &wndproc_table.entries[wndproc_table.count++];
+    entry->window = window;
+    entry->unicode = IsWindowUnicode(window);
+    /* Set a window proc that matches the window. Some applications (e.g. NoX)
+     * replace the window proc after we've set ours, and expect to be able to
+     * call the previous one (ours) directly, without using CallWindowProc(). */
+    if (entry->unicode)
+        entry->proc = (WNDPROC)SetWindowLongPtrW(window, GWLP_WNDPROC, (LONG_PTR)nine_wndproc);
+    else
+        entry->proc = (WNDPROC)SetWindowLongPtrA(window, GWLP_WNDPROC, (LONG_PTR)nine_wndproc);
+    entry->present = present;
+
+    nine_wndproc_mutex_unlock();
+
+    return TRUE;
+}
+
+BOOL nine_unregister_window(HWND window)
+{
+    struct nine_wndproc *entry, *last;
+    LONG_PTR proc;
+
+    nine_wndproc_mutex_lock();
+
+    if (!(entry = nine_find_wndproc(window)))
+    {
+        nine_wndproc_mutex_unlock();
+        return FALSE;
+    }
+
+    if (entry->unicode)
+    {
+        proc = GetWindowLongPtrW(window, GWLP_WNDPROC);
+        if (proc != (LONG_PTR)nine_wndproc)
+        {
+            entry->present = NULL;
+            nine_wndproc_mutex_unlock();
+            WINE_WARN("Not unregistering window %p, window proc %#lx doesn't match nine window proc %p.\n",
+                    window, proc, nine_wndproc);
+            return FALSE;
+        }
+
+        SetWindowLongPtrW(window, GWLP_WNDPROC, (LONG_PTR)entry->proc);
+    }
+    else
+    {
+        proc = GetWindowLongPtrA(window, GWLP_WNDPROC);
+        if (proc != (LONG_PTR)nine_wndproc)
+        {
+            entry->present = NULL;
+            nine_wndproc_mutex_unlock();
+            WINE_WARN("Not unregistering window %p, window proc %#lx doesn't match nine window proc %p.\n",
+                    window, proc, nine_wndproc);
+            return FALSE;
+        }
+
+        SetWindowLongPtrA(window, GWLP_WNDPROC, (LONG_PTR)entry->proc);
+    }
+
+    last = &wndproc_table.entries[--wndproc_table.count];
+    if (entry != last) *entry = *last;
+
+    nine_wndproc_mutex_unlock();
+    return TRUE;
+}
diff -purN a/dlls/d3d9-nine/wndproc.h b/dlls/d3d9-nine/wndproc.h
--- a/dlls/d3d9-nine/wndproc.h	1970-01-01 03:00:00.000000000 +0300
+++ b/dlls/d3d9-nine/wndproc.h	2019-09-12 21:01:47.926652315 +0300
@@ -0,0 +1,30 @@
+/* SPDX-License-Identifier: LGPL-2.1-or-later */
+/*
+ * Direct3D wine internal interface main
+ *
+ * Copyright 2002-2003 The wine-d3d team
+ * Copyright 2002-2003 Raphael Junqueira
+ * Copyright 2004      Jason Edmeades
+ * Copyright 2007-2008 Stefan Dsinger for CodeWeavers
+ * Copyright 2009 Henri Verbeet for CodeWeavers
+ */
+
+#ifndef __NINE_WNDPROC_H
+#define __NINE_WNDPROC_H
+
+#include <windef.h>
+
+struct DRIPresent;
+
+BOOL nine_register_window(HWND window, struct DRIPresent *present);
+BOOL nine_unregister_window(HWND window);
+
+BOOL nine_dll_init(HINSTANCE hInstDLL);
+BOOL nine_dll_destroy(HINSTANCE hInstDLL);
+
+LRESULT device_process_message(struct DRIPresent *present, HWND window, BOOL unicode,
+        UINT message, WPARAM wparam, LPARAM lparam, WNDPROC proc);
+
+#define NINE_WINDOW_CLASS_NAME "Gallium_Nine_Window"
+
+#endif /* __NINE_WNDPROC_H */
diff -purN a/dlls/d3d9-nine/xcb_present.c b/dlls/d3d9-nine/xcb_present.c
--- a/dlls/d3d9-nine/xcb_present.c	1970-01-01 03:00:00.000000000 +0300
+++ b/dlls/d3d9-nine/xcb_present.c	2019-09-12 21:01:47.929985667 +0300
@@ -0,0 +1,802 @@
+/* SPDX-License-Identifier: LGPL-2.1-or-later */
+/*
+ * Wine XCB PRESENT interface
+ *
+ * Copyright 2014-2015 Axel Davy
+ * Copyright 2015-2019 Patrick Rudolph
+ */
+
+#include <config.h>
+#include <windows.h>
+#include <wine/debug.h>
+#include <X11/Xlib-xcb.h>
+#include <xcb/present.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+#include "xcb_present.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(d3d9nine);
+
+struct PRESENTPriv {
+    xcb_connection_t *xcb_connection;
+    xcb_connection_t *xcb_connection_bis; /* to avoid libxcb thread bugs, use a different connection to present pixmaps */
+    XID window;
+    uint64_t last_msc;
+    uint64_t last_target;
+    xcb_special_event_t *special_event;
+    PRESENTPixmapPriv *first_present_priv;
+    int pixmap_present_pending;
+    BOOL idle_notify_since_last_check;
+    BOOL notify_with_serial_pending;
+    CRITICAL_SECTION mutex_present; /* protect readind/writing present_priv things */
+    CRITICAL_SECTION mutex_xcb_wait;
+    BOOL xcb_wait;
+};
+
+struct PRESENTPixmapPriv {
+    PRESENTpriv *present_priv;
+    Pixmap pixmap;
+    BOOL released;
+    unsigned int width;
+    unsigned int height;
+    unsigned int depth;
+    unsigned int present_complete_pending;
+    uint32_t serial;
+    BOOL last_present_was_flip;
+    PRESENTPixmapPriv *next;
+};
+
+static xcb_screen_t *screen_of_display(xcb_connection_t *c,
+        int screen)
+{
+  xcb_screen_iterator_t iter;
+
+  iter = xcb_setup_roots_iterator (xcb_get_setup (c));
+  for (; iter.rem; --screen, xcb_screen_next (&iter))
+    if (screen == 0)
+      return iter.data;
+
+  return NULL;
+}
+
+LONG PRESENTGetNewSerial(void)
+{
+    static LONG last_serial_given = 0;
+
+    return InterlockedIncrement(&last_serial_given);
+}
+
+BOOL PRESENTCheckExtension(Display *dpy, int major, int minor)
+{
+    xcb_connection_t *xcb_connection = XGetXCBConnection(dpy);
+    xcb_present_query_version_cookie_t present_cookie;
+    xcb_present_query_version_reply_t *present_reply;
+    xcb_generic_error_t *error;
+    const xcb_query_extension_reply_t *extension;
+
+    xcb_prefetch_extension_data(xcb_connection, &xcb_present_id);
+
+    extension = xcb_get_extension_data(xcb_connection, &xcb_present_id);
+    if (!(extension && extension->present))
+    {
+        WINE_ERR("PRESENT extension is not present\n");
+        return FALSE;
+    }
+
+    present_cookie = xcb_present_query_version(xcb_connection, major, minor);
+
+    present_reply = xcb_present_query_version_reply(xcb_connection, present_cookie, &error);
+    if (!present_reply)
+    {
+        free(error);
+        WINE_ERR("Issue getting requested v%d,%d of PRESENT\n", major, minor);
+        return FALSE;
+    }
+
+    WINE_TRACE("PRESENT v%d.%d found, v%u.%u requested\n", major, minor,
+            present_reply->major_version, present_reply->minor_version);
+
+    free(present_reply);
+
+    return TRUE;
+}
+
+static PRESENTPixmapPriv *PRESENTFindPixmapPriv(PRESENTpriv *present_priv, uint32_t serial)
+{
+    PRESENTPixmapPriv *current = present_priv->first_present_priv;
+
+    while (current)
+    {
+        if (current->serial == serial)
+            return current;
+        current = current->next;
+    }
+    return NULL;
+}
+
+static void PRESENThandle_events(PRESENTpriv *present_priv, xcb_present_generic_event_t *ge)
+{
+    PRESENTPixmapPriv *present_pixmap_priv = NULL;
+
+    switch (ge->evtype)
+    {
+        case XCB_PRESENT_COMPLETE_NOTIFY:
+        {
+            xcb_present_complete_notify_event_t *ce = (void *) ge;
+            if (ce->kind == XCB_PRESENT_COMPLETE_KIND_NOTIFY_MSC)
+            {
+                if (ce->serial)
+                    present_priv->notify_with_serial_pending = FALSE;
+                free(ce);
+                return;
+            }
+            present_pixmap_priv = PRESENTFindPixmapPriv(present_priv, ce->serial);
+            if (!present_pixmap_priv || ce->kind != XCB_PRESENT_COMPLETE_KIND_PIXMAP)
+            {
+                /* We received an event from another instance - ignore */
+                free(ce);
+                return;
+            }
+            present_pixmap_priv->present_complete_pending--;
+            switch (ce->mode)
+            {
+                case XCB_PRESENT_COMPLETE_MODE_FLIP:
+                    present_pixmap_priv->last_present_was_flip = TRUE;
+                    break;
+                case XCB_PRESENT_COMPLETE_MODE_COPY:
+                    present_pixmap_priv->last_present_was_flip = FALSE;
+                    break;
+            }
+            present_priv->pixmap_present_pending--;
+            present_priv->last_msc = ce->msc;
+            break;
+        }
+        case XCB_PRESENT_EVENT_IDLE_NOTIFY:
+        {
+            xcb_present_idle_notify_event_t *ie = (void *) ge;
+            present_pixmap_priv = PRESENTFindPixmapPriv(present_priv, ie->serial);
+            if (!present_pixmap_priv || present_pixmap_priv->pixmap != ie->pixmap)
+            {
+                /* We received an event from another instance - ignore */
+                free(ie);
+                return;
+            }
+            present_pixmap_priv->released = TRUE;
+            present_priv->idle_notify_since_last_check = TRUE;
+            break;
+        }
+    }
+    free(ge);
+}
+
+static void PRESENTflush_events(PRESENTpriv *present_priv, BOOL assert_no_other_thread_waiting)
+{
+    xcb_generic_event_t *ev;
+
+    if ((present_priv->xcb_wait && !assert_no_other_thread_waiting) || /* don't steal events to someone waiting */
+            !present_priv->special_event)
+        return;
+
+    while ((ev = xcb_poll_for_special_event(present_priv->xcb_connection,
+            present_priv->special_event)) != NULL)
+    {
+        PRESENThandle_events(present_priv, (void *) ev);
+    }
+}
+
+static BOOL PRESENTwait_events(PRESENTpriv *present_priv, BOOL allow_other_threads)
+{
+    xcb_generic_event_t *ev;
+
+    if (allow_other_threads)
+    {
+        present_priv->xcb_wait = TRUE;
+        EnterCriticalSection(&present_priv->mutex_xcb_wait);
+        LeaveCriticalSection(&present_priv->mutex_present);
+    }
+    ev = xcb_wait_for_special_event(present_priv->xcb_connection, present_priv->special_event);
+    if (allow_other_threads)
+    {
+        LeaveCriticalSection(&present_priv->mutex_xcb_wait);
+        EnterCriticalSection(&present_priv->mutex_present);
+        present_priv->xcb_wait = FALSE;
+    }
+    if (!ev)
+    {
+        WINE_ERR("FATAL error: xcb had an error\n");
+        return FALSE;
+    }
+
+    PRESENThandle_events(present_priv, (void *) ev);
+    return TRUE;
+}
+
+static struct xcb_connection_t *create_xcb_connection(Display *dpy)
+{
+    int screen_num = DefaultScreen(dpy);
+    xcb_connection_t *ret;
+    xcb_xfixes_query_version_cookie_t cookie;
+    xcb_xfixes_query_version_reply_t *rep;
+
+    ret = xcb_connect(DisplayString(dpy), &screen_num);
+    cookie = xcb_xfixes_query_version_unchecked(ret, XCB_XFIXES_MAJOR_VERSION, XCB_XFIXES_MINOR_VERSION);
+    rep = xcb_xfixes_query_version_reply(ret, cookie, NULL);
+    if (rep)
+        free(rep);
+    return ret;
+}
+
+BOOL PRESENTInit(Display *dpy, PRESENTpriv **present_priv)
+{
+    *present_priv = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(PRESENTpriv));
+
+    if (!*present_priv)
+        return FALSE;
+
+    (*present_priv)->xcb_connection = create_xcb_connection(dpy);
+    (*present_priv)->xcb_connection_bis = create_xcb_connection(dpy);
+
+    InitializeCriticalSection(&(*present_priv)->mutex_present);
+    InitializeCriticalSection(&(*present_priv)->mutex_xcb_wait);
+    return TRUE;
+}
+
+static void PRESENTForceReleases(PRESENTpriv *present_priv)
+{
+    PRESENTPixmapPriv *current = NULL;
+
+    if (!present_priv->window)
+        return;
+
+    /* There should be no other thread listening for events here.
+     * This can happen when hDestWindowOverride changes without reset.
+     * This case should never happen, but can happen in theory.*/
+    if (present_priv->xcb_wait)
+    {
+        xcb_present_notify_msc(present_priv->xcb_connection, present_priv->window, 0, 0, 0, 0);
+        xcb_flush(present_priv->xcb_connection);
+        EnterCriticalSection(&present_priv->mutex_xcb_wait);
+        LeaveCriticalSection(&present_priv->mutex_xcb_wait);
+        /* the problem here is that we don't have access to the event the other thread got.
+         * It is either presented event, idle event or notify event.
+         */
+        while (present_priv->pixmap_present_pending >= 2)
+            PRESENTwait_events(present_priv, FALSE);
+        PRESENTflush_events(present_priv, TRUE);
+        /* Remaining events to come can be a pair of present/idle,
+         * or an idle, or nothing. To be sure we are after all pixmaps
+         * have been presented, add an event to the queue that can only
+         * be after the present event, then if we receive an event more,
+         * we are sure all pixmaps were presented */
+        present_priv->notify_with_serial_pending = TRUE;
+        xcb_present_notify_msc(present_priv->xcb_connection, present_priv->window,
+                1, present_priv->last_target + 5, 0, 0);
+
+        xcb_flush(present_priv->xcb_connection);
+        while (present_priv->notify_with_serial_pending)
+            PRESENTwait_events(present_priv, FALSE);
+        /* Now we are sure we are not expecting any new event */
+    }
+    else
+    {
+        while (present_priv->pixmap_present_pending) /* wait all sent pixmaps are presented */
+            PRESENTwait_events(present_priv, FALSE);
+        PRESENTflush_events(present_priv, TRUE); /* may be remaining idle event */
+        /* Since idle events are send with the complete events when it is not flips,
+         * we are not expecting any new event here */
+    }
+
+    current = present_priv->first_present_priv;
+    while (current)
+    {
+        if (!current->released)
+        {
+            if (!current->last_present_was_flip && !present_priv->xcb_wait)
+            {
+                WINE_ERR("ERROR: a pixmap seems not released by PRESENT for no reason. Code bug.\n");
+            }
+            else
+            {
+                /* Present the same pixmap with a non-valid part to force the copy mode and the releases */
+                xcb_xfixes_region_t valid, update;
+                xcb_rectangle_t rect_update;
+                rect_update.x = 0;
+                rect_update.y = 0;
+                rect_update.width = 8;
+                rect_update.height = 1;
+                valid = xcb_generate_id(present_priv->xcb_connection);
+                update = xcb_generate_id(present_priv->xcb_connection);
+                xcb_xfixes_create_region(present_priv->xcb_connection, valid, 1, &rect_update);
+                xcb_xfixes_create_region(present_priv->xcb_connection, update, 1, &rect_update);
+                /* here we know the pixmap has been presented. Thus if it is on screen,
+                 * the following request can only make it released by the server if it is not */
+                xcb_present_pixmap(present_priv->xcb_connection, present_priv->window,
+                        current->pixmap, 0, valid, update, 0, 0, None, None,
+                        None, XCB_PRESENT_OPTION_COPY | XCB_PRESENT_OPTION_ASYNC, 0, 0, 0, 0, NULL);
+                xcb_flush(present_priv->xcb_connection);
+                PRESENTwait_events(present_priv, FALSE); /* by assumption this can only be idle event */
+                PRESENTflush_events(present_priv, TRUE); /* Shoudln't be needed */
+            }
+        }
+        current = current->next;
+    }
+    /* Now all pixmaps are released (possibility if xcb_wait is true that one is not aware yet),
+     * and we don't expect any new Present event to come from Xserver */
+}
+
+static void PRESENTFreeXcbQueue(PRESENTpriv *present_priv)
+{
+    if (present_priv->window)
+    {
+        xcb_unregister_for_special_event(present_priv->xcb_connection, present_priv->special_event);
+        present_priv->last_msc = 0;
+        present_priv->last_target = 0;
+        present_priv->special_event = NULL;
+    }
+}
+
+static BOOL PRESENTPrivChangeWindow(PRESENTpriv *present_priv, XID window)
+{
+    xcb_void_cookie_t cookie;
+    xcb_generic_error_t *error;
+    xcb_present_event_t eid;
+
+    PRESENTForceReleases(present_priv);
+    PRESENTFreeXcbQueue(present_priv);
+    present_priv->window = window;
+
+    if (window)
+    {
+        cookie = xcb_present_select_input_checked(present_priv->xcb_connection,
+                (eid = xcb_generate_id(present_priv->xcb_connection)), window,
+                XCB_PRESENT_EVENT_MASK_COMPLETE_NOTIFY | XCB_PRESENT_EVENT_MASK_IDLE_NOTIFY);
+
+        present_priv->special_event = xcb_register_for_special_xge(present_priv->xcb_connection,
+                &xcb_present_id, eid, NULL);
+
+        error = xcb_request_check(present_priv->xcb_connection, cookie); /* performs a flush */
+        if (error || !present_priv->special_event)
+        {
+            WINE_ERR("FAILED to use the X PRESENT extension. Was the destination a window ?\n");
+            if (present_priv->special_event)
+                xcb_unregister_for_special_event(present_priv->xcb_connection, present_priv->special_event);
+            present_priv->special_event = NULL;
+            present_priv->window = 0;
+        }
+    }
+    return (present_priv->window != 0);
+}
+
+/* Destroy the content, except the link and the struct mem */
+static void PRESENTDestroyPixmapContent(PRESENTPixmapPriv *present_pixmap)
+{
+    PRESENTpriv *present_priv = present_pixmap->present_priv;
+    xcb_void_cookie_t cookie;
+    xcb_generic_error_t *error;
+
+    WINE_TRACE("Releasing pixmap priv %p\n", present_pixmap);
+
+    cookie = xcb_free_pixmap(present_priv->xcb_connection,
+                             present_pixmap->pixmap);
+
+    error = xcb_request_check(present_priv->xcb_connection, cookie);
+    if (error)
+        WINE_ERR("Failed to free pixmap\n");
+}
+
+void PRESENTDestroy(PRESENTpriv *present_priv)
+{
+    PRESENTPixmapPriv *current = NULL;
+
+    EnterCriticalSection(&present_priv->mutex_present);
+
+    PRESENTForceReleases(present_priv);
+
+    current = present_priv->first_present_priv;
+    while (current)
+    {
+        PRESENTPixmapPriv *next = current->next;
+        PRESENTDestroyPixmapContent(current);
+        HeapFree(GetProcessHeap(), 0, current);
+        current = next;
+    }
+
+    PRESENTFreeXcbQueue(present_priv);
+
+    xcb_disconnect(present_priv->xcb_connection);
+    xcb_disconnect(present_priv->xcb_connection_bis);
+    LeaveCriticalSection(&present_priv->mutex_present);
+    DeleteCriticalSection(&present_priv->mutex_present);
+    DeleteCriticalSection(&present_priv->mutex_xcb_wait);
+
+    HeapFree(GetProcessHeap(), 0, present_priv);
+}
+
+BOOL PRESENTPixmapCreate(PRESENTpriv *present_priv, int screen,
+        Pixmap *pixmap, int width, int height, int stride, int depth,
+        int bpp)
+{
+    xcb_void_cookie_t cookie;
+    xcb_generic_error_t *error;
+    xcb_screen_t *xcb_screen;
+
+    WINE_TRACE("present_priv=%p, pixmap=%p, width=%d, height=%d, stride=%d,"
+            " depth=%d, bpp=%d\n", present_priv, pixmap, width, height,
+            stride, depth, bpp);
+
+    EnterCriticalSection(&present_priv->mutex_present);
+
+    xcb_screen = screen_of_display (present_priv->xcb_connection, screen);
+    if (!xcb_screen || !xcb_screen->root)
+    {
+        LeaveCriticalSection(&present_priv->mutex_present);
+        return FALSE;
+    }
+
+    *pixmap = xcb_generate_id(present_priv->xcb_connection);
+
+    cookie = xcb_create_pixmap(present_priv->xcb_connection, depth,
+                               *pixmap, xcb_screen->root, width, height);
+
+    error = xcb_request_check(present_priv->xcb_connection, cookie);
+    LeaveCriticalSection(&present_priv->mutex_present);
+
+    if (error)
+        return FALSE;
+    return TRUE;
+}
+
+BOOL PRESENTPixmapInit(PRESENTpriv *present_priv, Pixmap pixmap, PRESENTPixmapPriv **present_pixmap_priv)
+{
+    xcb_get_geometry_cookie_t cookie;
+    xcb_get_geometry_reply_t *reply;
+
+    cookie = xcb_get_geometry(present_priv->xcb_connection, pixmap);
+    reply = xcb_get_geometry_reply(present_priv->xcb_connection, cookie, NULL);
+
+    if (!reply)
+        return FALSE;
+
+    *present_pixmap_priv = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(PRESENTPixmapPriv));
+
+    if (!*present_pixmap_priv)
+    {
+        free(reply);
+        return FALSE;
+    }
+    EnterCriticalSection(&present_priv->mutex_present);
+
+    (*present_pixmap_priv)->released = TRUE;
+    (*present_pixmap_priv)->pixmap = pixmap;
+    (*present_pixmap_priv)->present_priv = present_priv;
+    (*present_pixmap_priv)->next = present_priv->first_present_priv;
+    (*present_pixmap_priv)->width = reply->width;
+    (*present_pixmap_priv)->height = reply->height;
+    (*present_pixmap_priv)->depth = reply->depth;
+    free(reply);
+
+    (*present_pixmap_priv)->serial = PRESENTGetNewSerial();
+    present_priv->first_present_priv = *present_pixmap_priv;
+
+    LeaveCriticalSection(&present_priv->mutex_present);
+    return TRUE;
+}
+
+BOOL PRESENTTryFreePixmap(PRESENTPixmapPriv *present_pixmap_priv)
+{
+    PRESENTpriv *present_priv = present_pixmap_priv->present_priv;
+    PRESENTPixmapPriv *current;
+
+    EnterCriticalSection(&present_priv->mutex_present);
+
+    if (!present_pixmap_priv->released || present_pixmap_priv->present_complete_pending)
+    {
+        LeaveCriticalSection(&present_priv->mutex_present);
+        WINE_TRACE("Releasing pixmap priv %p later\n", present_pixmap_priv);
+        return FALSE;
+    }
+
+    if (present_priv->first_present_priv == present_pixmap_priv)
+    {
+        present_priv->first_present_priv = present_pixmap_priv->next;
+        goto free_priv;
+    }
+
+    current = present_priv->first_present_priv;
+    while (current->next != present_pixmap_priv)
+        current = current->next;
+    current->next = present_pixmap_priv->next;
+free_priv:
+    PRESENTDestroyPixmapContent(present_pixmap_priv);
+    HeapFree(GetProcessHeap(), 0, present_pixmap_priv);
+    LeaveCriticalSection(&present_priv->mutex_present);
+    return TRUE;
+}
+
+BOOL PRESENTHelperCopyFront(PRESENTPixmapPriv *present_pixmap_priv)
+{
+    PRESENTpriv *present_priv = present_pixmap_priv->present_priv;
+    xcb_void_cookie_t cookie;
+    xcb_generic_error_t *error;
+    uint32_t v = 0;
+    xcb_gcontext_t gc;
+
+    EnterCriticalSection(&present_priv->mutex_present);
+
+    if (!present_priv->window)
+    {
+        LeaveCriticalSection(&present_priv->mutex_present);
+        return FALSE;
+    }
+
+    gc = xcb_generate_id(present_priv->xcb_connection);
+    xcb_create_gc(present_priv->xcb_connection, gc, present_priv->window,
+             XCB_GC_GRAPHICS_EXPOSURES, &v);
+
+    cookie = xcb_copy_area_checked(present_priv->xcb_connection,
+             present_priv->window, present_pixmap_priv->pixmap, gc,
+             0, 0, 0, 0, present_pixmap_priv->width, present_pixmap_priv->height);
+
+    error = xcb_request_check(present_priv->xcb_connection, cookie);
+    xcb_free_gc(present_priv->xcb_connection, gc);
+    LeaveCriticalSection(&present_priv->mutex_present);
+    return (error != NULL);
+}
+
+BOOL PRESENTPixmapPrepare(XID window, PRESENTPixmapPriv *present_pixmap_priv)
+{
+    PRESENTpriv *present_priv = present_pixmap_priv->present_priv;
+
+    EnterCriticalSection(&present_priv->mutex_present);
+
+    if (window != present_priv->window)
+        PRESENTPrivChangeWindow(present_priv, window);
+
+    if (!window)
+    {
+        WINE_ERR("ERROR: Try to Present a pixmap on a NULL window\n");
+        LeaveCriticalSection(&present_priv->mutex_present);
+        return FALSE;
+    }
+
+    PRESENTflush_events(present_priv, FALSE);
+    /* Note: present_pixmap_priv->present_complete_pending may be non-0, because
+     * on some paths the Xserver sends the complete event just after the idle
+     * event. */
+    if (!present_pixmap_priv->released)
+    {
+        WINE_ERR("FATAL ERROR: Trying to Present a pixmap not released\n");
+        LeaveCriticalSection(&present_priv->mutex_present);
+        return FALSE;
+    }
+
+    LeaveCriticalSection(&present_priv->mutex_present);
+    return TRUE;
+}
+
+BOOL PRESENTPixmap(XID window, PRESENTPixmapPriv *present_pixmap_priv,
+        const UINT PresentationInterval, const BOOL PresentAsync, const BOOL SwapEffectCopy,
+        const RECT *pSourceRect, const RECT *pDestRect, const RGNDATA *pDirtyRegion)
+{
+    PRESENTpriv *present_priv = present_pixmap_priv->present_priv;
+    xcb_void_cookie_t cookie;
+    xcb_generic_error_t *error;
+    int64_t target_msc, presentationInterval;
+    xcb_xfixes_region_t valid, update;
+    int16_t x_off, y_off;
+    uint32_t options = XCB_PRESENT_OPTION_NONE;
+
+    EnterCriticalSection(&present_priv->mutex_present);
+
+    target_msc = present_priv->last_msc;
+
+    presentationInterval = PresentationInterval;
+    if (PresentAsync)
+        options |= XCB_PRESENT_OPTION_ASYNC;
+    if (SwapEffectCopy)
+        options |= XCB_PRESENT_OPTION_COPY;
+
+    target_msc += presentationInterval * (present_priv->pixmap_present_pending + 1);
+
+    /* Note: PRESENT defines some way to do partial copy:
+     * presentproto:
+     * 'x-off' and 'y-off' define the location in the window where
+     *  the 0,0 location of the pixmap will be presented. valid-area
+     *  and update-area are relative to the pixmap.
+     */
+    if (!pSourceRect && !pDestRect && !pDirtyRegion)
+    {
+        valid = 0;
+        update = 0;
+        x_off = 0;
+        y_off = 0;
+    }
+    else
+    {
+        xcb_rectangle_t rect_update;
+        xcb_rectangle_t *rect_updates;
+        int i;
+
+        rect_update.x = 0;
+        rect_update.y = 0;
+        rect_update.width = present_pixmap_priv->width;
+        rect_update.height = present_pixmap_priv->height;
+        x_off = 0;
+        y_off = 0;
+        if (pSourceRect)
+        {
+            x_off = -pSourceRect->left;
+            y_off = -pSourceRect->top;
+            rect_update.x = pSourceRect->left;
+            rect_update.y = pSourceRect->top;
+            rect_update.width = pSourceRect->right - pSourceRect->left;
+            rect_update.height = pSourceRect->bottom - pSourceRect->top;
+        }
+        if (pDestRect)
+        {
+            x_off += pDestRect->left;
+            y_off += pDestRect->top;
+            rect_update.width = pDestRect->right - pDestRect->left;
+            rect_update.height = pDestRect->bottom - pDestRect->top;
+            /* Note: the size of pDestRect and pSourceRect are supposed to be the same size
+             * because the driver would have done things to assure that. */
+        }
+        valid = xcb_generate_id(present_priv->xcb_connection_bis);
+        update = xcb_generate_id(present_priv->xcb_connection_bis);
+        xcb_xfixes_create_region(present_priv->xcb_connection_bis, valid, 1, &rect_update);
+        if (pDirtyRegion && pDirtyRegion->rdh.nCount)
+        {
+            rect_updates = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
+                    sizeof(xcb_rectangle_t) * pDirtyRegion->rdh.nCount);
+
+            for (i = 0; i < pDirtyRegion->rdh.nCount; i++)
+            {
+                RECT rc;
+                memcpy(&rc, pDirtyRegion->Buffer + i * sizeof(RECT), sizeof(RECT));
+                rect_update.x = rc.left;
+                rect_update.y = rc.top;
+                rect_update.width = rc.right - rc.left;
+                rect_update.height = rc.bottom - rc.top;
+                memcpy(rect_updates + i * sizeof(xcb_rectangle_t), &rect_update, sizeof(xcb_rectangle_t));
+            }
+            xcb_xfixes_create_region(present_priv->xcb_connection_bis, update, pDirtyRegion->rdh.nCount, rect_updates);
+            HeapFree(GetProcessHeap(), 0, rect_updates);
+        } else
+            xcb_xfixes_create_region(present_priv->xcb_connection_bis, update, 1, &rect_update);
+    }
+
+    cookie = xcb_present_pixmap_checked(present_priv->xcb_connection_bis,
+            window, present_pixmap_priv->pixmap, present_pixmap_priv->serial,
+            valid, update, x_off, y_off, None, None, None, options,
+            target_msc, 0, 0, 0, NULL);
+    error = xcb_request_check(present_priv->xcb_connection_bis, cookie); /* performs a flush */
+
+    if (update)
+        xcb_xfixes_destroy_region(present_priv->xcb_connection_bis, update);
+    if (valid)
+        xcb_xfixes_destroy_region(present_priv->xcb_connection_bis, valid);
+
+    if (error)
+    {
+        xcb_get_geometry_cookie_t cookie_geom;
+        xcb_get_geometry_reply_t *reply;
+
+        cookie_geom = xcb_get_geometry(present_priv->xcb_connection_bis, window);
+        reply = xcb_get_geometry_reply(present_priv->xcb_connection_bis, cookie_geom, NULL);
+
+        WINE_ERR("Error using PRESENT. Here some debug info\n");
+        if (!reply)
+        {
+            WINE_ERR("Error querying window info. Perhaps it doesn't exist anymore\n");
+            LeaveCriticalSection(&present_priv->mutex_present);
+            return FALSE;
+        }
+        WINE_ERR("Pixmap: width=%d, height=%d, depth=%d\n",
+                present_pixmap_priv->width, present_pixmap_priv->height,
+                present_pixmap_priv->depth);
+
+        WINE_ERR("Window: width=%d, height=%d, depth=%d, x=%d, y=%d\n",
+                (int) reply->width, (int) reply->height,
+                (int) reply->depth, (int) reply->x, (int) reply->y);
+
+        WINE_ERR("Present parameter: PresentationInterval=%d, Pending presentations=%d\n",
+                PresentationInterval, present_priv->pixmap_present_pending);
+
+        if (present_pixmap_priv->depth != reply->depth)
+            WINE_ERR("Depths are different. PRESENT needs the pixmap and the window have same depth\n");
+        free(reply);
+        LeaveCriticalSection(&present_priv->mutex_present);
+        return FALSE;
+    }
+    present_priv->last_target = target_msc;
+    present_priv->pixmap_present_pending++;
+    present_pixmap_priv->present_complete_pending++;
+    present_pixmap_priv->released = FALSE;
+    LeaveCriticalSection(&present_priv->mutex_present);
+    return TRUE;
+}
+
+BOOL PRESENTWaitPixmapReleased(PRESENTPixmapPriv *present_pixmap_priv)
+{
+    PRESENTpriv *present_priv = present_pixmap_priv->present_priv;
+
+    EnterCriticalSection(&present_priv->mutex_present);
+
+    PRESENTflush_events(present_priv, FALSE);
+
+    /* The part with present_pixmap_priv->present_complete_pending is legacy behaviour.
+     * It matters for SwapEffectCopy with swapinterval > 0. */
+    while (!present_pixmap_priv->released || present_pixmap_priv->present_complete_pending)
+    {
+        /* Note: following if should not happen because we'll never
+         * use two PRESENTWaitPixmapReleased in parallels on same window.
+         * However it would make it work in that case */
+        if (present_priv->xcb_wait)
+        {
+            /* we allow only one thread to dispatch events */
+            EnterCriticalSection(&present_priv->mutex_xcb_wait);
+            /* here the other thread got an event but hasn't treated it yet */
+            LeaveCriticalSection(&present_priv->mutex_xcb_wait);
+            LeaveCriticalSection(&present_priv->mutex_present);
+            Sleep(10); /* Let it treat the event */
+            EnterCriticalSection(&present_priv->mutex_present);
+        }
+        else if (!PRESENTwait_events(present_priv, TRUE))
+        {
+            LeaveCriticalSection(&present_priv->mutex_present);
+            return FALSE;
+        }
+    }
+    LeaveCriticalSection(&present_priv->mutex_present);
+    return TRUE;
+}
+
+BOOL PRESENTIsPixmapReleased(PRESENTPixmapPriv *present_pixmap_priv)
+{
+    PRESENTpriv *present_priv = present_pixmap_priv->present_priv;
+    BOOL ret;
+
+    EnterCriticalSection(&present_priv->mutex_present);
+
+    PRESENTflush_events(present_priv, FALSE);
+
+    ret = present_pixmap_priv->released;
+
+    LeaveCriticalSection(&present_priv->mutex_present);
+    return ret;
+}
+
+BOOL PRESENTWaitReleaseEvent(PRESENTpriv *present_priv)
+{
+
+    EnterCriticalSection(&present_priv->mutex_present);
+
+    while (!present_priv->idle_notify_since_last_check)
+    {
+        /* Note: following if should not happen because we'll never
+         * use two PRESENTWaitPixmapReleased in parallels on same window.
+         * However it would make it work in that case */
+        if (present_priv->xcb_wait)
+        {
+            /* we allow only one thread to dispatch events */
+            EnterCriticalSection(&present_priv->mutex_xcb_wait);
+            /* here the other thread got an event but hasn't treated it yet */
+            LeaveCriticalSection(&present_priv->mutex_xcb_wait);
+            LeaveCriticalSection(&present_priv->mutex_present);
+            Sleep(10); /* Let it treat the event */
+            EnterCriticalSection(&present_priv->mutex_present);
+        }
+        else if (!PRESENTwait_events(present_priv, TRUE))
+        {
+            WINE_ERR("Issue in PRESENTWaitReleaseEvent\n");
+            LeaveCriticalSection(&present_priv->mutex_present);
+            return FALSE;
+        }
+    }
+    present_priv->idle_notify_since_last_check = FALSE;
+
+    LeaveCriticalSection(&present_priv->mutex_present);
+    return TRUE;
+}
diff -purN a/dlls/d3d9-nine/xcb_present.h b/dlls/d3d9-nine/xcb_present.h
--- a/dlls/d3d9-nine/xcb_present.h	1970-01-01 03:00:00.000000000 +0300
+++ b/dlls/d3d9-nine/xcb_present.h	2019-09-12 21:01:47.929985667 +0300
@@ -0,0 +1,53 @@
+/* SPDX-License-Identifier: LGPL-2.1-or-later */
+/*
+ * Wine XCB PRESENT interface
+ *
+ * Copyright 2014 Axel Davy
+ * Copyright 2019 Patrick Rudolph
+ */
+
+#ifndef __NINE_XCB_PRESENT_H
+#define __NINE_XCB_PRESENT_H
+
+#include <wingdi.h>
+#include <X11/Xlib.h>
+
+LONG PRESENTGetNewSerial(void);
+
+BOOL PRESENTCheckExtension(Display *dpy, int major, int minor);
+
+typedef struct PRESENTPriv PRESENTpriv;
+typedef struct PRESENTPixmapPriv PRESENTPixmapPriv;
+
+BOOL PRESENTInit(Display *dpy, PRESENTpriv **present_priv);
+
+/* will clean properly and free all PRESENTPixmapPriv associated to PRESENTpriv.
+ * PRESENTPixmapPriv should not be freed by something else.
+ * If never a PRESENTPixmapPriv has to be destroyed,
+ * please destroy the current PRESENTpriv and create a new one.
+ * This will take care than all pixmaps are released */
+void PRESENTDestroy(PRESENTpriv *present_priv);
+
+BOOL PRESENTPixmapCreate(PRESENTpriv *present_priv, int screen,
+        Pixmap *pixmap, int width, int height, int stride, int depth,
+        int bpp);
+
+BOOL PRESENTPixmapInit(PRESENTpriv *present_priv, Pixmap pixmap, PRESENTPixmapPriv **present_pixmap_priv);
+
+BOOL PRESENTTryFreePixmap(PRESENTPixmapPriv *present_pixmap_priv);
+
+BOOL PRESENTHelperCopyFront(PRESENTPixmapPriv *present_pixmap_priv);
+
+BOOL PRESENTPixmapPrepare(XID window, PRESENTPixmapPriv *present_pixmap_priv);
+
+BOOL PRESENTPixmap(XID window, PRESENTPixmapPriv *present_pixmap_priv,
+        const UINT PresentationInterval, const BOOL PresentAsync, const BOOL SwapEffectCopy,
+        const RECT *pSourceRect, const RECT *pDestRect, const RGNDATA *pDirtyRegion);
+
+BOOL PRESENTWaitPixmapReleased(PRESENTPixmapPriv *present_pixmap_priv);
+
+BOOL PRESENTIsPixmapReleased(PRESENTPixmapPriv *present_pixmap_priv);
+
+BOOL PRESENTWaitReleaseEvent(PRESENTpriv *present_priv);
+
+#endif /* __NINE_XCB_PRESENT_H */
